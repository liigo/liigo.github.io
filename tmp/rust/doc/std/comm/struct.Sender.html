<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>std::comm::Sender - Rust</title>

    <link href='http://fonts.googleapis.com/css?family=Oswald:700|Inconsolata:400,700'
          rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="../../main.css">

    <link rel="shortcut icon" href="http://www.rust-lang.org/favicon.ico" />
</head>
<body>
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <section class="sidebar">
        
            <a href='../../std/index.html'><img src='http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png' alt=''/></a>
        

        <p class='location'><a href='../index.html'>std</a>&#8203;::<a href='index.html'>comm</a></p><div class='block struct'><h2>Structs</h2><a class='struct ' href='struct.Handle.html' title='A handle to a receiver which is currently a member of a `Select` set of receivers.  This handle is used to keep the receiver in the set as well as interact with the underlying receiver.'>Handle</a><br/><a class='struct ' href='struct.Messages.html' title='An iterator over messages on a receiver, this iterator will block whenever `next` is called, waiting for a new message, and `None` will be returned when the corresponding channel has hung up.'>Messages</a><br/><a class='struct ' href='struct.Receiver.html' title='The receiving-half of Rust's channel type. This half can only be owned by one task'>Receiver</a><br/><a class='struct ' href='struct.Select.html' title='The "receiver set" of the select interface. This structure is used to manage a set of receivers which are being selected over.'>Select</a><br/><a class='struct current' href='struct.Sender.html' title='The sending-half of Rust's channel type. This half can only be owned by one task'>Sender</a><br/></div><div class='block enum'><h2>Enums</h2><a class='enum ' href='enum.TryRecvResult.html' title='This enumeration is the list of the possible reasons that try_recv could not return data when called.'>TryRecvResult</a><br/></div><div class='block fn'><h2>Functions</h2><a class='fn ' href='fn.channel.html' title='Creates a new channel, returning the sender/receiver halves. All data sent on the sender will become available on the receiver. See the documentation of `Receiver` and `Sender` to see what's possible with them.'>channel</a><br/></div>
    </section>

    <nav class="sub">
        <form class="search-form js-only">
            <button class="do-search">Search</button>
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Search documentation..."
                       type="search" />
            </div>
        </form>
    </nav>

    <section id='main' class="content struct"><a class='source'
                              href='../../src/std/MinGW/msys/1.0/home/LIIGO/rust/rust/src/libstd/comm/mod.rs.html#306-311'>[src]</a><h1 class='fqn'>Struct <a href='../index.html'>std</a>::<a href='index.html'>comm</a>::<a class='struct' href=''>Sender</a></h1><pre class='rust struct'>pub struct Sender&lt;T&gt; {
    // some fields omitted
}</pre><div class='docblock'><p>The sending-half of Rust&#39;s channel type. This half can only be owned by one
task</p>
</div><h2 id='methods'>Methods</h2><h3 class='impl'><code>impl&lt;T: <a class='trait' href='../../std/kinds/trait.Send.html' title='std::kinds::Send'>Send</a>&gt; <a class='struct' href='../../std/comm/struct.Sender.html' title='std::comm::Sender'>Sender</a>&lt;T&gt;</code></h3><div class='methods'><h4 id='method.send' class='method'><code>fn <a href='#method.send' class='fnname'>send</a>(&amp;self, t: T)</code></h4>
<div class='docblock'><p>Sends a value along this channel to be received by the corresponding
receiver.</p>

<p>Rust channels are infinitely buffered so this method will never block.</p>

<h1 id="failure" class='section-link'><a
                           href="#failure">Failure</a></h1>
<p>This function will fail if the other end of the channel has hung up.
This means that if the corresponding receiver has fallen out of scope,
this function will trigger a fail message saying that a message is
being sent on a closed channel.</p>

<p>Note that if this function does <em>not</em> fail, it does not mean that the
data will be successfully received. All sends are placed into a queue,
so it is possible for a send to succeed (the other end is alive), but
then the other end could immediately disconnect.</p>

<p>The purpose of this functionality is to propagate failure among tasks.
If failure is not desired, then consider using the <code>try_send</code> method</p>
</div><h4 id='method.try_send' class='method'><code>fn <a href='#method.try_send' class='fnname'>try_send</a>(&amp;self, t: T) -&gt; bool</code></h4>
<div class='docblock'><p>Attempts to send a value on this channel, returning whether it was
successfully sent.</p>

<p>A successful send occurs when it is determined that the other end of
the channel has not hung up already. An unsuccessful send would be one
where the corresponding receiver has already been deallocated. Note
that a return value of <code>false</code> means that the data will never be
received, but a return value of <code>true</code> does <em>not</em> mean that the data
will be received.  It is possible for the corresponding receiver to
hang up immediately after this function returns <code>true</code>.</p>

<p>Like <code>send</code>, this method will never block. If the failure of send cannot
be tolerated, then this method should be used instead.</p>
</div></div><h2 id='implementations'>Trait Implementations</h2><h3 class='impl'><code>impl&lt;T: <a class='trait' href='../../std/kinds/trait.Send.html' title='std::kinds::Send'>Send</a>&gt; <a class='trait' href='../../std/clone/trait.Clone.html' title='std::clone::Clone'>Clone</a> for <a class='struct' href='../../std/comm/struct.Sender.html' title='std::comm::Sender'>Sender</a>&lt;T&gt;</code></h3><div class='methods'><h4 id='method.clone' class='method'><code>fn <a href='#method.clone' class='fnname'>clone</a>(&amp;self) -&gt; <a class='struct' href='../../std/comm/struct.Sender.html' title='std::comm::Sender'>Sender</a>&lt;T&gt;</code></h4>
<div class='docblock'><p>Returns a copy of the value. The contents of owned pointers
are copied to maintain uniqueness, while the contents of
managed pointers are not copied.</p>
</div><h4 id='method.clone_from' class='method'><code>fn <a href='#method.clone_from' class='fnname'>clone_from</a>(&amp;mut self, source: &amp;Self)</code></h4>
<div class='docblock'><p>Perform copy-assignment from <code>source</code>.</p>

<p><code>a.clone_from(&amp;b)</code> is equivalent to <code>a = b.clone()</code> in functionality,
but can be overridden to reuse the resources of <code>a</code> to avoid unnecessary
allocations.</p>
</div></div><h3 class='impl'><code>impl&lt;T: <a class='trait' href='../../std/kinds/trait.Send.html' title='std::kinds::Send'>Send</a>&gt; <a class='trait' href='../../std/ops/trait.Drop.html' title='std::ops::Drop'>Drop</a> for <a class='struct' href='../../std/comm/struct.Sender.html' title='std::comm::Sender'>Sender</a>&lt;T&gt;</code></h3><div class='methods'><h4 id='method.drop' class='method'><code>fn <a href='#method.drop' class='fnname'>drop</a>(&amp;mut self)</code></h4>
<div class='docblock'><p>The <code>drop</code> method, called when the value goes out of scope.</p>
</div></div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <div id="help" class="hidden">
        <div class="shortcuts">
            <h1>Keyboard shortcuts</h1>
            <dl>
                <dt>?</dt>
                <dd>Show this help dialog</dd>
                <dt>S</dt>
                <dd>Focus the search field</dd>
                <dt>&uarr;</dt>
                <dd>Move up in search results</dd>
                <dt>&darr;</dt>
                <dd>Move down in search results</dd>
                <dt>&#9166;</dt>
                <dd>Go to active search result</dd>
            </dl>
        </div>
        <div class="infos">
            <h1>Search tricks</h1>
            <p>
                Prefix searches with a type followed by a colon (e.g.
                <code>fn:</code>) to restrict the search to a given type.
            </p>
            <p>
                Accepted types are: <code>fn</code>, <code>mod</code>,
                <code>struct</code> (or <code>str</code>), <code>enum</code>,
                <code>trait</code>, <code>typedef</code> (or
                <code>tdef</code>).
            </p>
        </div>
    </div>

    <script>
        var rootPath = "../../";
        var currentCrate = "std";
    </script>
    <script src="../../jquery.js"></script>
    <script src="../../main.js"></script>
    <script async src="../../search-index.js"></script>
</body>
</html>
