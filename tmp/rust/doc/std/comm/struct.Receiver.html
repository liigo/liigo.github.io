<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>std::comm::Receiver - Rust</title>

    <link href='http://fonts.googleapis.com/css?family=Oswald:700|Inconsolata:400,700'
          rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="../../main.css">

    <link rel="shortcut icon" href="http://www.rust-lang.org/favicon.ico" />
</head>
<body>
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <section class="sidebar">
        
            <a href='../../std/index.html'><img src='http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png' alt=''/></a>
        

        <p class='location'><a href='../index.html'>std</a>&#8203;::<a href='index.html'>comm</a></p><div class='block struct'><h2>Structs</h2><a class='struct ' href='struct.Handle.html' title='A handle to a receiver which is currently a member of a `Select` set of receivers.  This handle is used to keep the receiver in the set as well as interact with the underlying receiver.'>Handle</a><br/><a class='struct ' href='struct.Messages.html' title='An iterator over messages on a receiver, this iterator will block whenever `next` is called, waiting for a new message, and `None` will be returned when the corresponding channel has hung up.'>Messages</a><br/><a class='struct current' href='struct.Receiver.html' title='The receiving-half of Rust's channel type. This half can only be owned by one task'>Receiver</a><br/><a class='struct ' href='struct.Select.html' title='The "receiver set" of the select interface. This structure is used to manage a set of receivers which are being selected over.'>Select</a><br/><a class='struct ' href='struct.Sender.html' title='The sending-half of Rust's channel type. This half can only be owned by one task'>Sender</a><br/></div><div class='block enum'><h2>Enums</h2><a class='enum ' href='enum.TryRecvResult.html' title='This enumeration is the list of the possible reasons that try_recv could not return data when called.'>TryRecvResult</a><br/></div><div class='block fn'><h2>Functions</h2><a class='fn ' href='fn.channel.html' title='Creates a new channel, returning the sender/receiver halves. All data sent on the sender will become available on the receiver. See the documentation of `Receiver` and `Sender` to see what's possible with them.'>channel</a><br/></div>
    </section>

    <nav class="sub">
        <form class="search-form js-only">
            <button class="do-search">Search</button>
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Search documentation..."
                       type="search" />
            </div>
        </form>
    </nav>

    <section id='main' class="content struct"><a class='source'
                              href='../../src/std/MinGW/msys/1.0/home/LIIGO/rust/rust/src/libstd/comm/mod.rs.html#290-295'>[src]</a><h1 class='fqn'>Struct <a href='../index.html'>std</a>::<a href='index.html'>comm</a>::<a class='struct' href=''>Receiver</a></h1><pre class='rust struct'>pub struct Receiver&lt;T&gt; {
    // some fields omitted
}</pre><div class='docblock'><p>The receiving-half of Rust&#39;s channel type. This half can only be owned by
one task</p>
</div><h2 id='methods'>Methods</h2><h3 class='impl'><code>impl&lt;T: <a class='trait' href='../../std/kinds/trait.Send.html' title='std::kinds::Send'>Send</a>&gt; <a class='struct' href='../../std/comm/struct.Receiver.html' title='std::comm::Receiver'>Receiver</a>&lt;T&gt;</code></h3><div class='methods'><h4 id='method.recv' class='method'><code>fn <a href='#method.recv' class='fnname'>recv</a>(&amp;self) -&gt; T</code></h4>
<div class='docblock'><p>Blocks waiting for a value on this receiver</p>

<p>This function will block if necessary to wait for a corresponding send
on the channel from its paired <code>Sender</code> structure. This receiver will
be woken up when data is ready, and the data will be returned.</p>

<h1 id="failure" class='section-link'><a
                           href="#failure">Failure</a></h1>
<p>Similar to channels, this method will trigger a task failure if the
other end of the channel has hung up (been deallocated). The purpose of
this is to propagate failure among tasks.</p>

<p>If failure is not desired, then there are two options:</p>

<ul>
<li><p>If blocking is still desired, the <code>recv_opt</code> method will return <code>None</code>
when the other end hangs up</p></li>
<li><p>If blocking is not desired, then the <code>try_recv</code> method will attempt to
peek at a value on this receiver.</p></li>
</ul>
</div><h4 id='method.try_recv' class='method'><code>fn <a href='#method.try_recv' class='fnname'>try_recv</a>(&amp;self) -&gt; <a class='enum' href='../../std/comm/enum.TryRecvResult.html' title='std::comm::TryRecvResult'>TryRecvResult</a>&lt;T&gt;</code></h4>
<div class='docblock'><p>Attempts to return a pending value on this receiver without blocking</p>

<p>This method will never block the caller in order to wait for data to
become available. Instead, this will always return immediately with a
possible option of pending data on the channel.</p>

<p>This is useful for a flavor of &quot;optimistic check&quot; before deciding to
block on a receiver.</p>

<p>This function cannot fail.</p>
</div><h4 id='method.recv_opt' class='method'><code>fn <a href='#method.recv_opt' class='fnname'>recv_opt</a>(&amp;self) -&gt; <a class='enum' href='../../std/option/enum.Option.html' title='std::option::Option'>Option</a>&lt;T&gt;</code></h4>
<div class='docblock'><p>Attempt to wait for a value on this receiver, but does not fail if the
corresponding channel has hung up.</p>

<p>This implementation of iterators for ports will always block if there is
not data available on the receiver, but it will not fail in the case
that the channel has been deallocated.</p>

<p>In other words, this function has the same semantics as the <code>recv</code>
method except for the failure aspect.</p>

<p>If the channel has hung up, then <code>None</code> is returned. Otherwise <code>Some</code> of
the value found on the receiver is returned.</p>
</div><h4 id='method.iter' class='method'><code>fn <a href='#method.iter' class='fnname'>iter</a>&lt;'a&gt;(&amp;'a self) -&gt; <a class='struct' href='../../std/comm/struct.Messages.html' title='std::comm::Messages'>Messages</a>&lt;'a, T&gt;</code></h4>
<div class='docblock'><p>Returns an iterator which will block waiting for messages, but never
<code>fail!</code>. It will return <code>None</code> when the channel has hung up.</p>
</div></div><h2 id='implementations'>Trait Implementations</h2><h3 class='impl'><code>impl&lt;T: <a class='trait' href='../../std/kinds/trait.Send.html' title='std::kinds::Send'>Send</a>&gt; <a class='trait' href='../../std/ops/trait.Drop.html' title='std::ops::Drop'>Drop</a> for <a class='struct' href='../../std/comm/struct.Receiver.html' title='std::comm::Receiver'>Receiver</a>&lt;T&gt;</code></h3><div class='methods'><h4 id='method.drop' class='method'><code>fn <a href='#method.drop' class='fnname'>drop</a>(&amp;mut self)</code></h4>
<div class='docblock'><p>The <code>drop</code> method, called when the value goes out of scope.</p>
</div></div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <div id="help" class="hidden">
        <div class="shortcuts">
            <h1>Keyboard shortcuts</h1>
            <dl>
                <dt>?</dt>
                <dd>Show this help dialog</dd>
                <dt>S</dt>
                <dd>Focus the search field</dd>
                <dt>&uarr;</dt>
                <dd>Move up in search results</dd>
                <dt>&darr;</dt>
                <dd>Move down in search results</dd>
                <dt>&#9166;</dt>
                <dd>Go to active search result</dd>
            </dl>
        </div>
        <div class="infos">
            <h1>Search tricks</h1>
            <p>
                Prefix searches with a type followed by a colon (e.g.
                <code>fn:</code>) to restrict the search to a given type.
            </p>
            <p>
                Accepted types are: <code>fn</code>, <code>mod</code>,
                <code>struct</code> (or <code>str</code>), <code>enum</code>,
                <code>trait</code>, <code>typedef</code> (or
                <code>tdef</code>).
            </p>
        </div>
    </div>

    <script>
        var rootPath = "../../";
        var currentCrate = "std";
    </script>
    <script src="../../jquery.js"></script>
    <script src="../../main.js"></script>
    <script async src="../../search-index.js"></script>
</body>
</html>
