<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>std::str::OwnedStr - Rust</title>

    <link href='http://fonts.googleapis.com/css?family=Oswald:700|Inconsolata:400,700'
          rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="../../main.css">

    <link rel="shortcut icon" href="http://www.rust-lang.org/favicon.ico" />
</head>
<body>
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <section class="sidebar">
        
            <a href='../../std/index.html'><img src='http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png' alt=''/></a>
        

        <p class='location'><a href='../index.html'>std</a>&#8203;::<a href='index.html'>str</a></p><div class='block mod'><h2>Modules</h2><a class='mod ' href='raw/index.html' title='Unsafe operations'>raw</a><br/></div><div class='block struct'><h2>Structs</h2><a class='struct ' href='struct.CharOffsets.html' title='External iterator for a string's characters and their byte offsets. Use with the `std::iter` module.'>CharOffsets</a><br/><a class='struct ' href='struct.CharRange.html' title='Struct that contains a `char` and the index of the first byte of the next `char` in a string.  This can be used as a data structure for iterating over the UTF-8 bytes of a string.'>CharRange</a><br/><a class='struct ' href='struct.CharSplits.html' title='An iterator over the substrings of a string, separated by `sep`.'>CharSplits</a><br/><a class='struct ' href='struct.CharSplitsN.html' title='An iterator over the substrings of a string, separated by `sep`, splitting at most `count` times.'>CharSplitsN</a><br/><a class='struct ' href='struct.Chars.html' title='External iterator for a string's characters. Use with the `std::iter` module.'>Chars</a><br/><a class='struct ' href='struct.MatchIndices.html' title='An iterator over the start and end indices of the matches of a substring within a larger string'>MatchIndices</a><br/><a class='struct ' href='struct.Normalizations.html' title='External iterator for a string's normalization's characters. Use with the `std::iter` module.'>Normalizations</a><br/><a class='struct ' href='struct.StrSplits.html' title='An iterator over the substrings of a string separated by a given search string'>StrSplits</a><br/><a class='struct ' href='struct.UTF16Items.html' title='An iterator that decodes UTF-16 encoded codepoints from a vector of `u16`s.'>UTF16Items</a><br/></div><div class='block enum'><h2>Enums</h2><a class='enum ' href='enum.MaybeOwned.html' title='A MaybeOwned is a string that can hold either a ~str or a &str. This can be useful as an optimization when an allocation is sometimes needed but not always.'>MaybeOwned</a><br/><a class='enum ' href='enum.UTF16Item.html' title='The possibilities for values decoded from a `u16` stream.'>UTF16Item</a><br/></div><div class='block trait'><h2>Traits</h2><a class='trait ' href='trait.CharEq.html' title='Something that can be used to compare against a character'>CharEq</a><br/><a class='trait ' href='trait.IntoMaybeOwned.html' title='Trait for moving into a `MaybeOwned`'>IntoMaybeOwned</a><br/><a class='trait current' href='trait.OwnedStr.html' title='Methods for owned strings'>OwnedStr</a><br/><a class='trait ' href='trait.Str.html' title='Any string that can be represented as a slice'>Str</a><br/><a class='trait ' href='trait.StrSlice.html' title='Methods for string slices'>StrSlice</a><br/><a class='trait ' href='trait.StrVector.html' title='Methods for vectors of strings'>StrVector</a><br/></div><div class='block fn'><h2>Functions</h2><a class='fn ' href='fn.eq.html' title='Bytewise string equality'>eq</a><br/><a class='fn ' href='fn.eq_slice.html' title='Bytewise slice equality'>eq_slice</a><br/><a class='fn ' href='fn.from_byte.html' title='Convert a byte to a UTF-8 string'>from_byte</a><br/><a class='fn ' href='fn.from_char.html' title='Convert a char to a string'>from_char</a><br/><a class='fn ' href='fn.from_chars.html' title='Convert a vector of chars to a string'>from_chars</a><br/><a class='fn ' href='fn.from_utf16.html' title='Decode a UTF-16 encoded vector `v` into a string, returning `None` if `v` contains any invalid data.'>from_utf16</a><br/><a class='fn ' href='fn.from_utf16_lossy.html' title='Decode a UTF-16 encoded vector `v` into a string, replacing invalid data with the replacement character (U+FFFD).'>from_utf16_lossy</a><br/><a class='fn ' href='fn.from_utf8.html' title='Converts a vector to a string slice without performing any allocations.'>from_utf8</a><br/><a class='fn ' href='fn.from_utf8_lossy.html' title='Converts a vector of bytes to a new utf-8 string. Any invalid utf-8 sequences are replaced with U+FFFD REPLACEMENT CHARACTER.'>from_utf8_lossy</a><br/><a class='fn ' href='fn.from_utf8_owned.html' title='Consumes a vector of bytes to create a new utf-8 string. Returns None if the vector contains invalid UTF-8.'>from_utf8_owned</a><br/><a class='fn ' href='fn.is_utf16.html' title='Determines if a vector of `u16` contains valid UTF-16'>is_utf16</a><br/><a class='fn ' href='fn.is_utf8.html' title='Determines if a vector of bytes contains valid UTF-8.'>is_utf8</a><br/><a class='fn ' href='fn.replace.html' title='Replace all occurrences of one string with another'>replace</a><br/><a class='fn ' href='fn.truncate_utf16_at_nul.html' title='Return a slice of `v` ending at (and not including) the first NUL (0).'>truncate_utf16_at_nul</a><br/><a class='fn ' href='fn.utf16_items.html' title='Create an iterator over the UTF-16 encoded codepoints in `v`, returning invalid surrogates as `LoneSurrogate`s.'>utf16_items</a><br/><a class='fn ' href='fn.utf8_char_width.html' title='Given a first byte, determine how many bytes are in this UTF-8 character'>utf8_char_width</a><br/><a class='fn ' href='fn.with_capacity.html' title='Allocates a new string with the specified capacity. The string returned is the empty string, but has capacity for much more.'>with_capacity</a><br/></div>
    </section>

    <nav class="sub">
        <form class="search-form js-only">
            <button class="do-search">Search</button>
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Search documentation..."
                       type="search" />
            </div>
        </form>
    </nav>

    <section id='main' class="content trait"><a class='source'
                              href='../../src/std/MinGW/msys/1.0/home/LIIGO/rust/rust/src/libstd/str.rs.html#2812-2896'>[src]</a><h1 class='fqn'>Trait <a href='../index.html'>std</a>::<a href='index.html'>str</a>::<a class='trait' href=''>OwnedStr</a></h1><pre class='rust trait'>pub trait OwnedStr {
    fn <a href='#tymethod.push_str_no_overallocate' class='fnname'>push_str_no_overallocate</a>(&amp;mut self, rhs: &amp;str);
    fn <a href='#tymethod.push_str' class='fnname'>push_str</a>(&amp;mut self, rhs: &amp;str);
    fn <a href='#tymethod.push_char' class='fnname'>push_char</a>(&amp;mut self, c: char);
    fn <a href='#tymethod.pop_char' class='fnname'>pop_char</a>(&amp;mut self) -&gt; <a class='enum' href='../../std/option/enum.Option.html' title='std::option::Option'>Option</a>&lt;char&gt;;
    fn <a href='#tymethod.shift_char' class='fnname'>shift_char</a>(&amp;mut self) -&gt; <a class='enum' href='../../std/option/enum.Option.html' title='std::option::Option'>Option</a>&lt;char&gt;;
    fn <a href='#tymethod.unshift_char' class='fnname'>unshift_char</a>(&amp;mut self, ch: char);
    fn <a href='#tymethod.insert' class='fnname'>insert</a>(&amp;mut self, position: uint, substring: &amp;str);
    fn <a href='#tymethod.insert_char' class='fnname'>insert_char</a>(&amp;mut self, position: uint, ch: char);
    fn <a href='#tymethod.append' class='fnname'>append</a>(self, rhs: &amp;str) -&gt; ~str;
    fn <a href='#tymethod.reserve_exact' class='fnname'>reserve_exact</a>(&amp;mut self, n: uint);
    fn <a href='#tymethod.reserve' class='fnname'>reserve</a>(&amp;mut self, n: uint);
    fn <a href='#tymethod.capacity' class='fnname'>capacity</a>(&amp;self) -&gt; uint;
    fn <a href='#tymethod.truncate' class='fnname'>truncate</a>(&amp;mut self, len: uint);
    fn <a href='#tymethod.into_bytes' class='fnname'>into_bytes</a>(self) -&gt; ~[u8];
    unsafe fn <a href='#tymethod.set_len' class='fnname'>set_len</a>(&amp;mut self, new_len: uint);
}</pre><div class='docblock'><p>Methods for owned strings</p>
</div>
            <h2 id='required-methods'>Required Methods</h2>
            <div class='methods'>
        <h3 id='tymethod.push_str_no_overallocate' class='method'><code>fn <a href='#tymethod.push_str_no_overallocate' class='fnname'>push_str_no_overallocate</a>(&amp;mut self, rhs: &amp;str)</code></h3><div class='docblock'><p>Appends a string slice to the back of a string, without overallocating.</p>
</div><h3 id='tymethod.push_str' class='method'><code>fn <a href='#tymethod.push_str' class='fnname'>push_str</a>(&amp;mut self, rhs: &amp;str)</code></h3><div class='docblock'><p>Appends a string slice to the back of a string</p>
</div><h3 id='tymethod.push_char' class='method'><code>fn <a href='#tymethod.push_char' class='fnname'>push_char</a>(&amp;mut self, c: char)</code></h3><div class='docblock'><p>Appends a character to the back of a string</p>
</div><h3 id='tymethod.pop_char' class='method'><code>fn <a href='#tymethod.pop_char' class='fnname'>pop_char</a>(&amp;mut self) -&gt; <a class='enum' href='../../std/option/enum.Option.html' title='std::option::Option'>Option</a>&lt;char&gt;</code></h3><div class='docblock'><p>Remove the final character from a string and return it. Return None
when the string is empty.</p>
</div><h3 id='tymethod.shift_char' class='method'><code>fn <a href='#tymethod.shift_char' class='fnname'>shift_char</a>(&amp;mut self) -&gt; <a class='enum' href='../../std/option/enum.Option.html' title='std::option::Option'>Option</a>&lt;char&gt;</code></h3><div class='docblock'><p>Remove the first character from a string and return it. Return None
when the string is empty.</p>
</div><h3 id='tymethod.unshift_char' class='method'><code>fn <a href='#tymethod.unshift_char' class='fnname'>unshift_char</a>(&amp;mut self, ch: char)</code></h3><div class='docblock'><p>Prepend a char to a string</p>
</div><h3 id='tymethod.insert' class='method'><code>fn <a href='#tymethod.insert' class='fnname'>insert</a>(&amp;mut self, position: uint, substring: &amp;str)</code></h3><div class='docblock'><p>Insert a new sub-string at the given position in a string, in O(n + m) time
(with n and m the lengths of the string and the substring.)
This fails if <code>position</code> is not at a character boundary.</p>
</div><h3 id='tymethod.insert_char' class='method'><code>fn <a href='#tymethod.insert_char' class='fnname'>insert_char</a>(&amp;mut self, position: uint, ch: char)</code></h3><div class='docblock'><p>Insert a char at the given position in a string, in O(n + m) time
(with n and m the lengths of the string and the substring.)
This fails if <code>position</code> is not at a character boundary.</p>
</div><h3 id='tymethod.append' class='method'><code>fn <a href='#tymethod.append' class='fnname'>append</a>(self, rhs: &amp;str) -&gt; ~str</code></h3><div class='docblock'><p>Concatenate two strings together.</p>
</div><h3 id='tymethod.reserve_exact' class='method'><code>fn <a href='#tymethod.reserve_exact' class='fnname'>reserve_exact</a>(&amp;mut self, n: uint)</code></h3><div class='docblock'><p>Reserves capacity for exactly <code>n</code> bytes in the given string.</p>

<p>Assuming single-byte characters, the resulting string will be large
enough to hold a string of length <code>n</code>.</p>

<p>If the capacity for <code>s</code> is already equal to or greater than the requested
capacity, then no action is taken.</p>

<h1 id="arguments" class='section-link'><a
                           href="#arguments">Arguments</a></h1>
<ul>
<li>s - A string</li>
<li>n - The number of bytes to reserve space for</li>
</ul>
</div><h3 id='tymethod.reserve' class='method'><code>fn <a href='#tymethod.reserve' class='fnname'>reserve</a>(&amp;mut self, n: uint)</code></h3><div class='docblock'><p>Reserves capacity for at least <code>n</code> bytes in the given string.</p>

<p>Assuming single-byte characters, the resulting string will be large
enough to hold a string of length <code>n</code>.</p>

<p>This function will over-allocate in order to amortize the allocation costs
in scenarios where the caller may need to repeatedly reserve additional
space.</p>

<p>If the capacity for <code>s</code> is already equal to or greater than the requested
capacity, then no action is taken.</p>

<h1 id="arguments-1" class='section-link'><a
                           href="#arguments-1">Arguments</a></h1>
<ul>
<li>s - A string</li>
<li>n - The number of bytes to reserve space for</li>
</ul>
</div><h3 id='tymethod.capacity' class='method'><code>fn <a href='#tymethod.capacity' class='fnname'>capacity</a>(&amp;self) -&gt; uint</code></h3><div class='docblock'><p>Returns the number of single-byte characters the string can hold without
reallocating</p>
</div><h3 id='tymethod.truncate' class='method'><code>fn <a href='#tymethod.truncate' class='fnname'>truncate</a>(&amp;mut self, len: uint)</code></h3><div class='docblock'><p>Shorten a string to the specified length (which must be &lt;= the current length)</p>
</div><h3 id='tymethod.into_bytes' class='method'><code>fn <a href='#tymethod.into_bytes' class='fnname'>into_bytes</a>(self) -&gt; ~[u8]</code></h3><div class='docblock'><p>Consumes the string, returning the underlying byte buffer.</p>

<p>The buffer does not have a null terminator.</p>
</div><h3 id='tymethod.set_len' class='method'><code>unsafe fn <a href='#tymethod.set_len' class='fnname'>set_len</a>(&amp;mut self, new_len: uint)</code></h3><div class='docblock'><p>Sets the length of a string</p>

<p>This will explicitly set the size of the string, without actually
modifying its buffers, so it is up to the caller to ensure that
the string is actually the specified size.</p>
</div></div>
                    <h2 id='implementors'>Implementors</h2>
                    <ul class='item-list'>
                <li><code>impl <a class='trait' href='../../std/str/trait.OwnedStr.html' title='std::str::OwnedStr'>OwnedStr</a> for ~str</code></li></ul></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <div id="help" class="hidden">
        <div class="shortcuts">
            <h1>Keyboard shortcuts</h1>
            <dl>
                <dt>?</dt>
                <dd>Show this help dialog</dd>
                <dt>S</dt>
                <dd>Focus the search field</dd>
                <dt>&uarr;</dt>
                <dd>Move up in search results</dd>
                <dt>&darr;</dt>
                <dd>Move down in search results</dd>
                <dt>&#9166;</dt>
                <dd>Go to active search result</dd>
            </dl>
        </div>
        <div class="infos">
            <h1>Search tricks</h1>
            <p>
                Prefix searches with a type followed by a colon (e.g.
                <code>fn:</code>) to restrict the search to a given type.
            </p>
            <p>
                Accepted types are: <code>fn</code>, <code>mod</code>,
                <code>struct</code> (or <code>str</code>), <code>enum</code>,
                <code>trait</code>, <code>typedef</code> (or
                <code>tdef</code>).
            </p>
        </div>
    </div>

    <script>
        var rootPath = "../../";
        var currentCrate = "std";
    </script>
    <script src="../../jquery.js"></script>
    <script src="../../main.js"></script>
    <script async src="../../search-index.js"></script>
</body>
</html>
