<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>std::kinds::marker::InvariantLifetime - Rust</title>

    <link href='http://fonts.googleapis.com/css?family=Oswald:700|Inconsolata:400,700'
          rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="../../../main.css">

    <link rel="shortcut icon" href="http://www.rust-lang.org/favicon.ico" />
</head>
<body>
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <section class="sidebar">
        
            <a href='../../../std/index.html'><img src='http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png' alt=''/></a>
        

        <p class='location'><a href='../../index.html'>std</a>&#8203;::<a href='../index.html'>kinds</a>&#8203;::<a href='index.html'>marker</a></p><div class='block struct'><h2>Structs</h2><a class='struct ' href='struct.ContravariantLifetime.html' title='As `ContravariantType`, but for lifetime parameters. Using `ContravariantLifetime<'a>` indicates that it is ok to substitute a *shorter* lifetime for `'a` than the one you originally started with (e.g., you could convert `'static` to any lifetime `'foo`). This is appropriate for cases where you have an unsafe pointer that is actually a pointer into some memory with lifetime `'a`, and thus you want to limit the lifetime of your data structure to `'a`. An example of where this is used is the iterator for vectors.'>ContravariantLifetime</a><br/><a class='struct ' href='struct.ContravariantType.html' title='A marker type whose type parameter `T` is considered to be contravariant with respect to the type itself. This is (typically) used to indicate that an instance of the type `T` will be consumed (but not read from), even though that may not be apparent.'>ContravariantType</a><br/><a class='struct ' href='struct.CovariantLifetime.html' title='As `CovariantType`, but for lifetime parameters. Using `CovariantLifetime<'a>` indicates that it is ok to substitute a *longer* lifetime for `'a` than the one you originally started with (e.g., you could convert any lifetime `'foo` to `'static`). You almost certainly want `ContravariantLifetime` instead, or possibly `InvariantLifetime`. The only case where it would be appropriate is that you have a (type-casted, and hence hidden from the type system) function pointer with a signature like `fn(&'a T)` (and no other uses of `'a`). In this case, it is ok to substitute a larger lifetime for `'a` (e.g., `fn(&'static T)`), because the function is only becoming more selective in terms of what it accepts as argument.'>CovariantLifetime</a><br/><a class='struct ' href='struct.CovariantType.html' title='A marker type whose type parameter `T` is considered to be covariant with respect to the type itself. This is (typically) used to indicate that an instance of the type `T` is being stored into memory and read from, even though that may not be apparent.'>CovariantType</a><br/><a class='struct current' href='struct.InvariantLifetime.html' title='As `InvariantType`, but for lifetime parameters. Using `InvariantLifetime<'a>` indicates that it is not ok to substitute any other lifetime for `'a` besides its original value. This is appropriate for cases where you have an unsafe pointer that is actually a pointer into memory with lifetime `'a`, and this pointer is itself stored in an inherently mutable location (such as a `Cell`).'>InvariantLifetime</a><br/><a class='struct ' href='struct.InvariantType.html' title='A marker type whose type parameter `T` is considered to be invariant with respect to the type itself. This is (typically) used to indicate that instances of the type `T` may be read or written, even though that may not be apparent.'>InvariantType</a><br/><a class='struct ' href='struct.Managed.html' title='A type which is considered managed by the GC. This is typically embedded in other types.'>Managed</a><br/><a class='struct ' href='struct.NoFreeze.html' title='A type which is considered "not freezable", meaning that its contents could change even if stored in an immutable context or it is the referent of an `&T` pointer. This is typically embedded in other types, such as `Cell`.'>NoFreeze</a><br/><a class='struct ' href='struct.NoPod.html' title='A type which is considered "not POD", meaning that it is not implicitly copyable. This is typically embedded in other types to ensure that they are never copied, even if they lack a destructor.'>NoPod</a><br/><a class='struct ' href='struct.NoSend.html' title='A type which is considered "not sendable", meaning that it cannot be safely sent between tasks, even if it is owned. This is typically embedded in other types, such as `Gc`, to ensure that their instances remain thread-local.'>NoSend</a><br/></div>
    </section>

    <nav class="sub">
        <form class="search-form js-only">
            <button class="do-search">Search</button>
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Search documentation..."
                       type="search" />
            </div>
        </form>
    </nav>

    <section id='main' class="content struct"><a class='source'
                              href='../../../src/std/MinGW/msys/1.0/home/LIIGO/rust/rust/src/libstd/kinds.rs.html#210'>[src]</a><h1 class='fqn'>Struct <a href='../../index.html'>std</a>::<a href='../index.html'>kinds</a>::<a href='index.html'>marker</a>::<a class='struct' href=''>InvariantLifetime</a></h1><pre class='rust struct'>pub struct InvariantLifetime&lt;'a&gt;;</pre><div class='docblock'><p>As <code>InvariantType</code>, but for lifetime parameters. Using
<code>InvariantLifetime&lt;&#39;a&gt;</code> indicates that it is not ok to
substitute any other lifetime for <code>&#39;a</code> besides its original
value. This is appropriate for cases where you have an unsafe
pointer that is actually a pointer into memory with lifetime <code>&#39;a</code>,
and this pointer is itself stored in an inherently mutable
location (such as a <code>Cell</code>).</p>
</div><h2 id='implementations'>Trait Implementations</h2><h3 class='impl'><code>impl&lt;'a&gt; <a class='trait' href='../../../std/clone/trait.Clone.html' title='std::clone::Clone'>Clone</a> for <a class='struct' href='../../../std/kinds/marker/struct.InvariantLifetime.html' title='std::kinds::marker::InvariantLifetime'>InvariantLifetime</a>&lt;'a&gt;</code></h3><div class='methods'><h4 id='method.clone' class='method'><code>fn <a href='#method.clone' class='fnname'>clone</a>(&amp;self) -&gt; <a class='struct' href='../../../std/kinds/marker/struct.InvariantLifetime.html' title='std::kinds::marker::InvariantLifetime'>InvariantLifetime</a>&lt;'a&gt;</code></h4>
<div class='docblock'><p>Returns a copy of the value. The contents of owned pointers
are copied to maintain uniqueness, while the contents of
managed pointers are not copied.</p>
</div><h4 id='method.clone_from' class='method'><code>fn <a href='#method.clone_from' class='fnname'>clone_from</a>(&amp;mut self, source: &amp;Self)</code></h4>
<div class='docblock'><p>Perform copy-assignment from <code>source</code>.</p>

<p><code>a.clone_from(&amp;b)</code> is equivalent to <code>a = b.clone()</code> in functionality,
but can be overridden to reuse the resources of <code>a</code> to avoid unnecessary
allocations.</p>
</div></div><h3 class='impl'><code>impl&lt;'a&gt; <a class='trait' href='../../../std/cmp/trait.Eq.html' title='std::cmp::Eq'>Eq</a> for <a class='struct' href='../../../std/kinds/marker/struct.InvariantLifetime.html' title='std::kinds::marker::InvariantLifetime'>InvariantLifetime</a>&lt;'a&gt;</code></h3><div class='methods'><h4 id='method.eq' class='method'><code>fn <a href='#method.eq' class='fnname'>eq</a>(&amp;self, __arg_0: &amp;<a class='struct' href='../../../std/kinds/marker/struct.InvariantLifetime.html' title='std::kinds::marker::InvariantLifetime'>InvariantLifetime</a>&lt;'a&gt;) -&gt; bool</code></h4>
<h4 id='method.ne' class='method'><code>fn <a href='#method.ne' class='fnname'>ne</a>(&amp;self, __arg_0: &amp;<a class='struct' href='../../../std/kinds/marker/struct.InvariantLifetime.html' title='std::kinds::marker::InvariantLifetime'>InvariantLifetime</a>&lt;'a&gt;) -&gt; bool</code></h4>
</div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <div id="help" class="hidden">
        <div class="shortcuts">
            <h1>Keyboard shortcuts</h1>
            <dl>
                <dt>?</dt>
                <dd>Show this help dialog</dd>
                <dt>S</dt>
                <dd>Focus the search field</dd>
                <dt>&uarr;</dt>
                <dd>Move up in search results</dd>
                <dt>&darr;</dt>
                <dd>Move down in search results</dd>
                <dt>&#9166;</dt>
                <dd>Go to active search result</dd>
            </dl>
        </div>
        <div class="infos">
            <h1>Search tricks</h1>
            <p>
                Prefix searches with a type followed by a colon (e.g.
                <code>fn:</code>) to restrict the search to a given type.
            </p>
            <p>
                Accepted types are: <code>fn</code>, <code>mod</code>,
                <code>struct</code> (or <code>str</code>), <code>enum</code>,
                <code>trait</code>, <code>typedef</code> (or
                <code>tdef</code>).
            </p>
        </div>
    </div>

    <script>
        var rootPath = "../../../";
        var currentCrate = "std";
    </script>
    <script src="../../../jquery.js"></script>
    <script src="../../../main.js"></script>
    <script async src="../../../search-index.js"></script>
</body>
</html>
