<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>std::iter::Fuse - Rust</title>

    <link href='http://fonts.googleapis.com/css?family=Oswald:700|Inconsolata:400,700'
          rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="../../main.css">

    <link rel="shortcut icon" href="http://www.rust-lang.org/favicon.ico" />
</head>
<body>
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <section class="sidebar">
        
            <a href='../../std/index.html'><img src='http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png' alt=''/></a>
        

        <p class='location'><a href='../index.html'>std</a>&#8203;::<a href='index.html'>iter</a></p><div class='block mod'><h2>Modules</h2><a class='mod ' href='order/index.html' title='Functions for lexicographical ordering of sequences.'>order</a><br/></div><div class='block struct'><h2>Structs</h2><a class='struct ' href='struct.ByRef.html' title='A mutable reference to an iterator'>ByRef</a><br/><a class='struct ' href='struct.Chain.html' title='An iterator which strings two iterators together'>Chain</a><br/><a class='struct ' href='struct.Counter.html' title='An infinite iterator starting at `start` and advancing by `step` with each iteration'>Counter</a><br/><a class='struct ' href='struct.Cycle.html' title='An iterator that repeats endlessly'>Cycle</a><br/><a class='struct ' href='struct.Enumerate.html' title='An iterator which yields the current count and the element during iteration'>Enumerate</a><br/><a class='struct ' href='struct.Filter.html' title='An iterator which filters the elements of `iter` with `predicate`'>Filter</a><br/><a class='struct ' href='struct.FilterMap.html' title='An iterator which uses `f` to both filter and map elements from `iter`'>FilterMap</a><br/><a class='struct ' href='struct.FlatMap.html' title='An iterator that maps each element to an iterator, and yields the elements of the produced iterators '>FlatMap</a><br/><a class='struct current' href='struct.Fuse.html' title='An iterator that yields `None` forever after the underlying iterator yields `None` once.'>Fuse</a><br/><a class='struct ' href='struct.Inspect.html' title='An iterator that calls a function with a reference to each element before yielding it.'>Inspect</a><br/><a class='struct ' href='struct.Map.html' title='An iterator which maps the values of `iter` with `f`'>Map</a><br/><a class='struct ' href='struct.Peekable.html' title='An iterator with a `peek()` that returns an optional reference to the next element.'>Peekable</a><br/><a class='struct ' href='struct.Range.html' title='An iterator over the range [start, stop)'>Range</a><br/><a class='struct ' href='struct.RangeInclusive.html' title='An iterator over the range [start, stop]'>RangeInclusive</a><br/><a class='struct ' href='struct.RangeStep.html' title='An iterator over the range [start, stop) by `step`. It handles overflow by stopping.'>RangeStep</a><br/><a class='struct ' href='struct.RangeStepInclusive.html' title='An iterator over the range [start, stop] by `step`. It handles overflow by stopping.'>RangeStepInclusive</a><br/><a class='struct ' href='struct.Repeat.html' title='An iterator that repeats an element endlessly'>Repeat</a><br/><a class='struct ' href='struct.Rev.html' title='An double-ended iterator with the direction inverted'>Rev</a><br/><a class='struct ' href='struct.Scan.html' title='An iterator to maintain state while iterating another iterator'>Scan</a><br/><a class='struct ' href='struct.Skip.html' title='An iterator which skips over `n` elements of `iter`.'>Skip</a><br/><a class='struct ' href='struct.SkipWhile.html' title='An iterator which rejects elements while `predicate` is true'>SkipWhile</a><br/><a class='struct ' href='struct.Take.html' title='An iterator which only iterates over the first `n` iterations of `iter`.'>Take</a><br/><a class='struct ' href='struct.TakeWhile.html' title='An iterator which only accepts elements while `predicate` is true'>TakeWhile</a><br/><a class='struct ' href='struct.Unfold.html' title='An iterator which just modifies the contained state throughout iteration.'>Unfold</a><br/><a class='struct ' href='struct.Zip.html' title='An iterator which iterates two other iterators simultaneously'>Zip</a><br/></div><div class='block enum'><h2>Enums</h2><a class='enum ' href='enum.MinMaxResult.html' title='`MinMaxResult` is an enum returned by `min_max`. See `OrdIterator::min_max` for more detail.'>MinMaxResult</a><br/></div><div class='block trait'><h2>Traits</h2><a class='trait ' href='trait.AdditiveIterator.html' title='A trait for iterators over elements which can be added together'>AdditiveIterator</a><br/><a class='trait ' href='trait.CloneableIterator.html' title='A trait for iterators that are cloneable.'>CloneableIterator</a><br/><a class='trait ' href='trait.DoubleEndedIterator.html' title='A range iterator able to yield elements from both ends'>DoubleEndedIterator</a><br/><a class='trait ' href='trait.ExactSize.html' title='An iterator that knows its exact length'>ExactSize</a><br/><a class='trait ' href='trait.Extendable.html' title='A type growable from an `Iterator` implementation'>Extendable</a><br/><a class='trait ' href='trait.FromIterator.html' title='Conversion from an `Iterator`'>FromIterator</a><br/><a class='trait ' href='trait.Iterator.html' title='An interface for dealing with "external iterators". These types of iterators can be resumed at any time as all state is stored internally as opposed to being located on the call stack.'>Iterator</a><br/><a class='trait ' href='trait.MultiplicativeIterator.html' title='A trait for iterators over elements whose elements can be multiplied together.'>MultiplicativeIterator</a><br/><a class='trait ' href='trait.MutableDoubleEndedIterator.html' title='A double-ended iterator yielding mutable references'>MutableDoubleEndedIterator</a><br/><a class='trait ' href='trait.OrdIterator.html' title='A trait for iterators over elements which can be compared to one another. The type of each element must ascribe to the `Ord` trait.'>OrdIterator</a><br/><a class='trait ' href='trait.RandomAccessIterator.html' title='An object implementing random access indexing by `uint`'>RandomAccessIterator</a><br/></div><div class='block fn'><h2>Functions</h2><a class='fn ' href='fn.count.html' title='Creates a new counter with the specified start/step'>count</a><br/><a class='fn ' href='fn.range.html' title='Return an iterator over the range [start, stop)'>range</a><br/><a class='fn ' href='fn.range_inclusive.html' title='Return an iterator over the range [start, stop]'>range_inclusive</a><br/><a class='fn ' href='fn.range_step.html' title='Return an iterator over the range [start, stop) by `step`. It handles overflow by stopping.'>range_step</a><br/><a class='fn ' href='fn.range_step_inclusive.html' title='Return an iterator over the range [start, stop] by `step`. It handles overflow by stopping.'>range_step_inclusive</a><br/></div>
    </section>

    <nav class="sub">
        <form class="search-form js-only">
            <button class="do-search">Search</button>
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Search documentation..."
                       type="search" />
            </div>
        </form>
    </nav>

    <section id='main' class="content struct"><a class='source'
                              href='../../src/std/MinGW/msys/1.0/home/LIIGO/rust/rust/src/libstd/iter.rs.html#1761-1764'>[src]</a><h1 class='fqn'>Struct <a href='../index.html'>std</a>::<a href='index.html'>iter</a>::<a class='struct' href=''>Fuse</a></h1><pre class='rust struct'>pub struct Fuse&lt;T&gt; {
    // some fields omitted
}</pre><div class='docblock'><p>An iterator that yields <code>None</code> forever after the underlying iterator
yields <code>None</code> once.</p>
</div><h2 id='methods'>Methods</h2><h3 class='impl'><code>impl&lt;T&gt; <a class='struct' href='../../std/iter/struct.Fuse.html' title='std::iter::Fuse'>Fuse</a>&lt;T&gt;</code></h3><div class='methods'><h4 id='method.reset_fuse' class='method'><code>fn <a href='#method.reset_fuse' class='fnname'>reset_fuse</a>(&amp;mut self)</code></h4>
<div class='docblock'><p>Resets the fuse such that the next call to .next() or .next_back() will
call the underlying iterator again even if it previously returned None.</p>
</div></div><h2 id='implementations'>Trait Implementations</h2><h3 class='impl'><code>impl&lt;T: <a class='trait' href='../../std/clone/trait.Clone.html' title='std::clone::Clone'>Clone</a>&gt; <a class='trait' href='../../std/clone/trait.Clone.html' title='std::clone::Clone'>Clone</a> for <a class='struct' href='../../std/iter/struct.Fuse.html' title='std::iter::Fuse'>Fuse</a>&lt;T&gt;</code></h3><div class='methods'><h4 id='method.clone' class='method'><code>fn <a href='#method.clone' class='fnname'>clone</a>(&amp;self) -&gt; <a class='struct' href='../../std/iter/struct.Fuse.html' title='std::iter::Fuse'>Fuse</a>&lt;T&gt;</code></h4>
<div class='docblock'><p>Returns a copy of the value. The contents of owned pointers
are copied to maintain uniqueness, while the contents of
managed pointers are not copied.</p>
</div><h4 id='method.clone_from' class='method'><code>fn <a href='#method.clone_from' class='fnname'>clone_from</a>(&amp;mut self, source: &amp;Self)</code></h4>
<div class='docblock'><p>Perform copy-assignment from <code>source</code>.</p>

<p><code>a.clone_from(&amp;b)</code> is equivalent to <code>a = b.clone()</code> in functionality,
but can be overridden to reuse the resources of <code>a</code> to avoid unnecessary
allocations.</p>
</div></div><h3 class='impl'><code>impl&lt;A, T: <a class='trait' href='../../std/iter/trait.Iterator.html' title='std::iter::Iterator'>Iterator</a>&lt;A&gt;&gt; <a class='trait' href='../../std/iter/trait.Iterator.html' title='std::iter::Iterator'>Iterator</a>&lt;A&gt; for <a class='struct' href='../../std/iter/struct.Fuse.html' title='std::iter::Fuse'>Fuse</a>&lt;T&gt;</code></h3><div class='methods'><h4 id='method.next' class='method'><code>fn <a href='#method.next' class='fnname'>next</a>(&amp;mut self) -&gt; <a class='enum' href='../../std/option/enum.Option.html' title='std::option::Option'>Option</a>&lt;A&gt;</code></h4>
<div class='docblock'><p>Advance the iterator and return the next value. Return <code>None</code> when the end is reached.</p>
</div><h4 id='method.size_hint' class='method'><code>fn <a href='#method.size_hint' class='fnname'>size_hint</a>(&amp;self) -&gt; (uint, <a class='enum' href='../../std/option/enum.Option.html' title='std::option::Option'>Option</a>&lt;uint&gt;)</code></h4>
<div class='docblock'><p>Return a lower bound and upper bound on the remaining length of the iterator.</p>

<p>The common use case for the estimate is pre-allocating space to store the results.</p>
</div><h4 id='method.chain' class='method'><code>fn <a href='#method.chain' class='fnname'>chain</a>&lt;U: <a class='trait' href='../../std/iter/trait.Iterator.html' title='std::iter::Iterator'>Iterator</a>&lt;A&gt;&gt;(self, other: U) -&gt; <a class='struct' href='../../std/iter/struct.Chain.html' title='std::iter::Chain'>Chain</a>&lt;Self, U&gt;</code></h4>
<div class='docblock'><p>Chain this iterator with another, returning a new iterator which will
finish iterating over the current iterator, and then it will iterate
over the other specified iterator.</p>

<h1 id="example" class='section-link'><a
                           href="#example">Example</a></h1><pre class='rust '>
<span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> [<span class='number'>0</span>];
<span class='kw'>let</span> <span class='ident'>b</span> <span class='op'>=</span> [<span class='number'>1</span>];
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>it</span> <span class='op'>=</span> <span class='ident'>a</span>.<span class='ident'>iter</span>().<span class='ident'>chain</span>(<span class='ident'>b</span>.<span class='ident'>iter</span>());
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>().<span class='ident'>unwrap</span>(), <span class='kw-2'>&amp;</span><span class='number'>0</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>().<span class='ident'>unwrap</span>(), <span class='kw-2'>&amp;</span><span class='number'>1</span>);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>().<span class='ident'>is_none</span>());
</pre>
</div><h4 id='method.zip' class='method'><code>fn <a href='#method.zip' class='fnname'>zip</a>&lt;B, U: <a class='trait' href='../../std/iter/trait.Iterator.html' title='std::iter::Iterator'>Iterator</a>&lt;B&gt;&gt;(self, other: U) -&gt; <a class='struct' href='../../std/iter/struct.Zip.html' title='std::iter::Zip'>Zip</a>&lt;Self, U&gt;</code></h4>
<div class='docblock'><p>Creates an iterator which iterates over both this and the specified
iterators simultaneously, yielding the two elements as pairs. When
either iterator returns None, all further invocations of next() will
return None.</p>

<h1 id="example-1" class='section-link'><a
                           href="#example-1">Example</a></h1><pre class='rust '>
<span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> [<span class='number'>0</span>];
<span class='kw'>let</span> <span class='ident'>b</span> <span class='op'>=</span> [<span class='number'>1</span>];
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>it</span> <span class='op'>=</span> <span class='ident'>a</span>.<span class='ident'>iter</span>().<span class='ident'>zip</span>(<span class='ident'>b</span>.<span class='ident'>iter</span>());
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>().<span class='ident'>unwrap</span>(), (<span class='kw-2'>&amp;</span><span class='number'>0</span>, <span class='kw-2'>&amp;</span><span class='number'>1</span>));
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>().<span class='ident'>is_none</span>());
</pre>
</div><h4 id='method.map' class='method'><code>fn <a href='#method.map' class='fnname'>map</a>&lt;'r, B&gt;(self, f: 'r |A| -&gt; B) -&gt; <a class='struct' href='../../std/iter/struct.Map.html' title='std::iter::Map'>Map</a>&lt;'r, A, B, Self&gt;</code></h4>
<div class='docblock'><p>Creates a new iterator which will apply the specified function to each
element returned by the first, yielding the mapped element instead.</p>

<h1 id="example-2" class='section-link'><a
                           href="#example-2">Example</a></h1><pre class='rust '>
<span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> [<span class='number'>1</span>, <span class='number'>2</span>];
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>it</span> <span class='op'>=</span> <span class='ident'>a</span>.<span class='ident'>iter</span>().<span class='ident'>map</span>(<span class='op'>|</span><span class='kw-2'>&amp;</span><span class='ident'>x</span><span class='op'>|</span> <span class='number'>2</span> <span class='op'>*</span> <span class='ident'>x</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>().<span class='ident'>unwrap</span>(), <span class='number'>2</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>().<span class='ident'>unwrap</span>(), <span class='number'>4</span>);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>().<span class='ident'>is_none</span>());
</pre>
</div><h4 id='method.filter' class='method'><code>fn <a href='#method.filter' class='fnname'>filter</a>&lt;'r&gt;(self, predicate: 'r |&amp;A| -&gt; bool) -&gt; <a class='struct' href='../../std/iter/struct.Filter.html' title='std::iter::Filter'>Filter</a>&lt;'r, A, Self&gt;</code></h4>
<div class='docblock'><p>Creates an iterator which applies the predicate to each element returned
by this iterator. Only elements which have the predicate evaluate to
<code>true</code> will be yielded.</p>

<h1 id="example-3" class='section-link'><a
                           href="#example-3">Example</a></h1><pre class='rust '>
<span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> [<span class='number'>1</span>, <span class='number'>2</span>];
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>it</span> <span class='op'>=</span> <span class='ident'>a</span>.<span class='ident'>iter</span>().<span class='ident'>filter</span>(<span class='op'>|</span><span class='kw-2'>&amp;</span><span class='ident'>x</span><span class='op'>|</span> <span class='op'>*</span><span class='ident'>x</span> <span class='op'>&gt;</span> <span class='number'>1</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>().<span class='ident'>unwrap</span>(), <span class='kw-2'>&amp;</span><span class='number'>2</span>);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>().<span class='ident'>is_none</span>());
</pre>
</div><h4 id='method.filter_map' class='method'><code>fn <a href='#method.filter_map' class='fnname'>filter_map</a>&lt;'r, B&gt;(self, f: 'r |A| -&gt; <a class='enum' href='../../std/option/enum.Option.html' title='std::option::Option'>Option</a>&lt;B&gt;) -&gt; <a class='struct' href='../../std/iter/struct.FilterMap.html' title='std::iter::FilterMap'>FilterMap</a>&lt;'r, A, B, Self&gt;</code></h4>
<div class='docblock'><p>Creates an iterator which both filters and maps elements.
If the specified function returns None, the element is skipped.
Otherwise the option is unwrapped and the new value is yielded.</p>

<h1 id="example-4" class='section-link'><a
                           href="#example-4">Example</a></h1><pre class='rust '>
<span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> [<span class='number'>1</span>, <span class='number'>2</span>];
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>it</span> <span class='op'>=</span> <span class='ident'>a</span>.<span class='ident'>iter</span>().<span class='ident'>filter_map</span>(<span class='op'>|</span><span class='kw-2'>&amp;</span><span class='ident'>x</span><span class='op'>|</span> <span class='kw'>if</span> <span class='ident'>x</span> <span class='op'>&gt;</span> <span class='number'>1</span> {<span class='prelude-val'>Some</span>(<span class='number'>2</span> <span class='op'>*</span> <span class='ident'>x</span>)} <span class='kw'>else</span> {<span class='prelude-val'>None</span>});
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>().<span class='ident'>unwrap</span>(), <span class='number'>4</span>);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>().<span class='ident'>is_none</span>());
</pre>
</div><h4 id='method.enumerate' class='method'><code>fn <a href='#method.enumerate' class='fnname'>enumerate</a>(self) -&gt; <a class='struct' href='../../std/iter/struct.Enumerate.html' title='std::iter::Enumerate'>Enumerate</a>&lt;Self&gt;</code></h4>
<div class='docblock'><p>Creates an iterator which yields a pair of the value returned by this
iterator plus the current index of iteration.</p>

<h1 id="example-5" class='section-link'><a
                           href="#example-5">Example</a></h1><pre class='rust '>
<span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> [<span class='number'>100</span>, <span class='number'>200</span>];
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>it</span> <span class='op'>=</span> <span class='ident'>a</span>.<span class='ident'>iter</span>().<span class='ident'>enumerate</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>().<span class='ident'>unwrap</span>(), (<span class='number'>0</span>, <span class='kw-2'>&amp;</span><span class='number'>100</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>().<span class='ident'>unwrap</span>(), (<span class='number'>1</span>, <span class='kw-2'>&amp;</span><span class='number'>200</span>));
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>().<span class='ident'>is_none</span>());
</pre>
</div><h4 id='method.peekable' class='method'><code>fn <a href='#method.peekable' class='fnname'>peekable</a>(self) -&gt; <a class='struct' href='../../std/iter/struct.Peekable.html' title='std::iter::Peekable'>Peekable</a>&lt;A, Self&gt;</code></h4>
<div class='docblock'><p>Creates an iterator that has a <code>.peek()</code> method
that returns an optional reference to the next element.</p>

<h1 id="example-6" class='section-link'><a
                           href="#example-6">Example</a></h1><pre class='rust '>
<span class='kw'>let</span> <span class='ident'>xs</span> <span class='op'>=</span> [<span class='number'>100</span>, <span class='number'>200</span>, <span class='number'>300</span>];
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>it</span> <span class='op'>=</span> <span class='ident'>xs</span>.<span class='ident'>iter</span>().<span class='ident'>map</span>(<span class='op'>|</span><span class='ident'>x</span><span class='op'>|</span> <span class='op'>*</span><span class='ident'>x</span>).<span class='ident'>peekable</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>peek</span>().<span class='ident'>unwrap</span>(), <span class='kw-2'>&amp;</span><span class='number'>100</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>().<span class='ident'>unwrap</span>(), <span class='number'>100</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>().<span class='ident'>unwrap</span>(), <span class='number'>200</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>peek</span>().<span class='ident'>unwrap</span>(), <span class='kw-2'>&amp;</span><span class='number'>300</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>peek</span>().<span class='ident'>unwrap</span>(), <span class='kw-2'>&amp;</span><span class='number'>300</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>().<span class='ident'>unwrap</span>(), <span class='number'>300</span>);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>peek</span>().<span class='ident'>is_none</span>());
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>().<span class='ident'>is_none</span>());
</pre>
</div><h4 id='method.skip_while' class='method'><code>fn <a href='#method.skip_while' class='fnname'>skip_while</a>&lt;'r&gt;(self, predicate: 'r |&amp;A| -&gt; bool) -&gt; <a class='struct' href='../../std/iter/struct.SkipWhile.html' title='std::iter::SkipWhile'>SkipWhile</a>&lt;'r, A, Self&gt;</code></h4>
<div class='docblock'><p>Creates an iterator which invokes the predicate on elements until it
returns false. Once the predicate returns false, all further elements are
yielded.</p>

<h1 id="example-7" class='section-link'><a
                           href="#example-7">Example</a></h1><pre class='rust '>
<span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>2</span>, <span class='number'>1</span>];
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>it</span> <span class='op'>=</span> <span class='ident'>a</span>.<span class='ident'>iter</span>().<span class='ident'>skip_while</span>(<span class='op'>|</span><span class='kw-2'>&amp;</span><span class='ident'>a</span><span class='op'>|</span> <span class='op'>*</span><span class='ident'>a</span> <span class='op'>&lt;</span> <span class='number'>3</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>().<span class='ident'>unwrap</span>(), <span class='kw-2'>&amp;</span><span class='number'>3</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>().<span class='ident'>unwrap</span>(), <span class='kw-2'>&amp;</span><span class='number'>2</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>().<span class='ident'>unwrap</span>(), <span class='kw-2'>&amp;</span><span class='number'>1</span>);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>().<span class='ident'>is_none</span>());
</pre>
</div><h4 id='method.take_while' class='method'><code>fn <a href='#method.take_while' class='fnname'>take_while</a>&lt;'r&gt;(self, predicate: 'r |&amp;A| -&gt; bool) -&gt; <a class='struct' href='../../std/iter/struct.TakeWhile.html' title='std::iter::TakeWhile'>TakeWhile</a>&lt;'r, A, Self&gt;</code></h4>
<div class='docblock'><p>Creates an iterator which yields elements so long as the predicate
returns true. After the predicate returns false for the first time, no
further elements will be yielded.</p>

<h1 id="example-8" class='section-link'><a
                           href="#example-8">Example</a></h1><pre class='rust '>
<span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>2</span>, <span class='number'>1</span>];
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>it</span> <span class='op'>=</span> <span class='ident'>a</span>.<span class='ident'>iter</span>().<span class='ident'>take_while</span>(<span class='op'>|</span><span class='kw-2'>&amp;</span><span class='ident'>a</span><span class='op'>|</span> <span class='op'>*</span><span class='ident'>a</span> <span class='op'>&lt;</span> <span class='number'>3</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>().<span class='ident'>unwrap</span>(), <span class='kw-2'>&amp;</span><span class='number'>1</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>().<span class='ident'>unwrap</span>(), <span class='kw-2'>&amp;</span><span class='number'>2</span>);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>().<span class='ident'>is_none</span>());
</pre>
</div><h4 id='method.skip' class='method'><code>fn <a href='#method.skip' class='fnname'>skip</a>(self, n: uint) -&gt; <a class='struct' href='../../std/iter/struct.Skip.html' title='std::iter::Skip'>Skip</a>&lt;Self&gt;</code></h4>
<div class='docblock'><p>Creates an iterator which skips the first <code>n</code> elements of this iterator,
and then it yields all further items.</p>

<h1 id="example-9" class='section-link'><a
                           href="#example-9">Example</a></h1><pre class='rust '>
<span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>, <span class='number'>5</span>];
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>it</span> <span class='op'>=</span> <span class='ident'>a</span>.<span class='ident'>iter</span>().<span class='ident'>skip</span>(<span class='number'>3</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>().<span class='ident'>unwrap</span>(), <span class='kw-2'>&amp;</span><span class='number'>4</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>().<span class='ident'>unwrap</span>(), <span class='kw-2'>&amp;</span><span class='number'>5</span>);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>().<span class='ident'>is_none</span>());
</pre>
</div><h4 id='method.take' class='method'><code>fn <a href='#method.take' class='fnname'>take</a>(self, n: uint) -&gt; <a class='struct' href='../../std/iter/struct.Take.html' title='std::iter::Take'>Take</a>&lt;Self&gt;</code></h4>
<div class='docblock'><p>Creates an iterator which yields the first <code>n</code> elements of this
iterator, and then it will always return None.</p>

<h1 id="example-10" class='section-link'><a
                           href="#example-10">Example</a></h1><pre class='rust '>
<span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>, <span class='number'>5</span>];
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>it</span> <span class='op'>=</span> <span class='ident'>a</span>.<span class='ident'>iter</span>().<span class='ident'>take</span>(<span class='number'>3</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>().<span class='ident'>unwrap</span>(), <span class='kw-2'>&amp;</span><span class='number'>1</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>().<span class='ident'>unwrap</span>(), <span class='kw-2'>&amp;</span><span class='number'>2</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>().<span class='ident'>unwrap</span>(), <span class='kw-2'>&amp;</span><span class='number'>3</span>);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>().<span class='ident'>is_none</span>());
</pre>
</div><h4 id='method.scan' class='method'><code>fn <a href='#method.scan' class='fnname'>scan</a>&lt;'r, St, B&gt;(self, initial_state: St, f: 'r |&amp;mut St, A| -&gt; <a class='enum' href='../../std/option/enum.Option.html' title='std::option::Option'>Option</a>&lt;B&gt;) -&gt; <a class='struct' href='../../std/iter/struct.Scan.html' title='std::iter::Scan'>Scan</a>&lt;'r, A, B, Self, St&gt;</code></h4>
<div class='docblock'><p>Creates a new iterator which behaves in a similar fashion to foldl.
There is a state which is passed between each iteration and can be
mutated as necessary. The yielded values from the closure are yielded
from the Scan instance when not None.</p>

<h1 id="example-11" class='section-link'><a
                           href="#example-11">Example</a></h1><pre class='rust '>
<span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>, <span class='number'>5</span>];
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>it</span> <span class='op'>=</span> <span class='ident'>a</span>.<span class='ident'>iter</span>().<span class='ident'>scan</span>(<span class='number'>1</span>, <span class='op'>|</span><span class='ident'>fac</span>, <span class='kw-2'>&amp;</span><span class='ident'>x</span><span class='op'>|</span> {
  <span class='op'>*</span><span class='ident'>fac</span> <span class='op'>=</span> <span class='op'>*</span><span class='ident'>fac</span> <span class='op'>*</span> <span class='ident'>x</span>;
  <span class='prelude-val'>Some</span>(<span class='op'>*</span><span class='ident'>fac</span>)
});
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>().<span class='ident'>unwrap</span>(), <span class='number'>1</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>().<span class='ident'>unwrap</span>(), <span class='number'>2</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>().<span class='ident'>unwrap</span>(), <span class='number'>6</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>().<span class='ident'>unwrap</span>(), <span class='number'>24</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>().<span class='ident'>unwrap</span>(), <span class='number'>120</span>);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>().<span class='ident'>is_none</span>());
</pre>
</div><h4 id='method.flat_map' class='method'><code>fn <a href='#method.flat_map' class='fnname'>flat_map</a>&lt;'r, B, U: <a class='trait' href='../../std/iter/trait.Iterator.html' title='std::iter::Iterator'>Iterator</a>&lt;B&gt;&gt;(self, f: 'r |A| -&gt; U) -&gt; <a class='struct' href='../../std/iter/struct.FlatMap.html' title='std::iter::FlatMap'>FlatMap</a>&lt;'r, A, Self, U&gt;</code></h4>
<div class='docblock'><p>Creates an iterator that maps each element to an iterator,
and yields the elements of the produced iterators</p>

<h1 id="example-12" class='section-link'><a
                           href="#example-12">Example</a></h1><pre class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>iter</span>::<span class='ident'>count</span>;

<span class='kw'>let</span> <span class='ident'>xs</span> <span class='op'>=</span> [<span class='number'>2u</span>, <span class='number'>3</span>];
<span class='kw'>let</span> <span class='ident'>ys</span> <span class='op'>=</span> [<span class='number'>0u</span>, <span class='number'>1</span>, <span class='number'>0</span>, <span class='number'>1</span>, <span class='number'>2</span>];
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>it</span> <span class='op'>=</span> <span class='ident'>xs</span>.<span class='ident'>iter</span>().<span class='ident'>flat_map</span>(<span class='op'>|</span><span class='kw-2'>&amp;</span><span class='ident'>x</span><span class='op'>|</span> <span class='ident'>count</span>(<span class='number'>0u</span>, <span class='number'>1</span>).<span class='ident'>take</span>(<span class='ident'>x</span>));<span class='comment'>
// Check that `it` has the same elements as `ys`
</span><span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>i</span> <span class='op'>=</span> <span class='number'>0</span>;
<span class='kw'>for</span> <span class='ident'>x</span> <span class='kw'>in</span> <span class='ident'>it</span> {
    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>x</span>, <span class='ident'>ys</span>[<span class='ident'>i</span>]);
    <span class='ident'>i</span> <span class='op'>+=</span> <span class='number'>1</span>;
}
</pre>
</div><h4 id='method.fuse' class='method'><code>fn <a href='#method.fuse' class='fnname'>fuse</a>(self) -&gt; <a class='struct' href='../../std/iter/struct.Fuse.html' title='std::iter::Fuse'>Fuse</a>&lt;Self&gt;</code></h4>
<div class='docblock'><p>Creates an iterator that yields <code>None</code> forever after the underlying
iterator yields <code>None</code>. Random-access iterator behavior is not
affected, only single and double-ended iterator behavior.</p>

<h1 id="example-13" class='section-link'><a
                           href="#example-13">Example</a></h1><pre class='rust '>
<span class='kw'>fn</span> <span class='ident'>process</span><span class='op'>&lt;</span><span class='ident'>U</span>: <span class='ident'>Iterator</span><span class='op'>&lt;</span><span class='ident'>int</span><span class='op'>&gt;&gt;</span>(<span class='ident'>it</span>: <span class='ident'>U</span>) <span class='op'>-&gt;</span> <span class='ident'>int</span> {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>it</span> <span class='op'>=</span> <span class='ident'>it</span>.<span class='ident'>fuse</span>();
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>sum</span> <span class='op'>=</span> <span class='number'>0</span>;
    <span class='kw'>for</span> <span class='ident'>x</span> <span class='kw'>in</span> <span class='ident'>it</span> {
        <span class='kw'>if</span> <span class='ident'>x</span> <span class='op'>&gt;</span> <span class='number'>5</span> {
            <span class='kw'>continue</span>;
        }
        <span class='ident'>sum</span> <span class='op'>+=</span> <span class='ident'>x</span>;
    }<span class='comment'>
    // did we exhaust the iterator?
    </span><span class='kw'>if</span> <span class='ident'>it</span>.<span class='ident'>next</span>().<span class='ident'>is_none</span>() {
        <span class='ident'>sum</span> <span class='op'>+=</span> <span class='number'>1000</span>;
    }
    <span class='ident'>sum</span>
}
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='kw-2'>~</span>[<span class='number'>1</span>,<span class='number'>2</span>,<span class='number'>3</span>,<span class='number'>7</span>,<span class='number'>8</span>,<span class='number'>9</span>];
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>process</span>(<span class='ident'>x</span>.<span class='ident'>move_iter</span>()), <span class='number'>1006</span>);
</pre>
</div><h4 id='method.inspect' class='method'><code>fn <a href='#method.inspect' class='fnname'>inspect</a>&lt;'r&gt;(self, f: 'r |&amp;A|) -&gt; <a class='struct' href='../../std/iter/struct.Inspect.html' title='std::iter::Inspect'>Inspect</a>&lt;'r, A, Self&gt;</code></h4>
<div class='docblock'><p>Creates an iterator that calls a function with a reference to each
element before yielding it. This is often useful for debugging an
iterator pipeline.</p>

<h1 id="example-14" class='section-link'><a
                           href="#example-14">Example</a></h1><pre class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>iter</span>::<span class='ident'>AdditiveIterator</span>;

<span class='kw'>let</span> <span class='ident'>xs</span> <span class='op'>=</span> [<span class='number'>1u</span>, <span class='number'>4</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>8</span>, <span class='number'>9</span>, <span class='number'>6</span>];
<span class='kw'>let</span> <span class='ident'>sum</span> <span class='op'>=</span> <span class='ident'>xs</span>.<span class='ident'>iter</span>()
            .<span class='ident'>map</span>(<span class='op'>|</span><span class='kw-2'>&amp;</span><span class='ident'>x</span><span class='op'>|</span> <span class='ident'>x</span>)
            .<span class='ident'>inspect</span>(<span class='op'>|</span><span class='kw-2'>&amp;</span><span class='ident'>x</span><span class='op'>|</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;filtering {}&quot;</span>, <span class='ident'>x</span>))
            .<span class='ident'>filter</span>(<span class='op'>|</span><span class='kw-2'>&amp;</span><span class='ident'>x</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>%</span> <span class='number'>2</span> <span class='op'>==</span> <span class='number'>0</span>)
            .<span class='ident'>inspect</span>(<span class='op'>|</span><span class='kw-2'>&amp;</span><span class='ident'>x</span><span class='op'>|</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{} made it through&quot;</span>, <span class='ident'>x</span>))
            .<span class='ident'>sum</span>();
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>sum</span>);
</pre>
</div><h4 id='method.by_ref' class='method'><code>fn <a href='#method.by_ref' class='fnname'>by_ref</a>&lt;'r&gt;(&amp;'r mut self) -&gt; <a class='struct' href='../../std/iter/struct.ByRef.html' title='std::iter::ByRef'>ByRef</a>&lt;'r, Self&gt;</code></h4>
<div class='docblock'><p>Creates a wrapper around a mutable reference to the iterator.</p>

<p>This is useful to allow applying iterator adaptors while still
retaining ownership of the original iterator value.</p>

<h1 id="example-15" class='section-link'><a
                           href="#example-15">Example</a></h1><pre class='rust '>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>xs</span> <span class='op'>=</span> <span class='ident'>range</span>(<span class='number'>0</span>, <span class='number'>10</span>);<span class='comment'>
// sum the first five values
</span><span class='kw'>let</span> <span class='ident'>partial_sum</span> <span class='op'>=</span> <span class='ident'>xs</span>.<span class='ident'>by_ref</span>().<span class='ident'>take</span>(<span class='number'>5</span>).<span class='ident'>fold</span>(<span class='number'>0</span>, <span class='op'>|</span><span class='ident'>a</span>, <span class='ident'>b</span><span class='op'>|</span> <span class='ident'>a</span> <span class='op'>+</span> <span class='ident'>b</span>);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>partial_sum</span> <span class='op'>==</span> <span class='number'>10</span>);<span class='comment'>
// xs.next() is now `5`
</span><span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>xs</span>.<span class='ident'>next</span>() <span class='op'>==</span> <span class='prelude-val'>Some</span>(<span class='number'>5</span>));
</pre>
</div><h4 id='method.advance' class='method'><code>fn <a href='#method.advance' class='fnname'>advance</a>(&amp;mut self, f: |A| -&gt; bool) -&gt; bool</code></h4>
<div class='docblock'><p>Apply a function to each element, or stop iterating if the
function returns <code>false</code>.</p>

<h1 id="example-16" class='section-link'><a
                           href="#example-16">Example</a></h1><pre class='rust '>
<span class='ident'>range</span>(<span class='number'>0</span>, <span class='number'>5</span>).<span class='ident'>advance</span>(<span class='op'>|</span><span class='ident'>x</span><span class='op'>|</span> {<span class='macro'>print</span><span class='macro'>!</span>(<span class='string'>&quot;{} &quot;</span>, <span class='ident'>x</span>); <span class='boolval'>true</span>});
</pre>
</div><h4 id='method.collect' class='method'><code>fn <a href='#method.collect' class='fnname'>collect</a>&lt;B: <a class='trait' href='../../std/iter/trait.FromIterator.html' title='std::iter::FromIterator'>FromIterator</a>&lt;A&gt;&gt;(&amp;mut self) -&gt; B</code></h4>
<div class='docblock'><p>Loops through the entire iterator, collecting all of the elements into
a container implementing <code>FromIterator</code>.</p>

<h1 id="example-17" class='section-link'><a
                           href="#example-17">Example</a></h1><pre class='rust '>
<span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>, <span class='number'>5</span>];
<span class='kw'>let</span> <span class='ident'>b</span>: <span class='kw-2'>~</span>[<span class='ident'>int</span>] <span class='op'>=</span> <span class='ident'>a</span>.<span class='ident'>iter</span>().<span class='ident'>map</span>(<span class='op'>|</span><span class='kw-2'>&amp;</span><span class='ident'>x</span><span class='op'>|</span> <span class='ident'>x</span>).<span class='ident'>collect</span>();
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>a</span> <span class='op'>==</span> <span class='ident'>b</span>);
</pre>
</div><h4 id='method.to_owned_vec' class='method'><code>fn <a href='#method.to_owned_vec' class='fnname'>to_owned_vec</a>(&amp;mut self) -&gt; ~[A]</code></h4>
<div class='docblock'><p>Loops through the entire iterator, collecting all of the elements into
a unique vector. This is simply collect() specialized for vectors.</p>

<h1 id="example-18" class='section-link'><a
                           href="#example-18">Example</a></h1><pre class='rust '>
<span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>, <span class='number'>5</span>];
<span class='kw'>let</span> <span class='ident'>b</span>: <span class='kw-2'>~</span>[<span class='ident'>int</span>] <span class='op'>=</span> <span class='ident'>a</span>.<span class='ident'>iter</span>().<span class='ident'>map</span>(<span class='op'>|</span><span class='kw-2'>&amp;</span><span class='ident'>x</span><span class='op'>|</span> <span class='ident'>x</span>).<span class='ident'>to_owned_vec</span>();
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>a</span> <span class='op'>==</span> <span class='ident'>b</span>);
</pre>
</div><h4 id='method.nth' class='method'><code>fn <a href='#method.nth' class='fnname'>nth</a>(&amp;mut self, n: uint) -&gt; <a class='enum' href='../../std/option/enum.Option.html' title='std::option::Option'>Option</a>&lt;A&gt;</code></h4>
<div class='docblock'><p>Loops through <code>n</code> iterations, returning the <code>n</code>th element of the
iterator.</p>

<h1 id="example-19" class='section-link'><a
                           href="#example-19">Example</a></h1><pre class='rust '>
<span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>, <span class='number'>5</span>];
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>it</span> <span class='op'>=</span> <span class='ident'>a</span>.<span class='ident'>iter</span>();
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>nth</span>(<span class='number'>2</span>).<span class='ident'>unwrap</span>() <span class='op'>==</span> <span class='kw-2'>&amp;</span><span class='number'>3</span>);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>nth</span>(<span class='number'>2</span>) <span class='op'>==</span> <span class='prelude-val'>None</span>);
</pre>
</div><h4 id='method.last' class='method'><code>fn <a href='#method.last' class='fnname'>last</a>(&amp;mut self) -&gt; <a class='enum' href='../../std/option/enum.Option.html' title='std::option::Option'>Option</a>&lt;A&gt;</code></h4>
<div class='docblock'><p>Loops through the entire iterator, returning the last element of the
iterator.</p>

<h1 id="example-20" class='section-link'><a
                           href="#example-20">Example</a></h1><pre class='rust '>
<span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>, <span class='number'>5</span>];
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>a</span>.<span class='ident'>iter</span>().<span class='ident'>last</span>().<span class='ident'>unwrap</span>() <span class='op'>==</span> <span class='kw-2'>&amp;</span><span class='number'>5</span>);
</pre>
</div><h4 id='method.fold' class='method'><code>fn <a href='#method.fold' class='fnname'>fold</a>&lt;B&gt;(&amp;mut self, init: B, f: |B, A| -&gt; B) -&gt; B</code></h4>
<div class='docblock'><p>Performs a fold operation over the entire iterator, returning the
eventual state at the end of the iteration.</p>

<h1 id="example-21" class='section-link'><a
                           href="#example-21">Example</a></h1><pre class='rust '>
<span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>, <span class='number'>5</span>];
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>a</span>.<span class='ident'>iter</span>().<span class='ident'>fold</span>(<span class='number'>0</span>, <span class='op'>|</span><span class='ident'>a</span>, <span class='kw-2'>&amp;</span><span class='ident'>b</span><span class='op'>|</span> <span class='ident'>a</span> <span class='op'>+</span> <span class='ident'>b</span>) <span class='op'>==</span> <span class='number'>15</span>);
</pre>
</div><h4 id='method.len' class='method'><code>fn <a href='#method.len' class='fnname'>len</a>(&amp;mut self) -&gt; uint</code></h4>
<div class='docblock'><p>Counts the number of elements in this iterator.</p>

<h1 id="example-22" class='section-link'><a
                           href="#example-22">Example</a></h1><pre class='rust '>
<span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>, <span class='number'>5</span>];
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>it</span> <span class='op'>=</span> <span class='ident'>a</span>.<span class='ident'>iter</span>();
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>len</span>() <span class='op'>==</span> <span class='number'>5</span>);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>len</span>() <span class='op'>==</span> <span class='number'>0</span>);
</pre>
</div><h4 id='method.all' class='method'><code>fn <a href='#method.all' class='fnname'>all</a>(&amp;mut self, f: |A| -&gt; bool) -&gt; bool</code></h4>
<div class='docblock'><p>Tests whether the predicate holds true for all elements in the iterator.</p>

<h1 id="example-23" class='section-link'><a
                           href="#example-23">Example</a></h1><pre class='rust '>
<span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>, <span class='number'>5</span>];
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>a</span>.<span class='ident'>iter</span>().<span class='ident'>all</span>(<span class='op'>|</span><span class='ident'>x</span><span class='op'>|</span> <span class='op'>*</span><span class='ident'>x</span> <span class='op'>&gt;</span> <span class='number'>0</span>));
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='op'>!</span><span class='ident'>a</span>.<span class='ident'>iter</span>().<span class='ident'>all</span>(<span class='op'>|</span><span class='ident'>x</span><span class='op'>|</span> <span class='op'>*</span><span class='ident'>x</span> <span class='op'>&gt;</span> <span class='number'>2</span>));
</pre>
</div><h4 id='method.any' class='method'><code>fn <a href='#method.any' class='fnname'>any</a>(&amp;mut self, f: |A| -&gt; bool) -&gt; bool</code></h4>
<div class='docblock'><p>Tests whether any element of an iterator satisfies the specified
predicate.</p>

<h1 id="example-24" class='section-link'><a
                           href="#example-24">Example</a></h1><pre class='rust '>
<span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>, <span class='number'>5</span>];
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>it</span> <span class='op'>=</span> <span class='ident'>a</span>.<span class='ident'>iter</span>();
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>any</span>(<span class='op'>|</span><span class='ident'>x</span><span class='op'>|</span> <span class='op'>*</span><span class='ident'>x</span> <span class='op'>==</span> <span class='number'>3</span>));
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='op'>!</span><span class='ident'>it</span>.<span class='ident'>any</span>(<span class='op'>|</span><span class='ident'>x</span><span class='op'>|</span> <span class='op'>*</span><span class='ident'>x</span> <span class='op'>==</span> <span class='number'>3</span>));
</pre>
</div><h4 id='method.find' class='method'><code>fn <a href='#method.find' class='fnname'>find</a>(&amp;mut self, predicate: |&amp;A| -&gt; bool) -&gt; <a class='enum' href='../../std/option/enum.Option.html' title='std::option::Option'>Option</a>&lt;A&gt;</code></h4>
<div class='docblock'><p>Return the first element satisfying the specified predicate</p>
</div><h4 id='method.position' class='method'><code>fn <a href='#method.position' class='fnname'>position</a>(&amp;mut self, predicate: |A| -&gt; bool) -&gt; <a class='enum' href='../../std/option/enum.Option.html' title='std::option::Option'>Option</a>&lt;uint&gt;</code></h4>
<div class='docblock'><p>Return the index of the first element satisfying the specified predicate</p>
</div><h4 id='method.count' class='method'><code>fn <a href='#method.count' class='fnname'>count</a>(&amp;mut self, predicate: |A| -&gt; bool) -&gt; uint</code></h4>
<div class='docblock'><p>Count the number of elements satisfying the specified predicate</p>
</div><h4 id='method.max_by' class='method'><code>fn <a href='#method.max_by' class='fnname'>max_by</a>&lt;B: <a class='trait' href='../../std/cmp/trait.TotalOrd.html' title='std::cmp::TotalOrd'>TotalOrd</a>&gt;(&amp;mut self, f: |&amp;A| -&gt; B) -&gt; <a class='enum' href='../../std/option/enum.Option.html' title='std::option::Option'>Option</a>&lt;A&gt;</code></h4>
<div class='docblock'><p>Return the element that gives the maximum value from the
specified function.</p>

<h1 id="example-25" class='section-link'><a
                           href="#example-25">Example</a></h1><pre class='rust '>
<span class='kw'>let</span> <span class='ident'>xs</span> <span class='op'>=</span> [<span class='op'>-</span><span class='number'>3i</span>, <span class='number'>0</span>, <span class='number'>1</span>, <span class='number'>5</span>, <span class='op'>-</span><span class='number'>10</span>];
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='op'>*</span><span class='ident'>xs</span>.<span class='ident'>iter</span>().<span class='ident'>max_by</span>(<span class='op'>|</span><span class='ident'>x</span><span class='op'>|</span> <span class='ident'>x</span>.<span class='ident'>abs</span>()).<span class='ident'>unwrap</span>(), <span class='op'>-</span><span class='number'>10</span>);
</pre>
</div><h4 id='method.min_by' class='method'><code>fn <a href='#method.min_by' class='fnname'>min_by</a>&lt;B: <a class='trait' href='../../std/cmp/trait.TotalOrd.html' title='std::cmp::TotalOrd'>TotalOrd</a>&gt;(&amp;mut self, f: |&amp;A| -&gt; B) -&gt; <a class='enum' href='../../std/option/enum.Option.html' title='std::option::Option'>Option</a>&lt;A&gt;</code></h4>
<div class='docblock'><p>Return the element that gives the minimum value from the
specified function.</p>

<h1 id="example-26" class='section-link'><a
                           href="#example-26">Example</a></h1><pre class='rust '>
<span class='kw'>let</span> <span class='ident'>xs</span> <span class='op'>=</span> [<span class='op'>-</span><span class='number'>3i</span>, <span class='number'>0</span>, <span class='number'>1</span>, <span class='number'>5</span>, <span class='op'>-</span><span class='number'>10</span>];
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='op'>*</span><span class='ident'>xs</span>.<span class='ident'>iter</span>().<span class='ident'>min_by</span>(<span class='op'>|</span><span class='ident'>x</span><span class='op'>|</span> <span class='ident'>x</span>.<span class='ident'>abs</span>()).<span class='ident'>unwrap</span>(), <span class='number'>0</span>);
</pre>
</div></div><h3 class='impl'><code>impl&lt;A, T: <a class='trait' href='../../std/iter/trait.DoubleEndedIterator.html' title='std::iter::DoubleEndedIterator'>DoubleEndedIterator</a>&lt;A&gt;&gt; <a class='trait' href='../../std/iter/trait.DoubleEndedIterator.html' title='std::iter::DoubleEndedIterator'>DoubleEndedIterator</a>&lt;A&gt; for <a class='struct' href='../../std/iter/struct.Fuse.html' title='std::iter::Fuse'>Fuse</a>&lt;T&gt;</code></h3><div class='methods'><h4 id='method.next_back' class='method'><code>fn <a href='#method.next_back' class='fnname'>next_back</a>(&amp;mut self) -&gt; <a class='enum' href='../../std/option/enum.Option.html' title='std::option::Option'>Option</a>&lt;A&gt;</code></h4>
<div class='docblock'><p>Yield an element from the end of the range, returning <code>None</code> if the range is empty.</p>
</div><h4 id='method.rev' class='method'><code>fn <a href='#method.rev' class='fnname'>rev</a>(self) -&gt; <a class='struct' href='../../std/iter/struct.Rev.html' title='std::iter::Rev'>Rev</a>&lt;Self&gt;</code></h4>
<div class='docblock'><p>Change the direction of the iterator</p>

<p>The flipped iterator swaps the ends on an iterator that can already
be iterated from the front and from the back.</p>

<p>If the iterator also implements RandomAccessIterator, the flipped
iterator is also random access, with the indices starting at the back
of the original iterator.</p>

<p>Note: Random access with flipped indices still only applies to the first
<code>uint::MAX</code> elements of the original iterator.</p>
</div></div><h3 class='impl'><code>impl&lt;A, T: <a class='trait' href='../../std/iter/trait.RandomAccessIterator.html' title='std::iter::RandomAccessIterator'>RandomAccessIterator</a>&lt;A&gt;&gt; <a class='trait' href='../../std/iter/trait.RandomAccessIterator.html' title='std::iter::RandomAccessIterator'>RandomAccessIterator</a>&lt;A&gt; for <a class='struct' href='../../std/iter/struct.Fuse.html' title='std::iter::Fuse'>Fuse</a>&lt;T&gt;</code></h3><div class='methods'><h4 id='method.indexable' class='method'><code>fn <a href='#method.indexable' class='fnname'>indexable</a>(&amp;self) -&gt; uint</code></h4>
<div class='docblock'><p>Return the number of indexable elements. At most <code>std::uint::MAX</code>
elements are indexable, even if the iterator represents a longer range.</p>
</div><h4 id='method.idx' class='method'><code>fn <a href='#method.idx' class='fnname'>idx</a>(&amp;self, index: uint) -&gt; <a class='enum' href='../../std/option/enum.Option.html' title='std::option::Option'>Option</a>&lt;A&gt;</code></h4>
<div class='docblock'><p>Return an element at an index</p>
</div></div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <div id="help" class="hidden">
        <div class="shortcuts">
            <h1>Keyboard shortcuts</h1>
            <dl>
                <dt>?</dt>
                <dd>Show this help dialog</dd>
                <dt>S</dt>
                <dd>Focus the search field</dd>
                <dt>&uarr;</dt>
                <dd>Move up in search results</dd>
                <dt>&darr;</dt>
                <dd>Move down in search results</dd>
                <dt>&#9166;</dt>
                <dd>Go to active search result</dd>
            </dl>
        </div>
        <div class="infos">
            <h1>Search tricks</h1>
            <p>
                Prefix searches with a type followed by a colon (e.g.
                <code>fn:</code>) to restrict the search to a given type.
            </p>
            <p>
                Accepted types are: <code>fn</code>, <code>mod</code>,
                <code>struct</code> (or <code>str</code>), <code>enum</code>,
                <code>trait</code>, <code>typedef</code> (or
                <code>tdef</code>).
            </p>
        </div>
    </div>

    <script>
        var rootPath = "../../";
        var currentCrate = "std";
    </script>
    <script src="../../jquery.js"></script>
    <script src="../../main.js"></script>
    <script async src="../../search-index.js"></script>
</body>
</html>
