<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>std::path::windows::Path - Rust</title>

    <link href='http://fonts.googleapis.com/css?family=Oswald:700|Inconsolata:400,700'
          rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="../../../main.css">

    <link rel="shortcut icon" href="http://www.rust-lang.org/favicon.ico" />
</head>
<body>
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <section class="sidebar">
        
            <a href='../../../std/index.html'><img src='http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png' alt=''/></a>
        

        <p class='location'><a href='../../index.html'>std</a>&#8203;::<a href='../index.html'>path</a>&#8203;::<a href='index.html'>windows</a></p><div class='block struct'><h2>Structs</h2><a class='struct current' href='struct.Path.html' title='Represents a Windows path'>Path</a><br/></div><div class='block enum'><h2>Enums</h2><a class='enum ' href='enum.PathPrefix.html' title='Prefix types for Path'>PathPrefix</a><br/></div><div class='block fn'><h2>Functions</h2><a class='fn ' href='fn.is_cwd_relative.html' title='Returns whether the path is considered "cwd-relative", which means a path with a volume prefix that is not absolute. This look like "C:foo.txt". Paths of this form are relative to the cwd on the given volume.'>is_cwd_relative</a><br/><a class='fn ' href='fn.is_sep.html' title='Returns whether the given char is a path separator. Allows both the primary separator '\' and the alternative separator '/'.'>is_sep</a><br/><a class='fn ' href='fn.is_sep_byte.html' title='Returns whether the given byte is a path separator. Allows both the primary separator '\' and the alternative separator '/'.'>is_sep_byte</a><br/><a class='fn ' href='fn.is_sep_byte_verbatim.html' title='Returns whether the given byte is a path separator. Only allows the primary separator '\'; use is_sep_byte to allow '/'.'>is_sep_byte_verbatim</a><br/><a class='fn ' href='fn.is_sep_verbatim.html' title='Returns whether the given char is a path separator. Only allows the primary separator '\'; use is_sep to allow '/'.'>is_sep_verbatim</a><br/><a class='fn ' href='fn.is_verbatim.html' title='Returns whether the Path's prefix is a verbatim prefix, i.e. `\\?\`'>is_verbatim</a><br/><a class='fn ' href='fn.is_vol_relative.html' title='Returns whether the path is considered "volume-relative", which means a path that looks like "\foo". Paths of this form are relative to the current volume, but absolute within that volume.'>is_vol_relative</a><br/><a class='fn ' href='fn.make_non_verbatim.html' title='Returns the non-verbatim equivalent of the input path, if possible. If the input path is a device namespace path, None is returned. If the input path is not verbatim, it is returned as-is. If the input path is verbatim, but the same path can be expressed as non-verbatim, the non-verbatim version is returned. Otherwise, None is returned.'>make_non_verbatim</a><br/><a class='fn ' href='fn.prefix.html' title='Returns the PathPrefix for this Path'>prefix</a><br/></div>
    </section>

    <nav class="sub">
        <form class="search-form js-only">
            <button class="do-search">Search</button>
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Search documentation..."
                       type="search" />
            </div>
        </form>
    </nav>

    <section id='main' class="content struct"><a class='source'
                              href='../../../src/std/MinGW/msys/1.0/home/LIIGO/rust/rust/src/libstd/path/windows.rs.html#83-87'>[src]</a><h1 class='fqn'>Struct <a href='../../index.html'>std</a>::<a href='../index.html'>path</a>::<a href='index.html'>windows</a>::<a class='struct' href=''>Path</a></h1><pre class='rust struct'>pub struct Path {
    // some fields omitted
}</pre><div class='docblock'><p>Represents a Windows path</p>
</div><h2 id='methods'>Methods</h2><h3 class='impl'><code>impl <a class='struct' href='../../../std/path/windows/struct.Path.html' title='std::path::windows::Path'>Path</a></code></h3><div class='methods'><h4 id='method.stat' class='method'><code>fn <a href='#method.stat' class='fnname'>stat</a>(&amp;self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;<a class='struct' href='../../../std/io/struct.FileStat.html' title='std::io::FileStat'>FileStat</a>&gt;</code></h4>
<div class='docblock'><p>Get information on the file, directory, etc at this path.</p>

<p>Consult the <code>file::stat</code> documentation for more info.</p>

<p>This call preserves identical runtime/error semantics with <code>file::stat</code>.</p>
</div><h4 id='method.exists' class='method'><code>fn <a href='#method.exists' class='fnname'>exists</a>(&amp;self) -&gt; bool</code></h4>
<div class='docblock'><p>Boolean value indicator whether the underlying file exists on the local
filesystem. This will return true if the path points to either a
directory or a file.</p>

<h1 id="error" class='section-link'><a
                           href="#error">Error</a></h1>
<p>Will not raise a condition</p>
</div><h4 id='method.is_file' class='method'><code>fn <a href='#method.is_file' class='fnname'>is_file</a>(&amp;self) -&gt; bool</code></h4>
<div class='docblock'><p>Whether the underlying implementation (be it a file path, or something
else) points at a &quot;regular file&quot; on the FS. Will return false for paths
to non-existent locations or directories or other non-regular files
(named pipes, etc).</p>

<h1 id="error-1" class='section-link'><a
                           href="#error-1">Error</a></h1>
<p>Will not raise a condition</p>
</div><h4 id='method.is_dir' class='method'><code>fn <a href='#method.is_dir' class='fnname'>is_dir</a>(&amp;self) -&gt; bool</code></h4>
<div class='docblock'><p>Whether the underlying implementation (be it a file path,
or something else) is pointing at a directory in the underlying FS.
Will return false for paths to non-existent locations or if the item is
not a directory (eg files, named pipes, links, etc)</p>

<h1 id="error-2" class='section-link'><a
                           href="#error-2">Error</a></h1>
<p>Will not raise a condition</p>
</div></div><h3 class='impl'><code>impl <a class='struct' href='../../../std/path/windows/struct.Path.html' title='std::path::windows::Path'>Path</a></code></h3><div class='methods'><h4 id='method.new' class='method'><code>fn <a href='#method.new' class='fnname'>new</a>&lt;T: <a class='trait' href='../../../std/path/trait.BytesContainer.html' title='std::path::BytesContainer'>BytesContainer</a>&gt;(path: T) -&gt; <a class='struct' href='../../../std/path/windows/struct.Path.html' title='std::path::windows::Path'>Path</a></code></h4>
<div class='docblock'><p>Returns a new Path from a byte vector or string</p>

<h1 id="failure" class='section-link'><a
                           href="#failure">Failure</a></h1>
<p>Fails the task if the vector contains a NUL.
Fails if invalid UTF-8.</p>
</div><h4 id='method.new_opt' class='method'><code>fn <a href='#method.new_opt' class='fnname'>new_opt</a>&lt;T: <a class='trait' href='../../../std/path/trait.BytesContainer.html' title='std::path::BytesContainer'>BytesContainer</a>&gt;(path: T) -&gt; <a class='enum' href='../../../std/option/enum.Option.html' title='std::option::Option'>Option</a>&lt;<a class='struct' href='../../../std/path/windows/struct.Path.html' title='std::path::windows::Path'>Path</a>&gt;</code></h4>
<div class='docblock'><p>Returns a new Path from a byte vector or string, if possible</p>
</div><h4 id='method.str_components' class='method'><code>fn <a href='#method.str_components' class='fnname'>str_components</a>&lt;'a&gt;(&amp;'a self) -&gt; <a class='typedef' href='../../../std/path/windows/typedef.StrComponents.html' title='std::path::windows::StrComponents'>StrComponents</a>&lt;'a&gt;</code></h4>
<div class='docblock'><p>Returns an iterator that yields each component of the path in turn as a Option&lt;&amp;str&gt;.
Every component is guaranteed to be Some.
Does not yield the path prefix (including server/share components in UNC paths).
Does not distinguish between volume-relative and relative paths, e.g.
\a\b\c and a\b\c.
Does not distinguish between absolute and cwd-relative paths, e.g.
C:\foo and C:foo.</p>
</div><h4 id='method.rev_str_components' class='method'><code>fn <a href='#method.rev_str_components' class='fnname'>rev_str_components</a>&lt;'a&gt;(&amp;'a self) -&gt; <a class='typedef' href='../../../std/path/windows/typedef.RevStrComponents.html' title='std::path::windows::RevStrComponents'>RevStrComponents</a>&lt;'a&gt;</code></h4>
<div class='docblock'><p>Returns an iterator that yields each component of the path in reverse as an Option&lt;&amp;str&gt;
See str_components() for details.</p>
</div><h4 id='method.components' class='method'><code>fn <a href='#method.components' class='fnname'>components</a>&lt;'a&gt;(&amp;'a self) -&gt; <a class='typedef' href='../../../std/path/windows/typedef.Components.html' title='std::path::windows::Components'>Components</a>&lt;'a&gt;</code></h4>
<div class='docblock'><p>Returns an iterator that yields each component of the path in turn as a &amp;[u8].
See str_components() for details.</p>
</div><h4 id='method.rev_components' class='method'><code>fn <a href='#method.rev_components' class='fnname'>rev_components</a>&lt;'a&gt;(&amp;'a self) -&gt; <a class='typedef' href='../../../std/path/windows/typedef.RevComponents.html' title='std::path::windows::RevComponents'>RevComponents</a>&lt;'a&gt;</code></h4>
<div class='docblock'><p>Returns an iterator that yields each component of the path in reverse as a &amp;[u8].
See str_components() for details.</p>
</div></div><h2 id='implementations'>Trait Implementations</h2><h3 class='impl'><code>impl <a class='trait' href='../../../std/clone/trait.Clone.html' title='std::clone::Clone'>Clone</a> for <a class='struct' href='../../../std/path/windows/struct.Path.html' title='std::path::windows::Path'>Path</a></code></h3><div class='methods'><h4 id='method.clone' class='method'><code>fn <a href='#method.clone' class='fnname'>clone</a>(&amp;self) -&gt; <a class='struct' href='../../../std/path/windows/struct.Path.html' title='std::path::windows::Path'>Path</a></code></h4>
<div class='docblock'><p>Returns a copy of the value. The contents of owned pointers
are copied to maintain uniqueness, while the contents of
managed pointers are not copied.</p>
</div><h4 id='method.clone_from' class='method'><code>fn <a href='#method.clone_from' class='fnname'>clone_from</a>(&amp;mut self, source: &amp;Self)</code></h4>
<div class='docblock'><p>Perform copy-assignment from <code>source</code>.</p>

<p><code>a.clone_from(&amp;b)</code> is equivalent to <code>a = b.clone()</code> in functionality,
but can be overridden to reuse the resources of <code>a</code> to avoid unnecessary
allocations.</p>
</div></div><h3 class='impl'><code>impl <a class='trait' href='../../../std/cmp/trait.Eq.html' title='std::cmp::Eq'>Eq</a> for <a class='struct' href='../../../std/path/windows/struct.Path.html' title='std::path::windows::Path'>Path</a></code></h3><div class='methods'><h4 id='method.eq' class='method'><code>fn <a href='#method.eq' class='fnname'>eq</a>(&amp;self, other: &amp;<a class='struct' href='../../../std/path/windows/struct.Path.html' title='std::path::windows::Path'>Path</a>) -&gt; bool</code></h4>
<h4 id='method.ne' class='method'><code>fn <a href='#method.ne' class='fnname'>ne</a>(&amp;self, other: &amp;Self) -&gt; bool</code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../../std/from_str/trait.FromStr.html' title='std::from_str::FromStr'>FromStr</a> for <a class='struct' href='../../../std/path/windows/struct.Path.html' title='std::path::windows::Path'>Path</a></code></h3><div class='methods'><h4 id='method.from_str' class='method'><code>fn <a href='#method.from_str' class='fnname'>from_str</a>(s: &amp;str) -&gt; <a class='enum' href='../../../std/option/enum.Option.html' title='std::option::Option'>Option</a>&lt;<a class='struct' href='../../../std/path/windows/struct.Path.html' title='std::path::windows::Path'>Path</a>&gt;</code></h4>
<div class='docblock'><p>Parses a string <code>s</code> to return an optional value of this type. If the
string is ill-formatted, the None is returned.</p>
</div></div><h3 class='impl'><code>impl <a class='trait' href='../../../std/c_str/trait.ToCStr.html' title='std::c_str::ToCStr'>ToCStr</a> for <a class='struct' href='../../../std/path/windows/struct.Path.html' title='std::path::windows::Path'>Path</a></code></h3><div class='methods'><h4 id='method.to_c_str' class='method'><code>fn <a href='#method.to_c_str' class='fnname'>to_c_str</a>(&amp;self) -&gt; <a class='struct' href='../../../std/c_str/struct.CString.html' title='std::c_str::CString'>CString</a></code></h4>
<div class='docblock'><p>Copy the receiver into a CString.</p>

<h1 id="failure-1" class='section-link'><a
                           href="#failure-1">Failure</a></h1>
<p>Fails the task if the receiver has an interior null.</p>
</div><h4 id='method.to_c_str_unchecked' class='method'><code>unsafe fn <a href='#method.to_c_str_unchecked' class='fnname'>to_c_str_unchecked</a>(&amp;self) -&gt; <a class='struct' href='../../../std/c_str/struct.CString.html' title='std::c_str::CString'>CString</a></code></h4>
<div class='docblock'><p>Unsafe variant of <code>to_c_str()</code> that doesn&#39;t check for nulls.</p>
</div><h4 id='method.with_c_str' class='method'><code>fn <a href='#method.with_c_str' class='fnname'>with_c_str</a>&lt;T&gt;(&amp;self, f: |*<a class='typedef' href='../../../std/libc/types/os/arch/c95/typedef.c_char.html' title='std::libc::types::os::arch::c95::c_char'>c_char</a>| -&gt; T) -&gt; T</code></h4>
<div class='docblock'><p>Work with a temporary CString constructed from the receiver.
The provided <code>*libc::c_char</code> will be freed immediately upon return.</p>

<h1 id="example" class='section-link'><a
                           href="#example">Example</a></h1><pre class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>libc</span>;

<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot;PATH&quot;</span>.<span class='ident'>with_c_str</span>(<span class='op'>|</span><span class='ident'>path</span><span class='op'>|</span> <span class='kw'>unsafe</span> {
    <span class='ident'>libc</span>::<span class='ident'>getenv</span>(<span class='ident'>path</span>)
});
</pre>

<h1 id="failure-2" class='section-link'><a
                           href="#failure-2">Failure</a></h1>
<p>Fails the task if the receiver has an interior null.</p>
</div><h4 id='method.with_c_str_unchecked' class='method'><code>unsafe fn <a href='#method.with_c_str_unchecked' class='fnname'>with_c_str_unchecked</a>&lt;T&gt;(&amp;self, f: |*<a class='typedef' href='../../../std/libc/types/os/arch/c95/typedef.c_char.html' title='std::libc::types::os::arch::c95::c_char'>c_char</a>| -&gt; T) -&gt; T</code></h4>
<div class='docblock'><p>Unsafe variant of <code>with_c_str()</code> that doesn&#39;t check for nulls.</p>
</div></div><h3 class='impl'><code>impl&lt;S: <a class='trait' href='../../../std/io/trait.Writer.html' title='std::io::Writer'>Writer</a>&gt; <a class='trait' href='../../../std/hash/trait.Hash.html' title='std::hash::Hash'>Hash</a>&lt;S&gt; for <a class='struct' href='../../../std/path/windows/struct.Path.html' title='std::path::windows::Path'>Path</a></code></h3><div class='methods'><h4 id='method.hash' class='method'><code>fn <a href='#method.hash' class='fnname'>hash</a>(&amp;self, state: &amp;mut S)</code></h4>
<div class='docblock'><p>Compute a hash of the value.</p>
</div></div><h3 class='impl'><code>impl <a class='trait' href='../../../std/path/trait.BytesContainer.html' title='std::path::BytesContainer'>BytesContainer</a> for <a class='struct' href='../../../std/path/windows/struct.Path.html' title='std::path::windows::Path'>Path</a></code></h3><div class='methods'><h4 id='method.container_as_bytes' class='method'><code>fn <a href='#method.container_as_bytes' class='fnname'>container_as_bytes</a>&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a [u8]</code></h4>
<div class='docblock'><p>Returns a &amp;[u8] representing the receiver</p>
</div><h4 id='method.container_into_owned_bytes' class='method'><code>fn <a href='#method.container_into_owned_bytes' class='fnname'>container_into_owned_bytes</a>(self) -&gt; ~[u8]</code></h4>
<div class='docblock'><p>Consumes the receiver and converts it into ~[u8]</p>
</div><h4 id='method.container_as_str' class='method'><code>fn <a href='#method.container_as_str' class='fnname'>container_as_str</a>&lt;'a&gt;(&amp;'a self) -&gt; <a class='enum' href='../../../std/option/enum.Option.html' title='std::option::Option'>Option</a>&lt;&amp;'a str&gt;</code></h4>
<div class='docblock'><p>Returns the receiver interpreted as a utf-8 string, if possible</p>
</div><h4 id='method.is_str' class='method'><code>fn <a href='#method.is_str' class='fnname'>is_str</a>(_: <a class='enum' href='../../../std/option/enum.Option.html' title='std::option::Option'>Option</a>&lt;<a class='struct' href='../../../std/path/windows/struct.Path.html' title='std::path::windows::Path'>Path</a>&gt;) -&gt; bool</code></h4>
<div class='docblock'><p>Returns whether .container_as_str() is guaranteed to not fail</p>
</div></div><h3 class='impl'><code>impl <a class='trait' href='../../../std/path/trait.GenericPathUnsafe.html' title='std::path::GenericPathUnsafe'>GenericPathUnsafe</a> for <a class='struct' href='../../../std/path/windows/struct.Path.html' title='std::path::windows::Path'>Path</a></code></h3><div class='methods'><h4 id='method.new_unchecked' class='method'><code>unsafe fn <a href='#method.new_unchecked' class='fnname'>new_unchecked</a>&lt;T: <a class='trait' href='../../../std/path/trait.BytesContainer.html' title='std::path::BytesContainer'>BytesContainer</a>&gt;(path: T) -&gt; <a class='struct' href='../../../std/path/windows/struct.Path.html' title='std::path::windows::Path'>Path</a></code></h4>
<div class='docblock'><p>See <code>GenericPathUnsafe::from_vec_unchecked</code>.</p>

<h1 id="failure-3" class='section-link'><a
                           href="#failure-3">Failure</a></h1>
<p>Fails if not valid UTF-8.</p>
</div><h4 id='method.set_filename_unchecked' class='method'><code>unsafe fn <a href='#method.set_filename_unchecked' class='fnname'>set_filename_unchecked</a>&lt;T: <a class='trait' href='../../../std/path/trait.BytesContainer.html' title='std::path::BytesContainer'>BytesContainer</a>&gt;(&amp;mut self, filename: T)</code></h4>
<div class='docblock'><p>See <code>GenericPathUnsafe::set_filename_unchecekd</code>.</p>

<h1 id="failure-4" class='section-link'><a
                           href="#failure-4">Failure</a></h1>
<p>Fails if not valid UTF-8.</p>
</div><h4 id='method.push_unchecked' class='method'><code>unsafe fn <a href='#method.push_unchecked' class='fnname'>push_unchecked</a>&lt;T: <a class='trait' href='../../../std/path/trait.BytesContainer.html' title='std::path::BytesContainer'>BytesContainer</a>&gt;(&amp;mut self, path: T)</code></h4>
<div class='docblock'><p>See <code>GenericPathUnsafe::push_unchecked</code>.</p>

<p>Concatenating two Windows Paths is rather complicated.
For the most part, it will behave as expected, except in the case of
pushing a volume-relative path, e.g. <code>C:foo.txt</code>. Because we have no
concept of per-volume cwds like Windows does, we can&#39;t behave exactly
like Windows will. Instead, if the receiver is an absolute path on
the same volume as the new path, it will be treated as the cwd that
the new path is relative to. Otherwise, the new path will be treated
as if it were absolute and will replace the receiver outright.</p>
</div></div><h3 class='impl'><code>impl <a class='trait' href='../../../std/path/trait.GenericPath.html' title='std::path::GenericPath'>GenericPath</a> for <a class='struct' href='../../../std/path/windows/struct.Path.html' title='std::path::windows::Path'>Path</a></code></h3><div class='methods'><h4 id='method.new_opt' class='method'><code>fn <a href='#method.new_opt' class='fnname'>new_opt</a>&lt;T: <a class='trait' href='../../../std/path/trait.BytesContainer.html' title='std::path::BytesContainer'>BytesContainer</a>&gt;(path: T) -&gt; <a class='enum' href='../../../std/option/enum.Option.html' title='std::option::Option'>Option</a>&lt;<a class='struct' href='../../../std/path/windows/struct.Path.html' title='std::path::windows::Path'>Path</a>&gt;</code></h4>
<div class='docblock'><p>Creates a new Path from a byte vector or string, if possible.
The resulting Path will always be normalized.</p>
</div><h4 id='method.as_str' class='method'><code>fn <a href='#method.as_str' class='fnname'>as_str</a>&lt;'a&gt;(&amp;'a self) -&gt; <a class='enum' href='../../../std/option/enum.Option.html' title='std::option::Option'>Option</a>&lt;&amp;'a str&gt;</code></h4>
<div class='docblock'><p>See <code>GenericPath::as_str</code> for info.
Always returns a <code>Some</code> value.</p>
</div><h4 id='method.as_vec' class='method'><code>fn <a href='#method.as_vec' class='fnname'>as_vec</a>&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a [u8]</code></h4>
<div class='docblock'><p>Returns the path as a byte vector</p>
</div><h4 id='method.into_vec' class='method'><code>fn <a href='#method.into_vec' class='fnname'>into_vec</a>(self) -&gt; ~[u8]</code></h4>
<div class='docblock'><p>Converts the Path into an owned byte vector</p>
</div><h4 id='method.dirname' class='method'><code>fn <a href='#method.dirname' class='fnname'>dirname</a>&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a [u8]</code></h4>
<div class='docblock'><p>Returns the directory component of <code>self</code>, as a byte vector (with no trailing separator).
If <code>self</code> has no directory component, returns [&#39;.&#39;].</p>
</div><h4 id='method.dirname_str' class='method'><code>fn <a href='#method.dirname_str' class='fnname'>dirname_str</a>&lt;'a&gt;(&amp;'a self) -&gt; <a class='enum' href='../../../std/option/enum.Option.html' title='std::option::Option'>Option</a>&lt;&amp;'a str&gt;</code></h4>
<div class='docblock'><p>See <code>GenericPath::dirname_str</code> for info.
Always returns a <code>Some</code> value.</p>
</div><h4 id='method.filename' class='method'><code>fn <a href='#method.filename' class='fnname'>filename</a>&lt;'a&gt;(&amp;'a self) -&gt; <a class='enum' href='../../../std/option/enum.Option.html' title='std::option::Option'>Option</a>&lt;&amp;'a [u8]&gt;</code></h4>
<div class='docblock'><p>Returns the file component of <code>self</code>, as a byte vector.
If <code>self</code> represents the root of the file hierarchy, returns None.
If <code>self</code> is &quot;.&quot; or &quot;..&quot;, returns None.</p>
</div><h4 id='method.filename_str' class='method'><code>fn <a href='#method.filename_str' class='fnname'>filename_str</a>&lt;'a&gt;(&amp;'a self) -&gt; <a class='enum' href='../../../std/option/enum.Option.html' title='std::option::Option'>Option</a>&lt;&amp;'a str&gt;</code></h4>
<div class='docblock'><p>See <code>GenericPath::filename_str</code> for info.
Always returns a <code>Some</code> value if <code>filename</code> returns a <code>Some</code> value.</p>
</div><h4 id='method.filestem_str' class='method'><code>fn <a href='#method.filestem_str' class='fnname'>filestem_str</a>&lt;'a&gt;(&amp;'a self) -&gt; <a class='enum' href='../../../std/option/enum.Option.html' title='std::option::Option'>Option</a>&lt;&amp;'a str&gt;</code></h4>
<div class='docblock'><p>See <code>GenericPath::filestem_str</code> for info.
Always returns a <code>Some</code> value if <code>filestem</code> returns a <code>Some</code> value.</p>
</div><h4 id='method.extension_str' class='method'><code>fn <a href='#method.extension_str' class='fnname'>extension_str</a>&lt;'a&gt;(&amp;'a self) -&gt; <a class='enum' href='../../../std/option/enum.Option.html' title='std::option::Option'>Option</a>&lt;&amp;'a str&gt;</code></h4>
<div class='docblock'><p>Returns the extension of the filename of <code>self</code>, as a string, if possible.
See <code>extension</code> for details.</p>
</div><h4 id='method.dir_path' class='method'><code>fn <a href='#method.dir_path' class='fnname'>dir_path</a>(&amp;self) -&gt; <a class='struct' href='../../../std/path/windows/struct.Path.html' title='std::path::windows::Path'>Path</a></code></h4>
<div class='docblock'><p>Returns the directory component of <code>self</code>, as a Path.
If <code>self</code> represents the root of the filesystem hierarchy, returns <code>self</code>.</p>
</div><h4 id='method.pop' class='method'><code>fn <a href='#method.pop' class='fnname'>pop</a>(&amp;mut self) -&gt; bool</code></h4>
<div class='docblock'><p>Removes the last path component from the receiver.
Returns <code>true</code> if the receiver was modified, or <code>false</code> if it already
represented the root of the file hierarchy.</p>
</div><h4 id='method.root_path' class='method'><code>fn <a href='#method.root_path' class='fnname'>root_path</a>(&amp;self) -&gt; <a class='enum' href='../../../std/option/enum.Option.html' title='std::option::Option'>Option</a>&lt;<a class='struct' href='../../../std/path/windows/struct.Path.html' title='std::path::windows::Path'>Path</a>&gt;</code></h4>
<div class='docblock'><p>Returns a Path that represents the filesystem root that <code>self</code> is rooted in.</p>

<p>If <code>self</code> is not absolute, or vol/cwd-relative in the case of Windows, this returns None.</p>
</div><h4 id='method.is_absolute' class='method'><code>fn <a href='#method.is_absolute' class='fnname'>is_absolute</a>(&amp;self) -&gt; bool</code></h4>
<div class='docblock'><p>See <code>GenericPath::is_absolute</code> for info.</p>

<p>A Windows Path is considered absolute only if it has a non-volume prefix,
or if it has a volume prefix and the path starts with &#39;\&#39;.
A path of <code>\foo</code> is not considered absolute because it&#39;s actually
relative to the &quot;current volume&quot;. A separate method <code>Path::is_vol_relative</code>
is provided to indicate this case. Similarly a path of <code>C:foo</code> is not
considered absolute because it&#39;s relative to the cwd on volume C:. A
separate method <code>Path::is_cwd_relative</code> is provided to indicate this case.</p>
</div><h4 id='method.is_relative' class='method'><code>fn <a href='#method.is_relative' class='fnname'>is_relative</a>(&amp;self) -&gt; bool</code></h4>
<div class='docblock'><p>Returns whether <code>self</code> represents a relative path.
Typically this is the inverse of <code>is_absolute</code>.
But for Windows paths, it also means the path is not volume-relative or
relative to the current working directory.</p>
</div><h4 id='method.is_ancestor_of' class='method'><code>fn <a href='#method.is_ancestor_of' class='fnname'>is_ancestor_of</a>(&amp;self, other: &amp;<a class='struct' href='../../../std/path/windows/struct.Path.html' title='std::path::windows::Path'>Path</a>) -&gt; bool</code></h4>
<div class='docblock'><p>Returns whether <code>self</code> is equal to, or is an ancestor of, the given path.
If both paths are relative, they are compared as though they are relative
to the same parent path.</p>
</div><h4 id='method.path_relative_from' class='method'><code>fn <a href='#method.path_relative_from' class='fnname'>path_relative_from</a>(&amp;self, base: &amp;<a class='struct' href='../../../std/path/windows/struct.Path.html' title='std::path::windows::Path'>Path</a>) -&gt; <a class='enum' href='../../../std/option/enum.Option.html' title='std::option::Option'>Option</a>&lt;<a class='struct' href='../../../std/path/windows/struct.Path.html' title='std::path::windows::Path'>Path</a>&gt;</code></h4>
<div class='docblock'><p>Returns the Path that, were it joined to <code>base</code>, would yield <code>self</code>.
If no such path exists, None is returned.
If <code>self</code> is absolute and <code>base</code> is relative, or on Windows if both
paths refer to separate drives, an absolute path is returned.</p>
</div><h4 id='method.ends_with_path' class='method'><code>fn <a href='#method.ends_with_path' class='fnname'>ends_with_path</a>(&amp;self, child: &amp;<a class='struct' href='../../../std/path/windows/struct.Path.html' title='std::path::windows::Path'>Path</a>) -&gt; bool</code></h4>
<div class='docblock'><p>Returns whether the relative path <code>child</code> is a suffix of <code>self</code>.</p>
</div><h4 id='method.new' class='method'><code>fn <a href='#method.new' class='fnname'>new</a>&lt;T: <a class='trait' href='../../../std/path/trait.BytesContainer.html' title='std::path::BytesContainer'>BytesContainer</a>&gt;(path: T) -&gt; Self</code></h4>
<div class='docblock'><p>Creates a new Path from a byte vector or string.
The resulting Path will always be normalized.</p>

<h1 id="failure-5" class='section-link'><a
                           href="#failure-5">Failure</a></h1>
<p>Fails the task if the path contains a NUL.</p>

<p>See individual Path impls for additional restrictions.</p>
</div><h4 id='method.display' class='method'><code>fn <a href='#method.display' class='fnname'>display</a>&lt;'a&gt;(&amp;'a self) -&gt; <a class='struct' href='../../../std/path/struct.Display.html' title='std::path::Display'>Display</a>&lt;'a, Self&gt;</code></h4>
<div class='docblock'><p>Returns an object that implements <code>Show</code> for printing paths</p>

<p>This will print the equivalent of <code>to_display_str()</code> when used with a {} format parameter.</p>
</div><h4 id='method.filename_display' class='method'><code>fn <a href='#method.filename_display' class='fnname'>filename_display</a>&lt;'a&gt;(&amp;'a self) -&gt; <a class='struct' href='../../../std/path/struct.Display.html' title='std::path::Display'>Display</a>&lt;'a, Self&gt;</code></h4>
<div class='docblock'><p>Returns an object that implements <code>Show</code> for printing filenames</p>

<p>This will print the equivalent of <code>to_filename_display_str()</code> when used with a {}
format parameter. If there is no filename, nothing will be printed.</p>
</div><h4 id='method.filestem' class='method'><code>fn <a href='#method.filestem' class='fnname'>filestem</a>&lt;'a&gt;(&amp;'a self) -&gt; <a class='enum' href='../../../std/option/enum.Option.html' title='std::option::Option'>Option</a>&lt;&amp;'a [u8]&gt;</code></h4>
<div class='docblock'><p>Returns the stem of the filename of <code>self</code>, as a byte vector.
The stem is the portion of the filename just before the last &#39;.&#39;.
If there is no &#39;.&#39;, the entire filename is returned.</p>
</div><h4 id='method.extension' class='method'><code>fn <a href='#method.extension' class='fnname'>extension</a>&lt;'a&gt;(&amp;'a self) -&gt; <a class='enum' href='../../../std/option/enum.Option.html' title='std::option::Option'>Option</a>&lt;&amp;'a [u8]&gt;</code></h4>
<div class='docblock'><p>Returns the extension of the filename of <code>self</code>, as an optional byte vector.
The extension is the portion of the filename just after the last &#39;.&#39;.
If there is no extension, None is returned.
If the filename ends in &#39;.&#39;, the empty vector is returned.</p>
</div><h4 id='method.set_filename' class='method'><code>fn <a href='#method.set_filename' class='fnname'>set_filename</a>&lt;T: <a class='trait' href='../../../std/path/trait.BytesContainer.html' title='std::path::BytesContainer'>BytesContainer</a>&gt;(&amp;mut self, filename: T)</code></h4>
<div class='docblock'><p>Replaces the filename portion of the path with the given byte vector or string.
If the replacement name is [], this is equivalent to popping the path.</p>

<h1 id="failure-6" class='section-link'><a
                           href="#failure-6">Failure</a></h1>
<p>Fails the task if the filename contains a NUL.</p>
</div><h4 id='method.set_extension' class='method'><code>fn <a href='#method.set_extension' class='fnname'>set_extension</a>&lt;T: <a class='trait' href='../../../std/path/trait.BytesContainer.html' title='std::path::BytesContainer'>BytesContainer</a>&gt;(&amp;mut self, extension: T)</code></h4>
<div class='docblock'><p>Replaces the extension with the given byte vector or string.
If there is no extension in <code>self</code>, this adds one.
If the argument is [] or &quot;&quot;, this removes the extension.
If <code>self</code> has no filename, this is a no-op.</p>

<h1 id="failure-7" class='section-link'><a
                           href="#failure-7">Failure</a></h1>
<p>Fails the task if the extension contains a NUL.</p>
</div><h4 id='method.with_filename' class='method'><code>fn <a href='#method.with_filename' class='fnname'>with_filename</a>&lt;T: <a class='trait' href='../../../std/path/trait.BytesContainer.html' title='std::path::BytesContainer'>BytesContainer</a>&gt;(&amp;self, filename: T) -&gt; Self</code></h4>
<div class='docblock'><p>Returns a new Path constructed by replacing the filename with the given
byte vector or string.
See <code>set_filename</code> for details.</p>

<h1 id="failure-8" class='section-link'><a
                           href="#failure-8">Failure</a></h1>
<p>Fails the task if the filename contains a NUL.</p>
</div><h4 id='method.with_extension' class='method'><code>fn <a href='#method.with_extension' class='fnname'>with_extension</a>&lt;T: <a class='trait' href='../../../std/path/trait.BytesContainer.html' title='std::path::BytesContainer'>BytesContainer</a>&gt;(&amp;self, extension: T) -&gt; Self</code></h4>
<div class='docblock'><p>Returns a new Path constructed by setting the extension to the given
byte vector or string.
See <code>set_extension</code> for details.</p>

<h1 id="failure-9" class='section-link'><a
                           href="#failure-9">Failure</a></h1>
<p>Fails the task if the extension contains a NUL.</p>
</div><h4 id='method.push' class='method'><code>fn <a href='#method.push' class='fnname'>push</a>&lt;T: <a class='trait' href='../../../std/path/trait.BytesContainer.html' title='std::path::BytesContainer'>BytesContainer</a>&gt;(&amp;mut self, path: T)</code></h4>
<div class='docblock'><p>Pushes a path (as a byte vector or string) onto <code>self</code>.
If the argument represents an absolute path, it replaces <code>self</code>.</p>

<h1 id="failure-10" class='section-link'><a
                           href="#failure-10">Failure</a></h1>
<p>Fails the task if the path contains a NUL.</p>
</div><h4 id='method.push_many' class='method'><code>fn <a href='#method.push_many' class='fnname'>push_many</a>&lt;T: <a class='trait' href='../../../std/path/trait.BytesContainer.html' title='std::path::BytesContainer'>BytesContainer</a>&gt;(&amp;mut self, paths: &amp;[T])</code></h4>
<div class='docblock'><p>Pushes multiple paths (as byte vectors or strings) onto <code>self</code>.
See <code>push</code> for details.</p>
</div><h4 id='method.join' class='method'><code>fn <a href='#method.join' class='fnname'>join</a>&lt;T: <a class='trait' href='../../../std/path/trait.BytesContainer.html' title='std::path::BytesContainer'>BytesContainer</a>&gt;(&amp;self, path: T) -&gt; Self</code></h4>
<div class='docblock'><p>Returns a new Path constructed by joining <code>self</code> with the given path
(as a byte vector or string).
If the given path is absolute, the new Path will represent just that.</p>

<h1 id="failure-11" class='section-link'><a
                           href="#failure-11">Failure</a></h1>
<p>Fails the task if the path contains a NUL.</p>
</div><h4 id='method.join_many' class='method'><code>fn <a href='#method.join_many' class='fnname'>join_many</a>&lt;T: <a class='trait' href='../../../std/path/trait.BytesContainer.html' title='std::path::BytesContainer'>BytesContainer</a>&gt;(&amp;self, paths: &amp;[T]) -&gt; Self</code></h4>
<div class='docblock'><p>Returns a new Path constructed by joining <code>self</code> with the given paths
(as byte vectors or strings).
See <code>join</code> for details.</p>
</div></div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <div id="help" class="hidden">
        <div class="shortcuts">
            <h1>Keyboard shortcuts</h1>
            <dl>
                <dt>?</dt>
                <dd>Show this help dialog</dd>
                <dt>S</dt>
                <dd>Focus the search field</dd>
                <dt>&uarr;</dt>
                <dd>Move up in search results</dd>
                <dt>&darr;</dt>
                <dd>Move down in search results</dd>
                <dt>&#9166;</dt>
                <dd>Go to active search result</dd>
            </dl>
        </div>
        <div class="infos">
            <h1>Search tricks</h1>
            <p>
                Prefix searches with a type followed by a colon (e.g.
                <code>fn:</code>) to restrict the search to a given type.
            </p>
            <p>
                Accepted types are: <code>fn</code>, <code>mod</code>,
                <code>struct</code> (or <code>str</code>), <code>enum</code>,
                <code>trait</code>, <code>typedef</code> (or
                <code>tdef</code>).
            </p>
        </div>
    </div>

    <script>
        var rootPath = "../../../";
        var currentCrate = "std";
    </script>
    <script src="../../../jquery.js"></script>
    <script src="../../../main.js"></script>
    <script async src="../../../search-index.js"></script>
</body>
</html>
