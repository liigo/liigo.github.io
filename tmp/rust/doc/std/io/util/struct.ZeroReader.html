<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>std::io::util::ZeroReader - Rust</title>

    <link href='http://fonts.googleapis.com/css?family=Oswald:700|Inconsolata:400,700'
          rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="../../../main.css">

    <link rel="shortcut icon" href="http://www.rust-lang.org/favicon.ico" />
</head>
<body>
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <section class="sidebar">
        
            <a href='../../../std/index.html'><img src='http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png' alt=''/></a>
        

        <p class='location'><a href='../../index.html'>std</a>&#8203;::<a href='../index.html'>io</a>&#8203;::<a href='index.html'>util</a></p><div class='block struct'><h2>Structs</h2><a class='struct ' href='struct.ChainedReader.html' title='A `Reader` which chains input from multiple `Readers`, reading each to completion before moving onto the next.'>ChainedReader</a><br/><a class='struct ' href='struct.LimitReader.html' title='Wraps a `Reader`, limiting the number of bytes that can be read from it.'>LimitReader</a><br/><a class='struct ' href='struct.MultiWriter.html' title='A `Writer` which multiplexes writes to a set of `Writers`.'>MultiWriter</a><br/><a class='struct ' href='struct.NullReader.html' title='A `Reader` which is always at EOF, like /dev/null.'>NullReader</a><br/><a class='struct ' href='struct.NullWriter.html' title='A `Writer` which ignores bytes written to it, like /dev/null.'>NullWriter</a><br/><a class='struct ' href='struct.TeeReader.html' title='A `Reader` which forwards input from another `Reader`, passing it along to a `Writer` as well. Similar to the `tee(1)` command.'>TeeReader</a><br/><a class='struct current' href='struct.ZeroReader.html' title='A `Reader` which returns an infinite stream of 0 bytes, like /dev/zero.'>ZeroReader</a><br/></div><div class='block fn'><h2>Functions</h2><a class='fn ' href='fn.copy.html' title='Copies all data from a `Reader` to a `Writer`.'>copy</a><br/></div>
    </section>

    <nav class="sub">
        <form class="search-form js-only">
            <button class="do-search">Search</button>
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Search documentation..."
                       type="search" />
            </div>
        </form>
    </nav>

    <section id='main' class="content struct"><a class='source'
                              href='../../../src/std/MinGW/msys/1.0/home/LIIGO/rust/rust/src/libstd/io/util.rs.html#66'>[src]</a><h1 class='fqn'>Struct <a href='../../index.html'>std</a>::<a href='../index.html'>io</a>::<a href='index.html'>util</a>::<a class='struct' href=''>ZeroReader</a></h1><pre class='rust struct'>pub struct ZeroReader;</pre><div class='docblock'><p>A <code>Reader</code> which returns an infinite stream of 0 bytes, like /dev/zero.</p>
</div><h2 id='implementations'>Trait Implementations</h2><h3 class='impl'><code>impl <a class='trait' href='../../../std/io/trait.Reader.html' title='std::io::Reader'>Reader</a> for <a class='struct' href='../../../std/io/util/struct.ZeroReader.html' title='std::io::util::ZeroReader'>ZeroReader</a></code></h3><div class='methods'><h4 id='method.read' class='method'><code>fn <a href='#method.read' class='fnname'>read</a>(&amp;mut self, buf: &amp;mut [u8]) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;uint&gt;</code></h4>
<div class='docblock'><p>Read bytes, up to the length of <code>buf</code> and place them in <code>buf</code>.
Returns the number of bytes read. The number of bytes read my
be less than the number requested, even 0. Returns <code>Err</code> on EOF.</p>

<h1 id="error" class='section-link'><a
                           href="#error">Error</a></h1>
<p>If an error occurs during this I/O operation, then it is returned as
<code>Err(IoError)</code>. Note that end-of-file is considered an error, and can be
inspected for in the error&#39;s <code>kind</code> field. Also note that reading 0
bytes is not considered an error in all circumstances</p>
</div><h4 id='method.read_byte' class='method'><code>fn <a href='#method.read_byte' class='fnname'>read_byte</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;u8&gt;</code></h4>
<div class='docblock'><p>Reads a single byte. Returns <code>Err</code> on EOF.</p>
</div><h4 id='method.push_bytes' class='method'><code>fn <a href='#method.push_bytes' class='fnname'>push_bytes</a>(&amp;mut self, buf: &amp;mut ~[u8], len: uint) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Reads <code>len</code> bytes and appends them to a vector.</p>

<p>May push fewer than the requested number of bytes on error
or EOF. If <code>Ok(())</code> is returned, then all of the requested bytes were
pushed on to the vector, otherwise the amount <code>len</code> bytes couldn&#39;t be
read (an error was encountered), and the error is returned.</p>
</div><h4 id='method.read_bytes' class='method'><code>fn <a href='#method.read_bytes' class='fnname'>read_bytes</a>(&amp;mut self, len: uint) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;~[u8]&gt;</code></h4>
<div class='docblock'><p>Reads <code>len</code> bytes and gives you back a new vector of length <code>len</code></p>

<h1 id="error-1" class='section-link'><a
                           href="#error-1">Error</a></h1>
<p>Fails with the same conditions as <code>read</code>. Additionally returns error
on EOF. Note that if an error is returned, then some number of bytes may
have already been consumed from the underlying reader, and they are lost
(not returned as part of the error). If this is unacceptable, then it is
recommended to use the <code>push_bytes</code> or <code>read</code> methods.</p>
</div><h4 id='method.read_to_end' class='method'><code>fn <a href='#method.read_to_end' class='fnname'>read_to_end</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;~[u8]&gt;</code></h4>
<div class='docblock'><p>Reads all remaining bytes from the stream.</p>

<h1 id="error-2" class='section-link'><a
                           href="#error-2">Error</a></h1>
<p>Returns any non-EOF error immediately. Previously read bytes are
discarded when an error is returned.</p>

<p>When EOF is encountered, all bytes read up to that point are returned.</p>
</div><h4 id='method.read_to_str' class='method'><code>fn <a href='#method.read_to_str' class='fnname'>read_to_str</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;~str&gt;</code></h4>
<div class='docblock'><p>Reads all of the remaining bytes of this stream, interpreting them as a
UTF-8 encoded stream. The corresponding string is returned.</p>

<h1 id="error-3" class='section-link'><a
                           href="#error-3">Error</a></h1>
<p>This function returns all of the same errors as <code>read_to_end</code> with an
additional error if the reader&#39;s contents are not a valid sequence of
UTF-8 bytes.</p>
</div><h4 id='method.bytes' class='method'><code>fn <a href='#method.bytes' class='fnname'>bytes</a>&lt;'r&gt;(&amp;'r mut self) -&gt; <a class='struct' href='../../../std/io/extensions/struct.Bytes.html' title='std::io::extensions::Bytes'>Bytes</a>&lt;'r, Self&gt;</code></h4>
<div class='docblock'><p>Create an iterator that reads a single byte on
each iteration, until EOF.</p>

<h1 id="error-4" class='section-link'><a
                           href="#error-4">Error</a></h1>
<p>Any error other than <code>EndOfFile</code> that is produced by the underlying Reader
is returned by the iterator and should be handled by the caller.</p>
</div><h4 id='method.read_le_uint_n' class='method'><code>fn <a href='#method.read_le_uint_n' class='fnname'>read_le_uint_n</a>(&amp;mut self, nbytes: uint) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;u64&gt;</code></h4>
<div class='docblock'><p>Reads <code>n</code> little-endian unsigned integer bytes.</p>

<p><code>n</code> must be between 1 and 8, inclusive.</p>
</div><h4 id='method.read_le_int_n' class='method'><code>fn <a href='#method.read_le_int_n' class='fnname'>read_le_int_n</a>(&amp;mut self, nbytes: uint) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;i64&gt;</code></h4>
<div class='docblock'><p>Reads <code>n</code> little-endian signed integer bytes.</p>

<p><code>n</code> must be between 1 and 8, inclusive.</p>
</div><h4 id='method.read_be_uint_n' class='method'><code>fn <a href='#method.read_be_uint_n' class='fnname'>read_be_uint_n</a>(&amp;mut self, nbytes: uint) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;u64&gt;</code></h4>
<div class='docblock'><p>Reads <code>n</code> big-endian unsigned integer bytes.</p>

<p><code>n</code> must be between 1 and 8, inclusive.</p>
</div><h4 id='method.read_be_int_n' class='method'><code>fn <a href='#method.read_be_int_n' class='fnname'>read_be_int_n</a>(&amp;mut self, nbytes: uint) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;i64&gt;</code></h4>
<div class='docblock'><p>Reads <code>n</code> big-endian signed integer bytes.</p>

<p><code>n</code> must be between 1 and 8, inclusive.</p>
</div><h4 id='method.read_le_uint' class='method'><code>fn <a href='#method.read_le_uint' class='fnname'>read_le_uint</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;uint&gt;</code></h4>
<div class='docblock'><p>Reads a little-endian unsigned integer.</p>

<p>The number of bytes returned is system-dependant.</p>
</div><h4 id='method.read_le_int' class='method'><code>fn <a href='#method.read_le_int' class='fnname'>read_le_int</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;int&gt;</code></h4>
<div class='docblock'><p>Reads a little-endian integer.</p>

<p>The number of bytes returned is system-dependant.</p>
</div><h4 id='method.read_be_uint' class='method'><code>fn <a href='#method.read_be_uint' class='fnname'>read_be_uint</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;uint&gt;</code></h4>
<div class='docblock'><p>Reads a big-endian unsigned integer.</p>

<p>The number of bytes returned is system-dependant.</p>
</div><h4 id='method.read_be_int' class='method'><code>fn <a href='#method.read_be_int' class='fnname'>read_be_int</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;int&gt;</code></h4>
<div class='docblock'><p>Reads a big-endian integer.</p>

<p>The number of bytes returned is system-dependant.</p>
</div><h4 id='method.read_be_u64' class='method'><code>fn <a href='#method.read_be_u64' class='fnname'>read_be_u64</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;u64&gt;</code></h4>
<div class='docblock'><p>Reads a big-endian <code>u64</code>.</p>

<p><code>u64</code>s are 8 bytes long.</p>
</div><h4 id='method.read_be_u32' class='method'><code>fn <a href='#method.read_be_u32' class='fnname'>read_be_u32</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;u32&gt;</code></h4>
<div class='docblock'><p>Reads a big-endian <code>u32</code>.</p>

<p><code>u32</code>s are 4 bytes long.</p>
</div><h4 id='method.read_be_u16' class='method'><code>fn <a href='#method.read_be_u16' class='fnname'>read_be_u16</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;u16&gt;</code></h4>
<div class='docblock'><p>Reads a big-endian <code>u16</code>.</p>

<p><code>u16</code>s are 2 bytes long.</p>
</div><h4 id='method.read_be_i64' class='method'><code>fn <a href='#method.read_be_i64' class='fnname'>read_be_i64</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;i64&gt;</code></h4>
<div class='docblock'><p>Reads a big-endian <code>i64</code>.</p>

<p><code>i64</code>s are 8 bytes long.</p>
</div><h4 id='method.read_be_i32' class='method'><code>fn <a href='#method.read_be_i32' class='fnname'>read_be_i32</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;i32&gt;</code></h4>
<div class='docblock'><p>Reads a big-endian <code>i32</code>.</p>

<p><code>i32</code>s are 4 bytes long.</p>
</div><h4 id='method.read_be_i16' class='method'><code>fn <a href='#method.read_be_i16' class='fnname'>read_be_i16</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;i16&gt;</code></h4>
<div class='docblock'><p>Reads a big-endian <code>i16</code>.</p>

<p><code>i16</code>s are 2 bytes long.</p>
</div><h4 id='method.read_be_f64' class='method'><code>fn <a href='#method.read_be_f64' class='fnname'>read_be_f64</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;f64&gt;</code></h4>
<div class='docblock'><p>Reads a big-endian <code>f64</code>.</p>

<p><code>f64</code>s are 8 byte, IEEE754 double-precision floating point numbers.</p>
</div><h4 id='method.read_be_f32' class='method'><code>fn <a href='#method.read_be_f32' class='fnname'>read_be_f32</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;f32&gt;</code></h4>
<div class='docblock'><p>Reads a big-endian <code>f32</code>.</p>

<p><code>f32</code>s are 4 byte, IEEE754 single-precision floating point numbers.</p>
</div><h4 id='method.read_le_u64' class='method'><code>fn <a href='#method.read_le_u64' class='fnname'>read_le_u64</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;u64&gt;</code></h4>
<div class='docblock'><p>Reads a little-endian <code>u64</code>.</p>

<p><code>u64</code>s are 8 bytes long.</p>
</div><h4 id='method.read_le_u32' class='method'><code>fn <a href='#method.read_le_u32' class='fnname'>read_le_u32</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;u32&gt;</code></h4>
<div class='docblock'><p>Reads a little-endian <code>u32</code>.</p>

<p><code>u32</code>s are 4 bytes long.</p>
</div><h4 id='method.read_le_u16' class='method'><code>fn <a href='#method.read_le_u16' class='fnname'>read_le_u16</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;u16&gt;</code></h4>
<div class='docblock'><p>Reads a little-endian <code>u16</code>.</p>

<p><code>u16</code>s are 2 bytes long.</p>
</div><h4 id='method.read_le_i64' class='method'><code>fn <a href='#method.read_le_i64' class='fnname'>read_le_i64</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;i64&gt;</code></h4>
<div class='docblock'><p>Reads a little-endian <code>i64</code>.</p>

<p><code>i64</code>s are 8 bytes long.</p>
</div><h4 id='method.read_le_i32' class='method'><code>fn <a href='#method.read_le_i32' class='fnname'>read_le_i32</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;i32&gt;</code></h4>
<div class='docblock'><p>Reads a little-endian <code>i32</code>.</p>

<p><code>i32</code>s are 4 bytes long.</p>
</div><h4 id='method.read_le_i16' class='method'><code>fn <a href='#method.read_le_i16' class='fnname'>read_le_i16</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;i16&gt;</code></h4>
<div class='docblock'><p>Reads a little-endian <code>i16</code>.</p>

<p><code>i16</code>s are 2 bytes long.</p>
</div><h4 id='method.read_le_f64' class='method'><code>fn <a href='#method.read_le_f64' class='fnname'>read_le_f64</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;f64&gt;</code></h4>
<div class='docblock'><p>Reads a little-endian <code>f64</code>.</p>

<p><code>f64</code>s are 8 byte, IEEE754 double-precision floating point numbers.</p>
</div><h4 id='method.read_le_f32' class='method'><code>fn <a href='#method.read_le_f32' class='fnname'>read_le_f32</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;f32&gt;</code></h4>
<div class='docblock'><p>Reads a little-endian <code>f32</code>.</p>

<p><code>f32</code>s are 4 byte, IEEE754 single-precision floating point numbers.</p>
</div><h4 id='method.read_u8' class='method'><code>fn <a href='#method.read_u8' class='fnname'>read_u8</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;u8&gt;</code></h4>
<div class='docblock'><p>Read a u8.</p>

<p><code>u8</code>s are 1 byte.</p>
</div><h4 id='method.read_i8' class='method'><code>fn <a href='#method.read_i8' class='fnname'>read_i8</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;i8&gt;</code></h4>
<div class='docblock'><p>Read an i8.</p>

<p><code>i8</code>s are 1 byte.</p>
</div><h4 id='method.by_ref' class='method'><code>fn <a href='#method.by_ref' class='fnname'>by_ref</a>&lt;'a&gt;(&amp;'a mut self) -&gt; <a class='struct' href='../../../std/io/struct.RefReader.html' title='std::io::RefReader'>RefReader</a>&lt;'a, Self&gt;</code></h4>
<div class='docblock'><p>Creates a wrapper around a mutable reference to the reader.</p>

<p>This is useful to allow applying adaptors while still
retaining ownership of the original value.</p>
</div></div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <div id="help" class="hidden">
        <div class="shortcuts">
            <h1>Keyboard shortcuts</h1>
            <dl>
                <dt>?</dt>
                <dd>Show this help dialog</dd>
                <dt>S</dt>
                <dd>Focus the search field</dd>
                <dt>&uarr;</dt>
                <dd>Move up in search results</dd>
                <dt>&darr;</dt>
                <dd>Move down in search results</dd>
                <dt>&#9166;</dt>
                <dd>Go to active search result</dd>
            </dl>
        </div>
        <div class="infos">
            <h1>Search tricks</h1>
            <p>
                Prefix searches with a type followed by a colon (e.g.
                <code>fn:</code>) to restrict the search to a given type.
            </p>
            <p>
                Accepted types are: <code>fn</code>, <code>mod</code>,
                <code>struct</code> (or <code>str</code>), <code>enum</code>,
                <code>trait</code>, <code>typedef</code> (or
                <code>tdef</code>).
            </p>
        </div>
    </div>

    <script>
        var rootPath = "../../../";
        var currentCrate = "std";
    </script>
    <script src="../../../jquery.js"></script>
    <script src="../../../main.js"></script>
    <script async src="../../../search-index.js"></script>
</body>
</html>
