<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>std::io::BufferedReader - Rust</title>

    <link href='http://fonts.googleapis.com/css?family=Oswald:700|Inconsolata:400,700'
          rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="../../main.css">

    <link rel="shortcut icon" href="http://www.rust-lang.org/favicon.ico" />
</head>
<body>
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <section class="sidebar">
        
            <a href='../../std/index.html'><img src='http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png' alt=''/></a>
        

        <p class='location'><a href='../index.html'>std</a>&#8203;::<a href='index.html'>io</a></p><div class='block mod'><h2>Modules</h2><a class='mod ' href='extensions/index.html' title='Utility mixins that apply to all Readers and Writers'>extensions</a><br/><a class='mod ' href='fs/index.html' title='Synchronous File I/O'>fs</a><br/><a class='mod ' href='net/index.html' title='Networking I/O'>net</a><br/><a class='mod ' href='pipe/index.html' title='Synchronous, in-memory pipes.'>pipe</a><br/><a class='mod ' href='process/index.html' title='Bindings for executing child processes'>process</a><br/><a class='mod ' href='signal/index.html' title='Signal handling'>signal</a><br/><a class='mod ' href='stdio/index.html' title='Non-blocking access to stdin, stdout, and stderr.'>stdio</a><br/><a class='mod ' href='test/index.html' title='Various utility functions useful for writing I/O tests'>test</a><br/><a class='mod ' href='timer/index.html' title='Synchronous Timers'>timer</a><br/><a class='mod ' href='util/index.html' title='Utility implementations of Reader and Writer'>util</a><br/></div><div class='block struct'><h2>Structs</h2><a class='struct ' href='struct.BufReader.html' title='Reads from a fixed-size byte slice'>BufReader</a><br/><a class='struct ' href='struct.BufWriter.html' title='Writes to a fixed-size byte slice'>BufWriter</a><br/><a class='struct current' href='struct.BufferedReader.html' title='Wraps a Reader and buffers input from it'>BufferedReader</a><br/><a class='struct ' href='struct.BufferedStream.html' title='Wraps a Stream and buffers input and output to and from it.'>BufferedStream</a><br/><a class='struct ' href='struct.BufferedWriter.html' title='Wraps a Writer and buffers output to it'>BufferedWriter</a><br/><a class='struct ' href='struct.ChanReader.html' title='Allows reading from a rx.'>ChanReader</a><br/><a class='struct ' href='struct.ChanWriter.html' title='Allows writing to a tx.'>ChanWriter</a><br/><a class='struct ' href='struct.Chars.html' title='An iterator that reads a utf8-encoded character on each iteration, until `.read_char()` encounters `EndOfFile`.'>Chars</a><br/><a class='struct ' href='struct.FileStat.html' title='A structure used to describe metadata information about a file. This structure is created through the `stat` method on a `Path`.'>FileStat</a><br/><a class='struct ' href='struct.IncomingConnections.html' title='An infinite iterator over incoming connection attempts. Calling `next` will block the task until a connection is attempted.'>IncomingConnections</a><br/><a class='struct ' href='struct.IoError.html' title='The type passed to I/O condition handlers to indicate error'>IoError</a><br/><a class='struct ' href='struct.LineBufferedWriter.html' title='Wraps a Writer and buffers output to it, flushing whenever a newline (`0x0a`, `'\n'`) is detected.'>LineBufferedWriter</a><br/><a class='struct ' href='struct.Lines.html' title='An iterator that reads a line on each iteration, until `.read_line()` encounters `EndOfFile`.'>Lines</a><br/><a class='struct ' href='struct.MemReader.html' title='Reads from an owned byte vector'>MemReader</a><br/><a class='struct ' href='struct.MemWriter.html' title='Writes to an owned, growable byte vector'>MemWriter</a><br/><a class='struct ' href='struct.RefReader.html' title='A `RefReader` is a struct implementing `Reader` which contains a reference to another reader. This is often useful when composing streams.'>RefReader</a><br/><a class='struct ' href='struct.RefWriter.html' title='A `RefWriter` is a struct implementing `Writer` which contains a reference to another writer. This is often useful when composing streams.'>RefWriter</a><br/><a class='struct ' href='struct.TempDir.html' title='A wrapper for a path to temporary directory implementing automatic scope-based deletion.'>TempDir</a><br/><a class='struct ' href='struct.UnstableFileStat.html' title='This structure represents all of the possible information which can be returned from a `stat` syscall which is not contained in the `FileStat` structure. This information is not necessarily platform independent, and may have different meanings or no meaning at all on some platforms.'>UnstableFileStat</a><br/></div><div class='block enum'><h2>Enums</h2><a class='enum ' href='enum.FileAccess.html' title='Access permissions with which the file should be opened. `File`s opened with `Read` will return an error if written to.'>FileAccess</a><br/><a class='enum ' href='enum.FileMode.html' title='A mode specifies how a file should be opened or created. These modes are passed to `File::open_mode` and are used to control where the file is positioned when it is initially opened.'>FileMode</a><br/><a class='enum ' href='enum.FileType.html' title='Different kinds of files which can be identified by a call to stat'>FileType</a><br/><a class='enum ' href='enum.IoErrorKind.html' title=''>IoErrorKind</a><br/><a class='enum ' href='enum.SeekStyle.html' title='When seeking, the resulting cursor is offset from a base by the offset given to the `seek` function. The base used is specified by this enumeration.'>SeekStyle</a><br/></div><div class='block trait'><h2>Traits</h2><a class='trait ' href='trait.Acceptor.html' title='An acceptor is a value that presents incoming connections'>Acceptor</a><br/><a class='trait ' href='trait.Buffer.html' title='A Buffer is a type of reader which has some form of internal buffering to allow certain kinds of reading operations to be more optimized than others. This type extends the `Reader` trait with a few methods that are not possible to reasonably implement with purely a read interface.'>Buffer</a><br/><a class='trait ' href='trait.Listener.html' title='A listener is a value that can consume itself to start listening for connections.'>Listener</a><br/><a class='trait ' href='trait.Reader.html' title='A trait for objects which are byte-oriented streams. Readers are defined by one method, `read`. This function will block until data is available, filling in the provided buffer with any data read.'>Reader</a><br/><a class='trait ' href='trait.Seek.html' title='An object implementing `Seek` internally has some form of cursor which can be moved within a stream of bytes. The stream typically has a fixed size, allowing seeking relative to either end.'>Seek</a><br/><a class='trait ' href='trait.Stream.html' title='A Stream is a readable and a writable object. Data written is typically received by the object which reads receive data from.'>Stream</a><br/><a class='trait ' href='trait.Writer.html' title='A trait for objects which are byte-oriented streams. Writers are defined by one method, `write`. This function will block until the provided buffer of bytes has been entirely written, and it will return any failurs which occur.'>Writer</a><br/></div><div class='block fn'><h2>Functions</h2><a class='fn ' href='fn.standard_error.html' title='Creates a standard error for a commonly used flavor of error. The `detail` field of the returned error will always be `None`.'>standard_error</a><br/></div>
    </section>

    <nav class="sub">
        <form class="search-form js-only">
            <button class="do-search">Search</button>
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Search documentation..."
                       type="search" />
            </div>
        </form>
    </nav>

    <section id='main' class="content struct"><a class='source'
                              href='../../src/std/MinGW/msys/1.0/home/LIIGO/rust/rust/src/libstd/io/buffered.rs.html#44-50'>[src]</a><h1 class='fqn'>Struct <a href='../index.html'>std</a>::<a href='index.html'>io</a>::<a class='struct' href=''>BufferedReader</a></h1><pre class='rust struct'>pub struct BufferedReader&lt;R&gt; {
    // some fields omitted
}</pre><div class='docblock'><p>Wraps a Reader and buffers input from it</p>

<p>It can be excessively inefficient to work directly with a <code>Reader</code> or
<code>Writer</code>. Every call to <code>read</code> or <code>write</code> on <code>TcpStream</code> results in a
system call, for example. This module provides structures that wrap
<code>Readers</code>, <code>Writers</code>, and <code>Streams</code> and buffer input and output to them.</p>

<h1 id="example" class='section-link'><a
                           href="#example">Example</a></h1><pre class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::{<span class='ident'>BufferedReader</span>, <span class='ident'>File</span>};

<span class='kw'>let</span> <span class='ident'>file</span> <span class='op'>=</span> <span class='ident'>File</span>::<span class='ident'>open</span>(<span class='kw-2'>&amp;</span><span class='ident'>Path</span>::<span class='ident'>new</span>(<span class='string'>&quot;message.txt&quot;</span>));
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>reader</span> <span class='op'>=</span> <span class='ident'>BufferedReader</span>::<span class='ident'>new</span>(<span class='ident'>file</span>);

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>buf</span> <span class='op'>=</span> [<span class='number'>0</span>, ..<span class='number'>100</span>];
<span class='kw'>match</span> <span class='ident'>reader</span>.<span class='ident'>read</span>(<span class='ident'>buf</span>) {
    <span class='prelude-val'>Ok</span>(<span class='ident'>nread</span>) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Read {} bytes&quot;</span>, <span class='ident'>nread</span>),
    <span class='prelude-val'>Err</span>(<span class='ident'>e</span>) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;error reading: {}&quot;</span>, <span class='ident'>e</span>)
}
</pre>
</div><h2 id='methods'>Methods</h2><h3 class='impl'><code>impl&lt;R: <a class='trait' href='../../std/io/trait.Reader.html' title='std::io::Reader'>Reader</a>&gt; <a class='struct' href='../../std/io/struct.BufferedReader.html' title='std::io::BufferedReader'>BufferedReader</a>&lt;R&gt;</code></h3><div class='methods'><h4 id='method.with_capacity' class='method'><code>fn <a href='#method.with_capacity' class='fnname'>with_capacity</a>(cap: uint, inner: R) -&gt; <a class='struct' href='../../std/io/struct.BufferedReader.html' title='std::io::BufferedReader'>BufferedReader</a>&lt;R&gt;</code></h4>
<div class='docblock'><p>Creates a new <code>BufferedReader</code> with the specified buffer capacity</p>
</div><h4 id='method.new' class='method'><code>fn <a href='#method.new' class='fnname'>new</a>(inner: R) -&gt; <a class='struct' href='../../std/io/struct.BufferedReader.html' title='std::io::BufferedReader'>BufferedReader</a>&lt;R&gt;</code></h4>
<div class='docblock'><p>Creates a new <code>BufferedReader</code> with a default buffer capacity</p>
</div><h4 id='method.get_ref' class='method'><code>fn <a href='#method.get_ref' class='fnname'>get_ref</a>&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a R</code></h4>
<div class='docblock'><p>Gets a reference to the underlying reader.</p>

<p>This type does not expose the ability to get a mutable reference to the
underlying reader because that could possibly corrupt the buffer.</p>
</div><h4 id='method.unwrap' class='method'><code>fn <a href='#method.unwrap' class='fnname'>unwrap</a>(self) -&gt; R</code></h4>
<div class='docblock'><p>Unwraps this buffer, returning the underlying reader.</p>

<p>Note that any leftover data in the internal buffer is lost.</p>
</div></div><h2 id='implementations'>Trait Implementations</h2><h3 class='impl'><code>impl&lt;R: <a class='trait' href='../../std/io/trait.Reader.html' title='std::io::Reader'>Reader</a>&gt; <a class='trait' href='../../std/io/trait.Buffer.html' title='std::io::Buffer'>Buffer</a> for <a class='struct' href='../../std/io/struct.BufferedReader.html' title='std::io::BufferedReader'>BufferedReader</a>&lt;R&gt;</code></h3><div class='methods'><h4 id='method.fill' class='method'><code>fn <a href='#method.fill' class='fnname'>fill</a>&lt;'a&gt;(&amp;'a mut self) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;&amp;'a [u8]&gt;</code></h4>
<div class='docblock'><p>Fills the internal buffer of this object, returning the buffer contents.
Note that none of the contents will be &quot;read&quot; in the sense that later
calling <code>read</code> may return the same contents.</p>

<p>The <code>consume</code> function must be called with the number of bytes that are
consumed from this buffer returned to ensure that the bytes are never
returned twice.</p>

<h1 id="error" class='section-link'><a
                           href="#error">Error</a></h1>
<p>This function will return an I/O error if the underlying reader was
read, but returned an error. Note that it is not an error to return a
0-length buffer.</p>
</div><h4 id='method.consume' class='method'><code>fn <a href='#method.consume' class='fnname'>consume</a>(&amp;mut self, amt: uint)</code></h4>
<div class='docblock'><p>Tells this buffer that <code>amt</code> bytes have been consumed from the buffer,
so they should no longer be returned in calls to <code>fill</code> or <code>read</code>.</p>
</div><h4 id='method.read_line' class='method'><code>fn <a href='#method.read_line' class='fnname'>read_line</a>(&amp;mut self) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;~str&gt;</code></h4>
<div class='docblock'><p>Reads the next line of input, interpreted as a sequence of UTF-8
encoded unicode codepoints. If a newline is encountered, then the
newline is contained in the returned string.</p>

<h1 id="example-1" class='section-link'><a
                           href="#example-1">Example</a></h1><pre class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>reader</span> <span class='op'>=</span> <span class='ident'>io</span>::<span class='ident'>stdin</span>();
<span class='kw'>let</span> <span class='ident'>input</span> <span class='op'>=</span> <span class='ident'>reader</span>.<span class='ident'>read_line</span>().<span class='ident'>ok</span>().<span class='ident'>unwrap_or</span>(<span class='kw-2'>~</span><span class='string'>&quot;nothing&quot;</span>);
</pre>

<h1 id="error-1" class='section-link'><a
                           href="#error-1">Error</a></h1>
<p>This function has the same error semantics as <code>read_until</code>:</p>

<ul>
<li>All non-EOF errors will be returned immediately</li>
<li>If an error is returned previously consumed bytes are lost</li>
<li>EOF is only returned if no bytes have been read</li>
<li>Reach EOF may mean that the delimiter is not present in the return
value</li>
</ul>

<p>Additionally, this function can fail if the line of input read is not a
valid UTF-8 sequence of bytes.</p>
</div><h4 id='method.lines' class='method'><code>fn <a href='#method.lines' class='fnname'>lines</a>&lt;'r&gt;(&amp;'r mut self) -&gt; <a class='struct' href='../../std/io/struct.Lines.html' title='std::io::Lines'>Lines</a>&lt;'r, Self&gt;</code></h4>
<div class='docblock'><p>Create an iterator that reads a line on each iteration until EOF.</p>

<h1 id="error-2" class='section-link'><a
                           href="#error-2">Error</a></h1>
<p>Any error other than <code>EndOfFile</code> that is produced by the underlying Reader
is returned by the iterator and should be handled by the caller.</p>
</div><h4 id='method.read_until' class='method'><code>fn <a href='#method.read_until' class='fnname'>read_until</a>(&amp;mut self, byte: u8) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;~[u8]&gt;</code></h4>
<div class='docblock'><p>Reads a sequence of bytes leading up to a specified delimiter. Once the
specified byte is encountered, reading ceases and the bytes up to and
including the delimiter are returned.</p>

<h1 id="error-3" class='section-link'><a
                           href="#error-3">Error</a></h1>
<p>If any I/O error is encountered other than EOF, the error is immediately
returned. Note that this may discard bytes which have already been read,
and those bytes will <em>not</em> be returned. It is recommended to use other
methods if this case is worrying.</p>

<p>If EOF is encountered, then this function will return EOF if 0 bytes
have been read, otherwise the pending byte buffer is returned. This
is the reason that the byte buffer returned may not always contain the
delimiter.</p>
</div><h4 id='method.read_char' class='method'><code>fn <a href='#method.read_char' class='fnname'>read_char</a>(&amp;mut self) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;char&gt;</code></h4>
<div class='docblock'><p>Reads the next utf8-encoded character from the underlying stream.</p>

<h1 id="error-4" class='section-link'><a
                           href="#error-4">Error</a></h1>
<p>If an I/O error occurs, or EOF, then this function will return <code>Err</code>.
This function will also return error if the stream does not contain a
valid utf-8 encoded codepoint as the next few bytes in the stream.</p>
</div><h4 id='method.chars' class='method'><code>fn <a href='#method.chars' class='fnname'>chars</a>&lt;'r&gt;(&amp;'r mut self) -&gt; <a class='struct' href='../../std/io/struct.Chars.html' title='std::io::Chars'>Chars</a>&lt;'r, Self&gt;</code></h4>
<div class='docblock'><p>Create an iterator that reads a utf8-encoded character on each iteration
until EOF.</p>

<h1 id="error-5" class='section-link'><a
                           href="#error-5">Error</a></h1>
<p>Any error other than <code>EndOfFile</code> that is produced by the underlying Reader
is returned by the iterator and should be handled by the caller.</p>
</div></div><h3 class='impl'><code>impl&lt;R: <a class='trait' href='../../std/io/trait.Reader.html' title='std::io::Reader'>Reader</a>&gt; <a class='trait' href='../../std/io/trait.Reader.html' title='std::io::Reader'>Reader</a> for <a class='struct' href='../../std/io/struct.BufferedReader.html' title='std::io::BufferedReader'>BufferedReader</a>&lt;R&gt;</code></h3><div class='methods'><h4 id='method.read' class='method'><code>fn <a href='#method.read' class='fnname'>read</a>(&amp;mut self, buf: &amp;mut [u8]) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;uint&gt;</code></h4>
<div class='docblock'><p>Read bytes, up to the length of <code>buf</code> and place them in <code>buf</code>.
Returns the number of bytes read. The number of bytes read my
be less than the number requested, even 0. Returns <code>Err</code> on EOF.</p>

<h1 id="error-6" class='section-link'><a
                           href="#error-6">Error</a></h1>
<p>If an error occurs during this I/O operation, then it is returned as
<code>Err(IoError)</code>. Note that end-of-file is considered an error, and can be
inspected for in the error&#39;s <code>kind</code> field. Also note that reading 0
bytes is not considered an error in all circumstances</p>
</div><h4 id='method.read_byte' class='method'><code>fn <a href='#method.read_byte' class='fnname'>read_byte</a>(&amp;mut self) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;u8&gt;</code></h4>
<div class='docblock'><p>Reads a single byte. Returns <code>Err</code> on EOF.</p>
</div><h4 id='method.push_bytes' class='method'><code>fn <a href='#method.push_bytes' class='fnname'>push_bytes</a>(&amp;mut self, buf: &amp;mut ~[u8], len: uint) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Reads <code>len</code> bytes and appends them to a vector.</p>

<p>May push fewer than the requested number of bytes on error
or EOF. If <code>Ok(())</code> is returned, then all of the requested bytes were
pushed on to the vector, otherwise the amount <code>len</code> bytes couldn&#39;t be
read (an error was encountered), and the error is returned.</p>
</div><h4 id='method.read_bytes' class='method'><code>fn <a href='#method.read_bytes' class='fnname'>read_bytes</a>(&amp;mut self, len: uint) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;~[u8]&gt;</code></h4>
<div class='docblock'><p>Reads <code>len</code> bytes and gives you back a new vector of length <code>len</code></p>

<h1 id="error-7" class='section-link'><a
                           href="#error-7">Error</a></h1>
<p>Fails with the same conditions as <code>read</code>. Additionally returns error
on EOF. Note that if an error is returned, then some number of bytes may
have already been consumed from the underlying reader, and they are lost
(not returned as part of the error). If this is unacceptable, then it is
recommended to use the <code>push_bytes</code> or <code>read</code> methods.</p>
</div><h4 id='method.read_to_end' class='method'><code>fn <a href='#method.read_to_end' class='fnname'>read_to_end</a>(&amp;mut self) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;~[u8]&gt;</code></h4>
<div class='docblock'><p>Reads all remaining bytes from the stream.</p>

<h1 id="error-8" class='section-link'><a
                           href="#error-8">Error</a></h1>
<p>Returns any non-EOF error immediately. Previously read bytes are
discarded when an error is returned.</p>

<p>When EOF is encountered, all bytes read up to that point are returned.</p>
</div><h4 id='method.read_to_str' class='method'><code>fn <a href='#method.read_to_str' class='fnname'>read_to_str</a>(&amp;mut self) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;~str&gt;</code></h4>
<div class='docblock'><p>Reads all of the remaining bytes of this stream, interpreting them as a
UTF-8 encoded stream. The corresponding string is returned.</p>

<h1 id="error-9" class='section-link'><a
                           href="#error-9">Error</a></h1>
<p>This function returns all of the same errors as <code>read_to_end</code> with an
additional error if the reader&#39;s contents are not a valid sequence of
UTF-8 bytes.</p>
</div><h4 id='method.bytes' class='method'><code>fn <a href='#method.bytes' class='fnname'>bytes</a>&lt;'r&gt;(&amp;'r mut self) -&gt; <a class='struct' href='../../std/io/extensions/struct.Bytes.html' title='std::io::extensions::Bytes'>Bytes</a>&lt;'r, Self&gt;</code></h4>
<div class='docblock'><p>Create an iterator that reads a single byte on
each iteration, until EOF.</p>

<h1 id="error-10" class='section-link'><a
                           href="#error-10">Error</a></h1>
<p>Any error other than <code>EndOfFile</code> that is produced by the underlying Reader
is returned by the iterator and should be handled by the caller.</p>
</div><h4 id='method.read_le_uint_n' class='method'><code>fn <a href='#method.read_le_uint_n' class='fnname'>read_le_uint_n</a>(&amp;mut self, nbytes: uint) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;u64&gt;</code></h4>
<div class='docblock'><p>Reads <code>n</code> little-endian unsigned integer bytes.</p>

<p><code>n</code> must be between 1 and 8, inclusive.</p>
</div><h4 id='method.read_le_int_n' class='method'><code>fn <a href='#method.read_le_int_n' class='fnname'>read_le_int_n</a>(&amp;mut self, nbytes: uint) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;i64&gt;</code></h4>
<div class='docblock'><p>Reads <code>n</code> little-endian signed integer bytes.</p>

<p><code>n</code> must be between 1 and 8, inclusive.</p>
</div><h4 id='method.read_be_uint_n' class='method'><code>fn <a href='#method.read_be_uint_n' class='fnname'>read_be_uint_n</a>(&amp;mut self, nbytes: uint) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;u64&gt;</code></h4>
<div class='docblock'><p>Reads <code>n</code> big-endian unsigned integer bytes.</p>

<p><code>n</code> must be between 1 and 8, inclusive.</p>
</div><h4 id='method.read_be_int_n' class='method'><code>fn <a href='#method.read_be_int_n' class='fnname'>read_be_int_n</a>(&amp;mut self, nbytes: uint) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;i64&gt;</code></h4>
<div class='docblock'><p>Reads <code>n</code> big-endian signed integer bytes.</p>

<p><code>n</code> must be between 1 and 8, inclusive.</p>
</div><h4 id='method.read_le_uint' class='method'><code>fn <a href='#method.read_le_uint' class='fnname'>read_le_uint</a>(&amp;mut self) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;uint&gt;</code></h4>
<div class='docblock'><p>Reads a little-endian unsigned integer.</p>

<p>The number of bytes returned is system-dependant.</p>
</div><h4 id='method.read_le_int' class='method'><code>fn <a href='#method.read_le_int' class='fnname'>read_le_int</a>(&amp;mut self) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;int&gt;</code></h4>
<div class='docblock'><p>Reads a little-endian integer.</p>

<p>The number of bytes returned is system-dependant.</p>
</div><h4 id='method.read_be_uint' class='method'><code>fn <a href='#method.read_be_uint' class='fnname'>read_be_uint</a>(&amp;mut self) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;uint&gt;</code></h4>
<div class='docblock'><p>Reads a big-endian unsigned integer.</p>

<p>The number of bytes returned is system-dependant.</p>
</div><h4 id='method.read_be_int' class='method'><code>fn <a href='#method.read_be_int' class='fnname'>read_be_int</a>(&amp;mut self) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;int&gt;</code></h4>
<div class='docblock'><p>Reads a big-endian integer.</p>

<p>The number of bytes returned is system-dependant.</p>
</div><h4 id='method.read_be_u64' class='method'><code>fn <a href='#method.read_be_u64' class='fnname'>read_be_u64</a>(&amp;mut self) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;u64&gt;</code></h4>
<div class='docblock'><p>Reads a big-endian <code>u64</code>.</p>

<p><code>u64</code>s are 8 bytes long.</p>
</div><h4 id='method.read_be_u32' class='method'><code>fn <a href='#method.read_be_u32' class='fnname'>read_be_u32</a>(&amp;mut self) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;u32&gt;</code></h4>
<div class='docblock'><p>Reads a big-endian <code>u32</code>.</p>

<p><code>u32</code>s are 4 bytes long.</p>
</div><h4 id='method.read_be_u16' class='method'><code>fn <a href='#method.read_be_u16' class='fnname'>read_be_u16</a>(&amp;mut self) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;u16&gt;</code></h4>
<div class='docblock'><p>Reads a big-endian <code>u16</code>.</p>

<p><code>u16</code>s are 2 bytes long.</p>
</div><h4 id='method.read_be_i64' class='method'><code>fn <a href='#method.read_be_i64' class='fnname'>read_be_i64</a>(&amp;mut self) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;i64&gt;</code></h4>
<div class='docblock'><p>Reads a big-endian <code>i64</code>.</p>

<p><code>i64</code>s are 8 bytes long.</p>
</div><h4 id='method.read_be_i32' class='method'><code>fn <a href='#method.read_be_i32' class='fnname'>read_be_i32</a>(&amp;mut self) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;i32&gt;</code></h4>
<div class='docblock'><p>Reads a big-endian <code>i32</code>.</p>

<p><code>i32</code>s are 4 bytes long.</p>
</div><h4 id='method.read_be_i16' class='method'><code>fn <a href='#method.read_be_i16' class='fnname'>read_be_i16</a>(&amp;mut self) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;i16&gt;</code></h4>
<div class='docblock'><p>Reads a big-endian <code>i16</code>.</p>

<p><code>i16</code>s are 2 bytes long.</p>
</div><h4 id='method.read_be_f64' class='method'><code>fn <a href='#method.read_be_f64' class='fnname'>read_be_f64</a>(&amp;mut self) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;f64&gt;</code></h4>
<div class='docblock'><p>Reads a big-endian <code>f64</code>.</p>

<p><code>f64</code>s are 8 byte, IEEE754 double-precision floating point numbers.</p>
</div><h4 id='method.read_be_f32' class='method'><code>fn <a href='#method.read_be_f32' class='fnname'>read_be_f32</a>(&amp;mut self) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;f32&gt;</code></h4>
<div class='docblock'><p>Reads a big-endian <code>f32</code>.</p>

<p><code>f32</code>s are 4 byte, IEEE754 single-precision floating point numbers.</p>
</div><h4 id='method.read_le_u64' class='method'><code>fn <a href='#method.read_le_u64' class='fnname'>read_le_u64</a>(&amp;mut self) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;u64&gt;</code></h4>
<div class='docblock'><p>Reads a little-endian <code>u64</code>.</p>

<p><code>u64</code>s are 8 bytes long.</p>
</div><h4 id='method.read_le_u32' class='method'><code>fn <a href='#method.read_le_u32' class='fnname'>read_le_u32</a>(&amp;mut self) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;u32&gt;</code></h4>
<div class='docblock'><p>Reads a little-endian <code>u32</code>.</p>

<p><code>u32</code>s are 4 bytes long.</p>
</div><h4 id='method.read_le_u16' class='method'><code>fn <a href='#method.read_le_u16' class='fnname'>read_le_u16</a>(&amp;mut self) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;u16&gt;</code></h4>
<div class='docblock'><p>Reads a little-endian <code>u16</code>.</p>

<p><code>u16</code>s are 2 bytes long.</p>
</div><h4 id='method.read_le_i64' class='method'><code>fn <a href='#method.read_le_i64' class='fnname'>read_le_i64</a>(&amp;mut self) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;i64&gt;</code></h4>
<div class='docblock'><p>Reads a little-endian <code>i64</code>.</p>

<p><code>i64</code>s are 8 bytes long.</p>
</div><h4 id='method.read_le_i32' class='method'><code>fn <a href='#method.read_le_i32' class='fnname'>read_le_i32</a>(&amp;mut self) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;i32&gt;</code></h4>
<div class='docblock'><p>Reads a little-endian <code>i32</code>.</p>

<p><code>i32</code>s are 4 bytes long.</p>
</div><h4 id='method.read_le_i16' class='method'><code>fn <a href='#method.read_le_i16' class='fnname'>read_le_i16</a>(&amp;mut self) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;i16&gt;</code></h4>
<div class='docblock'><p>Reads a little-endian <code>i16</code>.</p>

<p><code>i16</code>s are 2 bytes long.</p>
</div><h4 id='method.read_le_f64' class='method'><code>fn <a href='#method.read_le_f64' class='fnname'>read_le_f64</a>(&amp;mut self) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;f64&gt;</code></h4>
<div class='docblock'><p>Reads a little-endian <code>f64</code>.</p>

<p><code>f64</code>s are 8 byte, IEEE754 double-precision floating point numbers.</p>
</div><h4 id='method.read_le_f32' class='method'><code>fn <a href='#method.read_le_f32' class='fnname'>read_le_f32</a>(&amp;mut self) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;f32&gt;</code></h4>
<div class='docblock'><p>Reads a little-endian <code>f32</code>.</p>

<p><code>f32</code>s are 4 byte, IEEE754 single-precision floating point numbers.</p>
</div><h4 id='method.read_u8' class='method'><code>fn <a href='#method.read_u8' class='fnname'>read_u8</a>(&amp;mut self) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;u8&gt;</code></h4>
<div class='docblock'><p>Read a u8.</p>

<p><code>u8</code>s are 1 byte.</p>
</div><h4 id='method.read_i8' class='method'><code>fn <a href='#method.read_i8' class='fnname'>read_i8</a>(&amp;mut self) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;i8&gt;</code></h4>
<div class='docblock'><p>Read an i8.</p>

<p><code>i8</code>s are 1 byte.</p>
</div><h4 id='method.by_ref' class='method'><code>fn <a href='#method.by_ref' class='fnname'>by_ref</a>&lt;'a&gt;(&amp;'a mut self) -&gt; <a class='struct' href='../../std/io/struct.RefReader.html' title='std::io::RefReader'>RefReader</a>&lt;'a, Self&gt;</code></h4>
<div class='docblock'><p>Creates a wrapper around a mutable reference to the reader.</p>

<p>This is useful to allow applying adaptors while still
retaining ownership of the original value.</p>
</div></div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <div id="help" class="hidden">
        <div class="shortcuts">
            <h1>Keyboard shortcuts</h1>
            <dl>
                <dt>?</dt>
                <dd>Show this help dialog</dd>
                <dt>S</dt>
                <dd>Focus the search field</dd>
                <dt>&uarr;</dt>
                <dd>Move up in search results</dd>
                <dt>&darr;</dt>
                <dd>Move down in search results</dd>
                <dt>&#9166;</dt>
                <dd>Go to active search result</dd>
            </dl>
        </div>
        <div class="infos">
            <h1>Search tricks</h1>
            <p>
                Prefix searches with a type followed by a colon (e.g.
                <code>fn:</code>) to restrict the search to a given type.
            </p>
            <p>
                Accepted types are: <code>fn</code>, <code>mod</code>,
                <code>struct</code> (or <code>str</code>), <code>enum</code>,
                <code>trait</code>, <code>typedef</code> (or
                <code>tdef</code>).
            </p>
        </div>
    </div>

    <script>
        var rootPath = "../../";
        var currentCrate = "std";
    </script>
    <script src="../../jquery.js"></script>
    <script src="../../main.js"></script>
    <script async src="../../search-index.js"></script>
</body>
</html>
