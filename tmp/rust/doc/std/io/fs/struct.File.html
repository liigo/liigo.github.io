<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>std::io::fs::File - Rust</title>

    <link href='http://fonts.googleapis.com/css?family=Oswald:700|Inconsolata:400,700'
          rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="../../../main.css">

    <link rel="shortcut icon" href="http://www.rust-lang.org/favicon.ico" />
</head>
<body>
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <section class="sidebar">
        
            <a href='../../../std/index.html'><img src='http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png' alt=''/></a>
        

        <p class='location'><a href='../../index.html'>std</a>&#8203;::<a href='../index.html'>io</a>&#8203;::<a href='index.html'>fs</a></p><div class='block struct'><h2>Structs</h2><a class='struct ' href='struct.Directories.html' title='An iterator which walks over a directory'>Directories</a><br/><a class='struct current' href='struct.File.html' title='Unconstrained file access type that exposes read and write operations'>File</a><br/></div><div class='block fn'><h2>Functions</h2><a class='fn ' href='fn.change_file_times.html' title='Changes the timestamps for a file's last modification and access time. The file at the path specified will have its last access time set to `atime` and its modification time set to `mtime`. The times specified should be in milliseconds.'>change_file_times</a><br/><a class='fn ' href='fn.chmod.html' title='Changes the permission mode bits found on a file or a directory. This function takes a mask from the `io` module'>chmod</a><br/><a class='fn ' href='fn.chown.html' title='Change the user and group owners of a file at the specified path.'>chown</a><br/><a class='fn ' href='fn.copy.html' title='Copies the contents of one file to another. This function will also copy the permission bits of the original file to the destination file.'>copy</a><br/><a class='fn ' href='fn.link.html' title='Creates a new hard link on the filesystem. The `dst` path will be a link pointing to the `src` path. Note that systems often require these two paths to both be located on the same filesystem.'>link</a><br/><a class='fn ' href='fn.lstat.html' title='Perform the same operation as the `stat` function, except that this function does not traverse through symlinks. This will return information about the symlink file instead of the file that it points to.'>lstat</a><br/><a class='fn ' href='fn.mkdir.html' title='Create a new, empty directory at the provided path'>mkdir</a><br/><a class='fn ' href='fn.mkdir_recursive.html' title='Recursively create a directory and all of its parent components if they are missing.'>mkdir_recursive</a><br/><a class='fn ' href='fn.readdir.html' title='Retrieve a vector containing all entries within a provided directory'>readdir</a><br/><a class='fn ' href='fn.readlink.html' title='Reads a symlink, returning the file that the symlink points to.'>readlink</a><br/><a class='fn ' href='fn.rename.html' title='Rename a file or directory to a new name.'>rename</a><br/><a class='fn ' href='fn.rmdir.html' title='Remove an existing, empty directory'>rmdir</a><br/><a class='fn ' href='fn.rmdir_recursive.html' title='Removes a directory at this path, after removing all its contents. Use carefully!'>rmdir_recursive</a><br/><a class='fn ' href='fn.stat.html' title='Given a path, query the file system to get information about a file, directory, etc. This function will traverse symlinks to query information about the destination file.'>stat</a><br/><a class='fn ' href='fn.symlink.html' title='Creates a new symbolic link on the filesystem. The `dst` path will be a symlink pointing to the `src` path.'>symlink</a><br/><a class='fn ' href='fn.unlink.html' title='Unlink a file from the underlying filesystem.'>unlink</a><br/><a class='fn ' href='fn.walk_dir.html' title='Returns an iterator which will recursively walk the directory structure rooted at `path`. The path given will not be iterated over, and this will perform iteration in a top-down order.'>walk_dir</a><br/></div>
    </section>

    <nav class="sub">
        <form class="search-form js-only">
            <button class="do-search">Search</button>
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Search documentation..."
                       type="search" />
            </div>
        </form>
    </nav>

    <section id='main' class="content struct"><a class='source'
                              href='../../../src/std/MinGW/msys/1.0/home/LIIGO/rust/rust/src/libstd/io/fs.rs.html#79-83'>[src]</a><h1 class='fqn'>Struct <a href='../../index.html'>std</a>::<a href='../index.html'>io</a>::<a href='index.html'>fs</a>::<a class='struct' href=''>File</a></h1><pre class='rust struct'>pub struct File {
    // some fields omitted
}</pre><div class='docblock'><p>Unconstrained file access type that exposes read and write operations</p>

<p>Can be constructed via <code>File::open()</code>, <code>File::create()</code>, and
<code>File::open_mode()</code>.</p>

<h1 id="error" class='section-link'><a
                           href="#error">Error</a></h1>
<p>This type will return errors as an <code>IoResult&lt;T&gt;</code> if operations are
attempted against it for which its underlying file descriptor was not
configured at creation time, via the <code>FileAccess</code> parameter to
<code>File::open_mode()</code>.</p>
</div><h2 id='methods'>Methods</h2><h3 class='impl'><code>impl <a class='struct' href='../../../std/io/fs/struct.File.html' title='std::io::fs::File'>File</a></code></h3><div class='methods'><h4 id='method.open_mode' class='method'><code>fn <a href='#method.open_mode' class='fnname'>open_mode</a>(path: &amp;<a class='struct' href='../../../std/path/windows/struct.Path.html' title='std::path::windows::Path'>Path</a>, mode: <a class='enum' href='../../../std/io/enum.FileMode.html' title='std::io::FileMode'>FileMode</a>, access: <a class='enum' href='../../../std/io/enum.FileAccess.html' title='std::io::FileAccess'>FileAccess</a>) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;<a class='struct' href='../../../std/io/fs/struct.File.html' title='std::io::fs::File'>File</a>&gt;</code></h4>
<div class='docblock'><p>Open a file at <code>path</code> in the mode specified by the <code>mode</code> and <code>access</code>
arguments</p>

<h1 id="example" class='section-link'><a
                           href="#example">Example</a></h1><pre class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::{<span class='ident'>File</span>, <span class='ident'>Open</span>, <span class='ident'>ReadWrite</span>};

<span class='kw'>let</span> <span class='ident'>p</span> <span class='op'>=</span> <span class='ident'>Path</span>::<span class='ident'>new</span>(<span class='string'>&quot;/some/file/path.txt&quot;</span>);

<span class='kw'>let</span> <span class='ident'>file</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>File</span>::<span class='ident'>open_mode</span>(<span class='kw-2'>&amp;</span><span class='ident'>p</span>, <span class='ident'>Open</span>, <span class='ident'>ReadWrite</span>) {
    <span class='prelude-val'>Ok</span>(<span class='ident'>f</span>) <span class='op'>=&gt;</span> <span class='ident'>f</span>,
    <span class='prelude-val'>Err</span>(<span class='ident'>e</span>) <span class='op'>=&gt;</span> <span class='macro'>fail</span><span class='macro'>!</span>(<span class='string'>&quot;file error: {}&quot;</span>, <span class='ident'>e</span>),
};<span class='comment'>
// do some stuff with that file

// the file will be closed at the end of this block
</span></pre>

<p><code>FileMode</code> and <code>FileAccess</code> provide information about the permissions
context in which a given stream is created. More information about them
can be found in <code>std::io</code>&#39;s docs. If a file is opened with <code>Write</code>
or <code>ReadWrite</code> access, then it will be created it does not already
exist.</p>

<p>Note that, with this function, a <code>File</code> is returned regardless of the
access-limitations indicated by <code>FileAccess</code> (e.g. calling <code>write</code> on a
<code>File</code> opened as <code>Read</code> will return an error at runtime).</p>

<h1 id="error-1" class='section-link'><a
                           href="#error-1">Error</a></h1>
<p>This function will return an error under a number of different
circumstances, to include but not limited to:</p>

<ul>
<li>Opening a file that does not exist with <code>Read</code> access.</li>
<li>Attempting to open a file with a <code>FileAccess</code> that the user lacks
permissions for</li>
<li>Filesystem-level errors (full disk, etc)</li>
</ul>
</div><h4 id='method.open' class='method'><code>fn <a href='#method.open' class='fnname'>open</a>(path: &amp;<a class='struct' href='../../../std/path/windows/struct.Path.html' title='std::path::windows::Path'>Path</a>) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;<a class='struct' href='../../../std/io/fs/struct.File.html' title='std::io::fs::File'>File</a>&gt;</code></h4>
<div class='docblock'><p>Attempts to open a file in read-only mode. This function is equivalent to
<code>File::open_mode(path, Open, Read)</code>, and will raise all of the same
errors that <code>File::open_mode</code> does.</p>

<p>For more information, see the <code>File::open_mode</code> function.</p>

<h1 id="example-1" class='section-link'><a
                           href="#example-1">Example</a></h1><pre class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>File</span>;

<span class='kw'>let</span> <span class='ident'>contents</span> <span class='op'>=</span> <span class='ident'>File</span>::<span class='ident'>open</span>(<span class='kw-2'>&amp;</span><span class='ident'>Path</span>::<span class='ident'>new</span>(<span class='string'>&quot;foo.txt&quot;</span>)).<span class='ident'>read_to_end</span>();
</pre>
</div><h4 id='method.create' class='method'><code>fn <a href='#method.create' class='fnname'>create</a>(path: &amp;<a class='struct' href='../../../std/path/windows/struct.Path.html' title='std::path::windows::Path'>Path</a>) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;<a class='struct' href='../../../std/io/fs/struct.File.html' title='std::io::fs::File'>File</a>&gt;</code></h4>
<div class='docblock'><p>Attempts to create a file in write-only mode. This function is
equivalent to <code>File::open_mode(path, Truncate, Write)</code>, and will
raise all of the same errors that <code>File::open_mode</code> does.</p>

<p>For more information, see the <code>File::open_mode</code> function.</p>

<h1 id="example-2" class='section-link'><a
                           href="#example-2">Example</a></h1><pre class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>File</span>;

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='ident'>File</span>::<span class='ident'>create</span>(<span class='kw-2'>&amp;</span><span class='ident'>Path</span>::<span class='ident'>new</span>(<span class='string'>&quot;foo.txt&quot;</span>));
<span class='ident'>f</span>.<span class='ident'>write</span>(<span class='macro'>bytes</span><span class='macro'>!</span>(<span class='string'>&quot;This is a sample file&quot;</span>));
</pre>
</div><h4 id='method.path' class='method'><code>fn <a href='#method.path' class='fnname'>path</a>&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a <a class='struct' href='../../../std/path/windows/struct.Path.html' title='std::path::windows::Path'>Path</a></code></h4>
<div class='docblock'><p>Returns the original path which was used to open this file.</p>
</div><h4 id='method.fsync' class='method'><code>fn <a href='#method.fsync' class='fnname'>fsync</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Synchronizes all modifications to this file to its permanent storage
device. This will flush any internal buffers necessary to perform this
operation.</p>
</div><h4 id='method.datasync' class='method'><code>fn <a href='#method.datasync' class='fnname'>datasync</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>This function is similar to <code>fsync</code>, except that it may not synchronize
file metadata to the filesystem. This is intended for use case which
must synchronize content, but don&#39;t need the metadata on disk. The goal
of this method is to reduce disk operations.</p>
</div><h4 id='method.truncate' class='method'><code>fn <a href='#method.truncate' class='fnname'>truncate</a>(&amp;mut self, size: i64) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Either truncates or extends the underlying file, updating the size of
this file to become <code>size</code>. This is equivalent to unix&#39;s <code>truncate</code>
function.</p>

<p>If the <code>size</code> is less than the current file&#39;s size, then the file will
be shrunk. If it is greater than the current file&#39;s size, then the file
will be extended to <code>size</code> and have all of the intermediate data filled
in with 0s.</p>
</div><h4 id='method.eof' class='method'><code>fn <a href='#method.eof' class='fnname'>eof</a>(&amp;self) -&gt; bool</code></h4>
<div class='docblock'><p>Tests whether this stream has reached EOF.</p>

<p>If true, then this file will no longer continue to return data via
<code>read</code>.</p>
</div></div><h2 id='implementations'>Trait Implementations</h2><h3 class='impl'><code>impl <a class='trait' href='../../../std/io/trait.Reader.html' title='std::io::Reader'>Reader</a> for <a class='struct' href='../../../std/io/fs/struct.File.html' title='std::io::fs::File'>File</a></code></h3><div class='methods'><h4 id='method.read' class='method'><code>fn <a href='#method.read' class='fnname'>read</a>(&amp;mut self, buf: &amp;mut [u8]) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;uint&gt;</code></h4>
<div class='docblock'><p>Read bytes, up to the length of <code>buf</code> and place them in <code>buf</code>.
Returns the number of bytes read. The number of bytes read my
be less than the number requested, even 0. Returns <code>Err</code> on EOF.</p>

<h1 id="error-2" class='section-link'><a
                           href="#error-2">Error</a></h1>
<p>If an error occurs during this I/O operation, then it is returned as
<code>Err(IoError)</code>. Note that end-of-file is considered an error, and can be
inspected for in the error&#39;s <code>kind</code> field. Also note that reading 0
bytes is not considered an error in all circumstances</p>
</div><h4 id='method.read_byte' class='method'><code>fn <a href='#method.read_byte' class='fnname'>read_byte</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;u8&gt;</code></h4>
<div class='docblock'><p>Reads a single byte. Returns <code>Err</code> on EOF.</p>
</div><h4 id='method.push_bytes' class='method'><code>fn <a href='#method.push_bytes' class='fnname'>push_bytes</a>(&amp;mut self, buf: &amp;mut ~[u8], len: uint) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Reads <code>len</code> bytes and appends them to a vector.</p>

<p>May push fewer than the requested number of bytes on error
or EOF. If <code>Ok(())</code> is returned, then all of the requested bytes were
pushed on to the vector, otherwise the amount <code>len</code> bytes couldn&#39;t be
read (an error was encountered), and the error is returned.</p>
</div><h4 id='method.read_bytes' class='method'><code>fn <a href='#method.read_bytes' class='fnname'>read_bytes</a>(&amp;mut self, len: uint) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;~[u8]&gt;</code></h4>
<div class='docblock'><p>Reads <code>len</code> bytes and gives you back a new vector of length <code>len</code></p>

<h1 id="error-3" class='section-link'><a
                           href="#error-3">Error</a></h1>
<p>Fails with the same conditions as <code>read</code>. Additionally returns error
on EOF. Note that if an error is returned, then some number of bytes may
have already been consumed from the underlying reader, and they are lost
(not returned as part of the error). If this is unacceptable, then it is
recommended to use the <code>push_bytes</code> or <code>read</code> methods.</p>
</div><h4 id='method.read_to_end' class='method'><code>fn <a href='#method.read_to_end' class='fnname'>read_to_end</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;~[u8]&gt;</code></h4>
<div class='docblock'><p>Reads all remaining bytes from the stream.</p>

<h1 id="error-4" class='section-link'><a
                           href="#error-4">Error</a></h1>
<p>Returns any non-EOF error immediately. Previously read bytes are
discarded when an error is returned.</p>

<p>When EOF is encountered, all bytes read up to that point are returned.</p>
</div><h4 id='method.read_to_str' class='method'><code>fn <a href='#method.read_to_str' class='fnname'>read_to_str</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;~str&gt;</code></h4>
<div class='docblock'><p>Reads all of the remaining bytes of this stream, interpreting them as a
UTF-8 encoded stream. The corresponding string is returned.</p>

<h1 id="error-5" class='section-link'><a
                           href="#error-5">Error</a></h1>
<p>This function returns all of the same errors as <code>read_to_end</code> with an
additional error if the reader&#39;s contents are not a valid sequence of
UTF-8 bytes.</p>
</div><h4 id='method.bytes' class='method'><code>fn <a href='#method.bytes' class='fnname'>bytes</a>&lt;'r&gt;(&amp;'r mut self) -&gt; <a class='struct' href='../../../std/io/extensions/struct.Bytes.html' title='std::io::extensions::Bytes'>Bytes</a>&lt;'r, Self&gt;</code></h4>
<div class='docblock'><p>Create an iterator that reads a single byte on
each iteration, until EOF.</p>

<h1 id="error-6" class='section-link'><a
                           href="#error-6">Error</a></h1>
<p>Any error other than <code>EndOfFile</code> that is produced by the underlying Reader
is returned by the iterator and should be handled by the caller.</p>
</div><h4 id='method.read_le_uint_n' class='method'><code>fn <a href='#method.read_le_uint_n' class='fnname'>read_le_uint_n</a>(&amp;mut self, nbytes: uint) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;u64&gt;</code></h4>
<div class='docblock'><p>Reads <code>n</code> little-endian unsigned integer bytes.</p>

<p><code>n</code> must be between 1 and 8, inclusive.</p>
</div><h4 id='method.read_le_int_n' class='method'><code>fn <a href='#method.read_le_int_n' class='fnname'>read_le_int_n</a>(&amp;mut self, nbytes: uint) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;i64&gt;</code></h4>
<div class='docblock'><p>Reads <code>n</code> little-endian signed integer bytes.</p>

<p><code>n</code> must be between 1 and 8, inclusive.</p>
</div><h4 id='method.read_be_uint_n' class='method'><code>fn <a href='#method.read_be_uint_n' class='fnname'>read_be_uint_n</a>(&amp;mut self, nbytes: uint) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;u64&gt;</code></h4>
<div class='docblock'><p>Reads <code>n</code> big-endian unsigned integer bytes.</p>

<p><code>n</code> must be between 1 and 8, inclusive.</p>
</div><h4 id='method.read_be_int_n' class='method'><code>fn <a href='#method.read_be_int_n' class='fnname'>read_be_int_n</a>(&amp;mut self, nbytes: uint) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;i64&gt;</code></h4>
<div class='docblock'><p>Reads <code>n</code> big-endian signed integer bytes.</p>

<p><code>n</code> must be between 1 and 8, inclusive.</p>
</div><h4 id='method.read_le_uint' class='method'><code>fn <a href='#method.read_le_uint' class='fnname'>read_le_uint</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;uint&gt;</code></h4>
<div class='docblock'><p>Reads a little-endian unsigned integer.</p>

<p>The number of bytes returned is system-dependant.</p>
</div><h4 id='method.read_le_int' class='method'><code>fn <a href='#method.read_le_int' class='fnname'>read_le_int</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;int&gt;</code></h4>
<div class='docblock'><p>Reads a little-endian integer.</p>

<p>The number of bytes returned is system-dependant.</p>
</div><h4 id='method.read_be_uint' class='method'><code>fn <a href='#method.read_be_uint' class='fnname'>read_be_uint</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;uint&gt;</code></h4>
<div class='docblock'><p>Reads a big-endian unsigned integer.</p>

<p>The number of bytes returned is system-dependant.</p>
</div><h4 id='method.read_be_int' class='method'><code>fn <a href='#method.read_be_int' class='fnname'>read_be_int</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;int&gt;</code></h4>
<div class='docblock'><p>Reads a big-endian integer.</p>

<p>The number of bytes returned is system-dependant.</p>
</div><h4 id='method.read_be_u64' class='method'><code>fn <a href='#method.read_be_u64' class='fnname'>read_be_u64</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;u64&gt;</code></h4>
<div class='docblock'><p>Reads a big-endian <code>u64</code>.</p>

<p><code>u64</code>s are 8 bytes long.</p>
</div><h4 id='method.read_be_u32' class='method'><code>fn <a href='#method.read_be_u32' class='fnname'>read_be_u32</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;u32&gt;</code></h4>
<div class='docblock'><p>Reads a big-endian <code>u32</code>.</p>

<p><code>u32</code>s are 4 bytes long.</p>
</div><h4 id='method.read_be_u16' class='method'><code>fn <a href='#method.read_be_u16' class='fnname'>read_be_u16</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;u16&gt;</code></h4>
<div class='docblock'><p>Reads a big-endian <code>u16</code>.</p>

<p><code>u16</code>s are 2 bytes long.</p>
</div><h4 id='method.read_be_i64' class='method'><code>fn <a href='#method.read_be_i64' class='fnname'>read_be_i64</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;i64&gt;</code></h4>
<div class='docblock'><p>Reads a big-endian <code>i64</code>.</p>

<p><code>i64</code>s are 8 bytes long.</p>
</div><h4 id='method.read_be_i32' class='method'><code>fn <a href='#method.read_be_i32' class='fnname'>read_be_i32</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;i32&gt;</code></h4>
<div class='docblock'><p>Reads a big-endian <code>i32</code>.</p>

<p><code>i32</code>s are 4 bytes long.</p>
</div><h4 id='method.read_be_i16' class='method'><code>fn <a href='#method.read_be_i16' class='fnname'>read_be_i16</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;i16&gt;</code></h4>
<div class='docblock'><p>Reads a big-endian <code>i16</code>.</p>

<p><code>i16</code>s are 2 bytes long.</p>
</div><h4 id='method.read_be_f64' class='method'><code>fn <a href='#method.read_be_f64' class='fnname'>read_be_f64</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;f64&gt;</code></h4>
<div class='docblock'><p>Reads a big-endian <code>f64</code>.</p>

<p><code>f64</code>s are 8 byte, IEEE754 double-precision floating point numbers.</p>
</div><h4 id='method.read_be_f32' class='method'><code>fn <a href='#method.read_be_f32' class='fnname'>read_be_f32</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;f32&gt;</code></h4>
<div class='docblock'><p>Reads a big-endian <code>f32</code>.</p>

<p><code>f32</code>s are 4 byte, IEEE754 single-precision floating point numbers.</p>
</div><h4 id='method.read_le_u64' class='method'><code>fn <a href='#method.read_le_u64' class='fnname'>read_le_u64</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;u64&gt;</code></h4>
<div class='docblock'><p>Reads a little-endian <code>u64</code>.</p>

<p><code>u64</code>s are 8 bytes long.</p>
</div><h4 id='method.read_le_u32' class='method'><code>fn <a href='#method.read_le_u32' class='fnname'>read_le_u32</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;u32&gt;</code></h4>
<div class='docblock'><p>Reads a little-endian <code>u32</code>.</p>

<p><code>u32</code>s are 4 bytes long.</p>
</div><h4 id='method.read_le_u16' class='method'><code>fn <a href='#method.read_le_u16' class='fnname'>read_le_u16</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;u16&gt;</code></h4>
<div class='docblock'><p>Reads a little-endian <code>u16</code>.</p>

<p><code>u16</code>s are 2 bytes long.</p>
</div><h4 id='method.read_le_i64' class='method'><code>fn <a href='#method.read_le_i64' class='fnname'>read_le_i64</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;i64&gt;</code></h4>
<div class='docblock'><p>Reads a little-endian <code>i64</code>.</p>

<p><code>i64</code>s are 8 bytes long.</p>
</div><h4 id='method.read_le_i32' class='method'><code>fn <a href='#method.read_le_i32' class='fnname'>read_le_i32</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;i32&gt;</code></h4>
<div class='docblock'><p>Reads a little-endian <code>i32</code>.</p>

<p><code>i32</code>s are 4 bytes long.</p>
</div><h4 id='method.read_le_i16' class='method'><code>fn <a href='#method.read_le_i16' class='fnname'>read_le_i16</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;i16&gt;</code></h4>
<div class='docblock'><p>Reads a little-endian <code>i16</code>.</p>

<p><code>i16</code>s are 2 bytes long.</p>
</div><h4 id='method.read_le_f64' class='method'><code>fn <a href='#method.read_le_f64' class='fnname'>read_le_f64</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;f64&gt;</code></h4>
<div class='docblock'><p>Reads a little-endian <code>f64</code>.</p>

<p><code>f64</code>s are 8 byte, IEEE754 double-precision floating point numbers.</p>
</div><h4 id='method.read_le_f32' class='method'><code>fn <a href='#method.read_le_f32' class='fnname'>read_le_f32</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;f32&gt;</code></h4>
<div class='docblock'><p>Reads a little-endian <code>f32</code>.</p>

<p><code>f32</code>s are 4 byte, IEEE754 single-precision floating point numbers.</p>
</div><h4 id='method.read_u8' class='method'><code>fn <a href='#method.read_u8' class='fnname'>read_u8</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;u8&gt;</code></h4>
<div class='docblock'><p>Read a u8.</p>

<p><code>u8</code>s are 1 byte.</p>
</div><h4 id='method.read_i8' class='method'><code>fn <a href='#method.read_i8' class='fnname'>read_i8</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;i8&gt;</code></h4>
<div class='docblock'><p>Read an i8.</p>

<p><code>i8</code>s are 1 byte.</p>
</div><h4 id='method.by_ref' class='method'><code>fn <a href='#method.by_ref' class='fnname'>by_ref</a>&lt;'a&gt;(&amp;'a mut self) -&gt; <a class='struct' href='../../../std/io/struct.RefReader.html' title='std::io::RefReader'>RefReader</a>&lt;'a, Self&gt;</code></h4>
<div class='docblock'><p>Creates a wrapper around a mutable reference to the reader.</p>

<p>This is useful to allow applying adaptors while still
retaining ownership of the original value.</p>
</div></div><h3 class='impl'><code>impl <a class='trait' href='../../../std/io/trait.Writer.html' title='std::io::Writer'>Writer</a> for <a class='struct' href='../../../std/io/fs/struct.File.html' title='std::io::fs::File'>File</a></code></h3><div class='methods'><h4 id='method.write' class='method'><code>fn <a href='#method.write' class='fnname'>write</a>(&amp;mut self, buf: &amp;[u8]) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write the entirety of a given buffer</p>

<h1 id="errors" class='section-link'><a
                           href="#errors">Errors</a></h1>
<p>If an error happens during the I/O operation, the error is returned as
<code>Err</code>. Note that it is considered an error if the entire buffer could
not be written, and if an error is returned then it is unknown how much
data (if any) was actually written.</p>
</div><h4 id='method.flush' class='method'><code>fn <a href='#method.flush' class='fnname'>flush</a>(&amp;mut self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Flush this output stream, ensuring that all intermediately buffered
contents reach their destination.</p>

<p>This is by default a no-op and implementers of the <code>Writer</code> trait should
decide whether their stream needs to be buffered or not.</p>
</div><h4 id='method.write_str' class='method'><code>fn <a href='#method.write_str' class='fnname'>write_str</a>(&amp;mut self, s: &amp;str) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write a rust string into this sink.</p>

<p>The bytes written will be the UTF-8 encoded version of the input string.
If other encodings are desired, it is recommended to compose this stream
with another performing the conversion, or to use <code>write</code> with a
converted byte-array instead.</p>
</div><h4 id='method.write_line' class='method'><code>fn <a href='#method.write_line' class='fnname'>write_line</a>(&amp;mut self, s: &amp;str) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Writes a string into this sink, and then writes a literal newline (<code>\n</code>)
byte afterwards. Note that the writing of the newline is <em>not</em> atomic in
the sense that the call to <code>write</code> is invoked twice (once with the
string and once with a newline character).</p>

<p>If other encodings or line ending flavors are desired, it is recommended
that the <code>write</code> method is used specifically instead.</p>
</div><h4 id='method.write_char' class='method'><code>fn <a href='#method.write_char' class='fnname'>write_char</a>(&amp;mut self, c: char) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write a single char, encoded as UTF-8.</p>
</div><h4 id='method.write_int' class='method'><code>fn <a href='#method.write_int' class='fnname'>write_int</a>(&amp;mut self, n: int) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write the result of passing n through <code>int::to_str_bytes</code>.</p>
</div><h4 id='method.write_uint' class='method'><code>fn <a href='#method.write_uint' class='fnname'>write_uint</a>(&amp;mut self, n: uint) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write the result of passing n through <code>uint::to_str_bytes</code>.</p>
</div><h4 id='method.write_le_uint' class='method'><code>fn <a href='#method.write_le_uint' class='fnname'>write_le_uint</a>(&amp;mut self, n: uint) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write a little-endian uint (number of bytes depends on system).</p>
</div><h4 id='method.write_le_int' class='method'><code>fn <a href='#method.write_le_int' class='fnname'>write_le_int</a>(&amp;mut self, n: int) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write a little-endian int (number of bytes depends on system).</p>
</div><h4 id='method.write_be_uint' class='method'><code>fn <a href='#method.write_be_uint' class='fnname'>write_be_uint</a>(&amp;mut self, n: uint) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write a big-endian uint (number of bytes depends on system).</p>
</div><h4 id='method.write_be_int' class='method'><code>fn <a href='#method.write_be_int' class='fnname'>write_be_int</a>(&amp;mut self, n: int) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write a big-endian int (number of bytes depends on system).</p>
</div><h4 id='method.write_be_u64' class='method'><code>fn <a href='#method.write_be_u64' class='fnname'>write_be_u64</a>(&amp;mut self, n: u64) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write a big-endian u64 (8 bytes).</p>
</div><h4 id='method.write_be_u32' class='method'><code>fn <a href='#method.write_be_u32' class='fnname'>write_be_u32</a>(&amp;mut self, n: u32) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write a big-endian u32 (4 bytes).</p>
</div><h4 id='method.write_be_u16' class='method'><code>fn <a href='#method.write_be_u16' class='fnname'>write_be_u16</a>(&amp;mut self, n: u16) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write a big-endian u16 (2 bytes).</p>
</div><h4 id='method.write_be_i64' class='method'><code>fn <a href='#method.write_be_i64' class='fnname'>write_be_i64</a>(&amp;mut self, n: i64) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write a big-endian i64 (8 bytes).</p>
</div><h4 id='method.write_be_i32' class='method'><code>fn <a href='#method.write_be_i32' class='fnname'>write_be_i32</a>(&amp;mut self, n: i32) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write a big-endian i32 (4 bytes).</p>
</div><h4 id='method.write_be_i16' class='method'><code>fn <a href='#method.write_be_i16' class='fnname'>write_be_i16</a>(&amp;mut self, n: i16) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write a big-endian i16 (2 bytes).</p>
</div><h4 id='method.write_be_f64' class='method'><code>fn <a href='#method.write_be_f64' class='fnname'>write_be_f64</a>(&amp;mut self, f: f64) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write a big-endian IEEE754 double-precision floating-point (8 bytes).</p>
</div><h4 id='method.write_be_f32' class='method'><code>fn <a href='#method.write_be_f32' class='fnname'>write_be_f32</a>(&amp;mut self, f: f32) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write a big-endian IEEE754 single-precision floating-point (4 bytes).</p>
</div><h4 id='method.write_le_u64' class='method'><code>fn <a href='#method.write_le_u64' class='fnname'>write_le_u64</a>(&amp;mut self, n: u64) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write a little-endian u64 (8 bytes).</p>
</div><h4 id='method.write_le_u32' class='method'><code>fn <a href='#method.write_le_u32' class='fnname'>write_le_u32</a>(&amp;mut self, n: u32) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write a little-endian u32 (4 bytes).</p>
</div><h4 id='method.write_le_u16' class='method'><code>fn <a href='#method.write_le_u16' class='fnname'>write_le_u16</a>(&amp;mut self, n: u16) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write a little-endian u16 (2 bytes).</p>
</div><h4 id='method.write_le_i64' class='method'><code>fn <a href='#method.write_le_i64' class='fnname'>write_le_i64</a>(&amp;mut self, n: i64) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write a little-endian i64 (8 bytes).</p>
</div><h4 id='method.write_le_i32' class='method'><code>fn <a href='#method.write_le_i32' class='fnname'>write_le_i32</a>(&amp;mut self, n: i32) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write a little-endian i32 (4 bytes).</p>
</div><h4 id='method.write_le_i16' class='method'><code>fn <a href='#method.write_le_i16' class='fnname'>write_le_i16</a>(&amp;mut self, n: i16) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write a little-endian i16 (2 bytes).</p>
</div><h4 id='method.write_le_f64' class='method'><code>fn <a href='#method.write_le_f64' class='fnname'>write_le_f64</a>(&amp;mut self, f: f64) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write a little-endian IEEE754 double-precision floating-point
(8 bytes).</p>
</div><h4 id='method.write_le_f32' class='method'><code>fn <a href='#method.write_le_f32' class='fnname'>write_le_f32</a>(&amp;mut self, f: f32) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write a little-endian IEEE754 single-precision floating-point
(4 bytes).</p>
</div><h4 id='method.write_u8' class='method'><code>fn <a href='#method.write_u8' class='fnname'>write_u8</a>(&amp;mut self, n: u8) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write a u8 (1 byte).</p>
</div><h4 id='method.write_i8' class='method'><code>fn <a href='#method.write_i8' class='fnname'>write_i8</a>(&amp;mut self, n: i8) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write a i8 (1 byte).</p>
</div><h4 id='method.by_ref' class='method'><code>fn <a href='#method.by_ref' class='fnname'>by_ref</a>&lt;'a&gt;(&amp;'a mut self) -&gt; <a class='struct' href='../../../std/io/struct.RefWriter.html' title='std::io::RefWriter'>RefWriter</a>&lt;'a, Self&gt;</code></h4>
<div class='docblock'><p>Creates a wrapper around a mutable reference to the writer.</p>

<p>This is useful to allow applying wrappers while still
retaining ownership of the original value.</p>
</div></div><h3 class='impl'><code>impl <a class='trait' href='../../../std/io/trait.Seek.html' title='std::io::Seek'>Seek</a> for <a class='struct' href='../../../std/io/fs/struct.File.html' title='std::io::fs::File'>File</a></code></h3><div class='methods'><h4 id='method.tell' class='method'><code>fn <a href='#method.tell' class='fnname'>tell</a>(&amp;self) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;u64&gt;</code></h4>
<div class='docblock'><p>Return position of file cursor in the stream</p>
</div><h4 id='method.seek' class='method'><code>fn <a href='#method.seek' class='fnname'>seek</a>(&amp;mut self, pos: i64, style: <a class='enum' href='../../../std/io/enum.SeekStyle.html' title='std::io::SeekStyle'>SeekStyle</a>) -&gt; <a class='typedef' href='../../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Seek to an offset in a stream</p>

<p>A successful seek clears the EOF indicator. Seeking beyond EOF is
allowed, but seeking before position 0 is not allowed.</p>

<h1 id="errors-1" class='section-link'><a
                           href="#errors-1">Errors</a></h1>
<ul>
<li>Seeking to a negative offset is considered an error</li>
<li>Seeking past the end of the stream does not modify the underlying
stream, but the next write may cause the previous data to be filled in
with a bit pattern.</li>
</ul>
</div></div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <div id="help" class="hidden">
        <div class="shortcuts">
            <h1>Keyboard shortcuts</h1>
            <dl>
                <dt>?</dt>
                <dd>Show this help dialog</dd>
                <dt>S</dt>
                <dd>Focus the search field</dd>
                <dt>&uarr;</dt>
                <dd>Move up in search results</dd>
                <dt>&darr;</dt>
                <dd>Move down in search results</dd>
                <dt>&#9166;</dt>
                <dd>Go to active search result</dd>
            </dl>
        </div>
        <div class="infos">
            <h1>Search tricks</h1>
            <p>
                Prefix searches with a type followed by a colon (e.g.
                <code>fn:</code>) to restrict the search to a given type.
            </p>
            <p>
                Accepted types are: <code>fn</code>, <code>mod</code>,
                <code>struct</code> (or <code>str</code>), <code>enum</code>,
                <code>trait</code>, <code>typedef</code> (or
                <code>tdef</code>).
            </p>
        </div>
    </div>

    <script>
        var rootPath = "../../../";
        var currentCrate = "std";
    </script>
    <script src="../../../jquery.js"></script>
    <script src="../../../main.js"></script>
    <script async src="../../../search-index.js"></script>
</body>
</html>
