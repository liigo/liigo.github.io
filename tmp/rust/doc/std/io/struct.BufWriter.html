<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>std::io::BufWriter - Rust</title>

    <link href='http://fonts.googleapis.com/css?family=Oswald:700|Inconsolata:400,700'
          rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="../../main.css">

    <link rel="shortcut icon" href="http://www.rust-lang.org/favicon.ico" />
</head>
<body>
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <section class="sidebar">
        
            <a href='../../std/index.html'><img src='http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png' alt=''/></a>
        

        <p class='location'><a href='../index.html'>std</a>&#8203;::<a href='index.html'>io</a></p><div class='block mod'><h2>Modules</h2><a class='mod ' href='extensions/index.html' title='Utility mixins that apply to all Readers and Writers'>extensions</a><br/><a class='mod ' href='fs/index.html' title='Synchronous File I/O'>fs</a><br/><a class='mod ' href='net/index.html' title='Networking I/O'>net</a><br/><a class='mod ' href='pipe/index.html' title='Synchronous, in-memory pipes.'>pipe</a><br/><a class='mod ' href='process/index.html' title='Bindings for executing child processes'>process</a><br/><a class='mod ' href='signal/index.html' title='Signal handling'>signal</a><br/><a class='mod ' href='stdio/index.html' title='Non-blocking access to stdin, stdout, and stderr.'>stdio</a><br/><a class='mod ' href='test/index.html' title='Various utility functions useful for writing I/O tests'>test</a><br/><a class='mod ' href='timer/index.html' title='Synchronous Timers'>timer</a><br/><a class='mod ' href='util/index.html' title='Utility implementations of Reader and Writer'>util</a><br/></div><div class='block struct'><h2>Structs</h2><a class='struct ' href='struct.BufReader.html' title='Reads from a fixed-size byte slice'>BufReader</a><br/><a class='struct current' href='struct.BufWriter.html' title='Writes to a fixed-size byte slice'>BufWriter</a><br/><a class='struct ' href='struct.BufferedReader.html' title='Wraps a Reader and buffers input from it'>BufferedReader</a><br/><a class='struct ' href='struct.BufferedStream.html' title='Wraps a Stream and buffers input and output to and from it.'>BufferedStream</a><br/><a class='struct ' href='struct.BufferedWriter.html' title='Wraps a Writer and buffers output to it'>BufferedWriter</a><br/><a class='struct ' href='struct.ChanReader.html' title='Allows reading from a rx.'>ChanReader</a><br/><a class='struct ' href='struct.ChanWriter.html' title='Allows writing to a tx.'>ChanWriter</a><br/><a class='struct ' href='struct.Chars.html' title='An iterator that reads a utf8-encoded character on each iteration, until `.read_char()` encounters `EndOfFile`.'>Chars</a><br/><a class='struct ' href='struct.FileStat.html' title='A structure used to describe metadata information about a file. This structure is created through the `stat` method on a `Path`.'>FileStat</a><br/><a class='struct ' href='struct.IncomingConnections.html' title='An infinite iterator over incoming connection attempts. Calling `next` will block the task until a connection is attempted.'>IncomingConnections</a><br/><a class='struct ' href='struct.IoError.html' title='The type passed to I/O condition handlers to indicate error'>IoError</a><br/><a class='struct ' href='struct.LineBufferedWriter.html' title='Wraps a Writer and buffers output to it, flushing whenever a newline (`0x0a`, `'\n'`) is detected.'>LineBufferedWriter</a><br/><a class='struct ' href='struct.Lines.html' title='An iterator that reads a line on each iteration, until `.read_line()` encounters `EndOfFile`.'>Lines</a><br/><a class='struct ' href='struct.MemReader.html' title='Reads from an owned byte vector'>MemReader</a><br/><a class='struct ' href='struct.MemWriter.html' title='Writes to an owned, growable byte vector'>MemWriter</a><br/><a class='struct ' href='struct.RefReader.html' title='A `RefReader` is a struct implementing `Reader` which contains a reference to another reader. This is often useful when composing streams.'>RefReader</a><br/><a class='struct ' href='struct.RefWriter.html' title='A `RefWriter` is a struct implementing `Writer` which contains a reference to another writer. This is often useful when composing streams.'>RefWriter</a><br/><a class='struct ' href='struct.TempDir.html' title='A wrapper for a path to temporary directory implementing automatic scope-based deletion.'>TempDir</a><br/><a class='struct ' href='struct.UnstableFileStat.html' title='This structure represents all of the possible information which can be returned from a `stat` syscall which is not contained in the `FileStat` structure. This information is not necessarily platform independent, and may have different meanings or no meaning at all on some platforms.'>UnstableFileStat</a><br/></div><div class='block enum'><h2>Enums</h2><a class='enum ' href='enum.FileAccess.html' title='Access permissions with which the file should be opened. `File`s opened with `Read` will return an error if written to.'>FileAccess</a><br/><a class='enum ' href='enum.FileMode.html' title='A mode specifies how a file should be opened or created. These modes are passed to `File::open_mode` and are used to control where the file is positioned when it is initially opened.'>FileMode</a><br/><a class='enum ' href='enum.FileType.html' title='Different kinds of files which can be identified by a call to stat'>FileType</a><br/><a class='enum ' href='enum.IoErrorKind.html' title=''>IoErrorKind</a><br/><a class='enum ' href='enum.SeekStyle.html' title='When seeking, the resulting cursor is offset from a base by the offset given to the `seek` function. The base used is specified by this enumeration.'>SeekStyle</a><br/></div><div class='block trait'><h2>Traits</h2><a class='trait ' href='trait.Acceptor.html' title='An acceptor is a value that presents incoming connections'>Acceptor</a><br/><a class='trait ' href='trait.Buffer.html' title='A Buffer is a type of reader which has some form of internal buffering to allow certain kinds of reading operations to be more optimized than others. This type extends the `Reader` trait with a few methods that are not possible to reasonably implement with purely a read interface.'>Buffer</a><br/><a class='trait ' href='trait.Listener.html' title='A listener is a value that can consume itself to start listening for connections.'>Listener</a><br/><a class='trait ' href='trait.Reader.html' title='A trait for objects which are byte-oriented streams. Readers are defined by one method, `read`. This function will block until data is available, filling in the provided buffer with any data read.'>Reader</a><br/><a class='trait ' href='trait.Seek.html' title='An object implementing `Seek` internally has some form of cursor which can be moved within a stream of bytes. The stream typically has a fixed size, allowing seeking relative to either end.'>Seek</a><br/><a class='trait ' href='trait.Stream.html' title='A Stream is a readable and a writable object. Data written is typically received by the object which reads receive data from.'>Stream</a><br/><a class='trait ' href='trait.Writer.html' title='A trait for objects which are byte-oriented streams. Writers are defined by one method, `write`. This function will block until the provided buffer of bytes has been entirely written, and it will return any failurs which occur.'>Writer</a><br/></div><div class='block fn'><h2>Functions</h2><a class='fn ' href='fn.standard_error.html' title='Creates a standard error for a commonly used flavor of error. The `detail` field of the returned error will always be `None`.'>standard_error</a><br/></div>
    </section>

    <nav class="sub">
        <form class="search-form js-only">
            <button class="do-search">Search</button>
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Search documentation..."
                       type="search" />
            </div>
        </form>
    </nav>

    <section id='main' class="content struct"><a class='source'
                              href='../../src/std/MinGW/msys/1.0/home/LIIGO/rust/rust/src/libstd/io/mem.rs.html#221-224'>[src]</a><h1 class='fqn'>Struct <a href='../index.html'>std</a>::<a href='index.html'>io</a>::<a class='struct' href=''>BufWriter</a></h1><pre class='rust struct'>pub struct BufWriter&lt;'a&gt; {
    // some fields omitted
}</pre><div class='docblock'><p>Writes to a fixed-size byte slice</p>

<p>If a write will not fit in the buffer, it returns an error and does not
write any data.</p>

<h1 id="example" class='section-link'><a
                           href="#example">Example</a></h1><pre class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>BufWriter</span>;

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>buf</span> <span class='op'>=</span> [<span class='number'>0</span>, ..<span class='number'>4</span>];
{
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>w</span> <span class='op'>=</span> <span class='ident'>BufWriter</span>::<span class='ident'>new</span>(<span class='ident'>buf</span>);
    <span class='ident'>w</span>.<span class='ident'>write</span>([<span class='number'>0</span>, <span class='number'>1</span>, <span class='number'>2</span>]);
}
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>buf</span> <span class='op'>==</span> [<span class='number'>0</span>, <span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>0</span>]);
</pre>
</div><h2 id='methods'>Methods</h2><h3 class='impl'><code>impl&lt;'a&gt; <a class='struct' href='../../std/io/struct.BufWriter.html' title='std::io::BufWriter'>BufWriter</a>&lt;'a&gt;</code></h3><div class='methods'><h4 id='method.new' class='method'><code>fn <a href='#method.new' class='fnname'>new</a>&lt;'a&gt;(buf: &amp;'a mut [u8]) -&gt; <a class='struct' href='../../std/io/struct.BufWriter.html' title='std::io::BufWriter'>BufWriter</a>&lt;'a&gt;</code></h4>
<div class='docblock'><p>Creates a new <code>BufWriter</code> which will wrap the specified buffer. The
writer initially starts at position 0.</p>
</div></div><h2 id='implementations'>Trait Implementations</h2><h3 class='impl'><code>impl&lt;'a&gt; <a class='trait' href='../../std/io/trait.Writer.html' title='std::io::Writer'>Writer</a> for <a class='struct' href='../../std/io/struct.BufWriter.html' title='std::io::BufWriter'>BufWriter</a>&lt;'a&gt;</code></h3><div class='methods'><h4 id='method.write' class='method'><code>fn <a href='#method.write' class='fnname'>write</a>(&amp;mut self, buf: &amp;[u8]) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write the entirety of a given buffer</p>

<h1 id="errors" class='section-link'><a
                           href="#errors">Errors</a></h1>
<p>If an error happens during the I/O operation, the error is returned as
<code>Err</code>. Note that it is considered an error if the entire buffer could
not be written, and if an error is returned then it is unknown how much
data (if any) was actually written.</p>
</div><h4 id='method.flush' class='method'><code>fn <a href='#method.flush' class='fnname'>flush</a>(&amp;mut self) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Flush this output stream, ensuring that all intermediately buffered
contents reach their destination.</p>

<p>This is by default a no-op and implementers of the <code>Writer</code> trait should
decide whether their stream needs to be buffered or not.</p>
</div><h4 id='method.write_str' class='method'><code>fn <a href='#method.write_str' class='fnname'>write_str</a>(&amp;mut self, s: &amp;str) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write a rust string into this sink.</p>

<p>The bytes written will be the UTF-8 encoded version of the input string.
If other encodings are desired, it is recommended to compose this stream
with another performing the conversion, or to use <code>write</code> with a
converted byte-array instead.</p>
</div><h4 id='method.write_line' class='method'><code>fn <a href='#method.write_line' class='fnname'>write_line</a>(&amp;mut self, s: &amp;str) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Writes a string into this sink, and then writes a literal newline (<code>\n</code>)
byte afterwards. Note that the writing of the newline is <em>not</em> atomic in
the sense that the call to <code>write</code> is invoked twice (once with the
string and once with a newline character).</p>

<p>If other encodings or line ending flavors are desired, it is recommended
that the <code>write</code> method is used specifically instead.</p>
</div><h4 id='method.write_char' class='method'><code>fn <a href='#method.write_char' class='fnname'>write_char</a>(&amp;mut self, c: char) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write a single char, encoded as UTF-8.</p>
</div><h4 id='method.write_int' class='method'><code>fn <a href='#method.write_int' class='fnname'>write_int</a>(&amp;mut self, n: int) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write the result of passing n through <code>int::to_str_bytes</code>.</p>
</div><h4 id='method.write_uint' class='method'><code>fn <a href='#method.write_uint' class='fnname'>write_uint</a>(&amp;mut self, n: uint) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write the result of passing n through <code>uint::to_str_bytes</code>.</p>
</div><h4 id='method.write_le_uint' class='method'><code>fn <a href='#method.write_le_uint' class='fnname'>write_le_uint</a>(&amp;mut self, n: uint) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write a little-endian uint (number of bytes depends on system).</p>
</div><h4 id='method.write_le_int' class='method'><code>fn <a href='#method.write_le_int' class='fnname'>write_le_int</a>(&amp;mut self, n: int) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write a little-endian int (number of bytes depends on system).</p>
</div><h4 id='method.write_be_uint' class='method'><code>fn <a href='#method.write_be_uint' class='fnname'>write_be_uint</a>(&amp;mut self, n: uint) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write a big-endian uint (number of bytes depends on system).</p>
</div><h4 id='method.write_be_int' class='method'><code>fn <a href='#method.write_be_int' class='fnname'>write_be_int</a>(&amp;mut self, n: int) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write a big-endian int (number of bytes depends on system).</p>
</div><h4 id='method.write_be_u64' class='method'><code>fn <a href='#method.write_be_u64' class='fnname'>write_be_u64</a>(&amp;mut self, n: u64) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write a big-endian u64 (8 bytes).</p>
</div><h4 id='method.write_be_u32' class='method'><code>fn <a href='#method.write_be_u32' class='fnname'>write_be_u32</a>(&amp;mut self, n: u32) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write a big-endian u32 (4 bytes).</p>
</div><h4 id='method.write_be_u16' class='method'><code>fn <a href='#method.write_be_u16' class='fnname'>write_be_u16</a>(&amp;mut self, n: u16) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write a big-endian u16 (2 bytes).</p>
</div><h4 id='method.write_be_i64' class='method'><code>fn <a href='#method.write_be_i64' class='fnname'>write_be_i64</a>(&amp;mut self, n: i64) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write a big-endian i64 (8 bytes).</p>
</div><h4 id='method.write_be_i32' class='method'><code>fn <a href='#method.write_be_i32' class='fnname'>write_be_i32</a>(&amp;mut self, n: i32) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write a big-endian i32 (4 bytes).</p>
</div><h4 id='method.write_be_i16' class='method'><code>fn <a href='#method.write_be_i16' class='fnname'>write_be_i16</a>(&amp;mut self, n: i16) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write a big-endian i16 (2 bytes).</p>
</div><h4 id='method.write_be_f64' class='method'><code>fn <a href='#method.write_be_f64' class='fnname'>write_be_f64</a>(&amp;mut self, f: f64) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write a big-endian IEEE754 double-precision floating-point (8 bytes).</p>
</div><h4 id='method.write_be_f32' class='method'><code>fn <a href='#method.write_be_f32' class='fnname'>write_be_f32</a>(&amp;mut self, f: f32) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write a big-endian IEEE754 single-precision floating-point (4 bytes).</p>
</div><h4 id='method.write_le_u64' class='method'><code>fn <a href='#method.write_le_u64' class='fnname'>write_le_u64</a>(&amp;mut self, n: u64) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write a little-endian u64 (8 bytes).</p>
</div><h4 id='method.write_le_u32' class='method'><code>fn <a href='#method.write_le_u32' class='fnname'>write_le_u32</a>(&amp;mut self, n: u32) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write a little-endian u32 (4 bytes).</p>
</div><h4 id='method.write_le_u16' class='method'><code>fn <a href='#method.write_le_u16' class='fnname'>write_le_u16</a>(&amp;mut self, n: u16) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write a little-endian u16 (2 bytes).</p>
</div><h4 id='method.write_le_i64' class='method'><code>fn <a href='#method.write_le_i64' class='fnname'>write_le_i64</a>(&amp;mut self, n: i64) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write a little-endian i64 (8 bytes).</p>
</div><h4 id='method.write_le_i32' class='method'><code>fn <a href='#method.write_le_i32' class='fnname'>write_le_i32</a>(&amp;mut self, n: i32) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write a little-endian i32 (4 bytes).</p>
</div><h4 id='method.write_le_i16' class='method'><code>fn <a href='#method.write_le_i16' class='fnname'>write_le_i16</a>(&amp;mut self, n: i16) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write a little-endian i16 (2 bytes).</p>
</div><h4 id='method.write_le_f64' class='method'><code>fn <a href='#method.write_le_f64' class='fnname'>write_le_f64</a>(&amp;mut self, f: f64) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write a little-endian IEEE754 double-precision floating-point
(8 bytes).</p>
</div><h4 id='method.write_le_f32' class='method'><code>fn <a href='#method.write_le_f32' class='fnname'>write_le_f32</a>(&amp;mut self, f: f32) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write a little-endian IEEE754 single-precision floating-point
(4 bytes).</p>
</div><h4 id='method.write_u8' class='method'><code>fn <a href='#method.write_u8' class='fnname'>write_u8</a>(&amp;mut self, n: u8) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write a u8 (1 byte).</p>
</div><h4 id='method.write_i8' class='method'><code>fn <a href='#method.write_i8' class='fnname'>write_i8</a>(&amp;mut self, n: i8) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Write a i8 (1 byte).</p>
</div><h4 id='method.by_ref' class='method'><code>fn <a href='#method.by_ref' class='fnname'>by_ref</a>&lt;'a&gt;(&amp;'a mut self) -&gt; <a class='struct' href='../../std/io/struct.RefWriter.html' title='std::io::RefWriter'>RefWriter</a>&lt;'a, Self&gt;</code></h4>
<div class='docblock'><p>Creates a wrapper around a mutable reference to the writer.</p>

<p>This is useful to allow applying wrappers while still
retaining ownership of the original value.</p>
</div></div><h3 class='impl'><code>impl&lt;'a&gt; <a class='trait' href='../../std/io/trait.Seek.html' title='std::io::Seek'>Seek</a> for <a class='struct' href='../../std/io/struct.BufWriter.html' title='std::io::BufWriter'>BufWriter</a>&lt;'a&gt;</code></h3><div class='methods'><h4 id='method.tell' class='method'><code>fn <a href='#method.tell' class='fnname'>tell</a>(&amp;self) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;u64&gt;</code></h4>
<div class='docblock'><p>Return position of file cursor in the stream</p>
</div><h4 id='method.seek' class='method'><code>fn <a href='#method.seek' class='fnname'>seek</a>(&amp;mut self, pos: i64, style: <a class='enum' href='../../std/io/enum.SeekStyle.html' title='std::io::SeekStyle'>SeekStyle</a>) -&gt; <a class='typedef' href='../../std/io/typedef.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Seek to an offset in a stream</p>

<p>A successful seek clears the EOF indicator. Seeking beyond EOF is
allowed, but seeking before position 0 is not allowed.</p>

<h1 id="errors-1" class='section-link'><a
                           href="#errors-1">Errors</a></h1>
<ul>
<li>Seeking to a negative offset is considered an error</li>
<li>Seeking past the end of the stream does not modify the underlying
stream, but the next write may cause the previous data to be filled in
with a bit pattern.</li>
</ul>
</div></div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <div id="help" class="hidden">
        <div class="shortcuts">
            <h1>Keyboard shortcuts</h1>
            <dl>
                <dt>?</dt>
                <dd>Show this help dialog</dd>
                <dt>S</dt>
                <dd>Focus the search field</dd>
                <dt>&uarr;</dt>
                <dd>Move up in search results</dd>
                <dt>&darr;</dt>
                <dd>Move down in search results</dd>
                <dt>&#9166;</dt>
                <dd>Go to active search result</dd>
            </dl>
        </div>
        <div class="infos">
            <h1>Search tricks</h1>
            <p>
                Prefix searches with a type followed by a colon (e.g.
                <code>fn:</code>) to restrict the search to a given type.
            </p>
            <p>
                Accepted types are: <code>fn</code>, <code>mod</code>,
                <code>struct</code> (or <code>str</code>), <code>enum</code>,
                <code>trait</code>, <code>typedef</code> (or
                <code>tdef</code>).
            </p>
        </div>
    </div>

    <script>
        var rootPath = "../../";
        var currentCrate = "std";
    </script>
    <script src="../../jquery.js"></script>
    <script src="../../main.js"></script>
    <script async src="../../search-index.js"></script>
</body>
</html>
