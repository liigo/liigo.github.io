var searchIndex = {};
searchIndex['rustc'] = {"items":[[0,"","rustc","The Rust compiler."],[3,"main","",""],[0,"back","",""],[0,"link","rustc::back",""],[2,"OutputType","rustc::back::link",""],[12,"OutputTypeBitcode","","",0],[12,"OutputTypeAssembly","","",0],[12,"OutputTypeLlvmAssembly","","",0],[12,"OutputTypeObject","","",0],[12,"OutputTypeExe","","",0],[3,"llvm_err","",""],[3,"write_output_file","",""],[3,"find_crate_name","",""],[3,"build_link_meta","",""],[3,"sanitize","",""],[3,"mangle","",""],[3,"exported_name","",""],[3,"mangle_exported_name","",""],[3,"mangle_internal_name_by_type_and_seq","",""],[3,"mangle_internal_name_by_path_and_seq","",""],[3,"get_cc_prog","",""],[3,"get_ar_prog","",""],[3,"link_binary","","Perform the linkage portion of the compilation phase. This will generate all\nof the requested outputs for this compilation session."],[3,"default_output_for_target","","Returns default crate type for target"],[3,"invalid_output_for_target","","Checks if target supports crate_type as output"],[3,"filename_for_input","",""],[0,"write","",""],[3,"run_passes","rustc::back::link::write",""],[3,"run_assembler","",""],[10,"cmp","rustc::back::link","",0],[10,"partial_cmp","","",0],[10,"lt","","",0],[10,"le","","",0],[10,"gt","","",0],[10,"ge","","",0],[10,"eq","","",0],[10,"ne","","",0],[10,"clone","","",0],[0,"lto","rustc::back",""],[3,"run","rustc::back::lto",""],[0,"abi","rustc::back",""],[5,"box_field_refcnt","rustc::back::abi",""],[5,"box_field_tydesc","",""],[5,"box_field_body","",""],[5,"tydesc_field_visit_glue","",""],[5,"fn_field_code","",""],[5,"fn_field_box","",""],[5,"trt_field_vtable","",""],[5,"trt_field_box","",""],[5,"vec_elt_fill","",""],[5,"vec_elt_alloc","",""],[5,"vec_elt_elems","",""],[5,"slice_elt_base","",""],[5,"slice_elt_len","",""],[0,"archive","rustc::back","A helper class for dealing with static archives"],[5,"METADATA_FILENAME","rustc::back::archive",""],[10,"open","rustc_back::archive","Opens an existing static archive",1],[10,"remove_file","","Removes a file from this archive",1],[10,"files","","Lists all files in an archive",1],[10,"extend","","Creates an `ArchiveBuilder` for adding files to this archive.",1],[10,"create","","Create a new static archive, ready for adding files.",2],[10,"add_native_library","","Adds all of the contents of a native library to this archive. This will\nsearch in the relevant locations for a library named `name`.",2],[10,"add_rlib","","Adds all of the contents of the rlib at the specified path to this\narchive.",2],[10,"add_file","","Adds an arbitrary file to this archive",2],[10,"update_symbols","","Indicate that the next call to `build` should updates all symbols in\nthe archive (run 'ar s' over it).",2],[10,"build","","Combine the provided files, rlibs, and native libraries into a single\n`Archive`.",2],[10,"input","rustc_back::sha2","",3],[10,"reset","","",3],[10,"zero_until","","",3],[10,"next","","",3],[10,"full_buffer","","",3],[10,"position","","",3],[10,"remaining","","",3],[10,"size","","",3],[10,"new","","Construct a new instance of a SHA-256 digest.",4],[10,"input","","",4],[10,"result","","",4],[10,"reset","","",4],[10,"output_bits","","",4],[10,"input_str","","",4],[10,"result_bytes","","",4],[10,"result_str","","",4],[10,"eq","rustc_back::svh","",5],[10,"ne","","",5],[10,"ne","","",5],[10,"clone","","",5],[10,"clone_from","","",5],[10,"new","","",5],[10,"as_str","","",5],[10,"calculate","","",5],[10,"fmt","","",5],[10,"hash","rustc_back::svh::svh_visitor","",6],[10,"hash","","",7],[10,"hash","","",8],[10,"get_content","syntax::ast","",9],[10,"get_content","","",10],[10,"visit_mac","rustc_back::svh::svh_visitor","",11],[10,"visit_struct_def","","",11],[10,"visit_variant","","",11],[10,"visit_opt_lifetime_ref","","",11],[10,"visit_ident","","",11],[10,"visit_lifetime_ref","","",11],[10,"visit_lifetime_decl","","",11],[10,"visit_expr","","",11],[10,"visit_stmt","","",11],[10,"visit_view_item","","",11],[10,"visit_foreign_item","","",11],[10,"visit_item","","",11],[10,"visit_mod","","",11],[10,"visit_decl","","",11],[10,"visit_ty","","",11],[10,"visit_generics","","",11],[10,"visit_fn","","",11],[10,"visit_ty_method","","",11],[10,"visit_trait_method","","",11],[10,"visit_struct_field","","",11],[10,"visit_explicit_self","","",11],[10,"visit_path","","",11],[10,"visit_block","","",11],[10,"visit_pat","","",11],[10,"visit_local","","",11],[10,"visit_arm","","",11],[10,"visit_ident","","",11],[10,"visit_mod","","",11],[10,"visit_view_item","","",11],[10,"visit_foreign_item","","",11],[10,"visit_item","","",11],[10,"visit_local","","",11],[10,"visit_block","","",11],[10,"visit_stmt","","",11],[10,"visit_arm","","",11],[10,"visit_pat","","",11],[10,"visit_decl","","",11],[10,"visit_expr","","",11],[10,"visit_expr_post","","",11],[10,"visit_ty","","",11],[10,"visit_generics","","",11],[10,"visit_fn","","",11],[10,"visit_ty_method","","",11],[10,"visit_trait_method","","",11],[10,"visit_struct_def","","",11],[10,"visit_struct_field","","",11],[10,"visit_variant","","",11],[10,"visit_opt_lifetime_ref","","",11],[10,"visit_lifetime_ref","","",11],[10,"visit_lifetime_decl","","",11],[10,"visit_explicit_self","","",11],[10,"visit_mac","","",11],[10,"visit_path","","",11],[10,"visit_attribute","","",11],[1,"ArchiveConfig","rustc::back::archive",""],[11,"handler","","",12],[11,"dst","","",12],[11,"lib_search_paths","","",12],[11,"os","","",12],[11,"maybe_ar_prog","","",12],[1,"Archive","",""],[1,"ArchiveBuilder","","Helper for adding many files to an archive with a single invocation of\n`ar`."],[0,"arm","rustc::back",""],[3,"get_target_strs","rustc::back::arm",""],[0,"mips","rustc::back",""],[3,"get_target_strs","rustc::back::mips",""],[0,"mipsel","rustc::back",""],[3,"get_target_strs","rustc::back::mipsel",""],[0,"rpath","rustc::back",""],[1,"RPathConfig","rustc::back::rpath",""],[11,"os","","",13],[11,"used_crates","","",13],[11,"out_filename","","",13],[11,"get_install_prefix_lib_path","","",13],[11,"realpath","","",13],[3,"get_rpath_flags","",""],[0,"svh","rustc::back","Calculation and management of a Strict Version Hash for crates"],[1,"Svh","rustc::back::svh",""],[0,"target_strs","rustc::back",""],[1,"t","rustc::back::target_strs",""],[11,"module_asm","","",14],[11,"data_layout","","",14],[11,"target_triple","","",14],[11,"cc_args","","",14],[0,"x86","rustc::back",""],[3,"get_target_strs","rustc::back::x86",""],[0,"x86_64","rustc::back",""],[3,"get_target_strs","rustc::back::x86_64",""],[0,"middle","rustc",""],[0,"astencode","rustc::middle",""],[3,"encode_inlined_item","rustc::middle::astencode",""],[3,"decode_inlined_item","",""],[3,"encode_vtable_res","",""],[3,"encode_vtable_param_res","",""],[3,"encode_vtable_origin","",""],[4,"Encoder","",""],[6,"tr","",""],[9,"tr","","",15],[6,"tr_intern","",""],[9,"tr_intern","","",16],[6,"def_id_encoder_helpers","",""],[9,"emit_def_id","","",17],[6,"def_id_decoder_helpers","",""],[9,"read_def_id","","",18],[9,"read_def_id_noxcx","","",18],[6,"rbml_decoder_helper","",""],[9,"read_freevar_entry","","",19],[6,"read_method_callee_helper","",""],[9,"read_method_callee","","",20],[6,"vtable_decoder_helpers","",""],[9,"read_vec_per_param_space","","",21],[9,"read_vtable_res_with_key","","",21],[9,"read_vtable_res","","",21],[9,"read_vtable_param_res","","",21],[9,"read_vtable_origin","","",21],[6,"get_ty_str_ctxt","",""],[9,"ty_str_ctxt","","",22],[6,"rbml_writer_helpers","",""],[9,"emit_closure_type","","",23],[9,"emit_ty","","",23],[9,"emit_tys","","",23],[9,"emit_type_param_def","","",23],[9,"emit_polytype","","",23],[9,"emit_substs","","",23],[9,"emit_auto_adjustment","","",23],[6,"write_tag_and_id","",""],[9,"tag","","",24],[9,"id","","",24],[6,"doc_decoder_helpers","",""],[9,"as_int","","",25],[9,"opt_child","","",25],[6,"rbml_decoder_decoder_helpers","",""],[9,"read_ty","","",26],[9,"read_tys","","",26],[9,"read_type_param_def","","",26],[9,"read_polytype","","",26],[9,"read_substs","","",26],[9,"read_auto_adjustment","","",26],[9,"read_unboxed_closure_type","","",26],[9,"convert_def_id","","",26],[9,"read_ty_noxcx","","",26],[9,"read_tys_noxcx","","",26],[9,"read_substs_noxcx","","",26],[10,"tr_intern","syntax::ast","",27],[10,"tr","","",27],[10,"tr","core::option","",28],[10,"tr","syntax::codemap","",29],[10,"read_freevar_entry","rbml::reader","",30],[10,"read_method_callee","","",30],[10,"read_vec_per_param_space","","",30],[10,"read_vtable_res_with_key","","",30],[10,"read_vtable_res","","",30],[10,"read_vtable_param_res","","",30],[10,"read_vtable_origin","","",30],[10,"emit_closure_type","rustc::middle::astencode","",31],[10,"emit_ty","","",31],[10,"emit_tys","","",31],[10,"emit_type_param_def","","",31],[10,"emit_polytype","","",31],[10,"emit_substs","","",31],[10,"emit_auto_adjustment","","",31],[10,"tag","","",31],[10,"id","","",31],[10,"as_int","rbml","",32],[10,"opt_child","","",32],[10,"read_ty_noxcx","rbml::reader","",30],[10,"read_tys_noxcx","","",30],[10,"read_substs_noxcx","","",30],[10,"read_ty","","",30],[10,"read_tys","","",30],[10,"read_type_param_def","","",30],[10,"read_polytype","","",30],[10,"read_substs","","",30],[10,"read_auto_adjustment","","",30],[10,"read_unboxed_closure_type","","",30],[10,"convert_def_id","","Converts a def-id that appears in a type.  The correct\ntranslation will depend on what kind of def-id this is.\nThis is a subtle point: type definitions are not\ninlined into the current crate, so if the def-id names\na nominal type or type alias, then it should be\ntranslated to refer to the source crate.",30],[0,"borrowck","rustc::middle","See doc.rs for a thorough explanation of the borrow checker"],[1,"LoanDataFlowOperator","rustc::middle::borrowck",""],[1,"AnalysisData","","Collection of conclusions determined via borrow checker analyses."],[11,"all_loans","","",33],[11,"loans","","",33],[11,"move_data","","",33],[1,"FnPartsWithCFG","","This and a `ty::ctxt` is all you need to run the dataflow analyses\nused in the borrow checker."],[11,"fn_parts","","",34],[11,"cfg","","",34],[1,"BorrowckCtxt","",""],[1,"BorrowStats","",""],[1,"Loan","","Record of a loan that was issued."],[1,"BckError","",""],[2,"PartialTotal","",""],[12,"Partial","","",35],[12,"Total","","",35],[2,"LoanPath","",""],[12,"LpVar","","",36],[12,"LpUpvar","","",36],[12,"LpExtend","","",36],[2,"LoanPathElem","",""],[12,"LpDeref","","",37],[12,"LpInterior","","",37],[2,"bckerr_code","",""],[12,"err_mutbl","","",38],[12,"err_out_of_scope","","",38],[12,"err_borrowed_pointer_too_short","","",38],[2,"AliasableViolationKind","",""],[12,"MutabilityViolation","","",39],[12,"BorrowViolation","","",39],[2,"MovedValueUseKind","",""],[12,"MovedInUse","","",40],[12,"MovedInCapture","","",40],[3,"check_crate","",""],[3,"build_borrowck_dataflow_data_for_fn","","Accessor for introspective clients inspecting `AnalysisData` and\nthe `BorrowckCtxt` itself , e.g. the flowgraph visualizer."],[3,"closure_to_block","",""],[3,"opt_loan_path","","Computes the `LoanPath` (if any) for a `cmt`.\nNote that this logic is somewhat duplicated in\nthe method `compute()` found in `gather_loans::restrictions`,\nwhich allows it to share common loan path pieces as it\ntraverses the CMT."],[0,"doc","","# The Borrow Checker"],[0,"check_loans","",""],[3,"check_loans","rustc::middle::borrowck::check_loans",""],[0,"gather_loans","rustc::middle::borrowck",""],[3,"gather_loans_in_fn","rustc::middle::borrowck::gather_loans",""],[3,"gather_loans_in_static_initializer","",""],[0,"graphviz","rustc::middle::borrowck","This module provides linkage between rustc::middle::graph and\nlibgraphviz traits, specialized to attaching borrowck analysis\ndata to rendered labels."],[1,"DataflowLabeller","rustc::middle::borrowck::graphviz",""],[11,"inner","","",41],[11,"variants","","",41],[11,"borrowck_ctxt","","",41],[11,"analysis_data","","",41],[2,"Variant","",""],[12,"Loans","","",42],[12,"Moves","","",42],[12,"Assigns","","",42],[10,"fmt","","",42],[10,"short_name","","",42],[10,"graph_id","","",41],[10,"node_id","","",41],[10,"node_label","","",41],[10,"edge_label","","",41],[10,"nodes","","",41],[10,"edges","","",41],[10,"source","","",41],[10,"target","","",41],[0,"move_data","rustc::middle::borrowck","Data structures used for tracking moves. Please see the extensive\ncomments in the section \"Moves and initialization\" and in `doc.rs`."],[1,"MoveData","rustc::middle::borrowck::move_data",""],[11,"paths","","Move paths. See section \"Move paths\" in `doc.rs`.",43],[11,"path_map","","Cache of loan path to move path index, for easy lookup.",43],[11,"moves","","Each move or uninitialized variable gets an entry here.",43],[11,"var_assignments","","Assignments to a variable, like `x = foo`. These are assigned\nbits for dataflow, since we must track them to ensure that\nimmutable variables are assigned at most once along each path.",43],[11,"path_assignments","","Assignments to a path, like `x.f = foo`. These are not\nassigned dataflow bits, but we track them because they still\nkill move bits.",43],[11,"assignee_ids","","Assignments to a variable or path, like `x = foo`, but not `x += foo`.",43],[1,"FlowedMoveData","",""],[11,"move_data","","",44],[11,"dfcx_moves","","",44],[11,"dfcx_assign","","",44],[1,"MovePathIndex","","Index into `MoveData.paths`, used like a pointer"],[1,"MoveIndex","","Index into `MoveData.moves`, used like a pointer"],[1,"MovePath","",""],[11,"loan_path","","Loan path corresponding to this move path",45],[11,"parent","","Parent pointer, `InvalidMovePathIndex` if root",45],[11,"first_move","","Head of linked list of moves to this path,\n`InvalidMoveIndex` if not moved",45],[11,"first_child","","First node in linked list of children, `InvalidMovePathIndex` if leaf",45],[11,"next_sibling","","Next node in linked list of parent's children (siblings),\n`InvalidMovePathIndex` if none.",45],[1,"Move","",""],[11,"path","","Path being moved.",46],[11,"id","","id of node that is doing the move.",46],[11,"kind","","Kind of move, for error messages.",46],[11,"next_move","","Next node in linked list of moves from `path`, or `InvalidMoveIndex`",46],[1,"Assignment","",""],[11,"path","","Path being assigned.",47],[11,"id","","id where assignment occurs",47],[11,"span","","span of node where assignment occurs",47],[1,"MoveDataFlowOperator","",""],[1,"AssignDataFlowOperator","",""],[2,"MoveKind","",""],[12,"Declared","","",48],[12,"MoveExpr","","",48],[12,"MovePat","","",48],[12,"Captured","","",48],[4,"MoveDataFlow","",""],[4,"AssignDataFlow","",""],[10,"eq","","",49],[10,"ne","","",49],[10,"clone","","",49],[10,"eq","","",50],[10,"ne","","",50],[10,"eq","","",48],[10,"ne","","",48],[10,"clone","","",51],[10,"clone","","",52],[10,"new","","",43],[10,"path_loan_path","","",43],[10,"move_path","","Returns the existing move path index for `lp`, if any,\nand otherwise adds a new index for `lp` and any of its\nbase paths that do not yet have an index.",43],[10,"add_move","","Adds a new move entry for a move of `lp` that occurs at\nlocation `id` with kind `kind`.",43],[10,"add_assignment","","Adds a new record for an assignment to `lp` that occurs at\nlocation `id` with the given `span`.",43],[10,"new","","",44],[10,"each_path_moved_by","","Iterates through each path moved by `id`",44],[10,"kind_of_move_of_path","","Returns the kind of a move of `loan_path` by `id`, if one exists.",44],[10,"each_move_of","","Iterates through each move of `loan_path` (or some base path\nof `loan_path`) that *may* have occurred on entry to `id` without\nan intervening assignment. In other words, any moves that\nwould invalidate a reference to `loan_path` at location `id`.",44],[10,"is_assignee","","True if `id` is the id of the LHS of an assignment",44],[10,"each_assignment_of","","Iterates through every assignment to `loan_path` that\nmay have occurred on entry to `id`. `loan_path` must be\na single variable.",44],[10,"join","","",51],[10,"initial_value","","",51],[10,"join","","",52],[10,"initial_value","","",52],[4,"LoanDataFlow","rustc::middle::borrowck",""],[4,"BckResult","",""],[10,"clone","","",53],[10,"visit_fn","","",54],[10,"visit_item","","",54],[10,"from_fn_like","","",34],[10,"eq","","",35],[10,"ne","","",35],[10,"loan_path","","",55],[10,"hash","","",36],[10,"eq","","",36],[10,"ne","","",36],[10,"hash","","",37],[10,"eq","","",37],[10,"ne","","",37],[10,"kill_scope","","",36],[10,"eq","","",38],[10,"ne","","",38],[10,"eq","","",56],[10,"ne","","",56],[10,"is_subregion_of","","",54],[10,"is_subscope_of","","",54],[10,"mc","","",54],[10,"cat_expr","","",54],[10,"cat_expr_unadjusted","","",54],[10,"cat_expr_autoderefd","","",54],[10,"cat_def","","",54],[10,"cat_captured_var","","",54],[10,"cat_discr","","",54],[10,"cat_pattern","","",54],[10,"report","","",54],[10,"report_use_of_moved_value","","",54],[10,"report_reassigned_immutable_variable","","",54],[10,"span_err","","",54],[10,"span_note","","",54],[10,"span_end_note","","",54],[10,"bckerr_to_string","","",54],[10,"report_aliasability_violation","","",54],[10,"note_and_explain_bckerr","","",54],[10,"append_loan_path_to_string","","",54],[10,"append_autoderefd_loan_path_to_string","","",54],[10,"loan_path_to_string","","",54],[10,"cmt_to_string","","",54],[10,"join","","",53],[10,"initial_value","","",53],[10,"repr","","",55],[10,"repr","","",36],[0,"cfg","rustc::middle","Module that constructs a control-flow graph representing an item.\nUses `Graph` as the underlying representation."],[1,"CFG","rustc::middle::cfg",""],[11,"exit_map","","",57],[11,"graph","","",57],[11,"entry","","",57],[11,"exit","","",57],[1,"CFGNodeData","",""],[11,"id","","",58],[1,"CFGEdgeData","",""],[11,"exiting_scopes","","",59],[0,"graphviz","",""],[1,"LabelledCFG","rustc::middle::cfg::graphviz",""],[11,"ast_map","","",60],[11,"cfg","","",60],[11,"name","","",60],[4,"Node","",""],[4,"Edge","",""],[10,"graph_id","","",60],[10,"node_id","","",60],[10,"node_label","","",60],[10,"edge_label","","",60],[10,"nodes","","",60],[10,"edges","","",60],[10,"source","","",60],[10,"target","","",60],[4,"CFGIndex","rustc::middle::cfg",""],[4,"CFGGraph","",""],[4,"CFGNode","",""],[4,"CFGEdge","",""],[10,"new","","",57],[0,"check_const","rustc::middle",""],[1,"CheckCrateVisitor","rustc::middle::check_const",""],[3,"check_crate","",""],[3,"check_item_recursion","",""],[10,"visit_item","","",61],[10,"visit_pat","","",61],[10,"visit_expr","","",61],[0,"check_loop","rustc::middle",""],[3,"check_crate","rustc::middle::check_loop",""],[0,"check_match","rustc::middle",""],[1,"MatchCheckCtxt","rustc::middle::check_match",""],[11,"tcx","","",62],[1,"StaticInliner","",""],[11,"tcx","","",63],[2,"Constructor","",""],[12,"Single","","The constructor of all patterns that don't vary by constructor,\ne.g. struct patterns and fixed-length arrays.",64],[12,"Variant","","Enum variants.",64],[12,"ConstantValue","","Literal values.",64],[12,"ConstantRange","","Ranges of literal values (2..5).",64],[12,"Slice","","Array patterns of length n.",64],[3,"check_crate","",""],[3,"constructor_arity","","This computes the arity of a constructor. The arity of a constructor\nis how many subpattern patterns of that constructor should be expanded to."],[3,"specialize","","This is the main specialization step. It expands the first pattern in the given row\ninto `arity` patterns based on the constructor. For most patterns, the step is trivial,\nfor instance tuple patterns are flattened and box patterns expand into their inner pattern."],[10,"eq","","",64],[10,"ne","","",64],[10,"clone","","",64],[10,"visit_expr","","",62],[10,"visit_local","","",62],[10,"visit_fn","","",62],[10,"fold_pat","","",63],[0,"check_static","rustc::middle",""],[3,"check_crate","rustc::middle::check_static",""],[0,"const_eval","rustc::middle",""],[2,"constness","rustc::middle::const_eval",""],[12,"integral_const","","",65],[12,"general_const","","",65],[12,"non_const","","",65],[2,"const_val","",""],[12,"const_float","","",66],[12,"const_int","","",66],[12,"const_uint","","",66],[12,"const_str","","",66],[12,"const_binary","","",66],[12,"const_bool","","",66],[12,"const_nil","","",66],[3,"join","",""],[3,"join_all","",""],[3,"lookup_const","",""],[3,"lookup_variant_by_id","",""],[3,"lookup_const_by_id","",""],[3,"process_crate","",""],[3,"const_expr_to_pat","",""],[3,"eval_const_expr","",""],[3,"eval_const_expr_partial","",""],[3,"lit_to_const","",""],[3,"compare_const_vals","",""],[3,"compare_lit_exprs","",""],[10,"eq","","",66],[10,"ne","","",66],[10,"clone","","",66],[0,"dataflow","rustc::middle","A module for propagating forward dataflow information. The analysis\nassumes that the items to be propagated can be represented as bits\nand thus uses bitvectors. Your job is simply to specify the so-called\nGEN and KILL bits for each expression."],[1,"DataFlowContext","rustc::middle::dataflow",""],[2,"EntryOrExit","",""],[12,"Entry","","",67],[12,"Exit","","",67],[6,"BitwiseOperator","",""],[9,"join","","Joins two predecessor bits together, typically either `|` or `&`",68],[6,"DataFlowOperator","","Parameterization for the precise form of data flow that is used."],[9,"initial_value","","Specifies the initial value for each bit in the `on_entry` set",69],[10,"fmt","","",67],[10,"clone","","",70],[10,"pre","","",70],[10,"new","","",70],[10,"add_gen","","Indicates that `id` generates `bit`",70],[10,"add_kill","","Indicates that `id` kills `bit`",70],[10,"each_bit_on_entry","","Iterates through each bit that is set on entry to `id`.\nOnly useful after `propagate()` has been called.",70],[10,"each_bit_for_node","","Iterates through each bit that is set on entry/exit to `cfgidx`.\nOnly useful after `propagate()` has been called.",70],[10,"each_gen_bit","","Iterates through each bit in the gen set for `id`.",70],[10,"add_kills_from_flow_exits","","Whenever you have a `break` or `continue` statement, flow\nexits through any number of enclosing scopes on its way to\nthe new destination. This function infers the kill bits of\nthose control operators based on the kill bits associated\nwith those scopes.",70],[10,"propagate","","Performs the data flow analysis.",70],[0,"dead","rustc::middle",""],[3,"check_crate","rustc::middle::dead",""],[0,"def","rustc::middle",""],[2,"Def","rustc::middle::def",""],[12,"DefFn","","",71],[12,"DefStaticMethod","","",71],[12,"DefSelfTy","","",71],[12,"DefMod","","",71],[12,"DefForeignMod","","",71],[12,"DefStatic","","",71],[12,"DefArg","","",71],[12,"DefLocal","","",71],[12,"DefVariant","","",71],[12,"DefTy","","",71],[12,"DefTrait","","",71],[12,"DefPrimTy","","",71],[12,"DefTyParam","","",71],[12,"DefBinding","","",71],[12,"DefUse","","",71],[12,"DefUpvar","","",71],[12,"DefStruct","","Note that if it's a tuple struct's definition, the node id of the ast::DefId\nmay either refer to the item definition's id or the StructDef.ctor_id.",71],[12,"DefTyParamBinder","","",71],[12,"DefRegion","","",71],[12,"DefLabel","","",71],[12,"DefMethod","","",71],[2,"MethodProvenance","",""],[12,"FromTrait","","",72],[12,"FromImpl","","",72],[10,"fmt","","",71],[10,"hash","","",71],[10,"decode","","",71],[10,"encode","","",71],[10,"eq","","",71],[10,"ne","","",71],[10,"clone","","",71],[10,"fmt","","",72],[10,"hash","","",72],[10,"decode","","",72],[10,"encode","","",72],[10,"eq","","",72],[10,"ne","","",72],[10,"clone","","",72],[10,"def_id","","",71],[10,"variant_def_ids","","",71],[0,"dependency_format","rustc::middle","Resolution of mixing rlibs and dylibs"],[3,"calculate","rustc::middle::dependency_format",""],[4,"DependencyList","","A list of dependencies for a certain crate type."],[4,"Dependencies","","A mapping of all required dependencies for a particular flavor of output."],[0,"effect","rustc::middle","Enforces the Rust effect system. Currently there is just one effect,"],[3,"check_crate","rustc::middle::effect",""],[0,"entry","rustc::middle",""],[3,"find_entry_point","rustc::middle::entry",""],[0,"expr_use_visitor","rustc::middle","A different sort of visitor for walking fn bodies.  Unlike the\nnormal visitor, which just walks the entire body in one shot, the\n`ExprUseVisitor` determines how expressions are being used."],[1,"ExprUseVisitor","rustc::middle::expr_use_visitor",""],[2,"LoanCause","",""],[12,"ClosureCapture","","",73],[12,"AddrOf","","",73],[12,"AutoRef","","",73],[12,"RefBinding","","",73],[12,"OverloadedOperator","","",73],[12,"ClosureInvocation","","",73],[12,"ForLoop","","",73],[2,"ConsumeMode","",""],[12,"Copy","","",74],[12,"Move","","",74],[2,"MoveReason","",""],[12,"DirectRefMove","","",75],[12,"PatBindingMove","","",75],[12,"CaptureMove","","",75],[2,"MutateMode","",""],[12,"Init","","",76],[12,"JustWrite","","",76],[12,"WriteAndRead","","",76],[6,"Delegate","","This trait defines the callbacks you can expect to receive when\nemploying the ExprUseVisitor."],[9,"consume","","",77],[9,"consume_pat","","",77],[9,"borrow","","",77],[9,"decl_without_init","","",77],[9,"mutate","","",77],[10,"eq","","",73],[10,"ne","","",73],[10,"fmt","","",74],[10,"eq","","",74],[10,"ne","","",74],[10,"fmt","","",75],[10,"eq","","",75],[10,"ne","","",75],[10,"fmt","","",76],[10,"eq","","",76],[10,"ne","","",76],[10,"new","","",78],[10,"walk_fn","","",78],[10,"walk_expr","","",78],[0,"freevars","rustc::middle",""],[1,"freevar_entry","rustc::middle::freevars",""],[11,"def","","",79],[11,"span","","",79],[2,"CaptureMode","",""],[12,"CaptureByValue","","Copy/move the value from this llvm ValueRef into the environment.",80],[12,"CaptureByRef","","Access by reference (used for stack closures).",80],[3,"annotate_freevars","",""],[3,"with_freevars","",""],[3,"get_capture_mode","",""],[4,"freevar_map","",""],[4,"UnboxedClosureList","",""],[10,"fmt","","",80],[10,"decode","","",79],[10,"encode","","",79],[0,"graph","rustc::middle","A graph module for use in dataflow, region resolution, and elsewhere."],[1,"Graph","rustc::middle::graph",""],[1,"Node","",""],[11,"data","","",81],[1,"Edge","",""],[11,"data","","",82],[1,"NodeIndex","",""],[1,"EdgeIndex","",""],[1,"Direction","",""],[3,"each_edge_index","",""],[5,"InvalidNodeIndex","",""],[5,"InvalidEdgeIndex","",""],[5,"Outgoing","",""],[5,"Incoming","",""],[10,"fmt","","",83],[10,"eq","","",83],[10,"ne","","",83],[10,"clone","","",83],[10,"eq","","",84],[10,"ne","","",84],[10,"node_id","","Returns unique id (unique with respect to the graph holding associated node).",83],[10,"edge_id","","Returns unique id (unique with respect to the graph holding associated edge).",84],[10,"new","","",85],[10,"with_capacity","","",85],[10,"all_nodes","","",85],[10,"all_edges","","",85],[10,"next_node_index","","",85],[10,"add_node","","",85],[10,"mut_node_data","","",85],[10,"node_data","","",85],[10,"node","","",85],[10,"next_edge_index","","",85],[10,"add_edge","","",85],[10,"mut_edge_data","","",85],[10,"edge_data","","",85],[10,"edge","","",85],[10,"first_adjacent","","Accesses the index of the first edge adjacent to `node`.\nThis is useful if you wish to modify the graph while walking\nthe linked list of edges.",85],[10,"next_adjacent","","Accesses the next edge in a given direction.\nThis is useful if you wish to modify the graph while walking\nthe linked list of edges.",85],[10,"each_node","","Iterates over all edges defined in the graph.",85],[10,"each_edge","","Iterates over all edges defined in the graph",85],[10,"each_outgoing_edge","","Iterates over all outgoing edges from the node `from`",85],[10,"each_incoming_edge","","Iterates over all incoming edges to the node `target`",85],[10,"each_adjacent_edge","","Iterates over all edges adjacent to the node `node`\nin the direction `dir` (either `Outgoing` or `Incoming)",85],[10,"iterate_until_fixed_point","","",85],[10,"source","","",82],[10,"target","","",82],[0,"intrinsicck","rustc::middle",""],[3,"check_crate","rustc::middle::intrinsicck",""],[0,"kind","rustc::middle",""],[1,"Context","rustc::middle::kind",""],[3,"check_crate","",""],[3,"check_expr","",""],[3,"check_builtin_bounds","",""],[3,"check_typaram_bounds","",""],[3,"check_freevar_bounds","",""],[3,"check_trait_cast_bounds","",""],[3,"check_static","",""],[3,"check_cast_for_escaping_regions","","This is rather subtle.  When we are casting a value to an instantiated\ntrait like `a as trait<'r>`, regionck already ensures that any references\nthat appear in the type of `a` are bounded by `'r` (ed.: rem\nFIXME(#5723)).  However, it is possible that there are *type parameters*\nin the type of `a`, and those *type parameters* may have references\nwithin them.  We have to guarantee that the regions which appear in those\ntype parameters are not obscured."],[10,"clone","","",86],[10,"visit_expr","","",86],[10,"visit_fn","","",86],[10,"visit_ty","","",86],[10,"visit_item","","",86],[10,"visit_pat","","",86],[0,"lang_items","rustc::middle",""],[1,"LanguageItems","rustc::middle::lang_items",""],[11,"items","","",87],[11,"missing","","",87],[2,"LangItem","",""],[12,"SendTraitLangItem","","",88],[12,"SizedTraitLangItem","","",88],[12,"CopyTraitLangItem","","",88],[12,"ShareTraitLangItem","","",88],[12,"DropTraitLangItem","","",88],[12,"AddTraitLangItem","","",88],[12,"SubTraitLangItem","","",88],[12,"MulTraitLangItem","","",88],[12,"DivTraitLangItem","","",88],[12,"RemTraitLangItem","","",88],[12,"NegTraitLangItem","","",88],[12,"NotTraitLangItem","","",88],[12,"BitXorTraitLangItem","","",88],[12,"BitAndTraitLangItem","","",88],[12,"BitOrTraitLangItem","","",88],[12,"ShlTraitLangItem","","",88],[12,"ShrTraitLangItem","","",88],[12,"IndexTraitLangItem","","",88],[12,"IndexMutTraitLangItem","","",88],[12,"UnsafeTypeLangItem","","",88],[12,"DerefTraitLangItem","","",88],[12,"DerefMutTraitLangItem","","",88],[12,"FnTraitLangItem","","",88],[12,"FnMutTraitLangItem","","",88],[12,"FnOnceTraitLangItem","","",88],[12,"EqTraitLangItem","","",88],[12,"OrdTraitLangItem","","",88],[12,"StrEqFnLangItem","","",88],[12,"FailFnLangItem","","",88],[12,"FailBoundsCheckFnLangItem","","",88],[12,"BeginUnwindLangItem","","",88],[12,"ExchangeMallocFnLangItem","","",88],[12,"ClosureExchangeMallocFnLangItem","","",88],[12,"ExchangeFreeFnLangItem","","",88],[12,"MallocFnLangItem","","",88],[12,"FreeFnLangItem","","",88],[12,"StrDupUniqFnLangItem","","",88],[12,"StartFnLangItem","","",88],[12,"TyDescStructLangItem","","",88],[12,"TyVisitorTraitLangItem","","",88],[12,"OpaqueStructLangItem","","",88],[12,"TypeIdLangItem","","",88],[12,"EhPersonalityLangItem","","",88],[12,"ManagedHeapLangItem","","",88],[12,"ExchangeHeapLangItem","","",88],[12,"GcLangItem","","",88],[12,"OwnedBoxLangItem","","",88],[12,"CovariantTypeItem","","",88],[12,"ContravariantTypeItem","","",88],[12,"InvariantTypeItem","","",88],[12,"CovariantLifetimeItem","","",88],[12,"ContravariantLifetimeItem","","",88],[12,"InvariantLifetimeItem","","",88],[12,"NoSendItem","","",88],[12,"NoCopyItem","","",88],[12,"NoShareItem","","",88],[12,"ManagedItem","","",88],[12,"IteratorItem","","",88],[12,"StackExhaustedLangItem","","",88],[3,"extract","",""],[3,"collect_language_items","",""],[10,"hash","","",88],[10,"eq","","",88],[10,"ne","","",88],[10,"from_i64","","",88],[10,"from_u64","","",88],[10,"new","","",87],[10,"items","","",87],[10,"item_name","","",87],[10,"require","","",87],[10,"to_builtin_kind","","",87],[10,"send_trait","","",87],[10,"sized_trait","","",87],[10,"copy_trait","","",87],[10,"share_trait","","",87],[10,"drop_trait","","",87],[10,"add_trait","","",87],[10,"sub_trait","","",87],[10,"mul_trait","","",87],[10,"div_trait","","",87],[10,"rem_trait","","",87],[10,"neg_trait","","",87],[10,"not_trait","","",87],[10,"bitxor_trait","","",87],[10,"bitand_trait","","",87],[10,"bitor_trait","","",87],[10,"shl_trait","","",87],[10,"shr_trait","","",87],[10,"index_trait","","",87],[10,"index_mut_trait","","",87],[10,"unsafe_type","","",87],[10,"deref_trait","","",87],[10,"deref_mut_trait","","",87],[10,"fn_trait","","",87],[10,"fn_mut_trait","","",87],[10,"fn_once_trait","","",87],[10,"eq_trait","","",87],[10,"ord_trait","","",87],[10,"str_eq_fn","","",87],[10,"fail_fn","","",87],[10,"fail_bounds_check_fn","","",87],[10,"begin_unwind","","",87],[10,"exchange_malloc_fn","","",87],[10,"closure_exchange_malloc_fn","","",87],[10,"exchange_free_fn","","",87],[10,"malloc_fn","","",87],[10,"free_fn","","",87],[10,"strdup_uniq_fn","","",87],[10,"start_fn","","",87],[10,"ty_desc","","",87],[10,"ty_visitor","","",87],[10,"opaque","","",87],[10,"type_id","","",87],[10,"eh_personality","","",87],[10,"managed_heap","","",87],[10,"exchange_heap","","",87],[10,"gc","","",87],[10,"owned_box","","",87],[10,"covariant_type","","",87],[10,"contravariant_type","","",87],[10,"invariant_type","","",87],[10,"covariant_lifetime","","",87],[10,"contravariant_lifetime","","",87],[10,"invariant_lifetime","","",87],[10,"no_send_bound","","",87],[10,"no_copy_bound","","",87],[10,"no_share_bound","","",87],[10,"managed_bound","","",87],[10,"iterator","","",87],[10,"stack_exhausted","","",87],[0,"liveness","rustc::middle","A classic liveness analysis based on dataflow over the AST.  Computes,\nfor each local variable in a function, whether that variable is live\nat a given point.  Program execution points are identified by their\nid."],[3,"check_crate","rustc::middle::liveness",""],[0,"mem_categorization","rustc::middle","# Categorization"],[1,"CopiedUpvar","rustc::middle::mem_categorization",""],[11,"upvar_id","","",89],[11,"onceness","","",89],[11,"capturing_proc","","",89],[1,"cmt_","",""],[11,"id","","",90],[11,"span","","",90],[11,"cat","","",90],[11,"mutbl","","",90],[11,"ty","","",90],[1,"MemCategorizationContext","",""],[2,"categorization","",""],[12,"cat_rvalue","","",91],[12,"cat_static_item","","",91],[12,"cat_copied_upvar","","",91],[12,"cat_upvar","","",91],[12,"cat_local","","",91],[12,"cat_arg","","",91],[12,"cat_deref","","",91],[12,"cat_interior","","",91],[12,"cat_downcast","","",91],[12,"cat_discr","","",91],[2,"PointerKind","",""],[12,"OwnedPtr","","",92],[12,"GcPtr","","",92],[12,"BorrowedPtr","","",92],[12,"Implicit","","",92],[12,"UnsafePtr","","",92],[2,"InteriorKind","",""],[12,"InteriorField","","",93],[12,"InteriorElement","","",93],[2,"FieldName","",""],[12,"NamedField","","",94],[12,"PositionalField","","",94],[2,"ElementKind","",""],[12,"VecElement","","",95],[12,"OtherElement","","",95],[2,"MutabilityCategory","",""],[12,"McImmutable","","",96],[12,"McDeclared","","",96],[12,"McInherited","","",96],[2,"deref_kind","",""],[12,"deref_ptr","","",97],[12,"deref_interior","","",97],[2,"InteriorSafety","",""],[12,"InteriorUnsafe","","",98],[12,"InteriorSafe","","",98],[2,"AliasableReason","",""],[12,"AliasableManaged","","",99],[12,"AliasableBorrowed","","",99],[12,"AliasableOther","","",99],[12,"AliasableStatic","","",99],[12,"AliasableStaticMut","","",99],[3,"opt_deref_kind","",""],[3,"deref_kind","",""],[3,"ptr_sigil","",""],[4,"cmt","",""],[4,"McResult","",""],[6,"ast_node","",""],[9,"id","","",100],[9,"span","","",100],[6,"Typer","","The `Typer` trait provides the interface for the mem-categorization\nmodule to the results of the type check. It can be used to query\nthe type assigned to an expression node, to inquire after adjustments,\nand so on."],[9,"tcx","","",101],[9,"node_ty","","",101],[9,"node_method_ty","","",101],[9,"adjustments","","",101],[9,"is_method_call","","",101],[9,"temporary_scope","","",101],[9,"upvar_borrow","","",101],[10,"eq","","",91],[10,"ne","","",91],[10,"clone","","",91],[10,"eq","","",89],[10,"ne","","",89],[10,"clone","","",89],[10,"hash","","",92],[10,"eq","","",92],[10,"ne","","",92],[10,"clone","","",92],[10,"hash","","",93],[10,"eq","","",93],[10,"ne","","",93],[10,"clone","","",93],[10,"hash","","",94],[10,"eq","","",94],[10,"ne","","",94],[10,"clone","","",94],[10,"hash","","",95],[10,"eq","","",95],[10,"ne","","",95],[10,"clone","","",95],[10,"fmt","","",96],[10,"hash","","",96],[10,"eq","","",96],[10,"ne","","",96],[10,"clone","","",96],[10,"eq","","",90],[10,"ne","","",90],[10,"clone","","",90],[10,"id","syntax::ast","",102],[10,"span","","",102],[10,"id","","",103],[10,"span","","",103],[10,"from_mutbl","rustc::middle::mem_categorization","",96],[10,"from_borrow_kind","","",96],[10,"from_pointer_kind","","",96],[10,"inherit","","",96],[10,"is_mutable","","",96],[10,"is_immutable","","",96],[10,"to_user_str","","",96],[10,"new","","",104],[10,"cat_expr","","",104],[10,"cat_expr_autoderefd","","",104],[10,"cat_expr_unadjusted","","",104],[10,"cat_def","","",104],[10,"cat_rvalue_node","","",104],[10,"cat_rvalue","","",104],[10,"cat_field","","",104],[10,"cat_deref_obj","","",104],[10,"cat_index","","Creates a cmt for an indexing operation (`[]`); this\nindexing operation may occurs as part of an\nAutoBorrowVec, which when converting a `~[]` to an `&[]`\neffectively takes the address of the 0th element.",104],[10,"cat_slice_pattern","","Given a pattern P like: `[_, ..Q, _]`, where `vec_cmt` is\nthe cmt for `P`, `slice_pat` is the pattern `Q`, returns:\n- a cmt for `Q`\n- the mutability and region of the slice `Q`",104],[10,"cat_imm_interior","","",104],[10,"cat_downcast","","",104],[10,"cat_pattern","","",104],[10,"cmt_to_string","","",104],[10,"guarantor","","Returns `self` after stripping away any owned pointer derefs or\ninterior content. The return value is basically the `cmt` which\ndetermines how long the value in `self` remains live.",90],[10,"freely_aliasable","","Returns `Some(_)` if this lvalue represents a freely aliasable\npointer type.",90],[10,"repr","","",90],[10,"repr","","",91],[10,"repr","","",93],[0,"pat_util","rustc::middle",""],[3,"pat_id_map","rustc::middle::pat_util",""],[3,"pat_is_variant_or_struct","",""],[3,"pat_is_const","",""],[3,"pat_is_binding","",""],[3,"pat_is_binding_or_wild","",""],[3,"pat_bindings","","Call `it` on every \"binding\" in a pattern, e.g., on `a` in\n`match foo() { Some(a) => (), None => () }`"],[3,"pat_contains_bindings","","Checks if the pattern contains any patterns that bind something to\nan ident, e.g. `foo`, or `Foo(foo)` or `foo @ Bar(..)`."],[3,"simple_identifier","",""],[3,"wild","",""],[3,"def_to_path","",""],[4,"PatIdMap","",""],[0,"privacy","rustc::middle","A pass that checks to make sure private fields and methods aren't used\noutside their scopes. This pass will also generate a set of exported items\nwhich are available for use externally when compiled as a library."],[3,"check_crate","rustc::middle::privacy",""],[4,"ExportedItems","","A set of AST nodes exported by the crate."],[4,"PublicItems","","A set of AST nodes that are fully public in the crate. This map is used for\ndocumentation purposes (reexporting a private struct inlines the doc,\nreexporting a public struct doesn't inline the doc)."],[0,"reachable","rustc::middle",""],[3,"find_reachable","rustc::middle::reachable",""],[0,"region","rustc::middle","This file actually contains two passes related to regions.  The first\npass builds up the `scope_map`, which describes the parent links in\nthe region hierarchy.  The second pass infers which types must be\nregion parameterized."],[1,"RegionMaps","rustc::middle::region","The region maps encode information about region relationships."],[1,"Context","",""],[3,"resolve_crate","",""],[3,"resolve_inlined_item","",""],[10,"clone","","",105],[10,"relate_free_regions","","",106],[10,"record_encl_scope","","",106],[10,"record_var_scope","","",106],[10,"record_rvalue_scope","","",106],[10,"mark_as_terminating_scope","","Records that a scope is a TERMINATING SCOPE. Whenever we\ncreate automatic temporaries -- e.g. by an\nexpression like `a().f` -- they will be freed within\nthe innermost terminating scope.",106],[10,"opt_encl_scope","","Returns the narrowest scope that encloses `id`, if any.",106],[10,"encl_scope","","Returns the narrowest scope that encloses `id`, if any.",106],[10,"var_scope","","Returns the lifetime of the local variable `var_id`",106],[10,"temporary_scope","","Returns the scope when temp created by expr_id will be cleaned up",106],[10,"var_region","","Returns the lifetime of the variable `id`.",106],[10,"scopes_intersect","","",106],[10,"is_subscope_of","","Returns true if `subscope` is equal to or is lexically\nnested inside `superscope` and false otherwise.",106],[10,"sub_free_region","","Determines whether two free regions have a subregion relationship\nby walking the graph encoded in `free_region_map`.  Note that\nit is possible that `sub != sup` and `sub <= sup` and `sup <= sub`\n(that is, the user can give two different names to the same lifetime).",106],[10,"is_subregion_of","","Determines whether one region is a subregion of another.  This is\nintended to run *after inference* and sadly the logic is somewhat\nduplicated with the code in infer.rs.",106],[10,"nearest_common_ancestor","","Finds the nearest common ancestor (if any) of two scopes.  That\nis, finds the smallest scope which is greater than or equal to\nboth `scope_a` and `scope_b`.",106],[0,"resolve","rustc::middle",""],[1,"Export2","rustc::middle::resolve",""],[11,"name","","",107],[11,"def_id","","",107],[1,"CrateMap","",""],[11,"def_map","","",108],[11,"exp_map2","","",108],[11,"trait_map","","",108],[11,"external_exports","","",108],[11,"last_private_map","","",108],[2,"LastPrivate","",""],[12,"LastMod","","",109],[12,"LastImport","","",109],[11,"value_priv","rustc::middle::resolve::LastPrivate","",109],[11,"value_used","","",109],[11,"type_priv","","",109],[11,"type_used","","",109],[2,"PrivateDep","rustc::middle::resolve",""],[12,"AllPublic","","",110],[12,"DependsOn","","",110],[2,"ImportUse","",""],[12,"Unused","","",111],[12,"Used","","",111],[3,"resolve_crate","","Entry point to crate resolution."],[4,"DefMap","",""],[4,"TraitMap","",""],[4,"ExportMap2","",""],[4,"ExternalExports","",""],[4,"LastPrivateMap","",""],[10,"eq","","",111],[10,"ne","","",111],[0,"resolve_lifetime","rustc::middle","Name resolution for lifetimes."],[2,"DefRegion","rustc::middle::resolve_lifetime",""],[12,"DefStaticRegion","","",112],[12,"DefEarlyBoundRegion","","",112],[12,"DefLateBoundRegion","","",112],[12,"DefFreeRegion","","",112],[3,"krate","",""],[3,"early_bound_lifetimes","",""],[3,"free_lifetimes","","Gathers up and returns the names of any lifetimes that appear\nfree in `ty_params`. Of course, right now, all lifetimes appear\nfree, since we don't currently have any binders in type parameter\ndeclarations; just being forwards compatible with future extensions."],[4,"NamedRegionMap","",""],[10,"fmt","","",112],[10,"decode","","",112],[10,"encode","","",112],[10,"hash","","",112],[10,"eq","","",112],[10,"ne","","",112],[10,"clone","","",112],[0,"save","rustc::middle","Output a CSV file containing the output from rustc's analysis. The data is\nprimarily designed to be used as input to the DXR tool, specifically its\nRust plugin. It could also be used by IDEs or other code browsing, search, or\ncross-referencing tools."],[3,"process_crate","rustc::middle::save",""],[0,"stability","rustc::middle","A pass that annotates every item and method with its stability level,\npropagating default levels lexically from parent to children ast nodes."],[1,"Index","rustc::middle::stability","A stability index, giving the stability level for items and methods."],[3,"lookup","","Lookup the stability for a node, loading external crate\nmetadata as necessary."],[10,"build","","Construct the stability index for a crate being compiled.",113],[0,"subst","rustc::middle",""],[1,"Substs","rustc::middle::subst","A substitution mapping type/region parameters to new values. We\nidentify each in-scope parameter by an *index* and a *parameter\nspace* (which indices where the parameter is defined; see\n`ParamSpace`)."],[11,"types","","",114],[11,"regions","","",114],[1,"VecPerParamSpace","","Vector of things sorted by param space. Used to keep\nthe set of things declared on the type, self, or method\ndistinct."],[2,"RegionSubsts","","Represents the values to use when substituting lifetime parameters.\nIf the value is `ErasedRegions`, then this subst is occurring during\ntrans, and all region parameters will be replaced with `ty::ReStatic`. "],[12,"ErasedRegions","","",115],[12,"NonerasedRegions","","",115],[2,"ParamSpace","",""],[12,"TypeSpace","","",116],[12,"SelfSpace","","",116],[12,"FnSpace","","",116],[6,"HomogeneousTuple3","",""],[9,"len","","",117],[9,"as_slice","","",117],[9,"as_mut_slice","","",117],[9,"iter","","",117],[9,"mut_iter","","",117],[9,"get","","",117],[9,"get_mut","","",117],[6,"Subst","",""],[10,"subst","","",118],[9,"subst_spanned","","",118],[10,"fmt","","",114],[10,"hash","","",114],[10,"eq","","",114],[10,"ne","","",114],[10,"clone","","",114],[10,"fmt","","",115],[10,"hash","","",115],[10,"eq","","",115],[10,"ne","","",115],[10,"clone","","",115],[10,"new","","",114],[10,"new_type","","",114],[10,"new_trait","","",114],[10,"erased","","",114],[10,"empty","","",114],[10,"trans_empty","","",114],[10,"is_noop","","",114],[10,"self_ty","","",114],[10,"with_self_ty","","",114],[10,"regions","","Since ErasedRegions are only to be used in trans, most of\nthe compiler can use this method to easily access the set\nof region substitutions.",114],[10,"mut_regions","","Since ErasedRegions are only to be used in trans, most of\nthe compiler can use this method to easily access the set\nof region substitutions.",114],[10,"with_method_from","","",114],[10,"with_method","","",114],[10,"fmt","","",116],[10,"decode","","",116],[10,"encode","","",116],[10,"hash","","",116],[10,"clone","","",116],[10,"eq","","",116],[10,"ne","","",116],[10,"cmp","","",116],[10,"partial_cmp","","",116],[10,"lt","","",116],[10,"le","","",116],[10,"gt","","",116],[10,"ge","","",116],[10,"all","","",116],[10,"to_uint","","",116],[10,"from_uint","","",116],[10,"decode","","",119],[10,"encode","","",119],[10,"hash","","",119],[10,"clone","","",119],[10,"eq","","",119],[10,"ne","","",119],[10,"fmt","","",119],[10,"push_all","","",119],[10,"empty","","",119],[10,"params_from_type","","",119],[10,"new","","`t` is the type space.\n`s` is the self space.\n`f` is the fn space.",119],[10,"sort","","",119],[10,"push","","Appends `value` to the vector associated with `space`.",119],[10,"pop","","",119],[10,"truncate","","",119],[10,"replace","","",119],[10,"get_self","","",119],[10,"len","","",119],[10,"is_empty_in","","",119],[10,"get_slice","","",119],[10,"opt_get","","",119],[10,"get","","",119],[10,"get_mut","","",119],[10,"iter","","",119],[10,"all_vecs","","",119],[10,"all","","",119],[10,"any","","",119],[10,"is_empty","","",119],[10,"map","","",119],[10,"map_rev","","Executes the map but in reverse order. For hacky reasons, we rely\non this in table.",119],[10,"split","","",119],[10,"with_vec","","",119],[0,"trans","rustc::middle",""],[0,"doc","rustc::middle::trans","# Documentation for the trans module"],[0,"inline","",""],[3,"maybe_instantiate_inline","rustc::middle::trans::inline",""],[0,"monomorphize","rustc::middle::trans",""],[1,"MonoParamId","rustc::middle::trans::monomorphize",""],[11,"subst","","",120],[1,"MonoId","",""],[11,"def","","",121],[11,"params","","",121],[3,"monomorphic_fn","",""],[3,"make_vtable_id","",""],[10,"hash","","",120],[10,"eq","","",120],[10,"ne","","",120],[10,"hash","","",121],[10,"eq","","",121],[10,"ne","","",121],[0,"controlflow","rustc::middle::trans",""],[3,"trans_stmt","rustc::middle::trans::controlflow",""],[3,"trans_stmt_semi","",""],[3,"trans_block","",""],[3,"trans_if","",""],[3,"trans_while","",""],[3,"trans_for","","Translates a `for` loop."],[3,"trans_loop","",""],[3,"trans_break_cont","",""],[3,"trans_break","",""],[3,"trans_cont","",""],[3,"trans_ret","",""],[3,"trans_fail","",""],[3,"trans_fail_bounds_check","",""],[0,"glue","rustc::middle::trans",""],[3,"trans_free","rustc::middle::trans::glue",""],[3,"trans_exchange_free_ty","",""],[3,"take_ty","",""],[3,"get_drop_glue_type","",""],[3,"drop_ty","",""],[3,"drop_ty_immediate","",""],[3,"get_drop_glue","",""],[3,"lazily_emit_visit_glue","",""],[3,"call_visit_glue","",""],[3,"declare_tydesc","",""],[3,"emit_tydescs","",""],[0,"datum","rustc::middle::trans","See the section on datums in `doc.rs` for an overview of what\nDatums are and how they are intended to be used."],[1,"Datum","rustc::middle::trans::datum","A `Datum` encapsulates the result of evaluating an expression.  It\ndescribes where the value is stored, what Rust type the value has,\nwhether it is addressed by reference, and so forth. Please refer\nthe section on datums in `doc.rs` for more details."],[11,"val","","The llvm value.  This is either a pointer to the Rust value or\nthe value itself, depending on `kind` below.",122],[11,"ty","","The rust type of the value.",122],[11,"kind","","Indicates whether this is by-ref or by-value.",122],[1,"DatumBlock","",""],[11,"bcx","","",123],[11,"datum","","",123],[1,"Lvalue","",""],[1,"Rvalue","",""],[11,"mode","","",124],[2,"Expr","",""],[12,"RvalueExpr","","a fresh value that was produced and which has no cleanup yet\nbecause it has not yet \"landed\" into its permanent home",125],[12,"LvalueExpr","","`val` is a pointer into memory for which a cleanup is scheduled\n(and thus has type *T). If you move out of an Lvalue, you must\nzero out the memory (FIXME #5016).",125],[2,"RvalueMode","",""],[12,"ByRef","","`val` is a pointer to the actual value (and thus has type *T)",126],[12,"ByValue","","`val` is the actual value (*only used for immediates* like ints, ptrs)",126],[3,"immediate_rvalue","",""],[3,"immediate_rvalue_bcx","",""],[3,"lvalue_scratch_datum","","Allocates temporary space on the stack using alloca() and\nreturns a by-ref Datum pointing to it. The memory will be\ndropped upon exit from `scope`. The callback `populate` should\ninitialize the memory. If `zero` is true, the space will be\nzeroed when it is allocated; this is not necessary unless `bcx`\ndoes not dominate the end of `scope`."],[3,"rvalue_scratch_datum","","Allocates temporary space on the stack using alloca() and\nreturns a by-ref Datum pointing to it.  If `zero` is true, the\nspace will be zeroed when it is allocated; this is normally not\nnecessary, but in the case of automatic rooting in match\nstatements it is possible to have temporaries that may not get\ninitialized if a certain arm is not taken, so we must zero\nthem. You must arrange any cleanups etc yourself!"],[3,"appropriate_rvalue_mode","","Indicates the \"appropriate\" mode for this value,\nwhich is either by ref or by value, depending\non whether type is immediate or not."],[6,"KindOps","",""],[9,"post_store","","Take appropriate action after the value in `datum` has been\nstored to a new location.",127],[9,"is_by_ref","","True if this mode is a reference mode, meaning that the datum's\nval field is a pointer to the actual value",127],[9,"to_expr_kind","","Converts to an Expr kind",127],[10,"clone","","",122],[10,"clone","","",128],[10,"new","","",124],[10,"drop","","",124],[10,"hash","","",126],[10,"eq","","",126],[10,"ne","","",126],[10,"post_store","","",124],[10,"is_by_ref","","",124],[10,"to_expr_kind","","",124],[10,"post_store","","If an lvalue is moved, we must zero out the memory in which\nit resides so as to cancel cleanup. If an @T lvalue is\ncopied, we must increment the reference count.",128],[10,"is_by_ref","","",128],[10,"to_expr_kind","","",128],[10,"post_store","","",125],[10,"is_by_ref","","",125],[10,"to_expr_kind","","",125],[10,"add_clean","","Schedules a cleanup for this datum in the given scope.\nThat means that this datum is no longer an rvalue datum;\nhence, this function consumes the datum and returns the\ncontained ValueRef.",122],[10,"to_lvalue_datum_in_scope","","Returns an lvalue datum (that is, a by ref datum with\ncleanup scheduled). If `self` is not already an lvalue,\ncleanup will be scheduled in the temporary scope for `expr_id`.",122],[10,"to_ref_datum","","",122],[10,"to_appropriate_datum","","",122],[10,"assert_lvalue","","Asserts that this datum *is* an lvalue and returns it.",122],[10,"assert_rvalue","","Asserts that this datum *is* an lvalue and returns it.",122],[10,"store_to_dest","","",122],[10,"add_clean_if_rvalue","","Arranges cleanup for `self` if it is an rvalue. Use when\nyou are done working with a value that may need drop.",122],[10,"clean","","Ensures that `self` will get cleaned up, if it is not an lvalue\nalready.",122],[10,"to_lvalue_datum","","",122],[10,"to_rvalue_datum","","Ensures that we have an rvalue datum (that is, a datum with\nno cleanup scheduled).",122],[10,"to_llref","","Converts a datum into a by-ref value. The datum type must\nbe one which is always passed by reference.",122],[10,"get_element","","",122],[10,"get_vec_base_and_len","","Converts a vector into the slice pair.",122],[10,"new","","",122],[10,"to_expr_datum","","",122],[10,"store_to","","Moves or copies this value into a new home, as appropriate\ndepending on the type of the datum. This method consumes\nthe datum, since it would be incorrect to go on using the\ndatum if the value represented is affine (and hence the value\nis moved).",122],[10,"shallow_copy_and_take","","Copies the value into a new location and runs any necessary\ntake glue on the new location. This function always\npreserves the existing datum as a valid value. Therefore,\nit does not consume `self` and, also, cannot be applied to\naffine values (since they must never be duplicated).",122],[10,"to_string","","",122],[10,"appropriate_rvalue_mode","","See the `appropriate_rvalue_mode()` function",122],[10,"to_llscalarish","","Converts `self` into a by-value `ValueRef`. Consumes this\ndatum (i.e., absolves you of responsibility to cleanup the\nvalue). For this to work, the value must be something\nscalar-ish (like an int or a pointer) which (1) does not\nrequire drop glue and (2) is naturally passed around by\nvalue, and not by reference.",122],[10,"to_llbool","","",122],[10,"new","","",123],[10,"to_expr_datumblock","","",123],[10,"store_to_dest","","",123],[10,"to_llbool","","",123],[0,"callee","rustc::middle::trans","Handles translation of callees as well as other call-related\nthings.  Callees are a superset of normal rust values and sometimes\nhave different representations.  In particular, top-level fn items\nand methods are represented as just a fn ptr and not a full\nclosure."],[1,"MethodData","rustc::middle::trans::callee",""],[11,"llfn","","",129],[11,"llself","","",129],[1,"Callee","",""],[11,"bcx","","",130],[11,"data","","",130],[2,"CalleeData","",""],[12,"Closure","","",131],[12,"NamedTupleConstructor","","",131],[12,"Fn","","",131],[12,"Intrinsic","","",131],[12,"TraitMethod","","",131],[2,"CallArgs","",""],[12,"ArgExprs","","",132],[12,"ArgVals","","",132],[12,"ArgOverloadedOp","","",132],[12,"ArgOverloadedCall","","",132],[2,"AutorefArg","",""],[12,"DontAutorefArg","","",133],[12,"DoAutorefArg","","",133],[3,"trans_fn_ref","","Translates a reference (with id `ref_id`) to the fn/method\nwith id `def_id` into a function pointer.  This may require\nmonomorphization or inlining."],[3,"trans_unboxing_shim","","Translates the adapter that deconstructs a `Box<Trait>` object into\n`Trait` so that a by-value self method can be called."],[3,"trans_fn_ref_with_vtables","","Translates a reference to a fn/method item, monomorphizing and\ninlining as it goes."],[3,"trans_call","",""],[3,"trans_method_call","",""],[3,"trans_lang_call","",""],[3,"trans_call_inner","","This behemoth of a function translates function calls.\nUnfortunately, in order to generate more efficient LLVM\noutput at -O0, it has quite a complex signature (refactoring\nthis into two functions seems like a good idea)."],[3,"trans_args","",""],[3,"trans_arg_datum","",""],[0,"expr","rustc::middle::trans","# Translation of Expressions"],[1,"StructBaseInfo","rustc::middle::trans::expr","Information that `trans_adt` needs in order to fill in the fields\nof a struct copied from a base struct (e.g., from an expression\nlike `Foo { a: b, ..base }`."],[2,"Dest","",""],[12,"SaveIn","","",134],[12,"Ignore","","",134],[2,"cast_kind","",""],[12,"cast_pointer","","",135],[12,"cast_integral","","",135],[12,"cast_float","","",135],[12,"cast_enum","","",135],[12,"cast_other","","",135],[3,"trans_into","","This function is equivalent to `trans(bcx, expr).store_to_dest(dest)`\nbut it may generate better optimized LLVM code."],[3,"trans","","Translates an expression, returning a datum (and new block)\nencapsulating the result. When possible, it is preferred to\nuse `trans_into`, as that may avoid creating a temporary on\nthe stack."],[3,"trans_to_lvalue","","Translates an expression in \"lvalue\" mode -- meaning that it\nreturns a reference to the memory that the expr represents."],[3,"trans_local_var","","Translates a reference to a local variable or argument.\nThis always results in an lvalue datum."],[3,"with_field_tys","","Helper for enumerating the field types of structs, enums, or records.\nThe optional node ID here is the node ID of the path identifying the enum\nvariant in use. If none, this cannot possibly an enum variant (so, if it\nis and `node_id_opt` is none, this function fails)."],[3,"trans_adt","","Constructs an ADT instance:"],[3,"cast_type_kind","",""],[10,"eq","","",134],[10,"ne","","",134],[10,"to_string","","",134],[10,"eq","","",135],[10,"ne","","",135],[0,"common","rustc::middle::trans","Code that is useful in various trans modules."],[1,"tydesc_info","rustc::middle::trans::common",""],[11,"ty","","",136],[11,"tydesc","","",136],[11,"size","","",136],[11,"align","","",136],[11,"name","","",136],[11,"visit_glue","","",136],[1,"NodeInfo","",""],[11,"id","","",137],[11,"span","","",137],[1,"BuilderRef_res","",""],[11,"b","","",138],[1,"param_substs","",""],[11,"substs","","",139],[11,"vtables","","",139],[1,"FunctionContext","",""],[11,"llfn","","",140],[11,"llenv","","",140],[11,"llretptr","","",140],[11,"alloca_insert_pt","","",140],[11,"llreturn","","",140],[11,"personality","","",140],[11,"caller_expects_out_pointer","","",140],[11,"llargs","","",140],[11,"lllocals","","",140],[11,"llupvars","","",140],[11,"id","","",140],[11,"param_substs","","",140],[11,"span","","",140],[11,"block_arena","","",140],[11,"ccx","","",140],[11,"debug_context","","",140],[11,"scopes","","",140],[11,"handle_items","","",140],[1,"Block","",""],[11,"llbb","","",141],[11,"terminated","","",141],[11,"unreachable","","",141],[11,"is_lpad","","",141],[11,"opt_node_id","","",141],[11,"fcx","","",141],[1,"Result","",""],[11,"bcx","","",142],[11,"val","","",142],[2,"HandleItemsFlag","",""],[12,"IgnoreItems","","",143],[12,"TranslateItems","","",143],[2,"ExprOrMethodCall","",""],[12,"ExprId","","",144],[12,"MethodCall","","",144],[3,"type_is_immediate","",""],[3,"type_is_zero_size","","Identify types which have size zero at runtime."],[3,"return_type_is_void","","Identifies types which we declare to be equivalent to `void`\nin C for the purpose of function return types. These are\n`()`, bot, and uninhabited enums. Note that all such types\nare also zero-size, but not all zero-size types use a `void`\nreturn type (in order to aid with C ABI compatibility)."],[3,"gensym_name","","Generates a unique symbol based off the name given. This is used to create\nunique symbols for things like closures."],[3,"expr_info","",""],[3,"BuilderRef_res","",""],[3,"val_ty","",""],[3,"C_null","",""],[3,"C_undef","",""],[3,"C_integral","",""],[3,"C_floating","",""],[3,"C_nil","",""],[3,"C_bool","",""],[3,"C_i32","",""],[3,"C_i64","",""],[3,"C_u64","",""],[3,"C_int","",""],[3,"C_uint","",""],[3,"C_u8","",""],[3,"C_cstr","",""],[3,"C_str_slice","",""],[3,"C_binary_slice","",""],[3,"C_struct","",""],[3,"C_named_struct","",""],[3,"C_array","",""],[3,"C_bytes","",""],[3,"const_get_elt","",""],[3,"is_const","",""],[3,"const_to_int","",""],[3,"const_to_uint","",""],[3,"is_undef","",""],[3,"is_null","",""],[3,"monomorphize_type","",""],[3,"node_id_type","",""],[3,"expr_ty","",""],[3,"expr_ty_adjusted","",""],[3,"node_id_substs","",""],[3,"node_vtables","",""],[3,"resolve_vtables_in_fn_ctxt","",""],[3,"resolve_vtables_under_param_substs","",""],[3,"resolve_param_vtables_under_param_substs","",""],[3,"resolve_vtable_under_param_substs","",""],[3,"find_vtable","",""],[3,"langcall","",""],[4,"ExternMap","",""],[4,"RvalueDatum","",""],[4,"LvalueDatum","",""],[6,"SubstP","",""],[9,"substp","","",145],[10,"drop","","",138],[10,"empty","","",139],[10,"validate","","",139],[10,"repr","","",139],[10,"eq","","",143],[10,"ne","","",143],[10,"clone","","",143],[10,"arg_pos","","",140],[10,"out_arg_pos","","",140],[10,"env_arg_pos","","",140],[10,"cleanup","","",140],[10,"get_llreturn","","",140],[10,"new_block","","",140],[10,"new_id_block","","",140],[10,"new_temp_block","","",140],[10,"join_blocks","","",140],[10,"new","","",141],[10,"ccx","","",141],[10,"tcx","","",141],[10,"sess","","",141],[10,"ident","","",141],[10,"node_id_to_string","","",141],[10,"expr_to_string","","",141],[10,"def","","",141],[10,"val_to_string","","",141],[10,"llty_str","","",141],[10,"ty_to_string","","",141],[10,"to_str","","",141],[10,"new","","",142],[10,"eq","","",144],[10,"ne","","",144],[0,"context","rustc::middle::trans",""],[1,"Stats","rustc::middle::trans::context",""],[11,"n_static_tydescs","","",146],[11,"n_glues_created","","",146],[11,"n_null_glues","","",146],[11,"n_real_glues","","",146],[11,"n_fns","","",146],[11,"n_monos","","",146],[11,"n_inlines","","",146],[11,"n_closures","","",146],[11,"n_llvm_insns","","",146],[11,"llvm_insns","","",146],[11,"fn_stats","","",146],[1,"CrateContext","",""],[11,"llmod","","",147],[11,"llcx","","",147],[11,"metadata_llmod","","",147],[11,"td","","",147],[11,"tn","","",147],[11,"externs","","",147],[11,"item_vals","","",147],[11,"exp_map2","","",147],[11,"reachable","","",147],[11,"item_symbols","","",147],[11,"link_meta","","",147],[11,"drop_glues","","",147],[11,"tydescs","","",147],[11,"finished_tydescs","","Set when running emit_tydescs to enforce that no more tydescs are\ncreated.",147],[11,"external","","Track mapping of external ids to local items imported for inlining",147],[11,"external_srcs","","Backwards version of the `external` map (inlined items to where they\ncame from)",147],[11,"non_inlineable_statics","","A set of static items which cannot be inlined into other crates. This\nwill prevent in IIItem() structures from being encoded into the metadata\nthat is generated",147],[11,"monomorphized","","Cache instances of monomorphized functions",147],[11,"monomorphizing","","",147],[11,"vtables","","Cache generated vtables",147],[11,"const_cstr_cache","","Cache of constant strings,",147],[11,"const_globals","","Reverse-direction for const ptrs cast from globals.\nKey is an int, cast from a ValueRef holding a *T,\nVal is a ValueRef holding a *[T].",147],[11,"const_values","","Cache of emitted const values",147],[11,"extern_const_values","","Cache of external const values",147],[11,"impl_method_cache","","",147],[11,"closure_bare_wrapper_cache","","Cache of closure wrappers for bare fn's.",147],[11,"lltypes","","",147],[11,"llsizingtypes","","",147],[11,"adt_reprs","","",147],[11,"symbol_hasher","","",147],[11,"type_hashcodes","","",147],[11,"all_llvm_symbols","","",147],[11,"tcx","","",147],[11,"stats","","",147],[11,"int_type","","",147],[11,"opaque_vec_type","","",147],[11,"builder","","",147],[11,"unboxed_closure_vals","","Holds the LLVM values for closure IDs.",147],[11,"dbg_cx","","",147],[11,"eh_personality","","",147],[10,"new","","",147],[10,"tcx","","",147],[10,"sess","","",147],[10,"builder","","",147],[10,"tydesc_type","","",147],[10,"get_intrinsic","","",147],[10,"is_split_stack_supported","","",147],[0,"consts","rustc::middle::trans",""],[3,"const_lit","rustc::middle::trans::consts",""],[3,"const_ptrcast","",""],[3,"const_addr_of","",""],[3,"get_const_val","",""],[3,"const_expr","",""],[3,"trans_const","",""],[0,"type_of","rustc::middle::trans",""],[2,"named_ty","rustc::middle::trans::type_of",""],[12,"a_struct","","",148],[12,"an_enum","","",148],[12,"an_unboxed_closure","","",148],[3,"arg_is_indirect","",""],[3,"return_uses_outptr","",""],[3,"type_of_explicit_arg","",""],[3,"type_of_rust_fn","",""],[3,"type_of_fn_from_ty","",""],[3,"sizing_type_of","",""],[3,"arg_type_of","",""],[3,"type_of","",""],[3,"llvm_type_name","",""],[3,"type_of_dtor","",""],[0,"build","rustc::middle::trans",""],[3,"terminate","rustc::middle::trans::build",""],[3,"check_not_terminated","",""],[3,"B","",""],[3,"RetVoid","",""],[3,"Ret","",""],[3,"AggregateRet","",""],[3,"Br","",""],[3,"CondBr","",""],[3,"Switch","",""],[3,"AddCase","",""],[3,"IndirectBr","",""],[3,"Invoke","",""],[3,"Unreachable","",""],[3,"_Undef","",""],[3,"Add","",""],[3,"NSWAdd","",""],[3,"NUWAdd","",""],[3,"FAdd","",""],[3,"Sub","",""],[3,"NSWSub","",""],[3,"NUWSub","",""],[3,"FSub","",""],[3,"Mul","",""],[3,"NSWMul","",""],[3,"NUWMul","",""],[3,"FMul","",""],[3,"UDiv","",""],[3,"SDiv","",""],[3,"ExactSDiv","",""],[3,"FDiv","",""],[3,"URem","",""],[3,"SRem","",""],[3,"FRem","",""],[3,"Shl","",""],[3,"LShr","",""],[3,"AShr","",""],[3,"And","",""],[3,"Or","",""],[3,"Xor","",""],[3,"BinOp","",""],[3,"Neg","",""],[3,"NSWNeg","",""],[3,"NUWNeg","",""],[3,"FNeg","",""],[3,"Not","",""],[3,"Malloc","",""],[3,"ArrayMalloc","",""],[3,"Alloca","",""],[3,"AllocaFcx","",""],[3,"ArrayAlloca","",""],[3,"Free","",""],[3,"Load","",""],[3,"VolatileLoad","",""],[3,"AtomicLoad","",""],[3,"LoadRangeAssert","",""],[3,"Store","",""],[3,"VolatileStore","",""],[3,"AtomicStore","",""],[3,"GEP","",""],[3,"GEPi","",""],[3,"InBoundsGEP","",""],[3,"StructGEP","",""],[3,"GlobalString","",""],[3,"GlobalStringPtr","",""],[3,"Trunc","",""],[3,"ZExt","",""],[3,"SExt","",""],[3,"FPToUI","",""],[3,"FPToSI","",""],[3,"UIToFP","",""],[3,"SIToFP","",""],[3,"FPTrunc","",""],[3,"FPExt","",""],[3,"PtrToInt","",""],[3,"IntToPtr","",""],[3,"BitCast","",""],[3,"ZExtOrBitCast","",""],[3,"SExtOrBitCast","",""],[3,"TruncOrBitCast","",""],[3,"Cast","",""],[3,"PointerCast","",""],[3,"IntCast","",""],[3,"FPCast","",""],[3,"ICmp","",""],[3,"FCmp","",""],[3,"EmptyPhi","",""],[3,"Phi","",""],[3,"AddIncomingToPhi","",""],[3,"_UndefReturn","",""],[3,"add_span_comment","",""],[3,"add_comment","",""],[3,"InlineAsmCall","",""],[3,"Call","",""],[3,"CallWithConv","",""],[3,"AtomicFence","",""],[3,"Select","",""],[3,"VAArg","",""],[3,"ExtractElement","",""],[3,"InsertElement","",""],[3,"ShuffleVector","",""],[3,"VectorSplat","",""],[3,"ExtractValue","",""],[3,"InsertValue","",""],[3,"IsNull","",""],[3,"IsNotNull","",""],[3,"PtrDiff","",""],[3,"Trap","",""],[3,"LandingPad","",""],[3,"SetCleanup","",""],[3,"Resume","",""],[3,"AtomicCmpXchg","",""],[3,"AtomicRMW","",""],[0,"builder","rustc::middle::trans",""],[1,"Builder","rustc::middle::trans::builder",""],[11,"llbuilder","","",149],[11,"ccx","","",149],[3,"noname","",""],[10,"new","","",149],[10,"count_insn","","",149],[10,"position_before","","",149],[10,"position_at_end","","",149],[10,"ret_void","","",149],[10,"ret","","",149],[10,"aggregate_ret","","",149],[10,"br","","",149],[10,"cond_br","","",149],[10,"switch","","",149],[10,"indirect_br","","",149],[10,"invoke","","",149],[10,"unreachable","","",149],[10,"add","","",149],[10,"nswadd","","",149],[10,"nuwadd","","",149],[10,"fadd","","",149],[10,"sub","","",149],[10,"nswsub","","",149],[10,"nuwsub","","",149],[10,"fsub","","",149],[10,"mul","","",149],[10,"nswmul","","",149],[10,"nuwmul","","",149],[10,"fmul","","",149],[10,"udiv","","",149],[10,"sdiv","","",149],[10,"exactsdiv","","",149],[10,"fdiv","","",149],[10,"urem","","",149],[10,"srem","","",149],[10,"frem","","",149],[10,"shl","","",149],[10,"lshr","","",149],[10,"ashr","","",149],[10,"and","","",149],[10,"or","","",149],[10,"xor","","",149],[10,"binop","","",149],[10,"neg","","",149],[10,"nswneg","","",149],[10,"nuwneg","","",149],[10,"fneg","","",149],[10,"not","","",149],[10,"malloc","","",149],[10,"array_malloc","","",149],[10,"alloca","","",149],[10,"array_alloca","","",149],[10,"free","","",149],[10,"load","","",149],[10,"volatile_load","","",149],[10,"atomic_load","","",149],[10,"load_range_assert","","",149],[10,"store","","",149],[10,"volatile_store","","",149],[10,"atomic_store","","",149],[10,"gep","","",149],[10,"gepi","","",149],[10,"inbounds_gep","","",149],[10,"struct_gep","","",149],[10,"global_string","","",149],[10,"global_string_ptr","","",149],[10,"trunc","","",149],[10,"zext","","",149],[10,"sext","","",149],[10,"fptoui","","",149],[10,"fptosi","","",149],[10,"uitofp","","",149],[10,"sitofp","","",149],[10,"fptrunc","","",149],[10,"fpext","","",149],[10,"ptrtoint","","",149],[10,"inttoptr","","",149],[10,"bitcast","","",149],[10,"zext_or_bitcast","","",149],[10,"sext_or_bitcast","","",149],[10,"trunc_or_bitcast","","",149],[10,"cast","","",149],[10,"pointercast","","",149],[10,"intcast","","",149],[10,"fpcast","","",149],[10,"icmp","","",149],[10,"fcmp","","",149],[10,"empty_phi","","",149],[10,"phi","","",149],[10,"add_span_comment","","",149],[10,"add_comment","","",149],[10,"inline_asm_call","","",149],[10,"call","","",149],[10,"call_with_conv","","",149],[10,"select","","",149],[10,"va_arg","","",149],[10,"extract_element","","",149],[10,"insert_element","","",149],[10,"shuffle_vector","","",149],[10,"vector_splat","","",149],[10,"extract_value","","",149],[10,"insert_value","","",149],[10,"is_null","","",149],[10,"is_not_null","","",149],[10,"ptrdiff","","",149],[10,"trap","","",149],[10,"landing_pad","","",149],[10,"set_cleanup","","",149],[10,"resume","","",149],[10,"atomic_cmpxchg","","",149],[10,"atomic_rmw","","",149],[10,"atomic_fence","","",149],[0,"base","rustc::middle::trans",""],[1,"_InsnCtxt","rustc::middle::trans::base",""],[1,"StatRecorder","",""],[1,"TransItemVisitor","",""],[11,"ccx","","",150],[2,"scalar_type","",""],[12,"nil_type","","",151],[12,"signed_int","","",151],[12,"unsigned_int","","",151],[12,"floating_point","","",151],[2,"IsUnboxedClosureFlag","",""],[12,"NotUnboxedClosure","","",152],[12,"IsUnboxedClosure","","",152],[3,"with_insn_ctxt","",""],[3,"init_insn_ctxt","",""],[3,"push_ctxt","",""],[3,"decl_cdecl_fn","",""],[3,"get_extern_fn","",""],[3,"decl_rust_fn","",""],[3,"decl_internal_rust_fn","",""],[3,"get_extern_const","",""],[3,"at_box_body","",""],[3,"malloc_raw_dyn","",""],[3,"malloc_raw_dyn_managed","",""],[3,"get_tydesc","",""],[3,"set_optimize_for_size","",""],[3,"set_no_inline","",""],[3,"set_no_unwind","",""],[3,"set_uwtable","",""],[3,"set_inline_hint","",""],[3,"set_llvm_fn_attrs","",""],[3,"set_always_inline","",""],[3,"set_split_stack","",""],[3,"unset_split_stack","",""],[3,"note_unique_llvm_symbol","",""],[3,"get_res_dtor","",""],[3,"maybe_name_value","",""],[3,"compare_scalar_types","",""],[3,"compare_scalar_values","",""],[3,"compare_simd_types","",""],[3,"iter_structural_ty","",""],[3,"cast_shift_expr_rhs","",""],[3,"cast_shift_const_rhs","",""],[3,"cast_shift_rhs","",""],[3,"fail_if_zero_or_overflows","",""],[3,"trans_external_path","",""],[3,"invoke","",""],[3,"need_invoke","",""],[3,"load_if_immediate","",""],[3,"load_ty","","Helper for loading values from memory. Does the necessary conversion if\nthe in-memory type differs from the type used for SSA values. Also\nhandles various special cases where the type gives us better information\nabout what we are loading."],[3,"store_ty","","Helper for storing values in memory. Does the necessary conversion if\nthe in-memory type differs from the type used for SSA values."],[3,"ignore_lhs","",""],[3,"init_local","",""],[3,"raw_block","",""],[3,"with_cond","",""],[3,"call_lifetime_start","",""],[3,"call_lifetime_end","",""],[3,"call_memcpy","",""],[3,"memcpy_ty","",""],[3,"zero_mem","",""],[3,"alloc_ty","",""],[3,"alloca","",""],[3,"alloca_no_lifetime","",""],[3,"alloca_zeroed","",""],[3,"arrayalloca","",""],[3,"make_return_pointer","",""],[3,"new_fn_ctxt","",""],[3,"init_function","","Performs setup on a newly created function, creating the entry scope block\nand allocating space for the return pointer."],[3,"arg_kind","",""],[3,"create_datums_for_fn_args","",""],[3,"finish_fn","",""],[3,"build_return_block","",""],[3,"trans_closure","",""],[3,"trans_fn","",""],[3,"trans_enum_variant","",""],[3,"trans_named_tuple_constructor","",""],[3,"trans_tuple_struct","",""],[3,"trans_item","",""],[3,"trans_mod","",""],[3,"get_fn_llvm_attributes","",""],[3,"register_fn_llvmty","",""],[3,"is_entry_fn","",""],[3,"create_entry_wrapper","",""],[3,"get_item_val","",""],[3,"p2i","",""],[3,"crate_ctxt_to_encode_parms","",""],[3,"write_metadata","",""],[3,"trans_crate","",""],[4,"val_and_ty_fn","",""],[4,"RvalueDatum","",""],[4,"LvalueDatum","",""],[10,"drop","","",153],[10,"new","","",154],[10,"drop","","",154],[10,"eq","","",152],[10,"ne","","",152],[10,"clone","","",152],[10,"visit_item","","",150],[0,"_match","rustc::middle::trans","\n# Compilation of match statements"],[1,"BindingInfo","rustc::middle::trans::_match","Information about a pattern binding:\n- `llmatch` is a pointer to a stack slot.  The stack slot contains a\n  pointer into the value being matched.  Hence, llmatch has type `T**`\n  where `T` is the value being matched.\n- `trmode` is the trans binding mode\n- `id` is the node id of the binding\n- `ty` is the Rust type of the binding "],[11,"llmatch","","",155],[11,"trmode","","",155],[11,"id","","",155],[11,"span","","",155],[11,"ty","","",155],[2,"VecLenOpt","",""],[12,"vec_len_eq","","",156],[12,"vec_len_ge","","",156],[2,"opt_result","",""],[12,"single_result","","",157],[12,"lower_bound","","",157],[12,"range_result","","",157],[2,"TransBindingMode","",""],[12,"TrByCopy","","",158],[12,"TrByMove","","",158],[12,"TrByRef","","",158],[2,"branch_kind","",""],[12,"no_branch","","",159],[12,"single","","",159],[12,"switch","","",159],[12,"compare","","",159],[12,"compare_vec_len","","",159],[3,"trans_match","",""],[3,"store_local","","Generates code for a local variable declaration like\n`let <pat>;` or `let <pat> = <opt_init_expr>`."],[3,"store_arg","","Generates code for argument patterns like `fn foo(<pat>: T)`.\nCreates entries in the `llargs` map for each of the bindings\nin `pat`."],[3,"store_for_loop_binding","","Generates code for the pattern binding in a `for` loop like\n`for <pat> in <expr> { ... }`."],[10,"eq","","",156],[10,"ne","","",156],[10,"clone","","",158],[10,"clone","","",155],[10,"eq","","",159],[10,"ne","","",159],[0,"closure","rustc::middle::trans",""],[1,"EnvValue","rustc::middle::trans::closure",""],[1,"ClosureResult","",""],[3,"mk_closure_tys","",""],[3,"store_environment","",""],[3,"trans_expr_fn","","*\n* Translates the body of a closure expression.\n*\n* - `store`\n* - `decl`\n* - `body`\n* - `id`: The id of the closure expression.\n* - `cap_clause`: information about captured variables, if any.\n* - `dest`: where to write the closure value, which must be a\n    (fn ptr, env) pair"],[3,"get_or_create_declaration_if_unboxed_closure","","Returns the LLVM function declaration for an unboxed closure, creating it\nif necessary. If the ID does not correspond to a closure ID, returns None."],[3,"trans_unboxed_closure","",""],[3,"get_wrapper_for_bare_fn","",""],[3,"make_closure_from_bare_fn","",""],[10,"to_string","","",160],[0,"tvec","rustc::middle::trans",""],[1,"VecTypes","rustc::middle::trans::tvec",""],[11,"unit_ty","","",161],[11,"llunit_ty","","",161],[11,"llunit_size","","",161],[11,"llunit_alloc_size","","",161],[3,"get_fill","",""],[3,"get_dataptr","",""],[3,"pointer_add_byte","",""],[3,"make_drop_glue_unboxed","",""],[3,"trans_fixed_vstore","",""],[3,"trans_slice_vstore","","&[...] allocates memory on the stack and writes the values into it,\nreturning a slice (pair of ptr, len).  &\"...\" is similar except that\nthe memory can be statically allocated."],[3,"trans_lit_str","","Literal strings translate to slices into static memory.  This is\ndifferent from trans_slice_vstore() above because it does need to copy\nthe content anywhere."],[3,"trans_uniq_vstore","","~[...] and \"...\".to_string() allocate boxes in the exchange heap and write\nthe array elements into them."],[3,"write_content","",""],[3,"vec_types_from_expr","",""],[3,"vec_types","",""],[3,"elements_required","","Figure out the number of elements we need to store this content"],[3,"get_fixed_base_and_byte_len","","Converts a fixed-length vector into the slice pair.\nThe vector should be stored in `llval` which should be by ref."],[3,"get_base_and_len","","Converts a vector into the slice pair.  The vector should be\nstored in `llval` which should be by-reference.  If you have a\ndatum, you would probably prefer to call\n`Datum::get_base_and_len()` which will handle any conversions\nfor you."],[3,"iter_vec_loop","",""],[3,"iter_vec_raw","",""],[4,"iter_vec_block","",""],[10,"to_string","","",161],[0,"meth","rustc::middle::trans",""],[3,"trans_impl","rustc::middle::trans::meth","The main \"translation\" pass for methods.  Generates code\nfor non-monomorphized methods only.  Other methods will\nbe generated once they are invoked with specific type parameters,\nsee `trans::base::lval_static_fn()` or `trans::base::monomorphic_fn()`."],[3,"trans_method_callee","",""],[3,"trans_static_method_callee","",""],[3,"trans_trait_callee_from_llval","","Same as `trans_trait_callee()` above, except that it is given\na by-ref pointer to the object pair."],[3,"make_vtable","","Helper function to declare and initialize the vtable."],[3,"trans_trait_cast","","Generates the code to convert from a pointer (`Box<T>`, `&T`, etc)\ninto an object (`Box<Trait>`, `&Trait`, etc). This means creating a\npair where the first word is the vtable and the second word is\nthe pointer."],[0,"cabi","rustc::middle::trans",""],[1,"ArgType","rustc::middle::trans::cabi","Information about how a specific C type\nshould be passed to or returned from a function"],[11,"kind","","",162],[11,"ty","","Original LLVM type",162],[11,"cast","","Coerced LLVM Type",162],[11,"pad","","Dummy argument, which is emitted before the real argument",162],[11,"attr","","LLVM attribute of argument",162],[1,"FnType","","Metadata describing how the arguments to a native function\nshould be passed in order to respect the native ABI."],[11,"arg_tys","","The LLVM types of each argument.",163],[11,"ret_ty","","LLVM return type.",163],[2,"ArgKind","",""],[12,"Direct","","Pass the argument directly using the normal converted\nLLVM type or by coercing to another specified type",164],[12,"Indirect","","Pass the argument indirectly via a hidden pointer",164],[12,"Ignore","","Ignore the argument (useful for empty struct)",164],[3,"compute_abi_info","",""],[10,"eq","","",164],[10,"ne","","",164],[10,"clone","","",164],[10,"clone","","",162],[10,"direct","","",162],[10,"indirect","","",162],[10,"ignore","","",162],[10,"is_indirect","","",162],[10,"is_ignore","","",162],[0,"cabi_x86","rustc::middle::trans",""],[3,"compute_abi_info","rustc::middle::trans::cabi_x86",""],[0,"cabi_x86_64","rustc::middle::trans",""],[3,"compute_abi_info","rustc::middle::trans::cabi_x86_64",""],[6,"TypeMethods","",""],[9,"is_reg_ty","","",165],[6,"ClassList","",""],[9,"is_pass_byval","","",166],[9,"is_ret_bysret","","",166],[0,"cabi_arm","rustc::middle::trans",""],[3,"compute_abi_info","rustc::middle::trans::cabi_arm",""],[0,"cabi_mips","rustc::middle::trans",""],[3,"compute_abi_info","rustc::middle::trans::cabi_mips",""],[0,"foreign","rustc::middle::trans",""],[3,"llvm_calling_convention","rustc::middle::trans::foreign",""],[3,"llvm_linkage_by_name","",""],[3,"register_static","",""],[3,"register_foreign_item_fn","","Registers a foreign function found in a library.\nJust adds a LLVM global."],[3,"trans_native_call","","Prepares a call to a native function. This requires adapting\nfrom the Rust argument passing rules to the native rules."],[3,"trans_foreign_mod","",""],[3,"register_rust_fn_with_foreign_abi","",""],[3,"trans_rust_fn_with_foreign_abi","",""],[3,"link_name","",""],[3,"lltype_for_foreign_fn","",""],[0,"intrinsic","rustc::middle::trans",""],[3,"get_simple_intrinsic","rustc::middle::trans::intrinsic",""],[3,"check_intrinsics","","Performs late verification that intrinsics are used correctly. At present,\nthe only intrinsic that needs such verification is `transmute`."],[3,"trans_intrinsic_call","",""],[0,"reflect","rustc::middle::trans",""],[1,"Reflector","rustc::middle::trans::reflect",""],[3,"emit_calls_to_trait_visit_ty","",""],[3,"ast_fn_style_constant","",""],[10,"c_uint","","",167],[10,"c_bool","","",167],[10,"c_slice","","",167],[10,"c_size_and_align","","",167],[10,"c_tydesc","","",167],[10,"c_mt","","",167],[10,"visit","","",167],[10,"bracketed","","",167],[10,"leaf","","",167],[10,"visit_ty","","",167],[10,"visit_sig","","",167],[0,"debuginfo","rustc::middle::trans","# Debug Info Module"],[1,"CrateDebugContext","rustc::middle::trans::debuginfo","A context object for maintaining all state needed by the debuginfo module."],[1,"FunctionDebugContext","",""],[3,"finalize","","Create any deferred debug metadata nodes"],[3,"create_global_var_metadata","","Creates debug information for the given global variable."],[3,"create_local_var_metadata","","Creates debug information for the given local variable."],[3,"create_captured_var_metadata","","Creates debug information for a variable captured in a closure."],[3,"create_match_binding_metadata","","Creates debug information for a local variable introduced in the head of a\nmatch-statement arm."],[3,"create_argument_metadata","","Creates debug information for the given function argument."],[3,"set_source_location","","Sets the current debug location at the beginning of the span."],[3,"clear_source_location","","Clears the current debug location."],[3,"start_emitting_source_locations","","Enables emitting source locations for the given functions."],[3,"create_function_debug_context","","Creates the function-specific debug context."],[10,"new","","",168],[0,"machine","rustc::middle::trans",""],[3,"llsize_of_store","rustc::middle::trans::machine",""],[3,"llsize_of_alloc","",""],[3,"llsize_of_real","",""],[3,"llbitsize_of_real","","Returns the \"real\" size of the type in bits."],[3,"llsize_of","","Returns the size of the type as an LLVM constant integer value."],[3,"nonzero_llsize_of","",""],[3,"llalign_of_pref","",""],[3,"llalign_of_min","",""],[3,"llalign_of","",""],[3,"llelement_offset","",""],[0,"adt","rustc::middle::trans","# Representation of Algebraic Data Types"],[1,"Struct","rustc::middle::trans::adt","For structs, and struct-like parts of anything fancier."],[11,"size","","",169],[11,"align","","",169],[11,"packed","","",169],[11,"fields","","",169],[2,"Repr","","Representations."],[12,"CEnum","","C-like enums; basically an int.",170],[12,"Univariant","","Single-case variants, and structs/tuples/records.",170],[12,"General","","General-case enums: for each case there is a struct, and they\nall start with a field for the discriminant.",170],[12,"RawNullablePointer","","Two cases distinguished by a nullable pointer: the case with discriminant\n`nndiscr` must have single field which is known to be nonnull due to its type.\nThe other case is known to be zero sized. Hence we represent the enum\nas simply a nullable pointer: if not null it indicates the `nndiscr` variant,\notherwise it indicates the other case.",170],[11,"nndiscr","rustc::middle::trans::adt::Repr","",170],[11,"nnty","","",170],[11,"nullfields","","",170],[12,"StructWrappedNullablePointer","rustc::middle::trans::adt","Two cases distinguished by a nullable pointer: the case with discriminant\n`nndiscr` is represented by the struct `nonnull`, where the `ptrfield`th\nfield is known to be nonnull due to its type; if that field is null, then\nit represents the other case, which is inhabited by at most one value\n(and all other fields are undefined/unused).",170],[11,"nonnull","rustc::middle::trans::adt::Repr","",170],[11,"nndiscr","","",170],[11,"ptrfield","","",170],[11,"nullfields","","",170],[2,"PointerField","rustc::middle::trans::adt",""],[12,"ThinPointer","","",171],[12,"FatPointer","","",171],[3,"represent_node","","Convenience for `represent_type`.  There should probably be more or\nthese, for places in trans where the `ty::t` isn't directly\navailable."],[3,"represent_type","","Decides how to represent a given type."],[3,"is_ffi_safe","","Determine, without doing translation, whether an ADT must be FFI-safe.\nFor use in lint or similar, where being sound but slightly incomplete is acceptable."],[3,"ll_inttype","",""],[3,"ty_of_inttype","",""],[3,"type_of","","LLVM-level types are a little complicated."],[3,"sizing_type_of","",""],[3,"incomplete_type_of","",""],[3,"finish_type_of","",""],[3,"trans_switch","","Obtain a representation of the discriminant sufficient to translate\ndestructuring; this may or may not involve the actual discriminant."],[3,"trans_get_discr","","Obtain the actual discriminant of a value."],[3,"trans_case","","Yield information about how to dispatch a case of the\ndiscriminant-like value returned by `trans_switch`."],[3,"trans_set_discr","","Set the discriminant for a new value of the given case of the given\nrepresentation."],[3,"num_args","","The number of fields in a given case; for use when obtaining this\ninformation from the type or definition is less convenient."],[3,"trans_field_ptr","","Access a field, at a point when the value's case is known."],[3,"struct_field_ptr","",""],[3,"fold_variants","",""],[3,"trans_drop_flag_ptr","","Access the struct drop flag, if present."],[3,"trans_const","","Construct a constant value, suitable for initializing a\nGlobalVariable, given a case and constant values for its fields.\nNote that this may have a different LLVM type (and different\nalignment!) from the representation's `type_of`, so it needs a\npointer cast before use."],[3,"const_get_discrim","","Get the discriminant of a constant value.  (Not currently used.)"],[3,"const_get_field","","Extract a field of a constant value, as appropriate for its\nrepresentation."],[10,"fmt","","",171],[0,"asm","rustc::middle::trans","# Translation of inline assembly."],[3,"trans_inline_asm","rustc::middle::trans::asm",""],[0,"type_","rustc::middle::trans",""],[1,"Type","rustc::middle::trans::type_",""],[1,"TypeNames","",""],[10,"fmt","","",172],[10,"eq","","",172],[10,"ne","","",172],[10,"clone","","",172],[10,"from_ref","","",172],[10,"to_ref","","",172],[10,"void","","",172],[10,"nil","","",172],[10,"metadata","","",172],[10,"i1","","",172],[10,"i8","","",172],[10,"i16","","",172],[10,"i32","","",172],[10,"i64","","",172],[10,"f32","","",172],[10,"f64","","",172],[10,"bool","","",172],[10,"char","","",172],[10,"i8p","","",172],[10,"int","","",172],[10,"int_from_ty","","",172],[10,"uint_from_ty","","",172],[10,"float_from_ty","","",172],[10,"func","","",172],[10,"variadic_func","","",172],[10,"struct_","","",172],[10,"named_struct","","",172],[10,"empty_struct","","",172],[10,"vtable","","",172],[10,"generic_glue_fn","","",172],[10,"glue_fn","","",172],[10,"tydesc","","",172],[10,"array","","",172],[10,"vector","","",172],[10,"vec","","",172],[10,"opaque_vec","","",172],[10,"at_box","","",172],[10,"opaque_trait","","",172],[10,"kind","","",172],[10,"set_struct_body","","",172],[10,"ptr_to","","",172],[10,"is_packed","","",172],[10,"element_type","","",172],[10,"array_length","","",172],[10,"field_types","","",172],[10,"return_type","","",172],[10,"func_params","","",172],[10,"float_width","","",172],[10,"new","","",173],[10,"associate_type","","",173],[10,"find_type","","",173],[10,"type_to_string","","",173],[10,"types_to_str","","",173],[10,"val_to_string","","",173],[0,"value","rustc::middle::trans",""],[1,"Value","rustc::middle::trans::value",""],[1,"Use","",""],[1,"Users","","Iterator for the users of a value"],[10,"get","","Returns the native ValueRef",174],[10,"get_parent","","Returns the BasicBlock that contains this value",174],[10,"erase_from_parent","","Removes this value from its containing BasicBlock",174],[10,"get_dominating_store","","Returns the single dominating store to this value, if any\nThis only performs a search for a trivially dominating store. The store\nmust be the only user of this value, and there must not be any conditional\nbranches between the store and the given block.",174],[10,"get_first_use","","Returns the first use of this value, if any",174],[10,"has_no_uses","","Tests if there are no uses of this value",174],[10,"get_single_user","","Returns the single user of this value\nIf there are no users or multiple users, this returns None",174],[10,"user_iter","","Returns an iterator for the users of this value",174],[10,"get_operand","","Returns the requested operand of this instruction\nReturns None, if there's no operand at the given index",174],[10,"as_store_inst","","Returns the Store represent by this value, if any",174],[10,"is_a_terminator_inst","","Tests if this value is a terminator instruction",174],[10,"get","","",175],[10,"get_user","","",175],[10,"get_next_use","","",175],[10,"next","","",176],[0,"basic_block","rustc::middle::trans",""],[1,"BasicBlock","rustc::middle::trans::basic_block",""],[4,"Preds","",""],[10,"get","","",177],[10,"as_value","","",177],[10,"pred_iter","","",177],[10,"get_single_predecessor","","",177],[0,"llrepr","rustc::middle::trans",""],[6,"LlvmRepr","rustc::middle::trans::llrepr",""],[9,"llrepr","","",178],[10,"llrepr","rustc::middle::trans::type_","",172],[10,"llrepr","rustc_llvm","",179],[0,"cleanup","rustc::middle::trans","Code pertaining to cleanup of temporaries as well as execution of\ndrop glue. See discussion in `doc.rs` for a high-level summary."],[1,"CleanupScope","rustc::middle::trans::cleanup",""],[1,"CustomScopeIndex","",""],[1,"CachedEarlyExit","",""],[1,"DropValue","",""],[1,"FreeValue","",""],[1,"LifetimeEnd","",""],[2,"CleanupScopeKind","",""],[12,"CustomScopeKind","","",180],[12,"AstScopeKind","","",180],[12,"LoopScopeKind","","",180],[2,"EarlyExitLabel","",""],[12,"UnwindExit","","",181],[12,"ReturnExit","","",181],[12,"LoopExit","","",181],[2,"ScopeId","",""],[12,"AstScope","","",182],[12,"CustomScope","","",182],[2,"Heap","",""],[12,"HeapManaged","","",183],[12,"HeapExchange","","",183],[3,"temporary_scope","",""],[3,"var_scope","",""],[5,"EXIT_BREAK","",""],[5,"EXIT_LOOP","",""],[5,"EXIT_MAX","",""],[6,"Cleanup","",""],[9,"must_unwind","","",184],[9,"clean_on_unwind","","",184],[9,"trans","","",184],[6,"CleanupMethods","",""],[9,"push_ast_cleanup_scope","","",185],[9,"push_loop_cleanup_scope","","",185],[9,"push_custom_cleanup_scope","","",185],[9,"pop_and_trans_ast_cleanup_scope","","",185],[9,"pop_loop_cleanup_scope","","",185],[9,"pop_custom_cleanup_scope","","",185],[9,"pop_and_trans_custom_cleanup_scope","","",185],[9,"top_loop_scope","","",185],[9,"normal_exit_block","","",185],[9,"return_exit_block","","",185],[9,"schedule_lifetime_end","","",185],[9,"schedule_drop_mem","","",185],[9,"schedule_drop_and_zero_mem","","",185],[9,"schedule_drop_immediate","","",185],[9,"schedule_free_value","","",185],[9,"schedule_clean","","",185],[9,"schedule_clean_in_ast_scope","","",185],[9,"schedule_clean_in_custom_scope","","",185],[9,"needs_invoke","","",185],[9,"get_landing_pad","","",185],[6,"CleanupHelperMethods","",""],[9,"top_ast_scope","","",186],[9,"top_nonempty_cleanup_scope","","",186],[9,"is_valid_to_pop_custom_scope","","",186],[9,"is_valid_custom_scope","","",186],[9,"trans_scope_cleanups","","",186],[9,"trans_cleanups_to_exit_scope","","",186],[9,"get_or_create_landing_pad","","",186],[9,"scopes_len","","",186],[9,"push_scope","","",186],[9,"pop_scope","","",186],[9,"top_scope","","",186],[10,"eq","","",181],[10,"ne","","",181],[10,"push_ast_cleanup_scope","rustc::middle::trans::common","Invoked when we start to trans the code contained\nwithin a new cleanup scope.",140],[10,"push_loop_cleanup_scope","","",140],[10,"push_custom_cleanup_scope","","",140],[10,"pop_and_trans_ast_cleanup_scope","","Removes the cleanup scope for id `cleanup_scope`, which\nmust be at the top of the cleanup stack, and generates the\ncode to do its cleanups for normal exit.",140],[10,"pop_loop_cleanup_scope","","Removes the loop cleanup scope for id `cleanup_scope`, which\nmust be at the top of the cleanup stack. Does not generate\nany cleanup code, since loop scopes should exit by\nbranching to a block generated by `normal_exit_block`.",140],[10,"pop_custom_cleanup_scope","","Removes the top cleanup scope from the stack without\nexecuting its cleanups. The top cleanup scope must\nbe the temporary scope `custom_scope`.",140],[10,"pop_and_trans_custom_cleanup_scope","","Removes the top cleanup scope from the stack, which must be\na temporary scope, and generates the code to do its\ncleanups for normal exit.",140],[10,"top_loop_scope","","Returns the id of the top-most loop scope",140],[10,"normal_exit_block","","Returns a block to branch to which will perform all pending\ncleanups and then break/continue (depending on `exit`) out\nof the loop with id `cleanup_scope`",140],[10,"return_exit_block","","Returns a block to branch to which will perform all pending\ncleanups and then return from this function",140],[10,"schedule_lifetime_end","","",140],[10,"schedule_drop_mem","","Schedules a (deep) drop of `val`, which is a pointer to an\ninstance of `ty`",140],[10,"schedule_drop_and_zero_mem","","Schedules a (deep) drop and zero-ing of `val`, which is a pointer\nto an instance of `ty`",140],[10,"schedule_drop_immediate","","Schedules a (deep) drop of `val`, which is an instance of `ty`",140],[10,"schedule_free_value","","Schedules a call to `free(val)`. Note that this is a shallow\noperation.",140],[10,"schedule_clean","","",140],[10,"schedule_clean_in_ast_scope","","Schedules a cleanup to occur upon exit from `cleanup_scope`.\nIf `cleanup_scope` is not provided, then the cleanup is scheduled\nin the topmost scope, which must be a temporary scope.",140],[10,"schedule_clean_in_custom_scope","","Schedules a cleanup to occur in the top-most scope,\nwhich must be a temporary scope.",140],[10,"needs_invoke","","Returns true if there are pending cleanups that should\nexecute on failure.",140],[10,"get_landing_pad","","Returns a basic block to branch to in the event of a failure.\nThis block will run the failure cleanups and eventually\ninvoke the LLVM `Resume` instruction.",140],[10,"top_ast_scope","","Returns the id of the current top-most AST scope, if any.",140],[10,"top_nonempty_cleanup_scope","","",140],[10,"is_valid_to_pop_custom_scope","","",140],[10,"is_valid_custom_scope","","",140],[10,"trans_scope_cleanups","","Generates the cleanups for `scope` into `bcx`",140],[10,"scopes_len","","",140],[10,"push_scope","","",140],[10,"pop_scope","","",140],[10,"top_scope","","",140],[10,"trans_cleanups_to_exit_scope","","Used when the caller wishes to jump to an early exit, such\nas a return, break, continue, or unwind. This function will\ngenerate all cleanups between the top of the stack and the\nexit `label` and return a basic block that the caller can\nbranch to.",140],[10,"get_or_create_landing_pad","","Creates a landing pad for the top scope, if one does not\nexist.  The landing pad will perform all cleanups necessary\nfor an unwind and then `resume` to continue error\npropagation:",140],[10,"must_unwind","rustc::middle::trans::cleanup","",187],[10,"clean_on_unwind","","",187],[10,"trans","","",187],[10,"must_unwind","","",188],[10,"clean_on_unwind","","",188],[10,"trans","","",188],[10,"must_unwind","","",189],[10,"clean_on_unwind","","",189],[10,"trans","","",189],[0,"ty","rustc::middle",""],[1,"field","rustc::middle::ty",""],[11,"ident","","",190],[11,"mt","","",190],[1,"Method","",""],[11,"ident","","",191],[11,"generics","","",191],[11,"fty","","",191],[11,"explicit_self","","",191],[11,"vis","","",191],[11,"def_id","","",191],[11,"container","","",191],[11,"provided_source","","",191],[1,"mt","",""],[11,"ty","","",192],[11,"mutbl","","",192],[1,"field_ty","",""],[11,"name","","",193],[11,"id","","",193],[11,"vis","","",193],[11,"origin","","",193],[1,"creader_cache_key","",""],[11,"cnum","","",194],[11,"pos","","",194],[11,"len","","",194],[1,"intern_key","",""],[1,"ItemVariances","",""],[11,"types","","",195],[11,"regions","","",195],[1,"AutoDerefRef","",""],[11,"autoderefs","","",196],[11,"autoref","","",196],[1,"TransmuteRestriction","","A restriction that certain types must be the same size. The use of\n`transmute` gives rise to these restrictions."],[11,"span","","The span from whence the restriction comes.",197],[11,"from","","The type being transmuted from.",197],[11,"to","","The type being transmuted to.",197],[1,"ctxt","","The data structure to keep track of all the information that typechecker\ngenerates so that so that it can be reused and doesn't have to be redone\nlater on."],[11,"interner","","Specifically use a speedy hash algorithm for this hash map, it's used\nquite often.",198],[11,"next_id","","",198],[11,"sess","","",198],[11,"def_map","","",198],[11,"named_region_map","","",198],[11,"region_maps","","",198],[11,"node_types","","Stores the types for various nodes in the AST.  Note that this table\nis not guaranteed to be populated until after typeck.  See\ntypeck::check::fn_ctxt for details.",198],[11,"item_substs","","Stores the type parameters which were substituted to obtain the type\nof this node.  This only applies to nodes that refer to entities\nparam<eterized by type parameters, such as generic fns, types, or\nother items.",198],[11,"methods","","Maps from a method to the method \"descriptor\"",198],[11,"trait_method_def_ids","","Maps from a trait def-id to a list of the def-ids of its methods",198],[11,"trait_methods_cache","","A cache for the trait_methods() routine",198],[11,"impl_trait_cache","","",198],[11,"trait_refs","","",198],[11,"trait_defs","","",198],[11,"map","","",198],[11,"intrinsic_defs","","",198],[11,"freevars","","",198],[11,"tcache","","",198],[11,"rcache","","",198],[11,"short_names_cache","","",198],[11,"needs_unwind_cleanup_cache","","",198],[11,"tc_cache","","",198],[11,"ast_ty_to_ty_cache","","",198],[11,"enum_var_cache","","",198],[11,"ty_param_defs","","",198],[11,"adjustments","","",198],[11,"normalized_cache","","",198],[11,"lang_items","","",198],[11,"provided_method_sources","","A mapping of fake provided method def_ids to the default implementation",198],[11,"supertraits","","",198],[11,"superstructs","","",198],[11,"struct_fields","","",198],[11,"item_variance_map","","Maps from def-id of a type or region parameter to its\n(inferred) variance.",198],[11,"variance_computed","","True if the variance has been computed yet; false otherwise.",198],[11,"destructor_for_type","","A mapping from the def ID of an enum or struct type to the def ID\nof the method that implements its destructor. If the type is not\npresent in this map, it does not have a destructor. This map is\npopulated during the coherence phase of typechecking.",198],[11,"destructors","","A method will be in this list if and only if it is a destructor.",198],[11,"trait_impls","","Maps a trait onto a list of impls of that trait.",198],[11,"inherent_impls","","Maps a DefId of a type to a list of its inherent impls.\nContains implementations of methods that are inherent to a type.\nMethods in these implementations don't need to be exported.",198],[11,"impl_methods","","Maps a DefId of an impl to a list of its methods.\nNote that this contains all of the impls that we know about,\nincluding ones in other crates. It's not clear that this is the best\nway to do it.",198],[11,"used_unsafe","","Set of used unsafe nodes (functions or blocks). Unsafe nodes not\npresent in this set can be warned about.",198],[11,"used_mut_nodes","","Set of nodes which mark locals as mutable which end up getting used at\nsome point. Local variable definitions not in this set can be warned\nabout.",198],[11,"impl_vtables","","vtable resolution information for impl declarations",198],[11,"populated_external_types","","The set of external nominal types whose implementations have been read.\nThis is used for lazy resolution of methods.",198],[11,"populated_external_traits","","The set of external traits whose implementations have been read. This\nis used for lazy resolution of traits.",198],[11,"upvar_borrow_map","","Borrows",198],[11,"extern_const_statics","","These two caches are used by const_eval when decoding external statics\nand variants that are found.",198],[11,"extern_const_variants","","",198],[11,"method_map","","",198],[11,"vtable_map","","",198],[11,"dependency_formats","","",198],[11,"unboxed_closure_types","","Records the type of each unboxed closure. The def ID is the ID of the\nexpression defining the unboxed closure.",198],[11,"node_lint_levels","","",198],[11,"transmute_restrictions","","The types that must be asserted to be the same size for `transmute`\nto be valid. We gather up these restrictions in the intrinsicck pass\nand check them in trans.",198],[11,"stability","","Maps any item's def-id to its stability index.",198],[1,"t_box_","",""],[11,"sty","","",199],[11,"id","","",199],[11,"flags","","",199],[1,"t","",""],[1,"BareFnTy","",""],[11,"fn_style","","",200],[11,"abi","","",200],[11,"sig","","",200],[1,"ClosureTy","",""],[11,"fn_style","","",201],[11,"onceness","","",201],[11,"store","","",201],[11,"bounds","","",201],[11,"sig","","",201],[11,"abi","","",201],[1,"FnSig","","Signature of a function type, which I have arbitrarily\ndecided to use to refer to the input/output types."],[11,"binder_id","","",202],[11,"inputs","","",202],[11,"output","","",202],[11,"variadic","","",202],[1,"ParamTy","",""],[11,"space","","",203],[11,"idx","","",203],[11,"def_id","","",203],[1,"UpvarId","","Upvars do not get their own node-id. Instead, we use the pair of\nthe original var id (that is, the root variable that is referenced\nby the upvar) and the id of the closure expression."],[11,"var_id","","",204],[11,"closure_expr_id","","",204],[1,"UpvarBorrow","","Information describing the borrowing of an upvar. This is computed\nduring `typeck`, specifically by `regionck`. The general idea is\nthat the compiler analyses treat closures like:"],[11,"kind","","",205],[11,"region","","",205],[1,"FreeRegion","",""],[11,"scope_id","","",206],[11,"bound_region","","",206],[1,"TyTrait","",""],[11,"def_id","","",207],[11,"substs","","",207],[11,"bounds","","",207],[1,"TraitRef","",""],[11,"def_id","","",208],[11,"substs","","",208],[1,"expected_found","",""],[11,"expected","","",209],[11,"found","","",209],[1,"ParamBounds","",""],[11,"builtin_bounds","","",210],[11,"trait_bounds","","",210],[1,"TyVid","",""],[11,"index","","",211],[1,"IntVid","",""],[11,"index","","",212],[1,"FloatVid","",""],[11,"index","","",213],[1,"RegionVid","",""],[11,"index","","",214],[1,"TypeParameterDef","",""],[11,"ident","","",215],[11,"def_id","","",215],[11,"space","","",215],[11,"index","","",215],[11,"bounds","","",215],[11,"default","","",215],[1,"RegionParameterDef","",""],[11,"name","","",216],[11,"def_id","","",216],[11,"space","","",216],[11,"index","","",216],[1,"Generics","","Information about the type/lifetime parameters associated with an\nitem or method. Analogous to ast::Generics."],[11,"types","","",217],[11,"regions","","",217],[1,"ParameterEnvironment","","When type checking, we use the `ParameterEnvironment` to track\ndetails about the type/lifetime parameters that are in scope.\nIt primarily stores the bounds information."],[11,"free_substs","","A substitution that can be applied to move from\nthe \"outer\" view of a type or method to the \"inner\" view.\nIn general, this means converting from bound parameters to\nfree parameters. Since we currently represent bound/free type\nparameters in the same way, this only has an affect on regions.",218],[11,"bounds","","Bounds on the various type parameters",218],[1,"Polytype","","A polytype."],[11,"generics","","",219],[11,"ty","","",219],[1,"TraitDef","","As `Polytype` but for a trait ref."],[11,"generics","","",220],[11,"bounds","","",220],[11,"trait_ref","","",220],[1,"ItemSubsts","","Records the substitutions used to translate the polytype for an\nitem into the monotype of an item reference."],[11,"substs","","",221],[1,"TypeContents","","Type contents is how the type checker reasons about kinds.\nThey track what kinds of things are found within a type.  You can\nthink of them as kind of an \"anti-kind\".  They track the kinds of values\nand thinks that are contained in types.  Having a larger contents for\na type tends to rule that type *out* from various kinds.  For example,\na type that contains a reference is not sendable."],[11,"bits","","",222],[1,"VariantInfo","",""],[11,"args","","",223],[11,"arg_names","","",223],[11,"ctor_ty","","",223],[11,"name","","",223],[11,"id","","",223],[11,"disr_val","","",223],[11,"vis","","",223],[1,"UnboxedClosureUpvar","",""],[11,"def","","",224],[11,"span","","",224],[11,"ty","","",224],[2,"MethodContainer","",""],[12,"TraitContainer","","",225],[12,"ImplContainer","","",225],[2,"TraitStore","",""],[12,"UniqTraitStore","","Box<Trait>",226],[12,"RegionTraitStore","","&Trait and &mut Trait",226],[2,"ast_ty_to_ty_cache_entry","",""],[12,"atttce_unresolved","","",227],[12,"atttce_resolved","","",227],[2,"Variance","",""],[12,"Covariant","","",228],[12,"Invariant","","",228],[12,"Contravariant","","",228],[12,"Bivariant","","",228],[2,"AutoAdjustment","",""],[12,"AutoAddEnv","","",229],[12,"AutoDerefRef","","",229],[12,"AutoObject","","",229],[2,"AutoRef","",""],[12,"AutoPtr","","Convert from T to &T",230],[12,"AutoBorrowVec","","Convert from ~[]/&[] to &[] or str",230],[12,"AutoBorrowVecRef","","Convert from ~[]/&[] to &&[] or str",230],[12,"AutoUnsafe","","Convert from T to *T",230],[12,"AutoBorrowObj","","Convert from Box<Trait>/&Trait to &Trait",230],[2,"tbox_flag","",""],[12,"has_params","","",231],[12,"has_self","","",231],[12,"needs_infer","","",231],[12,"has_regions","","",231],[12,"has_ty_err","","",231],[12,"has_ty_bot","","",231],[12,"needs_subst","","",231],[2,"Region","","Representation of regions:"],[12,"ReEarlyBound","","",232],[12,"ReLateBound","","",232],[12,"ReFree","","When checking a function body, the types of all arguments and so forth\nthat refer to bound region parameters are modified to refer to free\nregion parameters.",232],[12,"ReScope","","A concrete region naming some expression within the current function.",232],[12,"ReStatic","","Static data that has an \"infinite\" lifetime. Top in the region lattice.",232],[12,"ReInfer","","A region variable.  Should not exist after typeck.",232],[12,"ReEmpty","","Empty lifetime is for data that is never accessed.\nBottom in the region lattice. We treat ReEmpty somewhat\nspecially; at least right now, we do not generate instances of\nit during the GLB computations, but rather\ngenerate an error instead. This is to improve error messages.\nThe only way to get an instance of ReEmpty is to have a region\nvariable with no constraints.",232],[2,"BorrowKind","",""],[12,"ImmBorrow","","Data must be immutable and is aliasable.",233],[12,"UniqueImmBorrow","","Data must be immutable but not aliasable.  This kind of borrow\ncannot currently be expressed by the user and is used only in\nimplicit closure bindings. It is needed when you the closure\nis borrowing or mutating a mutable referent, e.g.:",233],[12,"MutBorrow","","Data is mutable and not aliasable.",233],[2,"BoundRegion","",""],[12,"BrAnon","","An anonymous region parameter for a given fn (&T)",234],[12,"BrNamed","","Named region parameters for functions (a in &'a T)",234],[12,"BrFresh","","Fresh bound identifiers created during GLB computations.",234],[2,"sty","",""],[12,"ty_nil","","",235],[12,"ty_bot","","",235],[12,"ty_bool","","",235],[12,"ty_char","","",235],[12,"ty_int","","",235],[12,"ty_uint","","",235],[12,"ty_float","","",235],[12,"ty_enum","","",235],[12,"ty_box","","",235],[12,"ty_uniq","","",235],[12,"ty_str","","",235],[12,"ty_vec","","",235],[12,"ty_ptr","","",235],[12,"ty_rptr","","",235],[12,"ty_bare_fn","","",235],[12,"ty_closure","","",235],[12,"ty_trait","","",235],[12,"ty_struct","","",235],[12,"ty_unboxed_closure","","",235],[12,"ty_tup","","",235],[12,"ty_param","","",235],[12,"ty_infer","","",235],[12,"ty_err","","",235],[2,"IntVarValue","",""],[12,"IntType","","",236],[12,"UintType","","",236],[2,"terr_vstore_kind","",""],[12,"terr_vec","","",237],[12,"terr_str","","",237],[12,"terr_fn","","",237],[12,"terr_trait","","",237],[2,"type_err","",""],[12,"terr_mismatch","","",238],[12,"terr_fn_style_mismatch","","",238],[12,"terr_onceness_mismatch","","",238],[12,"terr_abi_mismatch","","",238],[12,"terr_mutability","","",238],[12,"terr_sigil_mismatch","","",238],[12,"terr_box_mutability","","",238],[12,"terr_ptr_mutability","","",238],[12,"terr_ref_mutability","","",238],[12,"terr_vec_mutability","","",238],[12,"terr_tuple_size","","",238],[12,"terr_ty_param_size","","",238],[12,"terr_record_size","","",238],[12,"terr_record_mutability","","",238],[12,"terr_record_fields","","",238],[12,"terr_arg_count","","",238],[12,"terr_regions_does_not_outlive","","",238],[12,"terr_regions_not_same","","",238],[12,"terr_regions_no_overlap","","",238],[12,"terr_regions_insufficiently_polymorphic","","",238],[12,"terr_regions_overly_polymorphic","","",238],[12,"terr_trait_stores_differ","","",238],[12,"terr_sorts","","",238],[12,"terr_integer_as_char","","",238],[12,"terr_int_mismatch","","",238],[12,"terr_float_mismatch","","",238],[12,"terr_traits","","",238],[12,"terr_builtin_bounds","","",238],[12,"terr_variadic_mismatch","","",238],[2,"BuiltinBound","",""],[12,"BoundStatic","","",239],[12,"BoundSend","","",239],[12,"BoundSized","","",239],[12,"BoundCopy","","",239],[12,"BoundShare","","",239],[2,"InferTy","",""],[12,"TyVar","","",240],[12,"IntVar","","",240],[12,"FloatVar","","",240],[2,"InferRegion","",""],[12,"ReVar","","",241],[12,"ReSkolemized","","",241],[2,"Representability","","Describes whether a type is representable. For types that are not\nrepresentable, 'SelfRecursive' and 'ContainsRecursive' are used to\ndistinguish between types that are recursive with themselves and types that\ncontain a different recursive type. These cases can therefore be treated\ndifferently when reporting errors."],[12,"Representable","","",242],[12,"SelfRecursive","","",242],[12,"ContainsRecursive","","",242],[2,"ExprKind","","We categorize expressions into three kinds.  The distinction between\nlvalue/rvalue is fundamental to the language.  The distinction between the\ntwo kinds of rvalues is an artifact of trans which reflects how we will\ngenerate code for that kind of expression.  See trans/expr.rs for more\ninformation."],[12,"LvalueExpr","","",243],[12,"RvalueDpsExpr","","",243],[12,"RvalueDatumExpr","","",243],[12,"RvalueStmtExpr","","",243],[2,"DtorKind","",""],[12,"NoDtor","","",244],[12,"TraitDtor","","",244],[2,"ExplicitSelfCategory","","The category of explicit self."],[12,"StaticExplicitSelfCategory","","",245],[12,"ByValueExplicitSelfCategory","","",245],[12,"ByReferenceExplicitSelfCategory","","",245],[12,"ByBoxExplicitSelfCategory","","",245],[3,"get","",""],[3,"tbox_has_flag","",""],[3,"type_has_params","",""],[3,"type_has_self","",""],[3,"type_needs_infer","",""],[3,"type_id","",""],[3,"empty_builtin_bounds","",""],[3,"all_builtin_bounds","",""],[3,"mk_ctxt","",""],[3,"mk_t","",""],[3,"mk_prim_t","",""],[3,"mk_nil","",""],[3,"mk_err","",""],[3,"mk_bot","",""],[3,"mk_bool","",""],[3,"mk_int","",""],[3,"mk_i8","",""],[3,"mk_i16","",""],[3,"mk_i32","",""],[3,"mk_i64","",""],[3,"mk_f32","",""],[3,"mk_f64","",""],[3,"mk_uint","",""],[3,"mk_u8","",""],[3,"mk_u16","",""],[3,"mk_u32","",""],[3,"mk_u64","",""],[3,"mk_mach_int","",""],[3,"mk_mach_uint","",""],[3,"mk_mach_float","",""],[3,"mk_char","",""],[3,"mk_str","",""],[3,"mk_str_slice","",""],[3,"mk_enum","",""],[3,"mk_box","",""],[3,"mk_uniq","",""],[3,"mk_ptr","",""],[3,"mk_rptr","",""],[3,"mk_mut_rptr","",""],[3,"mk_imm_rptr","",""],[3,"mk_mut_ptr","",""],[3,"mk_imm_ptr","",""],[3,"mk_nil_ptr","",""],[3,"mk_vec","",""],[3,"mk_slice","",""],[3,"mk_tup","",""],[3,"mk_closure","",""],[3,"mk_bare_fn","",""],[3,"mk_ctor_fn","",""],[3,"mk_trait","",""],[3,"mk_struct","",""],[3,"mk_unboxed_closure","",""],[3,"mk_var","",""],[3,"mk_int_var","",""],[3,"mk_float_var","",""],[3,"mk_infer","",""],[3,"mk_param","",""],[3,"mk_self_type","",""],[3,"mk_param_from_def","",""],[3,"walk_ty","",""],[3,"maybe_walk_ty","",""],[3,"fold_ty","",""],[3,"walk_regions_and_ty","",""],[3,"type_is_nil","",""],[3,"type_is_bot","",""],[3,"type_is_error","",""],[3,"type_needs_subst","",""],[3,"trait_ref_contains_error","",""],[3,"type_is_ty_var","",""],[3,"type_is_bool","",""],[3,"type_is_self","",""],[3,"type_is_vec","",""],[3,"type_is_structural","",""],[3,"type_is_simd","",""],[3,"sequence_element_type","",""],[3,"simd_type","",""],[3,"simd_size","",""],[3,"type_is_boxed","",""],[3,"type_is_region_ptr","",""],[3,"type_is_unsafe_ptr","",""],[3,"type_is_unique","",""],[3,"type_is_scalar","",""],[3,"type_is_floating_point","","Returns true if this type is a floating point type and false otherwise."],[3,"type_needs_drop","",""],[3,"type_needs_unwind_cleanup","",""],[3,"type_is_static","",""],[3,"type_is_sendable","",""],[3,"type_interior_is_unsafe","",""],[3,"type_contents","",""],[3,"type_moves_by_default","",""],[3,"is_instantiable","",""],[3,"is_type_representable","","Check whether a type is representable. This means it cannot contain unboxed\nstructural recursion. This check is needed for structs and enums."],[3,"type_is_trait","",""],[3,"type_is_integral","",""],[3,"type_is_uint","",""],[3,"type_is_char","",""],[3,"type_is_bare_fn","",""],[3,"type_is_fp","",""],[3,"type_is_numeric","",""],[3,"type_is_signed","",""],[3,"type_is_machine","",""],[3,"type_is_sized","",""],[3,"type_is_c_like_enum","",""],[3,"deref","",""],[3,"index","",""],[3,"array_element_ty","",""],[3,"node_id_to_trait_ref","",""],[3,"try_node_id_to_type","",""],[3,"node_id_to_type","",""],[3,"node_id_to_type_opt","",""],[3,"node_id_item_substs","",""],[3,"fn_is_variadic","",""],[3,"ty_fn_sig","",""],[3,"ty_fn_abi","","Returns the ABI of the given function."],[3,"ty_fn_args","",""],[3,"ty_closure_store","",""],[3,"ty_fn_ret","",""],[3,"is_fn_ty","",""],[3,"ty_region","",""],[3,"free_region_from_def","",""],[3,"pat_ty","",""],[3,"expr_ty","",""],[3,"expr_ty_opt","",""],[3,"expr_ty_adjusted","","\nReturns the type of `expr`, considering any `AutoAdjustment`\nentry recorded for that expression."],[3,"expr_span","",""],[3,"local_var_name_str","",""],[3,"adjust_ty","","See `expr_ty_adjusted`"],[3,"method_call_type_param_defs","",""],[3,"resolve_expr","",""],[3,"expr_is_lval","",""],[3,"expr_kind","",""],[3,"stmt_node_id","",""],[3,"field_idx_strict","",""],[3,"method_idx","",""],[3,"param_tys_in_type","","Returns a vector containing the indices of all type parameters that appear\nin `ty`.  The vector may contain duplicates.  Probably should be converted\nto a bitset or some other representation."],[3,"ty_sort_string","",""],[3,"type_err_to_str","","\nExplains the source of a type err in a short,\nhuman readable way.  This is meant to be placed in\nparentheses after some larger message.  You should\nalso invoke `note_and_explain_type_err()` afterwards\nto present additional details, particularly when\nit comes to lifetime-related errors. "],[3,"note_and_explain_type_err","",""],[3,"provided_source","",""],[3,"provided_trait_methods","",""],[3,"trait_supertraits","",""],[3,"trait_ref_supertraits","",""],[3,"trait_method","",""],[3,"trait_methods","",""],[3,"method","",""],[3,"trait_method_def_ids","",""],[3,"impl_trait_ref","",""],[3,"trait_ref_to_def_id","",""],[3,"try_add_builtin_trait","","Checks whether `trait_ref` refers to one of the builtin\ntraits, like `Send`, and adds the corresponding\nbound to the set `builtin_bounds` if so. Returns true if `trait_ref`\nis a builtin trait."],[3,"ty_to_def_id","",""],[3,"substd_enum_variants","",""],[3,"item_path_str","",""],[3,"ty_dtor","",""],[3,"has_dtor","",""],[3,"with_path","",""],[3,"enum_is_univariant","",""],[3,"type_is_empty","",""],[3,"enum_variants","",""],[3,"enum_variant_with_id","",""],[3,"lookup_item_type","",""],[3,"lookup_impl_vtables","",""],[3,"lookup_trait_def","","Given the did of a trait, returns its canonical trait ref."],[3,"each_attr","","Iterate over attributes of a definition."],[3,"has_attr","","Determine whether an item is annotated with an attribute"],[3,"lookup_packed","","Determine whether an item is annotated with `#[packed]`"],[3,"lookup_simd","","Determine whether an item is annotated with `#[simd]`"],[3,"lookup_repr_hint","",""],[3,"lookup_field_type","",""],[3,"lookup_struct_fields","",""],[3,"lookup_struct_field","",""],[3,"struct_fields","",""],[3,"unboxed_closure_upvars","",""],[3,"is_binopable","",""],[3,"normalize_ty","","Returns an equivalent type with all the typedefs and self regions removed."],[3,"eval_repeat_count","",""],[3,"each_bound_trait_and_supertraits","",""],[3,"get_tydesc_ty","",""],[3,"get_opaque_ty","",""],[3,"visitor_object_ty","",""],[3,"item_variances","",""],[3,"record_trait_implementation","","Records a trait-to-implementation mapping."],[3,"populate_implementations_for_type_if_necessary","","Populates the type context with all the implementations for the given type\nif necessary."],[3,"populate_implementations_for_trait_if_necessary","","Populates the type context with all the implementations for the given\ntrait if necessary."],[3,"trait_id_of_impl","","Given the def_id of an impl, return the def_id of the trait it implements.\nIf it implements no trait, return `None`."],[3,"impl_of_method","","If the given def ID describes a method belonging to an impl, return the\nID of the impl that the method belongs to. Otherwise, return `None`."],[3,"trait_of_method","","If the given def ID describes a method belonging to a trait (either a\ndefault method or an implementation of a trait method), return the ID of\nthe trait that the method belongs to. Otherwise, return `None`."],[3,"trait_method_of_method","","If the given def ID describes a method belonging to a trait, (either a\ndefault method or an implementation of a trait method), return the ID of\nthe method inside trait definition (this means that if the given def ID\nis already that of the original trait method, then the return value is\nthe same).\nOtherwise, return `None`."],[3,"hash_crate_independent","","Creates a hash of the type `t` which will be the same no matter what crate\ncontext it's calculated within. This is used by the `type_id` intrinsic."],[3,"construct_parameter_environment","","See `ParameterEnvironment` struct def'n for details"],[3,"accumulate_lifetimes_in_type","","Pushes all the lifetimes in the given type onto the given list. A\n\"lifetime in a type\" is a lifetime specified by a reference or a lifetime\nin a list of type substitutions. This does *not* traverse into nominal\ntypes, nor does it resolve fictitious types."],[4,"Disr","",""],[4,"creader_cache","",""],[4,"t_box","",""],[4,"UpvarBorrowMap","",""],[4,"BuiltinBounds","",""],[4,"type_cache","",""],[4,"node_type_table","",""],[5,"INITIAL_DISCRIMINANT_VALUE","",""],[6,"ExprTyProvider","",""],[9,"expr_ty","","",246],[9,"ty_ctxt","","",246],[10,"hash","","",190],[10,"eq","","",190],[10,"ne","","",190],[10,"clone","","",225],[10,"clone","","",191],[10,"new","","",191],[10,"container_id","","",191],[10,"fmt","","",192],[10,"hash","","",192],[10,"eq","","",192],[10,"ne","","",192],[10,"clone","","",192],[10,"fmt","","",226],[10,"decode","","",226],[10,"encode","","",226],[10,"hash","","",226],[10,"eq","","",226],[10,"ne","","",226],[10,"clone","","",226],[10,"fmt","","",193],[10,"clone","","",193],[10,"hash","","",194],[10,"eq","","",194],[10,"ne","","",194],[10,"eq","","",247],[10,"ne","","",247],[10,"hash","","",247],[10,"encode","","",195],[10,"decode","","",195],[10,"eq","","",195],[10,"ne","","",195],[10,"clone","","",195],[10,"fmt","","",228],[10,"encode","","",228],[10,"decode","","",228],[10,"eq","","",228],[10,"ne","","",228],[10,"clone","","",228],[10,"clone","","",229],[10,"encode","","",196],[10,"decode","","",196],[10,"clone","","",196],[10,"fmt","","",230],[10,"eq","","",230],[10,"ne","","",230],[10,"encode","","",230],[10,"decode","","",230],[10,"clone","","",230],[10,"fmt","","",199],[10,"hash","","",248],[10,"eq","","",248],[10,"ne","","",248],[10,"clone","","",248],[10,"fmt","","",248],[10,"fmt","","",200],[10,"hash","","",200],[10,"eq","","",200],[10,"ne","","",200],[10,"clone","","",200],[10,"fmt","","",201],[10,"hash","","",201],[10,"eq","","",201],[10,"ne","","",201],[10,"clone","","",201],[10,"hash","","",202],[10,"eq","","",202],[10,"ne","","",202],[10,"clone","","",202],[10,"fmt","","",203],[10,"hash","","",203],[10,"eq","","",203],[10,"ne","","",203],[10,"clone","","",203],[10,"fmt","","",232],[10,"decode","","",232],[10,"encode","","",232],[10,"hash","","",232],[10,"eq","","",232],[10,"ne","","",232],[10,"clone","","",232],[10,"hash","","",204],[10,"eq","","",204],[10,"ne","","",204],[10,"clone","","",204],[10,"fmt","","",233],[10,"hash","","",233],[10,"eq","","",233],[10,"ne","","",233],[10,"clone","","",233],[10,"clone","","",205],[10,"eq","","",205],[10,"ne","","",205],[10,"is_bound","","",232],[10,"fmt","","",206],[10,"decode","","",206],[10,"encode","","",206],[10,"hash","","",206],[10,"cmp","","",206],[10,"partial_cmp","","",206],[10,"lt","","",206],[10,"le","","",206],[10,"gt","","",206],[10,"ge","","",206],[10,"eq","","",206],[10,"ne","","",206],[10,"clone","","",206],[10,"fmt","","",234],[10,"decode","","",234],[10,"encode","","",234],[10,"hash","","",234],[10,"cmp","","",234],[10,"partial_cmp","","",234],[10,"lt","","",234],[10,"le","","",234],[10,"gt","","",234],[10,"ge","","",234],[10,"eq","","",234],[10,"ne","","",234],[10,"clone","","",234],[10,"fmt","","",235],[10,"hash","","",235],[10,"eq","","",235],[10,"ne","","",235],[10,"clone","","",235],[10,"fmt","","",207],[10,"hash","","",207],[10,"eq","","",207],[10,"ne","","",207],[10,"clone","","",207],[10,"fmt","","",208],[10,"hash","","",208],[10,"eq","","",208],[10,"ne","","",208],[10,"eq","","",236],[10,"ne","","",236],[10,"clone","","",236],[10,"fmt","","",237],[10,"clone","","",237],[10,"fmt","","",209],[10,"clone","","",209],[10,"fmt","","",238],[10,"clone","","",238],[10,"fmt","","",210],[10,"hash","","",210],[10,"eq","","",210],[10,"ne","","",210],[10,"fmt","","",239],[10,"hash","","",239],[10,"decode","","",239],[10,"eq","","",239],[10,"ne","","",239],[10,"encode","","",239],[10,"clone","","",239],[10,"to_uint","","",239],[10,"from_uint","","",239],[10,"hash","","",211],[10,"eq","","",211],[10,"ne","","",211],[10,"clone","","",211],[10,"hash","","",212],[10,"eq","","",212],[10,"ne","","",212],[10,"clone","","",212],[10,"hash","","",213],[10,"eq","","",213],[10,"ne","","",213],[10,"clone","","",213],[10,"hash","","",214],[10,"decode","","",214],[10,"encode","","",214],[10,"eq","","",214],[10,"ne","","",214],[10,"clone","","",214],[10,"hash","","",240],[10,"eq","","",240],[10,"ne","","",240],[10,"clone","","",240],[10,"fmt","","",241],[10,"hash","","",241],[10,"decode","","",241],[10,"encode","","",241],[10,"clone","","",241],[10,"eq","","",241],[10,"ne","","",241],[10,"fmt","","",211],[10,"fmt","","",212],[10,"fmt","","",213],[10,"fmt","","",214],[10,"fmt","","",202],[10,"fmt","","",240],[10,"fmt","","",236],[10,"fmt","","",215],[10,"clone","","",215],[10,"fmt","","",216],[10,"clone","","",216],[10,"decode","","",216],[10,"encode","","",216],[10,"fmt","","",217],[10,"clone","","",217],[10,"empty","","",217],[10,"has_type_params","","",217],[10,"has_region_params","","",217],[10,"fmt","","",219],[10,"clone","","",219],[10,"clone","","",221],[10,"empty","","",221],[10,"is_noop","","",221],[10,"meets_bound","","",222],[10,"when","","",222],[10,"intersects","","",222],[10,"is_static","","",222],[10,"is_sendable","","",222],[10,"is_sharable","","",222],[10,"owns_managed","","",222],[10,"owns_owned","","",222],[10,"is_sized","","",222],[10,"is_copy","","",222],[10,"interior_unsafe","","",222],[10,"interior_unsized","","",222],[10,"moves_by_default","","",222],[10,"needs_drop","","",222],[10,"owned_pointer","","Includes only those bits that still apply\nwhen indirected through a `Box` pointer",222],[10,"reference","","Includes only those bits that still apply\nwhen indirected through a reference (`&`)",222],[10,"managed_pointer","","Includes only those bits that still apply\nwhen indirected through a managed pointer (`@`)",222],[10,"unsafe_pointer","","Includes only those bits that still apply\nwhen indirected through an unsafe pointer (`*`)",222],[10,"union","","",222],[10,"has_dtor","","",222],[10,"bitor","","",222],[10,"bitand","","",222],[10,"sub","","",222],[10,"fmt","","",222],[10,"eq","","",242],[10,"ne","","",242],[10,"map_region","","",230],[10,"clone","","",223],[10,"from_ast_variant","","Creates a new VariantInfo from the corresponding ast representation.",223],[10,"is_present","","",244],[10,"has_drop_flag","","",244],[10,"expr_ty","","",198],[10,"ty_ctxt","","",198],[10,"to_string","","",228],[10,"from_mutbl","","",233],[10,"to_user_str","","",233],[10,"tcx","","",198],[10,"node_ty","","",198],[10,"node_method_ty","","",198],[10,"adjustments","","",198],[10,"is_method_call","","",198],[10,"temporary_scope","","",198],[10,"upvar_borrow","","",198],[10,"eq","","",245],[10,"ne","","",245],[10,"clone","","",245],[0,"ty_fold","rustc::middle",""],[1,"BottomUpFolder","rustc::middle::ty_fold",""],[11,"tcx","","",249],[11,"fldop","","",249],[1,"RegionFolder","","Folds over the substructure of a type, visiting its component\ntypes and all regions that occur *free* within it."],[3,"super_fold_ty","",""],[3,"super_fold_substs","",""],[3,"super_fold_sig","",""],[3,"super_fold_bare_fn_ty","",""],[3,"super_fold_closure_ty","",""],[3,"super_fold_trait_ref","",""],[3,"super_fold_mt","",""],[3,"super_fold_sty","",""],[3,"super_fold_trait_store","",""],[3,"super_fold_autoref","",""],[3,"super_fold_item_substs","",""],[6,"TypeFoldable","","The TypeFoldable trait is implemented for every type that can be folded.\nBasically, every type that has a corresponding method in TypeFolder."],[9,"fold_with","","",250],[6,"TypeFolder","","The TypeFolder trait defines the actual *folding*. There is a\nmethod defined for every foldable type. Each of these has a\ndefault implementation that does an \"identity\" fold. Within each\nidentity fold, it should invoke `foo.fold_with(self)` to fold each\nsub-item."],[9,"tcx","","",251],[10,"fold_ty","","",251],[10,"fold_mt","","",251],[10,"fold_trait_ref","","",251],[10,"fold_sty","","",251],[10,"fold_substs","","",251],[10,"fold_sig","","",251],[10,"fold_bare_fn_ty","","",251],[10,"fold_closure_ty","","",251],[10,"fold_region","","",251],[10,"fold_trait_store","","",251],[10,"fold_autoref","","",251],[10,"fold_item_substs","","",251],[10,"fold_with","core::option","",28],[10,"fold_with","alloc::rc","",252],[10,"fold_with","collections::vec","",253],[10,"fold_with","syntax::owned_slice","",254],[10,"fold_with","rustc::middle::subst","",119],[10,"fold_with","rustc::middle::ty","",226],[10,"fold_with","","",248],[10,"fold_with","","",200],[10,"fold_with","","",201],[10,"fold_with","","",192],[10,"fold_with","","",202],[10,"fold_with","","",235],[10,"fold_with","","",208],[10,"fold_with","","",232],[10,"fold_with","rustc::middle::subst","",114],[10,"fold_with","rustc::middle::ty","",221],[10,"fold_with","","",230],[10,"fold_with","rustc::middle::ty_fold","",255],[10,"fold_with","rustc::middle::ty","",210],[10,"fold_with","","",215],[10,"fold_with","","",216],[10,"fold_with","","",217],[10,"tcx","rustc::middle::ty_fold","",249],[10,"fold_ty","","",249],[10,"general","","",256],[10,"regions","","",256],[10,"tcx","","",256],[10,"fold_ty","","",256],[10,"fold_region","","",256],[0,"typeck","rustc::middle",""],[1,"param_index","rustc::middle::typeck",""],[11,"space","","",257],[11,"index","","",257],[1,"MethodParam","",""],[11,"trait_id","","",258],[11,"method_num","","",258],[11,"param_num","","",258],[11,"bound_num","","",258],[1,"MethodObject","",""],[11,"trait_id","","",259],[11,"object_trait_id","","",259],[11,"method_num","","",259],[11,"real_index","","",259],[1,"MethodCallee","",""],[11,"origin","","",260],[11,"ty","","",260],[11,"substs","","",260],[1,"MethodCall","","With method calls, we store some extra information in\nside tables (i.e method_map, vtable_map). We use\nMethodCall as a key to index into these tables instead of\njust directly using the expression's NodeId. The reason\nfor this being that we may apply adjustments (coercions)\nwith the resulting expression also needing to use the\nside tables. The problem with this is that we don't\nassign a separate NodeId to this new expression\nand so it would clash with the base expression if both\nneeded to add to the side tables. Thus to disambiguate\nwe also keep track of whether there's an adjustment in\nour key."],[11,"expr_id","","",261],[11,"adjustment","","",261],[1,"TypeAndSubsts","",""],[11,"substs","","",262],[11,"ty","","",262],[1,"CrateCtxt","",""],[2,"MethodOrigin","",""],[12,"MethodStatic","","",263],[12,"MethodStaticUnboxedClosure","","",263],[12,"MethodParam","","",263],[12,"MethodObject","","",263],[2,"ExprAdjustment","",""],[12,"NoAdjustment","","",264],[12,"AutoDeref","","",264],[12,"AutoObject","","",264],[2,"vtable_origin","",""],[12,"vtable_static","","",265],[12,"vtable_param","","",265],[12,"vtable_unboxed_closure","","",265],[12,"vtable_error","","",265],[3,"write_ty_to_tcx","",""],[3,"write_substs_to_tcx","",""],[3,"lookup_def_tcx","",""],[3,"lookup_def_ccx","",""],[3,"no_params","",""],[3,"require_same_types","",""],[3,"check_crate","",""],[0,"check","",""],[1,"Inherited","rustc::middle::typeck::check","Fields that are part of a `FnCtxt` which are inherited by\nclosures defined within the function.  For example:"],[1,"FnStyleState","",""],[11,"def","","",266],[11,"fn_style","","",266],[1,"FnCtxt","",""],[2,"LvaluePreference","",""],[12,"PreferMutLvalue","","",267],[12,"NoPreference","","",267],[2,"DerefArgs","",""],[12,"DontDerefArgs","","",268],[12,"DoDerefArgs","","",268],[3,"check_item_types","",""],[3,"check_struct","",""],[3,"check_item_sized","",""],[3,"check_item","",""],[3,"autoderef","","Executes an autoderef loop for the type `t`. At each step, invokes\n`should_stop` to decide whether to terminate the loop. Returns\nthe final type and number of derefs that it performed."],[3,"valid_range_bounds","",""],[3,"check_expr_has_type","",""],[3,"impl_self_ty","",""],[3,"lookup_field_ty","",""],[3,"require_uint","",""],[3,"require_integral","",""],[3,"check_decl_initializer","",""],[3,"check_decl_local","",""],[3,"check_stmt","",""],[3,"check_block_no_value","",""],[3,"check_const","",""],[3,"check_const_with_ty","",""],[3,"check_representable","","Checks whether a type can be represented in memory. In particular, it\nidentifies types that contain themselves without indirection through a\npointer, which would mean their size is unbounded. This is different from\nthe question of whether a type can be instantiated. See the definition of\n`check_instantiable`."],[3,"check_instantiable","","Checks whether a type can be created without an instance of itself.\nThis is similar but different from the question of whether a type\ncan be represented.  For example, the following type:"],[3,"check_simd","",""],[3,"check_enum_variants_sized","",""],[3,"check_enum_variants","",""],[3,"lookup_def","",""],[3,"polytype_for_def","",""],[3,"instantiate_path","",""],[3,"structurally_resolved_type","",""],[3,"structure_of","",""],[3,"type_is_integral","",""],[3,"type_is_uint","",""],[3,"ast_expr_vstore_to_ty","",""],[3,"may_break","",""],[3,"check_bounds_are_used","",""],[3,"check_intrinsic_type","",""],[0,"_match","",""],[1,"pat_ctxt","rustc::middle::typeck::check::_match",""],[11,"fcx","","",269],[11,"map","","",269],[2,"PointerKind","",""],[12,"Send","","",270],[12,"Borrowed","","",270],[3,"check_match","",""],[3,"check_pat_variant","",""],[3,"check_struct_pat_fields","","`path` is the AST path item naming the type of this struct.\n`fields` is the field patterns of the struct pattern.\n`class_fields` describes the type of each field of the struct.\n`class_id` is the ID of the struct.\n`substitutions` are the type substitutions applied to this struct type\n(e.g. K,V in HashMap<K,V>).\n`etc` is true if the pattern said '...' and false otherwise."],[3,"check_struct_pat","",""],[3,"check_struct_like_enum_variant_pat","",""],[3,"check_pat","",""],[10,"eq","","",270],[10,"ne","","",270],[0,"vtable","rustc::middle::typeck::check",""],[1,"VtableContext","rustc::middle::typeck::check::vtable","A vtable context includes an inference context, a crate context, and a\ncallback function to call in case of type error."],[11,"infcx","","",271],[11,"param_env","","",271],[11,"unboxed_closure_types","","",271],[3,"early_resolve_expr","",""],[3,"resolve_impl","","The situation is as follows. We have some trait like:"],[3,"trans_resolve_method","","Resolve vtables for a method call after typeck has finished.\nUsed by trans to monomorphize artificial method callees (e.g. drop)."],[3,"resolve_in_block","",""],[10,"tcx","","",271],[0,"writeback","rustc::middle::typeck::check",""],[3,"resolve_type_vars_in_expr","rustc::middle::typeck::check::writeback",""],[3,"resolve_type_vars_in_fn","",""],[3,"resolve_impl_res","",""],[6,"ResolveIn","",""],[9,"resolve_in","","",272],[0,"regionmanip","rustc::middle::typeck::check",""],[3,"replace_late_bound_regions_in_fn_sig","rustc::middle::typeck::check::regionmanip",""],[3,"relate_nested_regions","","This rather specialized function walks each region `r` that appear\nin `ty` and invokes `relate_op(r_encl, r)` for each one.  `r_encl`\nhere is the region of any enclosing `&'r T` pointer.  If there is\nno enclosing pointer, and `opt_region` is Some, then `opt_region.get()`\nis used instead.  Otherwise, no callback occurs at all)."],[3,"relate_free_regions","","This function populates the region map's `free_region_map`.\nIt walks over the transformed self type and argument types\nfor each function just before we check the body of that\nfunction, looking for types where you have a borrowed\npointer to other borrowed data (e.g., `&'a &'b [uint]`.\nWe do not allow references to outlive the things they\npoint at, so we can assume that `'a <= 'b`."],[0,"regionck","rustc::middle::typeck::check","The region check is a final pass that runs over the AST after we have\ninferred the type constraints but before we have actually finalized\nthe types.  Its purpose is to embed a variety of region constraints.\nInserting these constraints as a separate pass is good because (1) it\nlocalizes the code that has to do with region inference and (2) often\nwe cannot know what constraints are needed until the basic types have\nbeen inferred."],[1,"Rcx","rustc::middle::typeck::check::regionck",""],[3,"regionck_expr","",""],[3,"regionck_fn","",""],[3,"mk_subregion_due_to_dereference","",""],[10,"tcx","","",273],[10,"set_repeating_scope","","",273],[10,"resolve_type","","Try to resolve the type for the given node, returning\nt_err if an error results.  Note that we never care\nabout the details of the error, the same error will be\ndetected and reported in the writeback phase.",273],[10,"resolve_expr_type_adjusted","","Try to resolve the type for the given node.",273],[10,"tcx","","",273],[10,"node_ty","","",273],[10,"node_method_ty","","",273],[10,"adjustments","","",273],[10,"is_method_call","","",273],[10,"temporary_scope","","",273],[10,"upvar_borrow","","",273],[10,"visit_item","","",273],[10,"visit_expr","","",273],[10,"visit_arm","","",273],[10,"visit_local","","",273],[10,"visit_block","","",273],[0,"demand","rustc::middle::typeck::check",""],[3,"suptype","rustc::middle::typeck::check::demand",""],[3,"subtype","",""],[3,"suptype_with_fn","",""],[3,"eqtype","",""],[3,"coerce","",""],[0,"method","rustc::middle::typeck::check","# Method lookup"],[2,"CheckTraitsFlag","rustc::middle::typeck::check::method",""],[12,"CheckTraitsOnly","","",274],[12,"CheckTraitsAndInherentMethods","","",274],[2,"AutoderefReceiverFlag","",""],[12,"AutoderefReceiver","","",275],[12,"DontAutoderefReceiver","","",275],[2,"StaticMethodsFlag","",""],[12,"ReportStaticMethods","","",276],[12,"IgnoreStaticMethods","","",276],[2,"RcvrMatchCondition","","This type represents the conditions under which the receiver is\nconsidered to \"match\" a given method candidate. Typically the test\nis whether the receiver is of a particular type. However, this\ntype is the type of the receiver *after accounting for the\nmethod's self type* (e.g., if the method is an `Box<self>` method, we\nhave *already verified* that the receiver is of some type `Box<T>` and\nnow we must check that the type `T` is correct).  Unfortunately,\nbecause traits are not types, this is a pain to do."],[12,"RcvrMatchesIfObject","","",277],[12,"RcvrMatchesIfSubtype","","",277],[3,"lookup","",""],[3,"lookup_in_trait","",""],[10,"eq","","",274],[10,"ne","","",274],[10,"eq","","",275],[10,"ne","","",275],[10,"eq","","",276],[10,"ne","","",276],[10,"clone","","",277],[10,"repr","","",277],[10,"clone","rustc::middle::typeck::check","",266],[10,"function","","",266],[10,"recurse","","",266],[10,"clone","","",278],[10,"expr_ty","","",278],[10,"ty_ctxt","","",278],[10,"tcx","","",278],[10,"get_item_ty","","",278],[10,"get_trait_def","","",278],[10,"ty_infer","","",278],[10,"infcx","","",278],[10,"err_count_since_creation","","",278],[10,"vtable_context","","",278],[10,"tag","","",278],[10,"local_ty","","",278],[10,"write_ty","","",278],[10,"write_substs","","",278],[10,"write_ty_substs","","",278],[10,"write_autoderef_adjustment","","",278],[10,"write_adjustment","","",278],[10,"write_nil","","",278],[10,"write_bot","","",278],[10,"write_error","","",278],[10,"to_ty","","",278],[10,"pat_to_string","","",278],[10,"expr_ty","","",278],[10,"node_ty","","",278],[10,"method_ty_substs","","",278],[10,"opt_node_ty_substs","","",278],[10,"mk_subty","","",278],[10,"can_mk_subty","","",278],[10,"mk_assignty","","",278],[10,"mk_eqty","","",278],[10,"mk_subr","","",278],[10,"with_region_lb","","",278],[10,"type_error_message","","",278],[10,"report_mismatched_return_types","","",278],[10,"report_mismatched_types","","",278],[0,"rscope","rustc::middle::typeck",""],[1,"ExplicitRscope","rustc::middle::typeck::rscope",""],[1,"BindingRscope","","A scope in which we generate anonymous, late-bound regions for\nomitted regions. This occurs in function signatures."],[1,"ImpliedSingleRscope","","A scope in which we generate one specific region. This occurs after the\n`->` (i.e. in the return type) of function signatures."],[11,"region","","",279],[6,"RegionScope","","Defines strategies for handling regions that are omitted.  For\nexample, if one writes the type `&Foo`, then the lifetime of\nthis reference has been omitted. When converting this\ntype, the generic functions in astconv will invoke `anon_regions`\non the provided region-scope to decide how to translate this\nomitted region."],[9,"anon_regions","","",280],[10,"anon_regions","","",281],[10,"new","","",282],[10,"anon_regions","","",282],[10,"anon_regions","","",279],[0,"astconv","rustc::middle::typeck","Conversion from AST representation of types to the ty.rs\nrepresentation.  The main routine here is `ast_ty_to_ty()`: each use\nis parameterized by an instance of `AstConv` and a `RegionScope`."],[3,"ast_region_to_region","rustc::middle::typeck::astconv",""],[3,"opt_ast_region_to_region","",""],[3,"ast_path_to_trait_ref","",""],[3,"ast_path_to_ty","",""],[3,"ast_path_to_ty_relaxed","","Returns the type that this AST path refers to. If the path has no type\nparameters and the corresponding type has type parameters, fresh type\nand/or region variables are substituted."],[3,"ast_ty_to_prim_ty","",""],[3,"ast_ty_to_builtin_ty","","Converts the given AST type to a built-in type. A \"built-in type\" is, at\npresent, either a core numeric type, a string, or `Box`."],[3,"trait_ref_for_unboxed_function","",""],[3,"ast_ty_to_ty","",""],[3,"ty_of_arg","",""],[3,"ty_of_method","",""],[3,"ty_of_bare_fn","",""],[3,"ty_of_closure","",""],[5,"NO_REGIONS","",""],[5,"NO_TPS","",""],[6,"AstConv","",""],[9,"tcx","","",283],[9,"get_item_ty","","",283],[9,"get_trait_def","","",283],[9,"ty_infer","","",283],[0,"infer","rustc::middle::typeck","See doc.rs for documentation"],[1,"Bounds","rustc::middle::typeck::infer",""],[11,"lb","","",284],[11,"ub","","",284],[1,"InferCtxt","",""],[11,"tcx","","",285],[1,"TypeTrace","","The trace designates the path through inference that we took to\nencounter an error or subtyping constraint."],[1,"CombinedSnapshot","",""],[2,"TypeOrigin","","Why did we require that the two types be related?"],[12,"Misc","","",286],[12,"MethodCompatCheck","","",286],[12,"ExprAssignable","","",286],[12,"RelateTraitRefs","","",286],[12,"RelateSelfType","","",286],[12,"MatchExpressionArm","","",286],[12,"IfExpression","","",286],[2,"ValuePairs","","See `error_reporting.rs` for more details"],[12,"Types","","",287],[12,"TraitRefs","","",287],[2,"SubregionOrigin","","The origin of a `r1 <= r2` constraint."],[12,"Subtype","","",288],[12,"InfStackClosure","","",288],[12,"InvokeClosure","","",288],[12,"DerefPointer","","",288],[12,"FreeVariable","","",288],[12,"IndexSlice","","",288],[12,"RelateObjectBound","","",288],[12,"Reborrow","","",288],[12,"ReborrowUpvar","","",288],[12,"ReferenceOutlivesReferent","","",288],[12,"BindingTypeIsNotValidAtDecl","","",288],[12,"CallRcvr","","",288],[12,"CallArg","","",288],[12,"CallReturn","","",288],[12,"AddrOf","","",288],[12,"AutoBorrow","","",288],[2,"RegionVariableOrigin","","Reasons to create a region inference variable"],[12,"MiscVariable","","",289],[12,"PatternRegion","","",289],[12,"AddrOfRegion","","",289],[12,"AddrOfSlice","","",289],[12,"Autoref","","",289],[12,"Coercion","","",289],[12,"EarlyBoundRegion","","",289],[12,"LateBoundRegion","","",289],[12,"BoundRegionInFnType","","",289],[12,"UpvarRegion","","",289],[12,"BoundRegionInCoherence","","",289],[2,"fixup_err","",""],[12,"unresolved_int_ty","","",290],[12,"unresolved_float_ty","","",290],[12,"unresolved_ty","","",290],[12,"cyclic_ty","","",290],[12,"unresolved_region","","",290],[12,"region_var_bound_by_region_var","","",290],[3,"fixup_err_to_string","",""],[3,"new_infer_ctxt","",""],[3,"common_supertype","","Computes the least upper-bound of `a` and `b`. If this is\nnot possible, reports an error and returns ty::err."],[3,"mk_subty","",""],[3,"can_mk_subty","",""],[3,"mk_subr","",""],[3,"mk_eqty","",""],[3,"mk_sub_trait_refs","",""],[3,"mk_coercety","",""],[3,"resolve_type","",""],[3,"resolve_region","",""],[3,"uok","",""],[3,"fold_regions_in_sig","",""],[0,"doc","","# Type inference engine"],[0,"combine","",""],[1,"CombineFields","rustc::middle::typeck::infer::combine",""],[11,"infcx","","",291],[11,"a_is_expected","","",291],[11,"trace","","",291],[3,"expected_found","",""],[3,"eq_tys","",""],[3,"eq_regions","",""],[3,"super_fn_sigs","",""],[3,"super_tys","",""],[6,"Combine","",""],[9,"infcx","","",292],[9,"tag","","",292],[9,"a_is_expected","","",292],[9,"trace","","",292],[9,"sub","","",292],[9,"lub","","",292],[9,"glb","","",292],[9,"mts","","",292],[9,"contratys","","",292],[9,"tys","","",292],[10,"tps","","",292],[10,"substs","","",292],[10,"bare_fn_tys","","",292],[10,"closure_tys","","",292],[9,"fn_sigs","","",292],[10,"args","","",292],[9,"fn_styles","","",292],[10,"abi","","",292],[9,"oncenesses","","",292],[9,"bounds","","",292],[9,"contraregions","","",292],[9,"regions","","",292],[10,"trait_stores","","",292],[10,"trait_refs","","",292],[10,"clone","","",291],[0,"glb","rustc::middle::typeck::infer",""],[1,"Glb","rustc::middle::typeck::infer::glb",""],[10,"get_ref","","",293],[10,"infcx","","",293],[10,"tag","","",293],[10,"a_is_expected","","",293],[10,"trace","","",293],[10,"sub","","",293],[10,"lub","","",293],[10,"glb","","",293],[10,"mts","","",293],[10,"contratys","","",293],[10,"fn_styles","","",293],[10,"oncenesses","","",293],[10,"bounds","","",293],[10,"regions","","",293],[10,"contraregions","","",293],[10,"tys","","",293],[10,"fn_sigs","","",293],[0,"lattice","rustc::middle::typeck::infer","\n# Lattice Variables"],[2,"LatticeVarResult","rustc::middle::typeck::infer::lattice",""],[12,"VarResult","","",294],[12,"ValueResult","","",294],[3,"super_lattice_tys","",""],[3,"lattice_vars","","Computes the LUB or GLB of two bounded variables.  These could be any\nsort of variables, but in the comments on this function I'll assume\nwe are doing an LUB on two type variables."],[3,"lattice_var_and_t","",""],[3,"var_ids","",""],[3,"is_var_in_set","",""],[4,"LatticeOp","",""],[4,"LatticeDirOp","",""],[6,"LatticeValue","",""],[9,"sub","","",295],[9,"lub","","",295],[9,"glb","","",295],[6,"CombineFieldsLatticeMethods","",""],[9,"var_sub_var","","make variable a subtype of variable",296],[9,"var_sub_t","","make variable a subtype of T",296],[9,"t_sub_var","","make T a subtype of variable",296],[9,"set_var_to_merged_bounds","","",296],[6,"CombineFieldsLatticeMethods2","",""],[9,"merge_bnd","","",297],[9,"bnds","","",297],[6,"LatticeDir","",""],[9,"combine_fields","","",298],[9,"bnd","","",298],[9,"with_bnd","","",298],[6,"TyLatticeDir","",""],[9,"ty_bot","","",299],[10,"sub","rustc::middle::ty","",248],[10,"lub","","",248],[10,"glb","","",248],[10,"var_sub_var","rustc::middle::typeck::infer::combine","Make one variable a subtype of another variable.  This is a\nsubtle and tricky process, as described in detail at the\ntop of infer.rs.",291],[10,"var_sub_t","","make variable a subtype of T\nMake a variable (`a_id`) a subtype of the concrete type `b`.",291],[10,"t_sub_var","","Make a concrete type (`a`) a subtype of the variable `b_id`",291],[10,"set_var_to_merged_bounds","","Updates the bounds for the variable `v_id` to be the intersection\nof `a` and `b`.  That is, the new bounds for `v_id` will be\na bounds c such that:\n   c.ub <: a.ub\n   c.ub <: b.ub\n   a.lb <: c.lb\n   b.lb <: c.lb\nIf this cannot be achieved, the result is failure.",291],[10,"merge_bnd","","Combines two bounds into a more general bound.",291],[10,"bnds","","",291],[10,"combine_fields","rustc::middle::typeck::infer::glb","",293],[10,"bnd","","",293],[10,"with_bnd","","",293],[10,"ty_bot","","",293],[10,"clone","rustc::middle::typeck::infer::lattice","",294],[0,"lub","rustc::middle::typeck::infer",""],[1,"Lub","rustc::middle::typeck::infer::lub",""],[10,"get_ref","","",300],[10,"infcx","","",300],[10,"tag","","",300],[10,"a_is_expected","","",300],[10,"trace","","",300],[10,"sub","","",300],[10,"lub","","",300],[10,"glb","","",300],[10,"mts","","",300],[10,"contratys","","",300],[10,"fn_styles","","",300],[10,"oncenesses","","",300],[10,"bounds","","",300],[10,"contraregions","","",300],[10,"regions","","",300],[10,"fn_sigs","","",300],[10,"tys","","",300],[0,"region_inference","rustc::middle::typeck::infer","See doc.rs"],[1,"TwoRegions","rustc::middle::typeck::infer::region_inference",""],[1,"SameRegions","","SameRegions is used to group regions that we think are the same and would\nlike to indicate so to the user.\nFor example, the following function\n```\nstruct Foo { bar: int }\nfn foo2<'a, 'b>(x: &'a Foo) -> &'b int {\n   &x.bar\n}\n```\nwould report an error because we expect 'a and 'b to match, and so we group\n'a and 'b together inside a SameRegions struct"],[11,"scope_id","","",301],[11,"regions","","",301],[1,"RegionVarBindings","",""],[1,"RegionSnapshot","",""],[1,"RegionMark","",""],[2,"Constraint","",""],[12,"ConstrainVarSubVar","","",302],[12,"ConstrainRegSubVar","","",302],[12,"ConstrainVarSubReg","","",302],[12,"ConstrainRegSubReg","","",302],[2,"UndoLogEntry","",""],[12,"OpenSnapshot","","",303],[12,"CommitedSnapshot","","",303],[12,"Mark","","",303],[12,"AddVar","","",303],[12,"AddConstraint","","",303],[12,"AddCombination","","",303],[2,"CombineMapType","",""],[12,"Lub","","",304],[12,"Glb","","",304],[2,"RegionResolutionError","",""],[12,"ConcreteFailure","","`ConcreteFailure(o, a, b)`:",305],[12,"SubSupConflict","","`SubSupConflict(v, sub_origin, sub_r, sup_origin, sup_r)`:",305],[12,"SupSupConflict","","`SupSupConflict(v, origin1, r1, origin2, r2)`:",305],[12,"ProcessedErrors","","For subsets of `ConcreteFailure` and `SubSupConflict`, we can derive\nmore specific errors message by suggesting to the user where they\nshould put a lifetime. In those cases we process and put those errors\ninto `ProcessedErrors` before we do any reporting.",305],[2,"VarValue","",""],[12,"NoValue","","",306],[12,"Value","","",306],[12,"ErrorValue","","",306],[4,"CombineMap","",""],[10,"hash","","",302],[10,"eq","","",302],[10,"ne","","",302],[10,"hash","","",307],[10,"eq","","",307],[10,"ne","","",307],[10,"eq","","",303],[10,"ne","","",303],[10,"eq","","",304],[10,"ne","","",304],[10,"clone","","",305],[10,"clone","","",301],[10,"contains","","",301],[10,"push","","",301],[10,"fmt","","",308],[10,"fmt","","",309],[10,"new","","",310],[10,"in_snapshot","","",310],[10,"start_snapshot","","",310],[10,"mark","","",310],[10,"commit","","",310],[10,"rollback_to","","",310],[10,"num_vars","","",310],[10,"new_region_var","","",310],[10,"new_skolemized","","",310],[10,"new_bound","","",310],[10,"add_constraint","","",310],[10,"make_subregion","","",310],[10,"lub_regions","","",310],[10,"glb_regions","","",310],[10,"resolve_var","","",310],[10,"combine_vars","","",310],[10,"vars_created_since_mark","","",310],[10,"tainted","","Computes all regions that have been related to `r0` in any\nway since the mark `mark` was made---`r0` itself will be\nthe first entry. This is used when checking whether\nskolemized regions are being improperly related to other\nregions.",310],[10,"resolve_regions","","This function performs the actual region resolution.  It must be\ncalled after all constraints have been added.  It performs a\nfixed-point iteration to find region values which satisfy all\nconstraints, assuming such values can be found; if they cannot,\nerrors are reported.",310],[10,"repr","","",302],[0,"resolve","rustc::middle::typeck::infer",""],[1,"ResolveState","rustc::middle::typeck::infer::resolve",""],[3,"resolver","",""],[5,"resolve_nested_tvar","",""],[5,"resolve_rvar","",""],[5,"resolve_ivar","",""],[5,"resolve_fvar","",""],[5,"resolve_all","",""],[5,"force_tvar","",""],[5,"force_rvar","",""],[5,"force_ivar","",""],[5,"force_fvar","",""],[5,"force_all","",""],[5,"not_regions","",""],[5,"try_resolve_tvar_shallow","",""],[5,"resolve_and_force_all_but_regions","",""],[10,"tcx","","",311],[10,"fold_ty","","",311],[10,"fold_region","","",311],[10,"should","","",311],[10,"resolve_type_chk","","",311],[10,"resolve_region_chk","","",311],[10,"resolve_type","","",311],[10,"resolve_region","","",311],[10,"resolve_region_var","","",311],[10,"resolve_ty_var","","",311],[10,"resolve_int_var","","",311],[10,"resolve_float_var","","",311],[0,"sub","rustc::middle::typeck::infer",""],[1,"Sub","rustc::middle::typeck::infer::sub",""],[10,"get_ref","","",312],[10,"infcx","","",312],[10,"tag","","",312],[10,"a_is_expected","","",312],[10,"trace","","",312],[10,"sub","","",312],[10,"lub","","",312],[10,"glb","","",312],[10,"contratys","","",312],[10,"contraregions","","",312],[10,"regions","","",312],[10,"mts","","",312],[10,"fn_styles","","",312],[10,"oncenesses","","",312],[10,"bounds","","",312],[10,"tys","","",312],[10,"fn_sigs","","",312],[0,"unify","rustc::middle::typeck::infer",""],[1,"UnificationTable","rustc::middle::typeck::infer::unify","Table of unification keys and their values."],[1,"Snapshot","","At any time, users may snapshot a unification table.  The changes\nmade during the snapshot may either be *committed* or *rolled back*."],[1,"Node","","Internal type used to represent the result of a `get()` operation.\nConveys the current root and value of the key."],[11,"key","","",313],[11,"value","","",313],[11,"rank","","",313],[2,"VarValue","","Value of a unification key. We implement Tarjan's union-find\nalgorithm: when two keys are unified, one of them is converted\ninto a \"redirect\" pointing at the other. These redirects form a\nDAG: the roots of the DAG (nodes that are not redirected) are each\nassociated with a value of type `V` and a rank. The rank is used\nto keep the DAG relatively balanced, which helps keep the running\ntime of the algorithm under control. For more information, see\n<http://en.wikipedia.org/wiki/Disjoint-set_data_structure>."],[12,"Redirect","","",314],[12,"Root","","",314],[3,"err","",""],[6,"UnifyKey","","This trait is implemented by any type that can serve as a type\nvariable. We call such variables *unification keys*. For example,\nthis trait is implemented by `TyVid`, which represents normal\ntype variables, and `IntVid`, which represents integral variables."],[9,"index","","",315],[9,"from_index","","",315],[9,"unification_table","","Given an inference context, returns the unification table\nappropriate to this key type.",315],[9,"tag","","",315],[6,"UnifyValue","","Trait for valid types that a type variable can be set to.  Note\nthat this is typically not the end type that the value will\ntake on, but rather some wrapper: for example, for normal type\nvariables, the associated type is not `ty::t` but rather\n`Bounds<ty::t>`."],[6,"SimplyUnifiable","","Indicates a type that does not have any kind of subtyping\nrelationship."],[9,"to_type_err","","",316],[6,"InferCtxtMethodsForSimplyUnifiableTypes","",""],[9,"simple_vars","","",317],[9,"simple_var_t","","",317],[10,"clone","","",314],[10,"eq","","",314],[10,"ne","","",314],[10,"new","","",318],[10,"in_snapshot","","True if a snapshot has been started.",318],[10,"snapshot","","Starts a new snapshot. Each snapshot must be either\nrolled back or committed in a \"LIFO\" (stack) order.",318],[10,"rollback_to","","Reverses all changes since the last snapshot. Also\nremoves any keys that have been created since then.",318],[10,"commit","","Commits all changes since the last snapshot. Of course, they\ncan still be undone if there is a snapshot further out.",318],[10,"new_key","","",318],[10,"get","","Find the root node for `vid`. This uses the standard\nunion-find algorithm with path compression:\nhttp://en.wikipedia.org/wiki/Disjoint-set_data_structure",318],[10,"set","","Sets the value for `vid` to `new_value`. `vid` MUST be a\nroot node! Also, we must be in the middle of a snapshot.",318],[10,"unify","","Either redirects node_a to node_b or vice versa, depending\non the relative rank. Returns the new root and rank.  You\nshould then update the value of the new root to something\nsuitable.",318],[10,"simple_vars","rustc::middle::typeck::infer","Unifies two simple keys.  Because simple keys do\nnot have any subtyping relationships, if both keys\nhave already been associated with a value, then those two\nvalues must be the same.",285],[10,"simple_var_t","","Sets the value of the key `a_id` to `b`.  Because\nsimple keys do not have any subtyping relationships,\nif `a_id` already has a value, it must be the same as\n`b`.",285],[10,"index","rustc::middle::ty","",211],[10,"from_index","","",211],[10,"unification_table","","",211],[10,"tag","","",211],[10,"index","","",212],[10,"from_index","","",212],[10,"unification_table","","",212],[10,"tag","","",212],[10,"to_type_err","","",236],[10,"index","","",213],[10,"from_index","","",213],[10,"unification_table","","",213],[10,"tag","","",213],[10,"to_type_err","syntax::ast","",319],[0,"coercion","rustc::middle::typeck::infer","# Type Coercion"],[1,"Coerce","rustc::middle::typeck::infer::coercion",""],[10,"get_ref","","",320],[10,"tys","","",320],[10,"subtype","","",320],[10,"unpack_actual_value","","",320],[10,"coerce_borrowed_pointer","","",320],[10,"coerce_borrowed_string","","",320],[10,"coerce_borrowed_vector","","",320],[10,"coerce_borrowed_fn","","",320],[10,"coerce_unsafe_ptr","","",320],[10,"coerce_object","","",320],[0,"error_reporting","rustc::middle::typeck::infer","Error Reporting Code for the inference engine"],[6,"ErrorReporting","rustc::middle::typeck::infer::error_reporting",""],[9,"report_region_errors","","",321],[9,"process_errors","","",321],[9,"report_type_error","","",321],[9,"report_and_explain_type_error","","",321],[9,"values_str","","",321],[9,"expected_found_str","","",321],[9,"report_concrete_failure","","",321],[9,"report_sub_sup_conflict","","",321],[9,"report_sup_sup_conflict","","",321],[9,"report_processed_errors","","",321],[9,"give_suggestion","","",321],[6,"ErrorReportingHelpers","",""],[9,"report_inference_failure","","",322],[9,"note_region_origin","","",322],[9,"give_expl_lifetime_param","","",322],[6,"Resolvable","",""],[9,"resolve","","",323],[9,"contains_error","","",323],[10,"report_region_errors","rustc::middle::typeck::infer","",285],[10,"process_errors","","",285],[10,"report_type_error","","",285],[10,"report_and_explain_type_error","","",285],[10,"values_str","","Returns a string of the form \"expected `{}` but found `{}`\",\nor None if this is a derived error.",285],[10,"expected_found_str","","",285],[10,"report_concrete_failure","","",285],[10,"report_sub_sup_conflict","","",285],[10,"report_sup_sup_conflict","","",285],[10,"report_processed_errors","","",285],[10,"give_suggestion","","",285],[10,"give_expl_lifetime_param","","",285],[10,"report_inference_failure","","",285],[10,"note_region_origin","","",285],[10,"resolve","rustc::middle::ty","",248],[10,"contains_error","","",248],[10,"resolve","alloc::rc","",252],[10,"contains_error","","",252],[0,"test","rustc::middle::typeck::infer","# Standalone Tests for the Inference Module"],[4,"Bound","",""],[4,"cres","",""],[4,"ures","",""],[4,"fres","",""],[4,"CoerceResult","",""],[6,"then","",""],[9,"then","","",324],[6,"ToUres","",""],[9,"to_ures","","",325],[6,"CresCompare","",""],[9,"compare","","",326],[10,"clone","","",284],[10,"eq","","",284],[10,"ne","","",284],[10,"clone","","",286],[10,"clone","","",287],[10,"clone","","",327],[10,"clone","","",288],[10,"clone","","",289],[10,"then","","",328],[10,"to_ures","","",329],[10,"compare","","",329],[10,"combine_fields","","",285],[10,"sub","","",285],[10,"lub","","",285],[10,"in_snapshot","","",285],[10,"commit_unconditionally","","Execute `f` and commit the bindings",285],[10,"commit_if_ok","","Execute `f` and commit the bindings if successful",285],[10,"try","","Execute `f`, unroll bindings on failure",285],[10,"probe","","Execute `f` then unroll any bindings it creates",285],[10,"next_ty_var_id","","",285],[10,"next_ty_var","","",285],[10,"next_ty_vars","","",285],[10,"next_int_var_id","","",285],[10,"next_float_var_id","","",285],[10,"next_region_var","","",285],[10,"region_vars_for_defs","","",285],[10,"fresh_substs_for_type","","Given a set of generics defined on a type or impl, returns\na substitution mapping each type/region parameter to a\nfresh inference variable.",285],[10,"fresh_bound_region","","",285],[10,"resolve_regions_and_report_errors","","",285],[10,"ty_to_string","","",285],[10,"tys_to_string","","",285],[10,"trait_ref_to_string","","",285],[10,"resolve_type_vars_if_possible","","",285],[10,"resolve_type_vars_in_trait_ref_if_possible","","",285],[10,"type_error_message_str","","",285],[10,"type_error_message_str_with_expected","","",285],[10,"type_error_message","","",285],[10,"report_mismatched_types","","",285],[10,"replace_late_bound_regions_with_fresh_regions","","",285],[10,"span","","",327],[10,"repr","","",327],[10,"span","","",286],[10,"repr","","",286],[10,"span","","",288],[10,"repr","","",288],[10,"span","","",289],[10,"repr","","",289],[0,"collect","rustc::middle::typeck",""],[3,"collect_item_types","rustc::middle::typeck::collect",""],[3,"get_enum_variant_types","",""],[3,"ensure_trait_methods","",""],[3,"convert_field","",""],[3,"ensure_no_ty_param_bounds","",""],[3,"convert","",""],[3,"convert_struct","",""],[3,"convert_foreign","",""],[3,"instantiate_trait_ref","","Instantiates the path for the given trait reference, assuming that\nit's bound to a valid trait type. Returns the def_id for the defining\ntrait. Fails if the type is a type other than a trait type."],[3,"trait_def_of_item","",""],[3,"ty_of_item","",""],[3,"ty_of_foreign_item","",""],[3,"ty_of_foreign_fn_decl","",""],[3,"mk_item_substs","",""],[6,"ToTy","",""],[9,"to_ty","","",330],[10,"to_ty","rustc::middle::typeck","",331],[10,"tcx","","",331],[10,"get_item_ty","","",331],[10,"get_trait_def","","",331],[10,"ty_infer","","",331],[0,"coherence","",""],[3,"make_substs_for_receiver_types","rustc::middle::typeck::coherence","Substitutes the values for the receiver's type parameters\nthat are found in method, leaving the method's type parameters\nintact."],[3,"check_coherence","",""],[0,"variance","rustc::middle::typeck","This file infers the variance of type and lifetime parameters. The\nalgorithm is taken from Section 4 of the paper \"Taming the Wildcards:\nCombining Definition- and Use-Site Variance\" published in PLDI'11 and\nwritten by Altidor et al., and hereafter referred to as The Paper."],[3,"infer_variance","rustc::middle::typeck::variance",""],[6,"Xform","",""],[9,"xform","","",332],[10,"xform","rustc::middle::ty","",228],[4,"MethodMap","rustc::middle::typeck",""],[4,"vtable_param_res","",""],[4,"vtable_res","",""],[4,"vtable_map","",""],[4,"impl_vtable_map","",""],[10,"partial_cmp","","",257],[10,"lt","","",257],[10,"le","","",257],[10,"gt","","",257],[10,"ge","","",257],[10,"eq","","",257],[10,"ne","","",257],[10,"decode","","",257],[10,"encode","","",257],[10,"clone","","",257],[10,"decode","","",263],[10,"encode","","",263],[10,"clone","","",263],[10,"decode","","",258],[10,"encode","","",258],[10,"clone","","",258],[10,"decode","","",259],[10,"encode","","",259],[10,"clone","","",259],[10,"clone","","",260],[10,"fmt","","",261],[10,"hash","","",261],[10,"eq","","",261],[10,"ne","","",261],[10,"clone","","",261],[10,"decode","","",264],[10,"encode","","",264],[10,"fmt","","",264],[10,"hash","","",264],[10,"eq","","",264],[10,"ne","","",264],[10,"clone","","",264],[10,"expr","","",261],[10,"autoobject","","",261],[10,"autoderef","","",261],[10,"clone","","",265],[10,"repr","","",265],[0,"weak_lang_items","rustc::middle","Validity checking for weak lang items"],[3,"check_crate","rustc::middle::weak_lang_items","Checks the crate for usage of weak lang items, returning a vector of all the\nlanguage items required by this crate, but not defined yet."],[3,"link_name","",""],[0,"front","rustc",""],[0,"config","rustc::front",""],[3,"strip_unconfigured_items","rustc::front::config",""],[3,"strip_items","",""],[0,"test","rustc::front",""],[3,"modify_for_testing","rustc::front::test",""],[0,"std_inject","rustc::front",""],[3,"maybe_inject_crates_ref","rustc::front::std_inject",""],[3,"maybe_inject_prelude","",""],[0,"assign_node_ids_and_map","rustc::front",""],[3,"assign_node_ids_and_map","rustc::front::assign_node_ids_and_map",""],[0,"feature_gate","rustc::front","Feature gating"],[1,"Features","rustc::front::feature_gate","A set of features to be used by later passes."],[11,"default_type_params","","",333],[11,"issue_5723_bootstrap","","",333],[11,"overloaded_calls","","",333],[11,"rustc_diagnostic_macros","","",333],[3,"check_crate","",""],[10,"new","","",333],[0,"show_span","rustc::front","Span debugger"],[3,"run","rustc::front::show_span",""],[0,"metadata","rustc",""],[0,"common","rustc::metadata",""],[1,"LinkMeta","rustc::metadata::common",""],[11,"crate_name","","",334],[11,"crate_hash","","",334],[2,"astencode_tag","",""],[12,"tag_ast","","",335],[12,"tag_tree","","",335],[12,"tag_id_range","","",335],[12,"tag_table","","",335],[12,"tag_table_id","","",335],[12,"tag_table_val","","",335],[12,"tag_table_def","","",335],[12,"tag_table_node_type","","",335],[12,"tag_table_item_subst","","",335],[12,"tag_table_freevars","","",335],[12,"tag_table_tcache","","",335],[12,"tag_table_param_defs","","",335],[12,"tag_table_mutbl","","",335],[12,"tag_table_last_use","","",335],[12,"tag_table_spill","","",335],[12,"tag_table_method_map","","",335],[12,"tag_table_vtable_map","","",335],[12,"tag_table_adjustments","","",335],[12,"tag_table_moves_map","","",335],[12,"tag_table_capture_map","","",335],[12,"tag_table_unboxed_closure_type","","",335],[5,"tag_items","",""],[5,"tag_paths_data_name","",""],[5,"tag_def_id","",""],[5,"tag_items_data","",""],[5,"tag_items_data_item","",""],[5,"tag_items_data_item_family","",""],[5,"tag_items_data_item_ty_param_bounds","",""],[5,"tag_items_data_item_type","",""],[5,"tag_items_data_item_symbol","",""],[5,"tag_items_data_item_variant","",""],[5,"tag_items_data_parent_item","",""],[5,"tag_items_data_item_is_tuple_struct_ctor","",""],[5,"tag_index","",""],[5,"tag_index_buckets","",""],[5,"tag_index_buckets_bucket","",""],[5,"tag_index_buckets_bucket_elt","",""],[5,"tag_index_table","",""],[5,"tag_meta_item_name_value","",""],[5,"tag_meta_item_name","",""],[5,"tag_meta_item_value","",""],[5,"tag_attributes","",""],[5,"tag_attribute","",""],[5,"tag_meta_item_word","",""],[5,"tag_meta_item_list","",""],[5,"tag_crate_deps","",""],[5,"tag_crate_dep","",""],[5,"tag_crate_hash","",""],[5,"tag_crate_crate_name","",""],[5,"tag_crate_dep_crate_name","",""],[5,"tag_crate_dep_hash","",""],[5,"tag_mod_impl","",""],[5,"tag_item_trait_method","",""],[5,"tag_item_trait_ref","",""],[5,"tag_item_super_trait_ref","",""],[5,"tag_disr_val","",""],[5,"tag_path","",""],[5,"tag_path_len","",""],[5,"tag_path_elem_mod","",""],[5,"tag_path_elem_name","",""],[5,"tag_item_field","",""],[5,"tag_item_field_origin","",""],[5,"tag_item_variances","",""],[5,"tag_item_impl_method","",""],[5,"tag_item_trait_method_explicit_self","",""],[5,"tag_items_data_item_reexport","",""],[5,"tag_items_data_item_reexport_def_id","",""],[5,"tag_items_data_item_reexport_name","",""],[5,"tag_item_trait_method_sort","",""],[5,"tag_item_impl_type_basename","",""],[5,"tag_crate_triple","",""],[5,"tag_dylib_dependency_formats","",""],[5,"tag_lang_items","",""],[5,"tag_lang_items_item","",""],[5,"tag_lang_items_item_id","",""],[5,"tag_lang_items_item_node_id","",""],[5,"tag_lang_items_missing","",""],[5,"tag_item_unnamed_field","",""],[5,"tag_items_data_item_visibility","",""],[5,"tag_items_data_item_sized","",""],[5,"tag_item_method_tps","",""],[5,"tag_item_method_fty","",""],[5,"tag_mod_child","",""],[5,"tag_misc_info","",""],[5,"tag_misc_info_crate_items","",""],[5,"tag_item_method_provided_source","",""],[5,"tag_item_impl_vtables","",""],[5,"tag_impls","",""],[5,"tag_impls_impl","",""],[5,"tag_items_data_item_inherent_impl","",""],[5,"tag_items_data_item_extension_impl","",""],[5,"tag_native_libraries","",""],[5,"tag_native_libraries_lib","",""],[5,"tag_native_libraries_name","",""],[5,"tag_native_libraries_kind","",""],[5,"tag_plugin_registrar_fn","",""],[5,"tag_exported_macros","",""],[5,"tag_macro_def","",""],[5,"tag_method_argument_names","",""],[5,"tag_method_argument_name","",""],[5,"tag_reachable_extern_fns","",""],[5,"tag_reachable_extern_fn_id","",""],[5,"tag_items_data_item_stability","",""],[5,"tag_region_param_def","",""],[5,"tag_region_param_def_ident","",""],[5,"tag_region_param_def_def_id","",""],[5,"tag_region_param_def_space","",""],[5,"tag_region_param_def_index","",""],[5,"tag_unboxed_closures","",""],[5,"tag_unboxed_closure","",""],[5,"tag_unboxed_closure_type","",""],[5,"tag_struct_fields","",""],[5,"tag_struct_field","",""],[5,"tag_struct_field_id","",""],[5,"tag_attribute_is_sugared_doc","",""],[10,"eq","","",335],[10,"ne","","",335],[10,"from_uint","","",335],[10,"fmt","","",334],[10,"clone","","",334],[0,"tyencode","rustc::metadata",""],[1,"ctxt","rustc::metadata::tyencode",""],[11,"diag","","",336],[11,"ds","","",336],[11,"tcx","","",336],[11,"abbrevs","","",336],[1,"ty_abbrev","",""],[3,"enc_ty","",""],[3,"enc_substs","",""],[3,"enc_trait_ref","",""],[3,"enc_trait_store","",""],[3,"enc_bare_fn_ty","",""],[3,"enc_closure_ty","",""],[3,"enc_type_param_def","",""],[4,"abbrev_map","",""],[0,"tydecode","rustc::metadata",""],[1,"PState","rustc::metadata::tydecode",""],[2,"DefIdSource","",""],[12,"NominalType","","",337],[12,"TypeWithId","","",337],[12,"TypeParameter","","",337],[12,"RegionParameter","","",337],[3,"parse_ident","",""],[3,"parse_state_from_data","",""],[3,"parse_ty_closure_data","",""],[3,"parse_ty_data","",""],[3,"parse_bare_fn_ty_data","",""],[3,"parse_trait_ref_data","",""],[3,"parse_substs_data","",""],[3,"parse_def_id","",""],[3,"parse_type_param_def_data","",""],[4,"conv_did","",""],[0,"encoder","rustc::metadata",""],[1,"EncodeParams","rustc::metadata::encoder",""],[11,"diag","","",338],[11,"tcx","","",338],[11,"reexports2","","",338],[11,"item_symbols","","",338],[11,"non_inlineable_statics","","",338],[11,"link_meta","","",338],[11,"cstore","","",338],[11,"encode_inlined_item","","",338],[11,"reachable","","",338],[1,"EncodeContext","",""],[11,"diag","","",339],[11,"tcx","","",339],[11,"reexports2","","",339],[11,"item_symbols","","",339],[11,"non_inlineable_statics","","",339],[11,"link_meta","","",339],[11,"cstore","","",339],[11,"encode_inlined_item","","",339],[11,"type_abbrevs","","",339],[11,"reachable","","",339],[2,"InlinedItemRef","","A borrowed version of ast::InlinedItem."],[12,"IIItemRef","","",340],[12,"IIMethodRef","","",340],[12,"IIForeignRef","","",340],[3,"encode_def_id","",""],[3,"def_to_string","",""],[3,"write_closure_type","",""],[3,"write_type","",""],[3,"encode_metadata","",""],[3,"encoded_ty","",""],[4,"Encoder","",""],[4,"EncodeInlinedItem","",""],[5,"metadata_encoding_version","",""],[0,"decoder","rustc::metadata",""],[1,"CrateDep","rustc::metadata::decoder",""],[11,"cnum","","",341],[11,"name","","",341],[11,"hash","","",341],[2,"DefLike","",""],[12,"DlDef","","",342],[12,"DlImpl","","",342],[12,"DlField","","",342],[3,"maybe_find_item","",""],[3,"item_type","",""],[3,"get_trait_def","",""],[3,"get_type","",""],[3,"get_stability","",""],[3,"get_impl_trait","",""],[3,"get_impl_vtables","",""],[3,"get_symbol","",""],[3,"each_lang_item","","Iterates over the language items in the given crate."],[3,"each_child_of_item","","Iterates over each child of the given item."],[3,"each_top_level_item_of_crate","","Iterates over all the top-level crate items."],[3,"get_item_path","",""],[3,"maybe_get_item_ast","",""],[3,"get_enum_variants","",""],[3,"get_impl_methods","","Returns information about the given implementation."],[3,"get_method_name_and_explicit_self","",""],[3,"get_method","",""],[3,"get_trait_method_def_ids","",""],[3,"get_item_variances","",""],[3,"get_provided_trait_methods","",""],[3,"get_supertraits","","Returns the supertraits of the given trait."],[3,"get_type_name_if_impl","",""],[3,"get_static_methods_if_impl","",""],[3,"get_tuple_struct_definition_if_ctor","","If node_id is the constructor of a tuple struct, retrieve the NodeId of\nthe actual type definition, otherwise, return None"],[3,"get_item_attrs","",""],[3,"get_struct_field_attrs","",""],[3,"get_struct_fields","",""],[3,"get_crate_attributes","",""],[3,"get_crate_deps","",""],[3,"maybe_get_crate_hash","",""],[3,"get_crate_hash","",""],[3,"maybe_get_crate_name","",""],[3,"get_crate_triple","",""],[3,"get_crate_name","",""],[3,"list_crate_metadata","",""],[3,"translate_def_id","",""],[3,"each_impl","",""],[3,"each_implementation_for_type","",""],[3,"each_implementation_for_trait","",""],[3,"get_trait_of_method","",""],[3,"get_native_libraries","",""],[3,"get_plugin_registrar_fn","",""],[3,"get_exported_macros","",""],[3,"get_dylib_dependency_formats","",""],[3,"get_missing_lang_items","",""],[3,"get_method_arg_names","",""],[3,"get_reachable_extern_fns","",""],[3,"is_typedef","",""],[4,"Cmd","",""],[4,"GetCrateDataCb","",""],[4,"DecodeInlinedItem","",""],[10,"clone","","",342],[10,"clone","","",341],[0,"creader","rustc::metadata","Validates all used crates and extern libraries and loads their metadata"],[1,"PluginMetadataReader","rustc::metadata::creader",""],[3,"read_crates","",""],[3,"validate_crate_name","",""],[10,"new","","",343],[10,"read_plugin_metadata","","",343],[0,"cstore","rustc::metadata",""],[1,"crate_metadata","rustc::metadata::cstore",""],[11,"name","","",344],[11,"data","","",344],[11,"cnum_map","","",344],[11,"cnum","","",344],[11,"span","","",344],[1,"CrateSource","",""],[11,"dylib","","",345],[11,"rlib","","",345],[11,"cnum","","",345],[1,"CStore","",""],[11,"intr","","",346],[2,"MetadataBlob","",""],[12,"MetadataVec","","",347],[12,"MetadataArchive","","",347],[2,"LinkagePreference","",""],[12,"RequireDynamic","","",348],[12,"RequireStatic","","",348],[2,"NativeLibaryKind","",""],[12,"NativeStatic","","",349],[12,"NativeFramework","","",349],[12,"NativeUnknown","","",349],[4,"cnum_map","",""],[10,"clone","","",348],[10,"eq","","",348],[10,"ne","","",348],[10,"fmt","","",348],[10,"from_i64","","",349],[10,"from_u64","","",349],[10,"eq","","",349],[10,"ne","","",349],[10,"clone","","",345],[10,"eq","","",345],[10,"ne","","",345],[10,"new","","",346],[10,"next_crate_num","","",346],[10,"get_crate_data","","",346],[10,"get_crate_hash","","",346],[10,"set_crate_data","","",346],[10,"iter_crate_data","","",346],[10,"iter_crate_data_origins","","Like `iter_crate_data`, but passes source paths (if available) as well.",346],[10,"add_used_crate_source","","",346],[10,"get_used_crate_source","","",346],[10,"reset","","",346],[10,"get_used_crates","","",346],[10,"add_used_library","","",346],[10,"get_used_libraries","","",346],[10,"add_used_link_args","","",346],[10,"get_used_link_args","","",346],[10,"add_extern_mod_stmt_cnum","","",346],[10,"find_extern_mod_stmt_cnum","","",346],[10,"data","","",344],[10,"name","","",344],[10,"hash","","",344],[10,"as_slice","","",347],[0,"csearch","rustc::metadata",""],[1,"StaticMethodInfo","rustc::metadata::csearch",""],[11,"ident","","",350],[11,"def_id","","",350],[11,"fn_style","","",350],[11,"vis","","",350],[2,"found_ast","",""],[12,"found","","",351],[12,"found_parent","","",351],[12,"not_found","","",351],[3,"get_symbol","",""],[3,"each_lang_item","","Iterates over all the language items in the given crate."],[3,"each_child_of_item","","Iterates over each child of the given item."],[3,"each_top_level_item_of_crate","","Iterates over each top-level crate item."],[3,"get_item_path","",""],[3,"maybe_get_item_ast","",""],[3,"get_enum_variants","",""],[3,"get_impl_methods","","Returns information about the given implementation."],[3,"get_method","",""],[3,"get_method_name_and_explicit_self","",""],[3,"get_trait_method_def_ids","",""],[3,"get_item_variances","",""],[3,"get_provided_trait_methods","",""],[3,"get_supertraits","",""],[3,"get_type_name_if_impl","",""],[3,"get_static_methods_if_impl","",""],[3,"get_item_attrs","",""],[3,"get_struct_fields","",""],[3,"get_struct_field_attrs","",""],[3,"get_type","",""],[3,"get_trait_def","",""],[3,"get_field_type","",""],[3,"get_impl_trait","",""],[3,"get_impl_vtables","",""],[3,"get_native_libraries","",""],[3,"each_impl","",""],[3,"each_implementation_for_type","",""],[3,"each_implementation_for_trait","",""],[3,"get_trait_of_method","","If the given def ID describes a method belonging to a trait (either a\ndefault method or an implementation of a trait method), returns the ID of\nthe trait that the method belongs to. Otherwise, returns `None`."],[3,"get_tuple_struct_definition_if_ctor","",""],[3,"get_dylib_dependency_formats","",""],[3,"get_missing_lang_items","",""],[3,"get_method_arg_names","",""],[3,"get_reachable_extern_fns","",""],[3,"is_typedef","",""],[3,"get_stability","",""],[0,"loader","rustc::metadata","Finds crate binaries and loads their metadata"],[1,"CrateMismatch","rustc::metadata::loader",""],[1,"Context","",""],[11,"sess","","",352],[11,"span","","",352],[11,"ident","","",352],[11,"crate_name","","",352],[11,"hash","","",352],[11,"triple","","",352],[11,"os","","",352],[11,"filesearch","","",352],[11,"root","","",352],[11,"rejected_via_hash","","",352],[11,"rejected_via_triple","","",352],[11,"should_match_name","","",352],[1,"Library","",""],[11,"dylib","","",353],[11,"rlib","","",353],[11,"metadata","","",353],[1,"ArchiveMetadata","",""],[1,"CratePaths","",""],[11,"ident","","",354],[11,"dylib","","",354],[11,"rlib","","",354],[3,"note_crate_name","",""],[3,"meta_section_name","",""],[3,"read_meta_section_name","",""],[3,"list_file_metadata","",""],[5,"MACOS_DLL_PREFIX","",""],[5,"MACOS_DLL_SUFFIX","",""],[5,"WIN32_DLL_PREFIX","",""],[5,"WIN32_DLL_SUFFIX","",""],[5,"LINUX_DLL_PREFIX","",""],[5,"LINUX_DLL_SUFFIX","",""],[5,"FREEBSD_DLL_PREFIX","",""],[5,"FREEBSD_DLL_SUFFIX","",""],[5,"DRAGONFLY_DLL_PREFIX","",""],[5,"DRAGONFLY_DLL_SUFFIX","",""],[5,"ANDROID_DLL_PREFIX","",""],[5,"ANDROID_DLL_SUFFIX","",""],[10,"maybe_load_library_crate","","",352],[10,"load_library_crate","","",352],[10,"report_load_errs","","",352],[10,"as_slice","","",355],[0,"filesearch","rustc::metadata",""],[1,"FileSearch","rustc::metadata::filesearch",""],[11,"sysroot","","",356],[11,"addl_lib_search_paths","","",356],[11,"triple","","",356],[2,"FileMatch","",""],[12,"FileMatches","","",357],[12,"FileDoesntMatch","","",357],[3,"relative_target_lib_path","",""],[3,"get_or_default_sysroot","",""],[3,"get_rust_path","","Returns RUST_PATH as a string, without default paths added"],[3,"rust_path","","Returns the value of RUST_PATH, as a list\nof Paths. Includes default entries for, if they exist:\n$HOME/.rust\nDIR/.rust for any DIR that's the current working directory\nor an ancestor of it"],[3,"rustlibdir","",""],[4,"pick","","Functions with type `pick` take a parent directory as well as\na file found in that directory."],[10,"for_each_lib_search_path","","",356],[10,"get_lib_path","","",356],[10,"search","","",356],[10,"new","","",356],[10,"add_dylib_search_paths","","",356],[0,"driver","rustc",""],[2,"PpMode","rustc::driver",""],[12,"PpmNormal","","",358],[12,"PpmExpanded","","",358],[12,"PpmTyped","","",358],[12,"PpmIdentified","","",358],[12,"PpmExpandedIdentified","","",358],[12,"PpmFlowGraph","","",358],[3,"main_args","",""],[3,"version","","Prints version information and returns None on success or an error\nmessage on failure."],[3,"handle_options","","Process command line options. Emits messages as appropriate. If compilation\nshould continue, returns a getopts::Matches object parsed from args, otherwise\nreturns None."],[3,"parse_pretty","",""],[3,"early_error","",""],[3,"early_warn","",""],[3,"list_metadata","",""],[3,"monitor","","Run a procedure which will detect failures in the compiler and print nicer\nerror messages rather than just failing the test."],[0,"driver","",""],[1,"CrateAnalysis","rustc::driver::driver",""],[11,"exp_map2","","",359],[11,"exported_items","","",359],[11,"public_items","","",359],[11,"ty_cx","","",359],[11,"reachable","","",359],[11,"name","","",359],[1,"CrateTranslation","",""],[11,"context","","",360],[11,"module","","",360],[11,"metadata_module","","",360],[11,"link","","",360],[11,"metadata","","",360],[11,"reachable","","",360],[11,"crate_formats","","",360],[11,"no_builtins","","",360],[1,"OutputFilenames","",""],[11,"out_directory","","",361],[11,"out_filestem","","",361],[11,"single_output_file","","",361],[2,"Input","",""],[12,"FileInput","","Load source from file",362],[12,"StrInput","","The string is the source",362],[3,"host_triple","",""],[3,"compile_input","",""],[3,"anon_src","","The name used for source code that doesn't originate in a file\n(e.g. source from stdin or a string)"],[3,"source_name","",""],[3,"phase_1_parse_input","",""],[3,"phase_2_configure_and_expand","","Run the \"early phases\" of the compiler: initial `cfg` processing,\nloading compiler plugins (including those from `addl_plugins`),\nsyntax expansion, secondary `cfg` expansion, synthesis of a test\nharness if one is to be provided and injection of a dependency on the\nstandard library and prelude."],[3,"phase_3_run_analysis_passes","","Run the resolution, typechecking, region checking and other\nmiscellaneous analysis passes on the crate. Return various\nstructures carrying the results of the analysis."],[3,"phase_save_analysis","",""],[3,"phase_4_translate_to_llvm","","Run the translation phase to LLVM, after which the AST and analysis can\nbe discarded."],[3,"phase_5_run_llvm_passes","","Run LLVM itself, producing a bitcode file, assembly file or object file\nas a side effect."],[3,"phase_6_link_output","","Run the linker on any artifacts that resulted from the LLVM run.\nThis should produce either a finished executable or library."],[3,"stop_after_phase_3","",""],[3,"stop_after_phase_1","",""],[3,"stop_after_phase_2","",""],[3,"stop_after_phase_5","",""],[3,"pretty_print_input","",""],[3,"collect_crate_types","",""],[3,"collect_crate_metadata","",""],[3,"build_output_filenames","",""],[10,"path","","",361],[10,"temp_path","","",361],[10,"with_extension","","",361],[0,"session","rustc::driver",""],[1,"Session","rustc::driver::session",""],[11,"targ_cfg","","",363],[11,"opts","","",363],[11,"cstore","","",363],[11,"parse_sess","","",363],[11,"entry_fn","","",363],[11,"entry_type","","",363],[11,"plugin_registrar_fn","","",363],[11,"default_sysroot","","",363],[11,"local_crate_source_file","","",363],[11,"working_dir","","",363],[11,"lint_store","","",363],[11,"lints","","",363],[11,"node_id","","",363],[11,"crate_types","","",363],[11,"crate_metadata","","",363],[11,"features","","",363],[11,"recursion_limit","","The maximum recursion limit for potentially infinitely recursive\noperations such as auto-dereference and monomorphization.",363],[3,"build_session","",""],[3,"build_session_","",""],[3,"expect","",""],[10,"span_fatal","","",363],[10,"fatal","","",363],[10,"span_err","","",363],[10,"span_err_with_code","","",363],[10,"err","","",363],[10,"err_count","","",363],[10,"has_errors","","",363],[10,"abort_if_errors","","",363],[10,"span_warn","","",363],[10,"span_warn_with_code","","",363],[10,"warn","","",363],[10,"span_note","","",363],[10,"span_end_note","","",363],[10,"fileline_note","","",363],[10,"note","","",363],[10,"span_bug","","",363],[10,"bug","","",363],[10,"span_unimpl","","",363],[10,"unimpl","","",363],[10,"add_lint","","",363],[10,"next_node_id","","",363],[10,"reserve_node_ids","","",363],[10,"diagnostic","","",363],[10,"debugging_opt","","",363],[10,"codemap","","",363],[10,"impossible_case","","",363],[10,"verbose","","",363],[10,"time_passes","","",363],[10,"count_llvm_insns","","",363],[10,"count_type_sizes","","",363],[10,"time_llvm_passes","","",363],[10,"trans_stats","","",363],[10,"meta_stats","","",363],[10,"asm_comments","","",363],[10,"no_verify","","",363],[10,"borrowck_stats","","",363],[10,"print_llvm_passes","","",363],[10,"lto","","",363],[10,"no_landing_pads","","",363],[10,"show_span","","",363],[10,"sysroot","","",363],[10,"target_filesearch","","",363],[10,"host_filesearch","","",363],[0,"config","rustc::driver","Contains infrastructure for configuring the compiler, including parsing\ncommand line options."],[1,"Config","rustc::driver::config",""],[11,"os","","",364],[11,"arch","","",364],[11,"target_strs","","",364],[11,"int_type","","",364],[11,"uint_type","","",364],[1,"Options","",""],[11,"crate_types","","",365],[11,"gc","","",365],[11,"optimize","","",365],[11,"debuginfo","","",365],[11,"lint_opts","","",365],[11,"describe_lints","","",365],[11,"output_types","","",365],[11,"addl_lib_search_paths","","",365],[11,"maybe_sysroot","","",365],[11,"target_triple","","",365],[11,"cfg","","",365],[11,"test","","",365],[11,"parse_only","","",365],[11,"no_trans","","",365],[11,"no_analysis","","",365],[11,"debugging_opts","","",365],[11,"write_dependency_info","","Whether to write dependency files. It's (enabled, optional filename).",365],[11,"print_metas","","Crate id-related things to maybe print. It's (crate_name, crate_file_name).",365],[11,"cg","","",365],[11,"color","","",365],[11,"externs","","",365],[11,"crate_name","","",365],[11,"alt_std_name","","An optional name to use as the crate for std during std injection,\nwritten `extern crate std = \"name\"`. Default to \"std\". Used by\nout-of-tree drivers.",365],[1,"CodegenOptions","",""],[11,"ar","","",366],[11,"linker","","",366],[11,"link_args","","",366],[11,"target_cpu","","",366],[11,"target_feature","","",366],[11,"passes","","",366],[11,"llvm_args","","",366],[11,"save_temps","","",366],[11,"rpath","","",366],[11,"no_prepopulate_passes","","",366],[11,"no_vectorize_loops","","",366],[11,"no_vectorize_slp","","",366],[11,"soft_float","","",366],[11,"prefer_dynamic","","",366],[11,"no_integrated_as","","",366],[11,"no_redzone","","",366],[11,"relocation_model","","",366],[11,"code_model","","",366],[11,"metadata","","",366],[11,"extra_filename","","",366],[2,"OptLevel","",""],[12,"No","","",367],[12,"Less","","",367],[12,"Default","","",367],[12,"Aggressive","","",367],[2,"DebugInfoLevel","",""],[12,"NoDebugInfo","","",368],[12,"LimitedDebugInfo","","",368],[12,"FullDebugInfo","","",368],[2,"EntryFnType","",""],[12,"EntryMain","","",369],[12,"EntryStart","","",369],[12,"EntryNone","","",369],[2,"CrateType","",""],[12,"CrateTypeExecutable","","",370],[12,"CrateTypeDylib","","",370],[12,"CrateTypeRlib","","",370],[12,"CrateTypeStaticlib","","",370],[3,"basic_options","","Some reasonable defaults"],[3,"debugging_opts_map","",""],[3,"basic_codegen_options","",""],[3,"build_codegen_options","",""],[3,"default_lib_output","",""],[3,"default_configuration","",""],[3,"append_configuration","",""],[3,"build_configuration","",""],[3,"get_os","",""],[3,"get_arch","",""],[3,"build_target_config","",""],[3,"optgroups","",""],[3,"build_session_options","",""],[3,"parse_crate_types_from_list","",""],[4,"CodegenSetter","",""],[5,"VERBOSE","",""],[5,"TIME_PASSES","",""],[5,"COUNT_LLVM_INSNS","",""],[5,"TIME_LLVM_PASSES","",""],[5,"TRANS_STATS","",""],[5,"ASM_COMMENTS","",""],[5,"NO_VERIFY","",""],[5,"BORROWCK_STATS","",""],[5,"NO_LANDING_PADS","",""],[5,"DEBUG_LLVM","",""],[5,"SHOW_SPAN","",""],[5,"COUNT_TYPE_SIZES","",""],[5,"META_STATS","",""],[5,"NO_OPT","",""],[5,"GC","",""],[5,"PRINT_LINK_ARGS","",""],[5,"PRINT_LLVM_PASSES","",""],[5,"LTO","",""],[5,"AST_JSON","",""],[5,"AST_JSON_NOEXPAND","",""],[5,"LS","",""],[5,"SAVE_ANALYSIS","",""],[5,"FLOWGRAPH_PRINT_LOANS","",""],[5,"FLOWGRAPH_PRINT_MOVES","",""],[5,"FLOWGRAPH_PRINT_ASSIGNS","",""],[5,"FLOWGRAPH_PRINT_ALL","",""],[5,"CG_OPTIONS","",""],[10,"eq","","",367],[10,"ne","","",367],[10,"clone","","",367],[10,"eq","","",368],[10,"ne","","",368],[10,"clone","","",368],[10,"clone","","",365],[10,"eq","","",369],[10,"ne","","",369],[10,"hash","","",370],[10,"cmp","","",370],[10,"clone","","",370],[10,"partial_cmp","","",370],[10,"lt","","",370],[10,"le","","",370],[10,"gt","","",370],[10,"ge","","",370],[10,"eq","","",370],[10,"ne","","",370],[10,"clone","","",366],[10,"fmt","","",370],[0,"diagnostic","rustc::driver",""],[10,"new","syntax::util::interner","",371],[10,"prefill","","",371],[10,"intern","","",371],[10,"gensym","","",371],[10,"get","","",371],[10,"len","","",371],[10,"find_equiv","","",371],[10,"clear","","",371],[10,"partial_cmp","","",372],[10,"lt","","",372],[10,"le","","",372],[10,"gt","","",372],[10,"ge","","",372],[10,"lt","","",372],[10,"le","","",372],[10,"gt","","",372],[10,"ge","","",372],[10,"hash","","",372],[10,"eq","","",372],[10,"ne","","",372],[10,"ne","","",372],[10,"clone","","",372],[10,"clone_from","","",372],[10,"assert_receiver_is_total_eq","","",372],[10,"cmp","","",372],[10,"as_slice","","",372],[10,"fmt","","",372],[10,"new","","",372],[10,"new","","",373],[10,"prefill","","",373],[10,"intern","","",373],[10,"gensym","","",373],[10,"gensym_copy","","Create a gensym with the same name as an existing\nentry.",373],[10,"get","","",373],[10,"get_ref","","Returns this string with lifetime tied to the interner. Since\nstrings may never be removed from the interner, this is safe.",373],[10,"len","","",373],[10,"find_equiv","","",373],[10,"clear","","",373],[10,"len","syntax::util::small_vector","",374],[10,"is_empty","","",374],[10,"from_iter","","",374],[10,"extend","","",374],[10,"zero","","",374],[10,"one","","",374],[10,"many","","",374],[10,"as_slice","","",374],[10,"push","","",374],[10,"push_all","","",374],[10,"get","","",374],[10,"expect_one","","",374],[10,"move_iter","","",374],[10,"next","","",375],[10,"size_hint","","",375],[10,"size_hint","","",375],[10,"chain","","",375],[10,"zip","","",375],[10,"map","","",375],[10,"filter","","",375],[10,"filter_map","","",375],[10,"enumerate","","",375],[10,"peekable","","",375],[10,"skip_while","","",375],[10,"take_while","","",375],[10,"skip","","",375],[10,"take","","",375],[10,"scan","","",375],[10,"flat_map","","",375],[10,"fuse","","",375],[10,"inspect","","",375],[10,"by_ref","","",375],[10,"advance","","",375],[10,"collect","","",375],[10,"nth","","",375],[10,"last","","",375],[10,"fold","","",375],[10,"count","","",375],[10,"all","","",375],[10,"any","","",375],[10,"find","","",375],[10,"position","","",375],[10,"max_by","","",375],[10,"min_by","","",375],[10,"new","syntax::diagnostics::registry","",376],[10,"find_description","","",376],[10,"expand","syntax::ext::base","",377],[10,"expand","","",378],[10,"new","","",379],[10,"make_expr","","",379],[10,"make_def","","",379],[10,"make_expr","","",379],[10,"make_items","","",379],[10,"make_methods","","",379],[10,"make_pat","","",379],[10,"make_stmt","","",379],[10,"new","","",380],[10,"make_pat","","",380],[10,"make_def","","",380],[10,"make_expr","","",380],[10,"make_items","","",380],[10,"make_methods","","",380],[10,"make_pat","","",380],[10,"make_stmt","","",380],[10,"new","","",381],[10,"make_items","","",381],[10,"make_stmt","","",381],[10,"make_def","","",381],[10,"make_expr","","",381],[10,"make_items","","",381],[10,"make_methods","","",381],[10,"make_pat","","",381],[10,"make_stmt","","",381],[10,"any","","Create a default MacResult that can be anything.",382],[10,"expr","","Create a default MacResult that can only be an expression.",382],[10,"raw_expr","","A plain dummy expression.",382],[10,"raw_pat","","A plain dummy pattern.",382],[10,"make_expr","","",382],[10,"make_pat","","",382],[10,"make_items","","",382],[10,"make_methods","","",382],[10,"make_stmt","","",382],[10,"make_def","","",382],[10,"make_expr","","",382],[10,"make_items","","",382],[10,"make_methods","","",382],[10,"make_pat","","",382],[10,"make_stmt","","",382],[10,"new","","",383],[10,"new","","",384],[10,"expand_expr","","",384],[10,"expander","","Returns a `Folder` for deeply expanding all macros in a AST node.",384],[10,"new_parser_from_tts","","",384],[10,"codemap","","",384],[10,"parse_sess","","",384],[10,"cfg","","",384],[10,"call_site","","",384],[10,"print_backtrace","","",384],[10,"backtrace","","",384],[10,"mod_push","","",384],[10,"mod_pop","","",384],[10,"mod_path","","",384],[10,"bt_push","","",384],[10,"bt_pop","","",384],[10,"span_fatal","","Emit `msg` attached to `sp`, and stop compilation immediately.",384],[10,"span_err","","Emit `msg` attached to `sp`, without immediately stopping\ncompilation.",384],[10,"span_warn","","",384],[10,"span_unimpl","","",384],[10,"span_bug","","",384],[10,"span_note","","",384],[10,"bug","","",384],[10,"trace_macros","","",384],[10,"set_trace_macros","","",384],[10,"ident_of","","",384],[10,"name_of","","",384],[10,"push_frame","","",385],[10,"pop_frame","","",385],[10,"find","","",385],[10,"insert","","",385],[10,"info","","",385],[10,"path","","",384],[10,"path_ident","","",384],[10,"path_global","","",384],[10,"path_all","","",384],[10,"ty_mt","","",384],[10,"ty","","",384],[10,"ty_path","","",384],[10,"ty_ident","","",384],[10,"ty_rptr","","",384],[10,"ty_uniq","","",384],[10,"ty_option","","",384],[10,"ty_field_imm","","",384],[10,"ty_infer","","",384],[10,"ty_nil","","",384],[10,"typaram","","",384],[10,"ty_vars","","",384],[10,"ty_vars_global","","",384],[10,"strip_bounds","","",384],[10,"trait_ref","","",384],[10,"typarambound","","",384],[10,"lifetime","","",384],[10,"stmt_expr","","",384],[10,"stmt_let","","",384],[10,"stmt_let_typed","","",384],[10,"block","","",384],[10,"stmt_item","","",384],[10,"block_expr","","",384],[10,"block_all","","",384],[10,"expr","","",384],[10,"expr_path","","",384],[10,"expr_ident","","",384],[10,"expr_self","","",384],[10,"expr_binary","","",384],[10,"expr_deref","","",384],[10,"expr_unary","","",384],[10,"expr_managed","","",384],[10,"expr_field_access","","",384],[10,"expr_addr_of","","",384],[10,"expr_mut_addr_of","","",384],[10,"expr_call","","",384],[10,"expr_call_ident","","",384],[10,"expr_call_global","","",384],[10,"expr_method_call","","",384],[10,"expr_block","","",384],[10,"field_imm","","",384],[10,"expr_struct","","",384],[10,"expr_struct_ident","","",384],[10,"expr_lit","","",384],[10,"expr_uint","","",384],[10,"expr_int","","",384],[10,"expr_u8","","",384],[10,"expr_bool","","",384],[10,"expr_vstore","","",384],[10,"expr_vec","","",384],[10,"expr_vec_ng","","",384],[10,"expr_vec_slice","","",384],[10,"expr_str","","",384],[10,"expr_str_uniq","","",384],[10,"expr_cast","","",384],[10,"expr_some","","",384],[10,"expr_none","","",384],[10,"expr_tuple","","",384],[10,"expr_fail","","",384],[10,"expr_unreachable","","",384],[10,"expr_ok","","",384],[10,"expr_err","","",384],[10,"expr_try","","",384],[10,"pat","","",384],[10,"pat_wild","","",384],[10,"pat_lit","","",384],[10,"pat_ident","","",384],[10,"pat_ident_binding_mode","","",384],[10,"pat_enum","","",384],[10,"pat_struct","","",384],[10,"pat_tuple","","",384],[10,"pat_some","","",384],[10,"pat_none","","",384],[10,"pat_ok","","",384],[10,"pat_err","","",384],[10,"arm","","",384],[10,"arm_unreachable","","",384],[10,"expr_match","","",384],[10,"expr_if","","",384],[10,"expr_loop","","",384],[10,"lambda_fn_decl","","",384],[10,"lambda","","",384],[10,"lambda0","","",384],[10,"lambda1","","",384],[10,"lambda_expr","","",384],[10,"lambda_expr_0","","",384],[10,"lambda_expr_1","","",384],[10,"lambda_stmts","","",384],[10,"lambda_stmts_0","","",384],[10,"lambda_stmts_1","","",384],[10,"arg","","",384],[10,"fn_decl","","",384],[10,"item","","",384],[10,"item_fn_poly","","",384],[10,"item_fn","","",384],[10,"variant","","",384],[10,"item_enum_poly","","",384],[10,"item_enum","","",384],[10,"item_struct","","",384],[10,"item_struct_poly","","",384],[10,"item_mod","","",384],[10,"item_static","","",384],[10,"item_ty_poly","","",384],[10,"item_ty","","",384],[10,"attribute","","",384],[10,"meta_word","","",384],[10,"meta_list","","",384],[10,"meta_name_value","","",384],[10,"view_use","","",384],[10,"view_use_simple","","",384],[10,"view_use_simple_","","",384],[10,"view_use_list","","",384],[10,"view_use_glob","","",384],[10,"new_id","syntax::ext::build","",386],[10,"fold_crate","","",386],[10,"fold_meta_items","","",386],[10,"fold_meta_item","","",386],[10,"fold_view_path","","",386],[10,"fold_view_item","","",386],[10,"fold_foreign_item","","",386],[10,"fold_item","","",386],[10,"fold_item_simple","","",386],[10,"fold_struct_field","","",386],[10,"fold_item_underscore","","",386],[10,"fold_fn_decl","","",386],[10,"fold_type_method","","",386],[10,"fold_method","","",386],[10,"fold_block","","",386],[10,"fold_stmt","","",386],[10,"fold_arm","","",386],[10,"fold_pat","","",386],[10,"fold_decl","","",386],[10,"fold_expr","","",386],[10,"fold_ty","","",386],[10,"fold_mod","","",386],[10,"fold_foreign_mod","","",386],[10,"fold_variant","","",386],[10,"fold_ident","","",386],[10,"fold_path","","",386],[10,"fold_local","","",386],[10,"fold_mac","","",386],[10,"fold_explicit_self","","",386],[10,"fold_explicit_self_underscore","","",386],[10,"fold_lifetime","","",386],[10,"fold_attribute","","",386],[10,"fold_arg","","",386],[10,"fold_generics","","",386],[10,"fold_trait_ref","","",386],[10,"fold_struct_def","","",386],[10,"fold_lifetimes","","",386],[10,"fold_ty_param","","",386],[10,"fold_ty_params","","",386],[10,"fold_tt","","",386],[10,"fold_tts","","",386],[10,"fold_token","","",386],[10,"fold_interpolated","","",386],[10,"fold_opt_lifetime","","",386],[10,"fold_variant_arg","","",386],[10,"fold_ty_param_bound","","",386],[10,"fold_opt_bounds","","",386],[10,"fold_mt","","",386],[10,"fold_field","","",386],[10,"map_exprs","","",386],[10,"new_id","","",386],[10,"new_span","","",386],[10,"duplicate","std::gc","",387],[10,"clone","syntax::ext::deriving::generic::ty","",388],[10,"clone_from","","",388],[10,"clone","","",389],[10,"clone_from","","",389],[10,"new","","",389],[10,"new_local","","",389],[10,"new_","","",389],[10,"to_ty","","",389],[10,"to_path","","",389],[10,"clone","","",390],[10,"clone_from","","",390],[10,"to_ty","","",390],[10,"to_path","","",390],[10,"clone","","",391],[10,"clone_from","","",391],[10,"empty","","",391],[10,"to_generics","","",391],[10,"expand","syntax::ext::deriving::generic","",392],[10,"eq","","",393],[10,"ne","","",393],[10,"ne","","",393],[10,"clone","syntax::ext::expand","",394],[10,"clone_from","","",394],[10,"visit_pat","","",394],[10,"visit_ident","","",394],[10,"visit_mod","","",394],[10,"visit_view_item","","",394],[10,"visit_foreign_item","","",394],[10,"visit_item","","",394],[10,"visit_local","","",394],[10,"visit_block","","",394],[10,"visit_stmt","","",394],[10,"visit_arm","","",394],[10,"visit_pat","","",394],[10,"visit_decl","","",394],[10,"visit_expr","","",394],[10,"visit_expr_post","","",394],[10,"visit_ty","","",394],[10,"visit_generics","","",394],[10,"visit_fn","","",394],[10,"visit_ty_method","","",394],[10,"visit_trait_method","","",394],[10,"visit_struct_def","","",394],[10,"visit_struct_field","","",394],[10,"visit_variant","","",394],[10,"visit_opt_lifetime_ref","","",394],[10,"visit_lifetime_ref","","",394],[10,"visit_lifetime_decl","","",394],[10,"visit_explicit_self","","",394],[10,"visit_mac","","",394],[10,"visit_path","","",394],[10,"visit_attribute","","",394],[10,"fold_ident","","",395],[10,"fold_mac","","",395],[10,"fold_crate","","",395],[10,"fold_meta_items","","",395],[10,"fold_meta_item","","",395],[10,"fold_view_path","","",395],[10,"fold_view_item","","",395],[10,"fold_foreign_item","","",395],[10,"fold_item","","",395],[10,"fold_item_simple","","",395],[10,"fold_struct_field","","",395],[10,"fold_item_underscore","","",395],[10,"fold_fn_decl","","",395],[10,"fold_type_method","","",395],[10,"fold_method","","",395],[10,"fold_block","","",395],[10,"fold_stmt","","",395],[10,"fold_arm","","",395],[10,"fold_pat","","",395],[10,"fold_decl","","",395],[10,"fold_expr","","",395],[10,"fold_ty","","",395],[10,"fold_mod","","",395],[10,"fold_foreign_mod","","",395],[10,"fold_variant","","",395],[10,"fold_ident","","",395],[10,"fold_path","","",395],[10,"fold_local","","",395],[10,"fold_mac","","",395],[10,"fold_explicit_self","","",395],[10,"fold_explicit_self_underscore","","",395],[10,"fold_lifetime","","",395],[10,"fold_attribute","","",395],[10,"fold_arg","","",395],[10,"fold_generics","","",395],[10,"fold_trait_ref","","",395],[10,"fold_struct_def","","",395],[10,"fold_lifetimes","","",395],[10,"fold_ty_param","","",395],[10,"fold_ty_params","","",395],[10,"fold_tt","","",395],[10,"fold_tts","","",395],[10,"fold_token","","",395],[10,"fold_interpolated","","",395],[10,"fold_opt_lifetime","","",395],[10,"fold_variant_arg","","",395],[10,"fold_ty_param_bound","","",395],[10,"fold_opt_bounds","","",395],[10,"fold_mt","","",395],[10,"fold_field","","",395],[10,"map_exprs","","",395],[10,"new_id","","",395],[10,"new_span","","",395],[10,"fold_pat","","",396],[10,"fold_mac","","",396],[10,"fold_crate","","",396],[10,"fold_meta_items","","",396],[10,"fold_meta_item","","",396],[10,"fold_view_path","","",396],[10,"fold_view_item","","",396],[10,"fold_foreign_item","","",396],[10,"fold_item","","",396],[10,"fold_item_simple","","",396],[10,"fold_struct_field","","",396],[10,"fold_item_underscore","","",396],[10,"fold_fn_decl","","",396],[10,"fold_type_method","","",396],[10,"fold_method","","",396],[10,"fold_block","","",396],[10,"fold_stmt","","",396],[10,"fold_arm","","",396],[10,"fold_pat","","",396],[10,"fold_decl","","",396],[10,"fold_expr","","",396],[10,"fold_ty","","",396],[10,"fold_mod","","",396],[10,"fold_foreign_mod","","",396],[10,"fold_variant","","",396],[10,"fold_ident","","",396],[10,"fold_path","","",396],[10,"fold_local","","",396],[10,"fold_mac","","",396],[10,"fold_explicit_self","","",396],[10,"fold_explicit_self_underscore","","",396],[10,"fold_lifetime","","",396],[10,"fold_attribute","","",396],[10,"fold_arg","","",396],[10,"fold_generics","","",396],[10,"fold_trait_ref","","",396],[10,"fold_struct_def","","",396],[10,"fold_lifetimes","","",396],[10,"fold_ty_param","","",396],[10,"fold_ty_params","","",396],[10,"fold_tt","","",396],[10,"fold_tts","","",396],[10,"fold_token","","",396],[10,"fold_interpolated","","",396],[10,"fold_opt_lifetime","","",396],[10,"fold_variant_arg","","",396],[10,"fold_ty_param_bound","","",396],[10,"fold_opt_bounds","","",396],[10,"fold_mt","","",396],[10,"fold_field","","",396],[10,"map_exprs","","",396],[10,"new_id","","",396],[10,"new_span","","",396],[10,"fold_expr","","",397],[10,"fold_pat","","",397],[10,"fold_item","","",397],[10,"fold_item_underscore","","",397],[10,"fold_stmt","","",397],[10,"fold_block","","",397],[10,"fold_arm","","",397],[10,"fold_method","","",397],[10,"new_span","","",397],[10,"fold_crate","","",397],[10,"fold_meta_items","","",397],[10,"fold_meta_item","","",397],[10,"fold_view_path","","",397],[10,"fold_view_item","","",397],[10,"fold_foreign_item","","",397],[10,"fold_item","","",397],[10,"fold_item_simple","","",397],[10,"fold_struct_field","","",397],[10,"fold_item_underscore","","",397],[10,"fold_fn_decl","","",397],[10,"fold_type_method","","",397],[10,"fold_method","","",397],[10,"fold_block","","",397],[10,"fold_stmt","","",397],[10,"fold_arm","","",397],[10,"fold_pat","","",397],[10,"fold_decl","","",397],[10,"fold_expr","","",397],[10,"fold_ty","","",397],[10,"fold_mod","","",397],[10,"fold_foreign_mod","","",397],[10,"fold_variant","","",397],[10,"fold_ident","","",397],[10,"fold_path","","",397],[10,"fold_local","","",397],[10,"fold_mac","","",397],[10,"fold_explicit_self","","",397],[10,"fold_explicit_self_underscore","","",397],[10,"fold_lifetime","","",397],[10,"fold_attribute","","",397],[10,"fold_arg","","",397],[10,"fold_generics","","",397],[10,"fold_trait_ref","","",397],[10,"fold_struct_def","","",397],[10,"fold_lifetimes","","",397],[10,"fold_ty_param","","",397],[10,"fold_ty_params","","",397],[10,"fold_tt","","",397],[10,"fold_tts","","",397],[10,"fold_token","","",397],[10,"fold_interpolated","","",397],[10,"fold_opt_lifetime","","",397],[10,"fold_variant_arg","","",397],[10,"fold_ty_param_bound","","",397],[10,"fold_opt_bounds","","",397],[10,"fold_mt","","",397],[10,"fold_field","","",397],[10,"map_exprs","","",397],[10,"new_id","","",397],[10,"new_span","","",397],[10,"fold_ident","","",398],[10,"fold_mac","","",398],[10,"fold_crate","","",398],[10,"fold_meta_items","","",398],[10,"fold_meta_item","","",398],[10,"fold_view_path","","",398],[10,"fold_view_item","","",398],[10,"fold_foreign_item","","",398],[10,"fold_item","","",398],[10,"fold_item_simple","","",398],[10,"fold_struct_field","","",398],[10,"fold_item_underscore","","",398],[10,"fold_fn_decl","","",398],[10,"fold_type_method","","",398],[10,"fold_method","","",398],[10,"fold_block","","",398],[10,"fold_stmt","","",398],[10,"fold_arm","","",398],[10,"fold_pat","","",398],[10,"fold_decl","","",398],[10,"fold_expr","","",398],[10,"fold_ty","","",398],[10,"fold_mod","","",398],[10,"fold_foreign_mod","","",398],[10,"fold_variant","","",398],[10,"fold_ident","","",398],[10,"fold_path","","",398],[10,"fold_local","","",398],[10,"fold_mac","","",398],[10,"fold_explicit_self","","",398],[10,"fold_explicit_self_underscore","","",398],[10,"fold_lifetime","","",398],[10,"fold_attribute","","",398],[10,"fold_arg","","",398],[10,"fold_generics","","",398],[10,"fold_trait_ref","","",398],[10,"fold_struct_def","","",398],[10,"fold_lifetimes","","",398],[10,"fold_ty_param","","",398],[10,"fold_ty_params","","",398],[10,"fold_tt","","",398],[10,"fold_tts","","",398],[10,"fold_token","","",398],[10,"fold_interpolated","","",398],[10,"fold_opt_lifetime","","",398],[10,"fold_variant_arg","","",398],[10,"fold_ty_param_bound","","",398],[10,"fold_opt_bounds","","",398],[10,"fold_mt","","",398],[10,"fold_field","","",398],[10,"map_exprs","","",398],[10,"new_id","","",398],[10,"new_span","","",398],[10,"visit_mac","","",399],[10,"visit_ident","","",399],[10,"visit_mod","","",399],[10,"visit_view_item","","",399],[10,"visit_foreign_item","","",399],[10,"visit_item","","",399],[10,"visit_local","","",399],[10,"visit_block","","",399],[10,"visit_stmt","","",399],[10,"visit_arm","","",399],[10,"visit_pat","","",399],[10,"visit_decl","","",399],[10,"visit_expr","","",399],[10,"visit_expr_post","","",399],[10,"visit_ty","","",399],[10,"visit_generics","","",399],[10,"visit_fn","","",399],[10,"visit_ty_method","","",399],[10,"visit_trait_method","","",399],[10,"visit_struct_def","","",399],[10,"visit_struct_field","","",399],[10,"visit_variant","","",399],[10,"visit_opt_lifetime_ref","","",399],[10,"visit_lifetime_ref","","",399],[10,"visit_lifetime_decl","","",399],[10,"visit_explicit_self","","",399],[10,"visit_mac","","",399],[10,"visit_path","","",399],[10,"visit_attribute","","",399],[10,"eq","syntax::ext::format","",400],[10,"ne","","",400],[10,"ne","","",400],[10,"hash","syntax::ext::mtwt","",401],[10,"decode","","",401],[10,"encode","","",401],[10,"eq","","",401],[10,"ne","","",401],[10,"ne","","",401],[10,"to_tokens","syntax::ast","",402],[10,"to_tokens","collections::vec","",253],[10,"to_tokens","syntax::codemap","",403],[10,"to_tokens","core::option","",28],[10,"to_source","syntax::ast","",9],[10,"to_source","","",404],[10,"to_source","","",405],[10,"to_source","","",406],[10,"to_source","","",407],[10,"to_source","std::gc","",387],[10,"to_source","","",387],[10,"to_source","","",387],[10,"to_source","","",387],[10,"to_source","","",387],[10,"to_source","syntax::ast","",408],[10,"to_source","","",409],[10,"to_tokens","","",9],[10,"to_tokens","std::gc","",387],[10,"to_tokens","","",387],[10,"to_tokens","syntax::ast","",408],[10,"to_tokens","std::gc","",387],[10,"to_tokens","syntax::ast","",404],[10,"to_tokens","","",407],[10,"to_tokens","std::gc","",387],[10,"to_tokens","","",387],[10,"to_tokens","syntax::ast","",405],[10,"to_tokens","","",406],[10,"to_tokens","","",409],[10,"parse_item","syntax::ext::base","",384],[10,"parse_stmt","","",384],[10,"parse_expr","","",384],[10,"parse_tts","","",384],[10,"clone","syntax::ext::tt::transcribe","",410],[10,"clone_from","","",410],[10,"clone","","",411],[10,"clone_from","","",411],[10,"clone","","",412],[10,"clone_from","","",412],[10,"clone","syntax::ext::tt::macro_parser","",413],[10,"clone_from","","",413],[10,"make_expr","syntax::ext::tt::macro_rules","",414],[10,"make_pat","","",414],[10,"make_items","","",414],[10,"make_methods","","",414],[10,"make_stmt","","",414],[10,"make_def","","",414],[10,"make_expr","","",414],[10,"make_items","","",414],[10,"make_methods","","",414],[10,"make_pat","","",414],[10,"make_stmt","","",414],[10,"expand","","",415],[10,"make_def","","",416],[10,"make_def","","",416],[10,"make_expr","","",416],[10,"make_items","","",416],[10,"make_methods","","",416],[10,"make_pat","","",416],[10,"make_stmt","","",416],[10,"cmp","syntax::ast","",9],[10,"assert_receiver_is_total_eq","","",9],[10,"partial_cmp","","",9],[10,"lt","","",9],[10,"le","","",9],[10,"gt","","",9],[10,"ge","","",9],[10,"lt","","",9],[10,"le","","",9],[10,"gt","","",9],[10,"ge","","",9],[10,"hash","","",9],[10,"clone","","",9],[10,"clone_from","","",9],[10,"new","","Construct an identifier with the given name and an empty context:",9],[10,"as_str","","",9],[10,"fmt","","",9],[10,"fmt","","",10],[10,"eq","","",9],[10,"ne","","",9],[10,"ne","","",9],[10,"clone","","",10],[10,"clone_from","","",10],[10,"decode","","",10],[10,"encode","","",10],[10,"hash","","",10],[10,"partial_cmp","","",10],[10,"lt","","",10],[10,"le","","",10],[10,"gt","","",10],[10,"ge","","",10],[10,"lt","","",10],[10,"le","","",10],[10,"gt","","",10],[10,"ge","","",10],[10,"eq","","",10],[10,"ne","","",10],[10,"ne","","",10],[10,"cmp","","",10],[10,"assert_receiver_is_total_eq","","",10],[10,"as_str","","",10],[10,"uint","","",10],[10,"ident","","",10],[10,"encode","","",9],[10,"decode","","",9],[10,"fmt","","",417],[10,"hash","","",417],[10,"decode","","",417],[10,"encode","","",417],[10,"assert_receiver_is_total_eq","","",417],[10,"eq","","",417],[10,"ne","","",417],[10,"ne","","",417],[10,"clone","","",417],[10,"clone_from","","",417],[10,"fmt","","",418],[10,"hash","","",418],[10,"decode","","",418],[10,"encode","","",418],[10,"assert_receiver_is_total_eq","","",418],[10,"eq","","",418],[10,"ne","","",418],[10,"ne","","",418],[10,"clone","","",418],[10,"clone_from","","",418],[10,"fmt","","",419],[10,"hash","","",419],[10,"decode","","",419],[10,"encode","","",419],[10,"assert_receiver_is_total_eq","","",419],[10,"eq","","",419],[10,"ne","","",419],[10,"ne","","",419],[10,"clone","","",419],[10,"clone_from","","",419],[10,"fmt","","",27],[10,"hash","","",27],[10,"decode","","",27],[10,"encode","","",27],[10,"eq","","",27],[10,"ne","","",27],[10,"ne","","",27],[10,"partial_cmp","","",27],[10,"lt","","",27],[10,"le","","",27],[10,"gt","","",27],[10,"ge","","",27],[10,"lt","","",27],[10,"le","","",27],[10,"gt","","",27],[10,"ge","","",27],[10,"cmp","","",27],[10,"assert_receiver_is_total_eq","","",27],[10,"clone","","",27],[10,"clone_from","","",27],[10,"fmt","","",420],[10,"hash","","",420],[10,"decode","","",420],[10,"encode","","",420],[10,"assert_receiver_is_total_eq","","",420],[10,"eq","","",420],[10,"ne","","",420],[10,"ne","","",420],[10,"clone","","",420],[10,"clone_from","","",420],[10,"fmt","","",421],[10,"hash","","",421],[10,"decode","","",421],[10,"encode","","",421],[10,"assert_receiver_is_total_eq","","",421],[10,"eq","","",421],[10,"ne","","",421],[10,"ne","","",421],[10,"clone","","",421],[10,"clone_from","","",421],[10,"fmt","","",407],[10,"hash","","",407],[10,"decode","","",407],[10,"encode","","",407],[10,"assert_receiver_is_total_eq","","",407],[10,"eq","","",407],[10,"ne","","",407],[10,"ne","","",407],[10,"clone","","",407],[10,"clone_from","","",407],[10,"is_parameterized","","",407],[10,"is_lt_parameterized","","",407],[10,"is_type_parameterized","","",407],[10,"fmt","","",422],[10,"hash","","",422],[10,"decode","","",422],[10,"encode","","",422],[10,"assert_receiver_is_total_eq","","",422],[10,"eq","","",422],[10,"ne","","",422],[10,"ne","","",422],[10,"clone","","",422],[10,"clone_from","","",422],[10,"fmt","","",423],[10,"hash","","",423],[10,"decode","","",423],[10,"encode","","",423],[10,"assert_receiver_is_total_eq","","",423],[10,"clone","","",423],[10,"clone_from","","",423],[10,"eq","","",423],[10,"ne","","",423],[10,"fmt","","",405],[10,"hash","","",405],[10,"decode","","",405],[10,"encode","","",405],[10,"assert_receiver_is_total_eq","","",405],[10,"eq","","",405],[10,"ne","","",405],[10,"ne","","",405],[10,"clone","","",405],[10,"clone_from","","",405],[10,"fmt","","",103],[10,"hash","","",103],[10,"decode","","",103],[10,"encode","","",103],[10,"assert_receiver_is_total_eq","","",103],[10,"eq","","",103],[10,"ne","","",103],[10,"ne","","",103],[10,"clone","","",103],[10,"clone_from","","",103],[10,"fmt","","",424],[10,"hash","","",424],[10,"decode","","",424],[10,"encode","","",424],[10,"assert_receiver_is_total_eq","","",424],[10,"eq","","",424],[10,"ne","","",424],[10,"ne","","",424],[10,"clone","","",424],[10,"clone_from","","",424],[10,"fmt","","",425],[10,"hash","","",425],[10,"decode","","",425],[10,"encode","","",425],[10,"assert_receiver_is_total_eq","","",425],[10,"eq","","",425],[10,"ne","","",425],[10,"ne","","",425],[10,"clone","","",425],[10,"clone_from","","",425],[10,"fmt","","",426],[10,"hash","","",426],[10,"decode","","",426],[10,"encode","","",426],[10,"assert_receiver_is_total_eq","","",426],[10,"eq","","",426],[10,"ne","","",426],[10,"ne","","",426],[10,"clone","","",426],[10,"clone_from","","",426],[10,"fmt","","",427],[10,"hash","","",427],[10,"decode","","",427],[10,"encode","","",427],[10,"assert_receiver_is_total_eq","","",427],[10,"eq","","",427],[10,"ne","","",427],[10,"ne","","",427],[10,"clone","","",427],[10,"clone_from","","",427],[10,"fmt","","",428],[10,"hash","","",428],[10,"decode","","",428],[10,"encode","","",428],[10,"assert_receiver_is_total_eq","","",428],[10,"eq","","",428],[10,"ne","","",428],[10,"ne","","",428],[10,"clone","","",428],[10,"clone_from","","",428],[10,"fmt","","",429],[10,"hash","","",429],[10,"decode","","",429],[10,"encode","","",429],[10,"assert_receiver_is_total_eq","","",429],[10,"eq","","",429],[10,"ne","","",429],[10,"ne","","",429],[10,"clone","","",429],[10,"clone_from","","",429],[10,"fmt","","",430],[10,"hash","","",430],[10,"decode","","",430],[10,"encode","","",430],[10,"assert_receiver_is_total_eq","","",430],[10,"eq","","",430],[10,"ne","","",430],[10,"ne","","",430],[10,"clone","","",430],[10,"clone_from","","",430],[10,"fmt","","",431],[10,"hash","","",431],[10,"decode","","",431],[10,"encode","","",431],[10,"assert_receiver_is_total_eq","","",431],[10,"eq","","",431],[10,"ne","","",431],[10,"ne","","",431],[10,"clone","","",431],[10,"clone_from","","",431],[10,"fmt","","",432],[10,"hash","","",432],[10,"decode","","",432],[10,"encode","","",432],[10,"assert_receiver_is_total_eq","","",432],[10,"eq","","",432],[10,"ne","","",432],[10,"ne","","",432],[10,"clone","","",432],[10,"clone_from","","",432],[10,"fmt","","",433],[10,"hash","","",433],[10,"decode","","",433],[10,"encode","","",433],[10,"assert_receiver_is_total_eq","","",433],[10,"eq","","",433],[10,"ne","","",433],[10,"ne","","",433],[10,"clone","","",433],[10,"clone_from","","",433],[10,"fmt","","",434],[10,"hash","","",434],[10,"decode","","",434],[10,"encode","","",434],[10,"assert_receiver_is_total_eq","","",434],[10,"eq","","",434],[10,"ne","","",434],[10,"ne","","",434],[10,"clone","","",434],[10,"clone_from","","",434],[10,"fmt","","",408],[10,"hash","","",408],[10,"decode","","",408],[10,"encode","","",408],[10,"assert_receiver_is_total_eq","","",408],[10,"eq","","",408],[10,"ne","","",408],[10,"ne","","",408],[10,"clone","","",408],[10,"clone_from","","",408],[10,"fmt","","",435],[10,"hash","","",435],[10,"decode","","",435],[10,"encode","","",435],[10,"assert_receiver_is_total_eq","","",435],[10,"eq","","",435],[10,"ne","","",435],[10,"ne","","",435],[10,"clone","","",435],[10,"clone_from","","",435],[10,"fmt","","",436],[10,"hash","","",436],[10,"decode","","",436],[10,"encode","","",436],[10,"assert_receiver_is_total_eq","","",436],[10,"eq","","",436],[10,"ne","","",436],[10,"ne","","",436],[10,"clone","","",436],[10,"clone_from","","",436],[10,"fmt","","",437],[10,"hash","","",437],[10,"decode","","",437],[10,"encode","","",437],[10,"assert_receiver_is_total_eq","","",437],[10,"eq","","",437],[10,"ne","","",437],[10,"ne","","",437],[10,"clone","","",437],[10,"clone_from","","",437],[10,"fmt","","",102],[10,"hash","","",102],[10,"decode","","",102],[10,"encode","","",102],[10,"assert_receiver_is_total_eq","","",102],[10,"eq","","",102],[10,"ne","","",102],[10,"ne","","",102],[10,"clone","","",102],[10,"clone_from","","",102],[10,"fmt","","",438],[10,"hash","","",438],[10,"decode","","",438],[10,"encode","","",438],[10,"assert_receiver_is_total_eq","","",438],[10,"eq","","",438],[10,"ne","","",438],[10,"ne","","",438],[10,"clone","","",438],[10,"clone_from","","",438],[10,"fmt","","",402],[10,"hash","","",402],[10,"decode","","",402],[10,"encode","","",402],[10,"assert_receiver_is_total_eq","","",402],[10,"eq","","",402],[10,"ne","","",402],[10,"ne","","",402],[10,"clone","","",402],[10,"clone_from","","",402],[10,"fmt","","",439],[10,"hash","","",439],[10,"decode","","",439],[10,"encode","","",439],[10,"assert_receiver_is_total_eq","","",439],[10,"eq","","",439],[10,"ne","","",439],[10,"ne","","",439],[10,"clone","","",439],[10,"clone_from","","",439],[10,"fmt","","",440],[10,"hash","","",440],[10,"decode","","",440],[10,"encode","","",440],[10,"assert_receiver_is_total_eq","","",440],[10,"eq","","",440],[10,"ne","","",440],[10,"ne","","",440],[10,"clone","","",440],[10,"clone_from","","",440],[10,"fmt","","",441],[10,"hash","","",441],[10,"decode","","",441],[10,"encode","","",441],[10,"assert_receiver_is_total_eq","","",441],[10,"eq","","",441],[10,"ne","","",441],[10,"ne","","",441],[10,"clone","","",441],[10,"clone_from","","",441],[10,"fmt","","",442],[10,"hash","","",442],[10,"decode","","",442],[10,"encode","","",442],[10,"assert_receiver_is_total_eq","","",442],[10,"eq","","",442],[10,"ne","","",442],[10,"ne","","",442],[10,"clone","","",442],[10,"clone_from","","",442],[10,"fmt","","",443],[10,"hash","","",443],[10,"decode","","",443],[10,"encode","","",443],[10,"assert_receiver_is_total_eq","","",443],[10,"eq","","",443],[10,"ne","","",443],[10,"ne","","",443],[10,"clone","","",443],[10,"clone_from","","",443],[10,"fmt","","",444],[10,"hash","","",444],[10,"decode","","",444],[10,"encode","","",444],[10,"assert_receiver_is_total_eq","","",444],[10,"eq","","",444],[10,"ne","","",444],[10,"ne","","",444],[10,"clone","","",444],[10,"clone_from","","",444],[10,"fmt","","",445],[10,"hash","","",445],[10,"decode","","",445],[10,"encode","","",445],[10,"assert_receiver_is_total_eq","","",445],[10,"eq","","",445],[10,"ne","","",445],[10,"ne","","",445],[10,"clone","","",445],[10,"clone_from","","",445],[10,"fmt","","",446],[10,"hash","","",446],[10,"decode","","",446],[10,"encode","","",446],[10,"assert_receiver_is_total_eq","","",446],[10,"eq","","",446],[10,"ne","","",446],[10,"ne","","",446],[10,"clone","","",446],[10,"clone_from","","",446],[10,"hash","","",447],[10,"decode","","",447],[10,"encode","","",447],[10,"assert_receiver_is_total_eq","","",447],[10,"eq","","",447],[10,"ne","","",447],[10,"ne","","",447],[10,"clone","","",447],[10,"clone_from","","",447],[10,"fmt","","",447],[10,"suffix_len","","",447],[10,"hash","","",448],[10,"decode","","",448],[10,"encode","","",448],[10,"assert_receiver_is_total_eq","","",448],[10,"eq","","",448],[10,"ne","","",448],[10,"ne","","",448],[10,"clone","","",448],[10,"clone_from","","",448],[10,"suffix_len","","",448],[10,"fmt","","",448],[10,"hash","","",319],[10,"decode","","",319],[10,"encode","","",319],[10,"assert_receiver_is_total_eq","","",319],[10,"eq","","",319],[10,"ne","","",319],[10,"ne","","",319],[10,"clone","","",319],[10,"clone_from","","",319],[10,"fmt","","",319],[10,"suffix_len","","",319],[10,"fmt","","",404],[10,"hash","","",404],[10,"decode","","",404],[10,"encode","","",404],[10,"assert_receiver_is_total_eq","","",404],[10,"eq","","",404],[10,"ne","","",404],[10,"ne","","",404],[10,"clone","","",404],[10,"clone_from","","",404],[10,"fmt","","",449],[10,"hash","","",449],[10,"decode","","",449],[10,"encode","","",449],[10,"assert_receiver_is_total_eq","","",449],[10,"eq","","",449],[10,"ne","","",449],[10,"ne","","",449],[10,"clone","","",449],[10,"clone_from","","",449],[10,"hash","","",450],[10,"decode","","",450],[10,"encode","","",450],[10,"assert_receiver_is_total_eq","","",450],[10,"eq","","",450],[10,"ne","","",450],[10,"ne","","",450],[10,"clone","","",450],[10,"clone_from","","",450],[10,"fmt","","",450],[10,"fmt","","",451],[10,"hash","","",451],[10,"decode","","",451],[10,"encode","","",451],[10,"assert_receiver_is_total_eq","","",451],[10,"eq","","",451],[10,"ne","","",451],[10,"ne","","",451],[10,"fmt","","",452],[10,"hash","","",452],[10,"decode","","",452],[10,"encode","","",452],[10,"assert_receiver_is_total_eq","","",452],[10,"eq","","",452],[10,"ne","","",452],[10,"ne","","",452],[10,"fmt","","",453],[10,"hash","","",453],[10,"decode","","",453],[10,"encode","","",453],[10,"assert_receiver_is_total_eq","","",453],[10,"eq","","",453],[10,"ne","","",453],[10,"ne","","",453],[10,"clone","","",453],[10,"clone_from","","",453],[10,"fmt","","",454],[10,"hash","","",454],[10,"decode","","",454],[10,"encode","","",454],[10,"assert_receiver_is_total_eq","","",454],[10,"eq","","",454],[10,"ne","","",454],[10,"ne","","",454],[10,"clone","","",454],[10,"clone_from","","",454],[10,"fmt","","",455],[10,"hash","","",455],[10,"decode","","",455],[10,"encode","","",455],[10,"assert_receiver_is_total_eq","","",455],[10,"eq","","",455],[10,"ne","","",455],[10,"ne","","",455],[10,"clone","","",455],[10,"clone_from","","",455],[10,"fmt","","",456],[10,"hash","","",456],[10,"decode","","",456],[10,"encode","","",456],[10,"assert_receiver_is_total_eq","","",456],[10,"eq","","",456],[10,"ne","","",456],[10,"ne","","",456],[10,"clone","","",456],[10,"clone_from","","",456],[10,"fmt","","",406],[10,"hash","","",406],[10,"decode","","",406],[10,"encode","","",406],[10,"assert_receiver_is_total_eq","","",406],[10,"eq","","",406],[10,"ne","","",406],[10,"ne","","",406],[10,"clone","","",406],[10,"clone_from","","",406],[10,"new_self","","",406],[10,"fmt","","",457],[10,"hash","","",457],[10,"decode","","",457],[10,"encode","","",457],[10,"assert_receiver_is_total_eq","","",457],[10,"eq","","",457],[10,"ne","","",457],[10,"ne","","",457],[10,"clone","","",457],[10,"clone_from","","",457],[10,"hash","","",458],[10,"decode","","",458],[10,"encode","","",458],[10,"assert_receiver_is_total_eq","","",458],[10,"eq","","",458],[10,"ne","","",458],[10,"ne","","",458],[10,"clone","","",458],[10,"clone_from","","",458],[10,"fmt","","",458],[10,"fmt","","",459],[10,"hash","","",459],[10,"decode","","",459],[10,"encode","","",459],[10,"assert_receiver_is_total_eq","","",459],[10,"eq","","",459],[10,"ne","","",459],[10,"ne","","",459],[10,"clone","","",459],[10,"clone_from","","",459],[10,"fmt","","",460],[10,"hash","","",460],[10,"decode","","",460],[10,"encode","","",460],[10,"assert_receiver_is_total_eq","","",460],[10,"eq","","",460],[10,"ne","","",460],[10,"ne","","",460],[10,"clone","","",460],[10,"clone_from","","",460],[10,"fmt","","",461],[10,"hash","","",461],[10,"decode","","",461],[10,"encode","","",461],[10,"assert_receiver_is_total_eq","","",461],[10,"eq","","",461],[10,"ne","","",461],[10,"ne","","",461],[10,"clone","","",461],[10,"clone_from","","",461],[10,"fmt","","",462],[10,"hash","","",462],[10,"decode","","",462],[10,"encode","","",462],[10,"assert_receiver_is_total_eq","","",462],[10,"eq","","",462],[10,"ne","","",462],[10,"ne","","",462],[10,"clone","","",462],[10,"clone_from","","",462],[10,"fmt","","",463],[10,"hash","","",463],[10,"decode","","",463],[10,"encode","","",463],[10,"assert_receiver_is_total_eq","","",463],[10,"eq","","",463],[10,"ne","","",463],[10,"ne","","",463],[10,"clone","","",463],[10,"clone_from","","",463],[10,"fmt","","",464],[10,"hash","","",464],[10,"decode","","",464],[10,"encode","","",464],[10,"assert_receiver_is_total_eq","","",464],[10,"eq","","",464],[10,"ne","","",464],[10,"ne","","",464],[10,"clone","","",464],[10,"clone_from","","",464],[10,"fmt","","",465],[10,"hash","","",465],[10,"decode","","",465],[10,"encode","","",465],[10,"assert_receiver_is_total_eq","","",465],[10,"eq","","",465],[10,"ne","","",465],[10,"ne","","",465],[10,"clone","","",465],[10,"clone_from","","",465],[10,"fmt","","",466],[10,"hash","","",466],[10,"decode","","",466],[10,"encode","","",466],[10,"assert_receiver_is_total_eq","","",466],[10,"eq","","",466],[10,"ne","","",466],[10,"ne","","",466],[10,"clone","","",466],[10,"clone_from","","",466],[10,"fmt","","",467],[10,"hash","","",467],[10,"decode","","",467],[10,"encode","","",467],[10,"assert_receiver_is_total_eq","","",467],[10,"eq","","",467],[10,"ne","","",467],[10,"ne","","",467],[10,"clone","","",467],[10,"clone_from","","",467],[10,"fmt","","",468],[10,"hash","","",468],[10,"decode","","",468],[10,"encode","","",468],[10,"assert_receiver_is_total_eq","","",468],[10,"eq","","",468],[10,"ne","","",468],[10,"ne","","",468],[10,"clone","","",468],[10,"clone_from","","",468],[10,"fmt","","",469],[10,"hash","","",469],[10,"decode","","",469],[10,"encode","","",469],[10,"assert_receiver_is_total_eq","","",469],[10,"eq","","",469],[10,"ne","","",469],[10,"ne","","",469],[10,"clone","","",469],[10,"clone_from","","",469],[10,"id","","",469],[10,"fmt","","",470],[10,"hash","","",470],[10,"decode","","",470],[10,"encode","","",470],[10,"assert_receiver_is_total_eq","","",470],[10,"eq","","",470],[10,"ne","","",470],[10,"ne","","",470],[10,"clone","","",470],[10,"clone_from","","",470],[10,"fmt","","",471],[10,"hash","","",471],[10,"decode","","",471],[10,"encode","","",471],[10,"assert_receiver_is_total_eq","","",471],[10,"eq","","",471],[10,"ne","","",471],[10,"ne","","",471],[10,"clone","","",471],[10,"clone_from","","",471],[10,"fmt","","",472],[10,"hash","","",472],[10,"decode","","",472],[10,"encode","","",472],[10,"assert_receiver_is_total_eq","","",472],[10,"eq","","",472],[10,"ne","","",472],[10,"ne","","",472],[10,"clone","","",472],[10,"clone_from","","",472],[10,"fmt","","",473],[10,"hash","","",473],[10,"decode","","",473],[10,"encode","","",473],[10,"assert_receiver_is_total_eq","","",473],[10,"eq","","",473],[10,"ne","","",473],[10,"ne","","",473],[10,"clone","","",473],[10,"clone_from","","",473],[10,"fmt","","",474],[10,"hash","","",474],[10,"decode","","",474],[10,"encode","","",474],[10,"assert_receiver_is_total_eq","","",474],[10,"eq","","",474],[10,"ne","","",474],[10,"ne","","",474],[10,"clone","","",474],[10,"clone_from","","",474],[10,"fmt","","",409],[10,"hash","","",409],[10,"decode","","",409],[10,"encode","","",409],[10,"assert_receiver_is_total_eq","","",409],[10,"eq","","",409],[10,"ne","","",409],[10,"ne","","",409],[10,"clone","","",409],[10,"clone_from","","",409],[10,"fmt","","",475],[10,"hash","","",475],[10,"decode","","",475],[10,"encode","","",475],[10,"assert_receiver_is_total_eq","","",475],[10,"eq","","",475],[10,"ne","","",475],[10,"ne","","",475],[10,"clone","","",475],[10,"clone_from","","",475],[10,"fmt","","",476],[10,"hash","","",476],[10,"decode","","",476],[10,"encode","","",476],[10,"assert_receiver_is_total_eq","","",476],[10,"eq","","",476],[10,"ne","","",476],[10,"ne","","",476],[10,"clone","","",476],[10,"clone_from","","",476],[10,"inherit_from","","",476],[10,"fmt","","",477],[10,"hash","","",477],[10,"decode","","",477],[10,"encode","","",477],[10,"assert_receiver_is_total_eq","","",477],[10,"eq","","",477],[10,"ne","","",477],[10,"ne","","",477],[10,"clone","","",477],[10,"clone_from","","",477],[10,"ident","","",477],[10,"fmt","","",478],[10,"hash","","",478],[10,"decode","","",478],[10,"encode","","",478],[10,"assert_receiver_is_total_eq","","",478],[10,"eq","","",478],[10,"ne","","",478],[10,"ne","","",478],[10,"clone","","",478],[10,"clone_from","","",478],[10,"is_unnamed","","",478],[10,"fmt","","",479],[10,"hash","","",479],[10,"decode","","",479],[10,"encode","","",479],[10,"assert_receiver_is_total_eq","","",479],[10,"eq","","",479],[10,"ne","","",479],[10,"ne","","",479],[10,"clone","","",479],[10,"clone_from","","",479],[10,"fmt","","",480],[10,"hash","","",480],[10,"decode","","",480],[10,"encode","","",480],[10,"assert_receiver_is_total_eq","","",480],[10,"eq","","",480],[10,"ne","","",480],[10,"ne","","",480],[10,"clone","","",480],[10,"clone_from","","",480],[10,"fmt","","",481],[10,"hash","","",481],[10,"decode","","",481],[10,"encode","","",481],[10,"assert_receiver_is_total_eq","","",481],[10,"eq","","",481],[10,"ne","","",481],[10,"ne","","",481],[10,"clone","","",481],[10,"clone_from","","",481],[10,"fmt","","",482],[10,"hash","","",482],[10,"decode","","",482],[10,"encode","","",482],[10,"assert_receiver_is_total_eq","","",482],[10,"eq","","",482],[10,"ne","","",482],[10,"ne","","",482],[10,"clone","","",482],[10,"clone_from","","",482],[10,"fmt","","",483],[10,"hash","","",483],[10,"decode","","",483],[10,"encode","","",483],[10,"assert_receiver_is_total_eq","","",483],[10,"eq","","",483],[10,"ne","","",483],[10,"ne","","",483],[10,"clone","","",483],[10,"clone_from","","",483],[10,"fmt","","",484],[10,"hash","","",484],[10,"decode","","",484],[10,"encode","","",484],[10,"assert_receiver_is_total_eq","","",484],[10,"eq","","",484],[10,"ne","","",484],[10,"ne","","",484],[10,"clone","","",484],[10,"clone_from","","",484],[10,"eq","syntax::parse::lexer::comments","",485],[10,"ne","","",485],[10,"ne","","",485],[10,"clone","","",485],[10,"clone_from","","",485],[10,"clone","","",486],[10,"clone_from","","",486],[10,"clone","","",487],[10,"clone_from","","",487],[10,"fmt","syntax::parse::lexer","",488],[10,"assert_receiver_is_total_eq","","",488],[10,"eq","","",488],[10,"ne","","",488],[10,"ne","","",488],[10,"clone","","",488],[10,"clone_from","","",488],[10,"is_eof","","",489],[10,"next_token","","Return the next token. EFFECT: advances the string_reader.",489],[10,"fatal","","",489],[10,"err","","",489],[10,"peek","","",489],[10,"is_eof","syntax::ext::tt::transcribe","",411],[10,"next_token","","",411],[10,"fatal","","",411],[10,"err","","",411],[10,"peek","","",411],[10,"new_raw","syntax::parse::lexer","For comments.rs, which hackily pokes into pos and curr",489],[10,"new","","",489],[10,"curr_is","","",489],[10,"fatal_span","","Report a fatal lexical error with a given span.",489],[10,"err_span","","Report a lexical error with a given span.",489],[10,"with_str_from","","Calls `f` with a string slice of the source text spanning from `start`\nup to but excluding `self.last_pos`, meaning the slice does not include\nthe character `self.curr`.",489],[10,"name_from","","Create a Name from a given offset to the current offset, each\nadjusted 1 towards each other (assumes that on either side there is a\nsingle-byte delimiter).",489],[10,"name_from_to","","As name_from, with an explicit endpoint.",489],[10,"bump","","Advance the StringReader by one character. If a newline is\ndiscovered, add it to the FileMap's list of line start offsets.",489],[10,"nextch","","",489],[10,"nextch_is","","",489],[10,"nextnextch","","",489],[10,"nextnextch_is","","",489],[10,"eq","syntax::parse::parser","",490],[10,"ne","","",490],[10,"ne","","",490],[10,"eq","","",491],[10,"ne","","",491],[10,"ne","","",491],[10,"new","","",492],[10,"token_to_string","","Convert a token to a string using self's reader",492],[10,"this_token_to_string","","Convert the current token to a string using self's reader",492],[10,"unexpected_last","","",492],[10,"unexpected","","",492],[10,"expect","","Expect and consume the token t. Signal an error if\nthe next token is not t.",492],[10,"expect_one_of","","Expect next token to be edible or inedible token.  If edible,\nthen consume it; if inedible, then return without consuming\nanything.  Signal a fatal error if next token is unexpected.",492],[10,"check_for_erroneous_unit_struct_expecting","","Check for erroneous `ident { }`; if matches, signal error and\nrecover (without consuming any expected input token).  Returns\ntrue if and only if input was consumed for recovery.",492],[10,"commit_expr","","Commit to parsing a complete expression `e` expected to be\nfollowed by some token from the set edible + inedible.  Recover\nfrom anticipated input errors, discarding erroneous characters.",492],[10,"commit_expr_expecting","","",492],[10,"commit_stmt","","Commit to parsing a complete statement `s`, which expects to be\nfollowed by some token from the set edible + inedible.  Check\nfor recoverable input errors, discarding erroneous characters.",492],[10,"commit_stmt_expecting","","",492],[10,"parse_ident","","",492],[10,"parse_path_list_item","","",492],[10,"eat","","Consume token 'tok' if it exists. Returns true if the given\ntoken was present, false otherwise.",492],[10,"is_keyword","","",492],[10,"eat_keyword","","If the next token is the given keyword, eat it and return\ntrue. Otherwise, return false.",492],[10,"expect_keyword","","If the given word is not a keyword, signal an error.\nIf the next token is not the given word, signal an error.\nOtherwise, eat it.",492],[10,"check_strict_keywords","","Signal an error if the given string is a strict keyword",492],[10,"check_reserved_keywords","","Signal an error if the current token is a reserved keyword",492],[10,"expect_gt","","Expect and consume a GT. if a >> is seen, replace it\nwith a single > and continue. If a GT is not seen,\nsignal an error.",492],[10,"parse_seq_to_before_gt","","Parse a sequence bracketed by '<' and '>', stopping\nbefore the '>'.",492],[10,"parse_seq_to_gt","","",492],[10,"parse_seq_to_end","","Parse a sequence, including the closing delimiter. The function\nf must consume tokens until reaching the next separator or\nclosing bracket.",492],[10,"parse_seq_to_before_end","","Parse a sequence, not including the closing delimiter. The function\nf must consume tokens until reaching the next separator or\nclosing bracket.",492],[10,"parse_unspanned_seq","","Parse a sequence, including the closing delimiter. The function\nf must consume tokens until reaching the next separator or\nclosing bracket.",492],[10,"parse_enum_variant_seq","","Parse a sequence parameter of enum variant. For consistency purposes,\nthese should not be empty.",492],[10,"parse_seq","","",492],[10,"bump","","Advance the parser by one token",492],[10,"bump_and_get","","Advance the parser by one token and return the bumped token.",492],[10,"replace_token","","EFFECT: replace the current token and span with the given one",492],[10,"buffer_length","","",492],[10,"look_ahead","","",492],[10,"fatal","","",492],[10,"span_fatal","","",492],[10,"span_note","","",492],[10,"bug","","",492],[10,"warn","","",492],[10,"span_warn","","",492],[10,"span_err","","",492],[10,"abort_if_errors","","",492],[10,"id_to_interned_str","","",492],[10,"token_is_bare_fn_keyword","","Is the current token one of the keywords that signals a bare function\ntype?",492],[10,"token_is_closure_keyword","","Is the current token one of the keywords that signals a closure type?",492],[10,"token_is_old_style_closure_keyword","","Is the current token one of the keywords that signals an old-style\nclosure type (with explicit sigil)?",492],[10,"token_is_lifetime","","",492],[10,"get_lifetime","","",492],[10,"parse_ty_bare_fn","","parse a TyBareFn type:",492],[10,"parse_proc_type","","Parses a procedure type (`proc`). The initial `proc` keyword must\nalready have been parsed.",492],[10,"parse_ty_closure","","Parse a TyClosure type",492],[10,"parse_unsafety","","",492],[10,"parse_ty_fn_decl","","Parse a function type (following the 'fn')",492],[10,"parse_trait_methods","","Parse the methods in a trait declaration",492],[10,"parse_mt","","Parse a possibly mutable type",492],[10,"parse_ty_field","","Parse [mut/const/imm] ID : TY\nnow used only by obsolete record syntax parser...",492],[10,"parse_ret_ty","","Parse optional return type [ -> TY ] in function decl",492],[10,"parse_ty","","Parse a type.",492],[10,"parse_borrowed_pointee","","",492],[10,"parse_ptr","","",492],[10,"is_named_argument","","",492],[10,"parse_arg_general","","This version of parse arg doesn't necessarily require\nidentifier names.",492],[10,"parse_arg","","Parse a single function argument",492],[10,"parse_fn_block_arg","","Parse an argument in a lambda header e.g. |arg, arg|",492],[10,"maybe_parse_fixed_vstore","","",492],[10,"lit_from_token","","Matches token_lit = LIT_INTEGER | ...",492],[10,"parse_lit","","Matches lit = true | false | token_lit",492],[10,"parse_literal_maybe_minus","","matches '-' lit | lit",492],[10,"parse_path","","Parses a path and optional type parameter bounds, depending on the\nmode. The `mode` parameter determines whether lifetimes, types, and/or\nbounds are permitted and whether `::` must precede type parameter\ngroups.",492],[10,"parse_opt_lifetime","","parses 0 or 1 lifetime",492],[10,"parse_lifetime","","Parses a single lifetime\nMatches lifetime = LIFETIME",492],[10,"parse_lifetimes","","\nParses zero or more comma separated lifetimes.\nExpects each lifetime to be followed by either\na comma or `>`.  Used when parsing type parameter\nlists, where we expect something like `<'a, 'b, T>`.",492],[10,"token_is_mutability","","",492],[10,"parse_mutability","","Parse mutability declaration (mut/const/imm)",492],[10,"parse_field","","Parse ident COLON expr",492],[10,"mk_expr","","",492],[10,"mk_unary","","",492],[10,"mk_binary","","",492],[10,"mk_call","","",492],[10,"mk_index","","",492],[10,"mk_field","","",492],[10,"mk_assign_op","","",492],[10,"mk_mac_expr","","",492],[10,"mk_lit_u32","","",492],[10,"parse_bottom_expr","","At the bottom (top?) of the precedence hierarchy,\nparse things like parenthesized exprs,\nmacros, return, etc.",492],[10,"parse_block_expr","","Parse a block or unsafe block",492],[10,"parse_dot_or_call_expr","","parse a.b or a(13) or a[4] or just a",492],[10,"parse_dot_or_call_expr_with","","",492],[10,"parse_sep_and_zerok","","Parse an optional separator followed by a kleene-style\nrepetition token (+ or *).",492],[10,"parse_token_tree","","parse a single token tree from the input.",492],[10,"parse_all_token_trees","","",492],[10,"parse_matchers","","",492],[10,"parse_matcher_subseq_upto","","This goofy function is necessary to correctly match parens in Matcher's.\nOtherwise, `$( ( )` would be a valid Matcher, and `$( () )` would be\ninvalid. It's similar to common::parse_seq.",492],[10,"parse_matcher","","",492],[10,"parse_prefix_expr","","Parse a prefix-operator expr",492],[10,"parse_binops","","Parse an expression of binops",492],[10,"parse_more_binops","","Parse an expression of binops of at least min_prec precedence",492],[10,"parse_assign_expr","","Parse an assignment expression....\nactually, this seems to be the main entry point for\nparsing an arbitrary expression.",492],[10,"parse_if_expr","","Parse an 'if' expression ('if' token already eaten)",492],[10,"parse_lambda_expr","","",492],[10,"parse_else_expr","","",492],[10,"parse_for_expr","","Parse a 'for' .. 'in' expression ('for' token already eaten)",492],[10,"parse_while_expr","","",492],[10,"parse_loop_expr","","",492],[10,"parse_arm","","",492],[10,"parse_expr","","Parse an expression",492],[10,"parse_expr_res","","Parse an expression, subject to the given restriction",492],[10,"parse_pat","","Parse a pattern.",492],[10,"parse_stmt","","Parse a statement. may include decl.\nPrecondition: any attributes are parsed already",492],[10,"parse_block","","Parse a block. No inner attrs are allowed.",492],[10,"parse_generics","","Parse a set of optional generic type parameter declarations\nmatches generics = ( ) | ( < > ) | ( < typaramseq ( , )? > ) | ( < lifetimes ( , )? > )\n                 | ( < lifetimes , typaramseq ( , )? > )\nwhere   typaramseq = ( typaram ) | ( typaram , typaramseq )",492],[10,"parse_fn_decl","","Parse the argument list and result type of a function declaration",492],[10,"parse_method","","Parse a method in a trait impl, starting with `attrs` attributes.",492],[10,"parse_single_struct_field","","Parse a structure field declaration",492],[10,"parse_item_with_outer_attributes","","",492],[10,"parse_item","","",492],[10,"parse_crate_mod","","Parses a source module as a crate. This is the main\nentry point for the parser.",492],[10,"parse_optional_str","","",492],[10,"parse_str","","",492],[10,"fmt","syntax::parse::token","",493],[10,"hash","","",493],[10,"assert_receiver_is_total_eq","","",493],[10,"eq","","",493],[10,"ne","","",493],[10,"ne","","",493],[10,"decode","","",493],[10,"encode","","",493],[10,"clone","","",493],[10,"clone_from","","",493],[10,"fmt","","",494],[10,"hash","","",494],[10,"assert_receiver_is_total_eq","","",494],[10,"eq","","",494],[10,"ne","","",494],[10,"ne","","",494],[10,"decode","","",494],[10,"encode","","",494],[10,"clone","","",494],[10,"clone_from","","",494],[10,"hash","","",495],[10,"assert_receiver_is_total_eq","","",495],[10,"eq","","",495],[10,"ne","","",495],[10,"ne","","",495],[10,"decode","","",495],[10,"encode","","",495],[10,"clone","","",495],[10,"clone_from","","",495],[10,"fmt","","",495],[10,"to_name","syntax::parse::token::keywords","",496],[10,"cmp","syntax::parse::token","",497],[10,"assert_receiver_is_total_eq","","",497],[10,"partial_cmp","","",497],[10,"lt","","",497],[10,"le","","",497],[10,"gt","","",497],[10,"ge","","",497],[10,"lt","","",497],[10,"le","","",497],[10,"gt","","",497],[10,"ge","","",497],[10,"hash","","",497],[10,"eq","","",497],[10,"ne","","",497],[10,"ne","","",497],[10,"clone","","",497],[10,"clone_from","","",497],[10,"new","","",497],[10,"get","","",497],[10,"container_as_bytes","","",497],[10,"container_into_owned_bytes","","",497],[10,"container_as_str","","",497],[10,"is_str","","",497],[10,"fmt","","",497],[10,"equiv","","",497],[10,"decode","","",497],[10,"encode","","",497],[10,"parse_outer_attributes","syntax::parse::parser","Parse attributes that appear before an item",492],[10,"parse_attribute","","Matches `attribute = # ! [ meta_item ]`",492],[10,"parse_inner_attrs_and_next","","Parse attributes that appear after the opening of an item. These should\nbe preceded by an exclamation mark, but we accept and warn about one\nterminated by a semicolon. In addition to a vector of inner attributes,\nthis function also returns a vector that may contain the first outer\nattribute of the next item (since we can't know whether the attribute\nis an inner attribute of the containing item or an outer attribute of\nthe first contained item until we see the semi).\nmatches inner_attrs* outer_attr?\nyou can make the 'next' field an Option, but the result is going to be\nmore useful as a vector.",492],[10,"parse_meta_item","","matches meta_item = IDENT\n| IDENT = lit\n| IDENT meta_seq",492],[10,"parse_meta_seq","","matches meta_seq = ( COMMASEP(meta_item) )",492],[10,"parse_optional_meta","","",492],[10,"hash","syntax::parse::obsolete","",498],[10,"assert_receiver_is_total_eq","","",498],[10,"eq","","",498],[10,"ne","","",498],[10,"ne","","",498],[10,"obsolete","syntax::parse::parser","Reports an obsolete syntax non-fatal error.",492],[10,"obsolete_expr","","Reports an obsolete syntax non-fatal error, and returns\na placeholder expression",492],[10,"report","","",492],[10,"is_obsolete_ident","","",492],[10,"eat_obsolete_ident","","",492],[10,"eq","syntax::abi","",499],[10,"ne","","",499],[10,"ne","","",499],[10,"clone","","",500],[10,"clone_from","","",500],[10,"decode","","",500],[10,"encode","","",500],[10,"hash","","",500],[10,"assert_receiver_is_total_eq","","",500],[10,"eq","","",500],[10,"ne","","",500],[10,"ne","","",500],[10,"eq","","",501],[10,"ne","","",501],[10,"ne","","",501],[10,"index","","",500],[10,"data","","",500],[10,"name","","",500],[10,"for_target","","",500],[10,"fmt","","",500],[10,"fmt","","",499],[10,"is_fn_like","syntax::ast","",480],[10,"is_fn_like","","",446],[10,"is_fn_like","","",102],[10,"id","syntax::ast_map::blocks","",502],[10,"from_node","","Attempts to construct a Code from presumed FnLike or Block node input.",502],[10,"to_fn_parts","","",503],[10,"body","","",503],[10,"decl","","",503],[10,"span","","",503],[10,"id","","",503],[10,"kind","","",503],[10,"eq","syntax::ast_map","",504],[10,"ne","","",504],[10,"ne","","",504],[10,"clone","","",504],[10,"clone_from","","",504],[10,"name","","",504],[10,"fmt","","",504],[10,"clone","","",505],[10,"clone_from","","",505],[10,"next","core::option","",28],[10,"size_hint","","",28],[10,"chain","","",28],[10,"zip","","",28],[10,"map","","",28],[10,"filter","","",28],[10,"filter_map","","",28],[10,"enumerate","","",28],[10,"peekable","","",28],[10,"skip_while","","",28],[10,"take_while","","",28],[10,"skip","","",28],[10,"take","","",28],[10,"scan","","",28],[10,"flat_map","","",28],[10,"fuse","","",28],[10,"inspect","","",28],[10,"by_ref","","",28],[10,"advance","","",28],[10,"collect","","",28],[10,"nth","","",28],[10,"last","","",28],[10,"fold","","",28],[10,"count","","",28],[10,"all","","",28],[10,"any","","",28],[10,"find","","",28],[10,"position","","",28],[10,"max_by","","",28],[10,"min_by","","",28],[10,"clone","syntax::ast_map","",506],[10,"clone_from","","",506],[10,"next","","",506],[10,"size_hint","","",506],[10,"chain","","",506],[10,"zip","","",506],[10,"map","","",506],[10,"filter","","",506],[10,"filter_map","","",506],[10,"enumerate","","",506],[10,"peekable","","",506],[10,"skip_while","","",506],[10,"take_while","","",506],[10,"skip","","",506],[10,"take","","",506],[10,"scan","","",506],[10,"flat_map","","",506],[10,"fuse","","",506],[10,"inspect","","",506],[10,"by_ref","","",506],[10,"advance","","",506],[10,"collect","","",506],[10,"nth","","",506],[10,"last","","",506],[10,"fold","","",506],[10,"count","","",506],[10,"all","","",506],[10,"any","","",506],[10,"find","","",506],[10,"position","","",506],[10,"max_by","","",506],[10,"min_by","","",506],[10,"clone","","",507],[10,"clone_from","","",507],[10,"clone","","",508],[10,"clone_from","","",508],[10,"get","","Retrieve the Node corresponding to `id`, failing if it cannot\nbe found.",509],[10,"find","","Retrieve the Node corresponding to `id`, returning None if\ncannot be found.",509],[10,"get_parent","","Retrieve the parent NodeId for `id`, or `id` itself if no\nparent is registered in this map.",509],[10,"get_parent_did","","",509],[10,"get_foreign_abi","","",509],[10,"get_foreign_vis","","",509],[10,"expect_item","","",509],[10,"expect_struct","","",509],[10,"expect_variant","","",509],[10,"expect_foreign_item","","",509],[10,"get_path_elem","","returns the name associated with the given NodeId's AST",509],[10,"with_path","","",509],[10,"path_to_string","","",509],[10,"with_attrs","","Given a node ID and a closure, apply the closure to the array\nof attributes associated with the AST corresponding to the Node ID",509],[10,"opt_span","","",509],[10,"span","","",509],[10,"node_to_string","","",509],[10,"new_id","","",510],[10,"new_span","","",510],[10,"fold_item","","",510],[10,"fold_pat","","",510],[10,"fold_expr","","",510],[10,"fold_stmt","","",510],[10,"fold_type_method","","",510],[10,"fold_method","","",510],[10,"fold_fn_decl","","",510],[10,"fold_block","","",510],[10,"fold_lifetime","","",510],[10,"fold_mac","","",510],[10,"fold_crate","","",510],[10,"fold_meta_items","","",510],[10,"fold_meta_item","","",510],[10,"fold_view_path","","",510],[10,"fold_view_item","","",510],[10,"fold_foreign_item","","",510],[10,"fold_item","","",510],[10,"fold_item_simple","","",510],[10,"fold_struct_field","","",510],[10,"fold_item_underscore","","",510],[10,"fold_fn_decl","","",510],[10,"fold_type_method","","",510],[10,"fold_method","","",510],[10,"fold_block","","",510],[10,"fold_stmt","","",510],[10,"fold_arm","","",510],[10,"fold_pat","","",510],[10,"fold_decl","","",510],[10,"fold_expr","","",510],[10,"fold_ty","","",510],[10,"fold_mod","","",510],[10,"fold_foreign_mod","","",510],[10,"fold_variant","","",510],[10,"fold_ident","","",510],[10,"fold_path","","",510],[10,"fold_local","","",510],[10,"fold_mac","","",510],[10,"fold_explicit_self","","",510],[10,"fold_explicit_self_underscore","","",510],[10,"fold_lifetime","","",510],[10,"fold_attribute","","",510],[10,"fold_arg","","",510],[10,"fold_generics","","",510],[10,"fold_trait_ref","","",510],[10,"fold_struct_def","","",510],[10,"fold_lifetimes","","",510],[10,"fold_ty_param","","",510],[10,"fold_ty_params","","",510],[10,"fold_tt","","",510],[10,"fold_tts","","",510],[10,"fold_token","","",510],[10,"fold_interpolated","","",510],[10,"fold_opt_lifetime","","",510],[10,"fold_variant_arg","","",510],[10,"fold_ty_param_bound","","",510],[10,"fold_opt_bounds","","",510],[10,"fold_mt","","",510],[10,"fold_field","","",510],[10,"map_exprs","","",510],[10,"new_id","","",510],[10,"new_span","","",510],[10,"decode","syntax::ast_util","",511],[10,"encode","","",511],[10,"max","","",511],[10,"empty","","",511],[10,"add","","",511],[10,"visit_mod","","",512],[10,"visit_view_item","","",512],[10,"visit_foreign_item","","",512],[10,"visit_item","","",512],[10,"visit_local","","",512],[10,"visit_block","","",512],[10,"visit_stmt","","",512],[10,"visit_pat","","",512],[10,"visit_expr","","",512],[10,"visit_ty","","",512],[10,"visit_generics","","",512],[10,"visit_fn","","",512],[10,"visit_struct_field","","",512],[10,"visit_struct_def","","",512],[10,"visit_trait_method","","",512],[10,"visit_ident","","",512],[10,"visit_mod","","",512],[10,"visit_view_item","","",512],[10,"visit_foreign_item","","",512],[10,"visit_item","","",512],[10,"visit_local","","",512],[10,"visit_block","","",512],[10,"visit_stmt","","",512],[10,"visit_arm","","",512],[10,"visit_pat","","",512],[10,"visit_decl","","",512],[10,"visit_expr","","",512],[10,"visit_expr_post","","",512],[10,"visit_ty","","",512],[10,"visit_generics","","",512],[10,"visit_fn","","",512],[10,"visit_ty_method","","",512],[10,"visit_trait_method","","",512],[10,"visit_struct_def","","",512],[10,"visit_struct_field","","",512],[10,"visit_variant","","",512],[10,"visit_opt_lifetime_ref","","",512],[10,"visit_lifetime_ref","","",512],[10,"visit_lifetime_decl","","",512],[10,"visit_explicit_self","","",512],[10,"visit_mac","","",512],[10,"visit_path","","",512],[10,"visit_attribute","","",512],[10,"visit_id","","",513],[10,"visit_view_item","","",514],[10,"visit_ident","","",514],[10,"visit_mod","","",514],[10,"visit_view_item","","",514],[10,"visit_foreign_item","","",514],[10,"visit_item","","",514],[10,"visit_local","","",514],[10,"visit_block","","",514],[10,"visit_stmt","","",514],[10,"visit_arm","","",514],[10,"visit_pat","","",514],[10,"visit_decl","","",514],[10,"visit_expr","","",514],[10,"visit_expr_post","","",514],[10,"visit_ty","","",514],[10,"visit_generics","","",514],[10,"visit_fn","","",514],[10,"visit_ty_method","","",514],[10,"visit_trait_method","","",514],[10,"visit_struct_def","","",514],[10,"visit_struct_field","","",514],[10,"visit_variant","","",514],[10,"visit_opt_lifetime_ref","","",514],[10,"visit_lifetime_ref","","",514],[10,"visit_lifetime_decl","","",514],[10,"visit_explicit_self","","",514],[10,"visit_mac","","",514],[10,"visit_path","","",514],[10,"visit_attribute","","",514],[10,"each_view_item","syntax::ast","",422],[10,"pe_ident","","",461],[10,"pe_generics","","",461],[10,"pe_abi","","",461],[10,"pe_explicit_self","","",461],[10,"pe_fn_style","","",461],[10,"pe_fn_decl","","",461],[10,"pe_body","","",461],[10,"pe_vis","","",461],[10,"check_name","syntax::codemap","",403],[10,"name","","",403],[10,"value_str","","",403],[10,"meta_item_list","","",403],[10,"check_name","","",403],[10,"name","","",403],[10,"value_str","","",403],[10,"meta_item_list","","",403],[10,"check_name","","",403],[10,"name","std::gc","",387],[10,"value_str","","",387],[10,"meta_item_list","","",387],[10,"check_name","","",387],[10,"meta","syntax::codemap","Extract the MetaItem from inside this Attribute.",403],[10,"desugar_doc","","Convert self to a normal #[doc=\"foo\"] comment, if it is a\ncomment like `///` or `/** */`. (Returns self unchanged for\nnon-sugared doc attributes.)",403],[10,"eq","syntax::attr","",515],[10,"ne","","",515],[10,"ne","","",515],[10,"fmt","","",516],[10,"clone","","",516],[10,"clone_from","","",516],[10,"decode","","",516],[10,"encode","","",516],[10,"fmt","","",517],[10,"clone","","",517],[10,"clone_from","","",517],[10,"partial_cmp","","",517],[10,"lt","","",517],[10,"le","","",517],[10,"gt","","",517],[10,"ge","","",517],[10,"lt","","",517],[10,"le","","",517],[10,"gt","","",517],[10,"ge","","",517],[10,"eq","","",517],[10,"ne","","",517],[10,"ne","","",517],[10,"decode","","",517],[10,"encode","","",517],[10,"fmt","","",518],[10,"eq","","",518],[10,"ne","","",518],[10,"ne","","",518],[10,"is_ffi_safe","","",518],[10,"fmt","","",519],[10,"eq","","",519],[10,"ne","","",519],[10,"ne","","",519],[10,"is_signed","","",519],[10,"fmt","syntax::codemap","",520],[10,"partial_cmp","","",520],[10,"lt","","",520],[10,"le","","",520],[10,"gt","","",520],[10,"ge","","",520],[10,"lt","","",520],[10,"le","","",520],[10,"gt","","",520],[10,"ge","","",520],[10,"hash","","",520],[10,"assert_receiver_is_total_eq","","",520],[10,"eq","","",520],[10,"ne","","",520],[10,"ne","","",520],[10,"clone","","",520],[10,"clone_from","","",520],[10,"fmt","","",521],[10,"partial_cmp","","",521],[10,"lt","","",521],[10,"le","","",521],[10,"gt","","",521],[10,"ge","","",521],[10,"lt","","",521],[10,"le","","",521],[10,"gt","","",521],[10,"ge","","",521],[10,"hash","","",521],[10,"eq","","",521],[10,"ne","","",521],[10,"ne","","",521],[10,"from_uint","","",520],[10,"to_uint","","",520],[10,"add","","",520],[10,"sub","","",520],[10,"from_uint","","",521],[10,"to_uint","","",521],[10,"add","","",521],[10,"sub","","",521],[10,"hash","","",29],[10,"fmt","","",29],[10,"clone","","",29],[10,"clone_from","","",29],[10,"fmt","","",403],[10,"hash","","",403],[10,"decode","","",403],[10,"encode","","",403],[10,"assert_receiver_is_total_eq","","",403],[10,"eq","","",403],[10,"ne","","",403],[10,"ne","","",403],[10,"clone","","",403],[10,"clone_from","","",403],[10,"eq","","",29],[10,"ne","","",29],[10,"ne","","",29],[10,"assert_receiver_is_total_eq","","",29],[10,"encode","","",29],[10,"decode","","",29],[10,"fmt","","",522],[10,"hash","","",522],[10,"clone","","",522],[10,"clone_from","","",522],[10,"fmt","","",523],[10,"hash","","",523],[10,"clone","","",523],[10,"clone_from","","",523],[10,"fmt","","",524],[10,"hash","","",524],[10,"next_line","","EFFECT: register a start-of-line offset in the\ntable of line-beginnings.\nUNCHECKED INVARIANT: these offsets must be added in the right\norder and must be in the right places; there is shared knowledge\nabout what ends a line between this file and parse.rs\nWARNING: pos param here is the offset relative to start of CodeMap,\nand CodeMap will append a newline when adding a filemap without a newline at the end,\nso the safe way to call this is with value calculated as\nfilemap.start_pos + newline_offset_relative_to_the_start_of_filemap.",525],[10,"get_line","","get a line from the list of pre-computed line-beginnings",525],[10,"record_multibyte_char","","",525],[10,"is_real_file","","",525],[10,"new","","",526],[10,"new_filemap","","",526],[10,"mk_substr_filename","","",526],[10,"lookup_char_pos","","Lookup source information about a BytePos",526],[10,"lookup_char_pos_adj","","",526],[10,"span_to_string","","",526],[10,"span_to_filename","","",526],[10,"span_to_lines","","",526],[10,"span_to_snippet","","",526],[10,"get_filemap","","",526],[10,"lookup_byte_offset","","",526],[10,"bytepos_to_file_charpos","","Converts an absolute BytePos to a CharPos relative to the filemap and above.",526],[10,"eq","syntax::crateid","",527],[10,"ne","","",527],[10,"ne","","",527],[10,"clone","","",527],[10,"clone_from","","",527],[10,"fmt","","",527],[10,"from_str","","",527],[10,"version_or_default","","",527],[10,"short_name_with_version","","",527],[10,"matches","","",527],[10,"clone","syntax::diagnostic","",528],[10,"clone_from","","",528],[10,"clone","","",529],[10,"clone_from","","",529],[10,"span_fatal","","",530],[10,"span_err","","",530],[10,"span_err_with_code","","",530],[10,"span_warn","","",530],[10,"span_warn_with_code","","",530],[10,"span_note","","",530],[10,"span_end_note","","",530],[10,"fileline_note","","",530],[10,"span_bug","","",530],[10,"span_unimpl","","",530],[10,"handler","","",530],[10,"fatal","","",531],[10,"err","","",531],[10,"bump_err_count","","",531],[10,"err_count","","",531],[10,"has_errors","","",531],[10,"abort_if_errors","","",531],[10,"warn","","",531],[10,"note","","",531],[10,"bug","","",531],[10,"unimpl","","",531],[10,"emit","","",531],[10,"emit_with_code","","",531],[10,"custom_emit","","",531],[10,"eq","","",532],[10,"ne","","",532],[10,"ne","","",532],[10,"fmt","","",532],[10,"stderr","","",533],[10,"new","","",533],[10,"write","","",534],[10,"flush","","",534],[10,"write_fmt","","",534],[10,"write_str","","",534],[10,"write_line","","",534],[10,"write_char","","",534],[10,"write_int","","",534],[10,"write_uint","","",534],[10,"write_le_uint","","",534],[10,"write_le_int","","",534],[10,"write_be_uint","","",534],[10,"write_be_int","","",534],[10,"write_be_u64","","",534],[10,"write_be_u32","","",534],[10,"write_be_u16","","",534],[10,"write_be_i64","","",534],[10,"write_be_i32","","",534],[10,"write_be_i16","","",534],[10,"write_be_f64","","",534],[10,"write_be_f32","","",534],[10,"write_le_u64","","",534],[10,"write_le_u32","","",534],[10,"write_le_u16","","",534],[10,"write_le_i64","","",534],[10,"write_le_i32","","",534],[10,"write_le_i16","","",534],[10,"write_le_f64","","",534],[10,"write_le_f32","","",534],[10,"write_u8","","",534],[10,"write_i8","","",534],[10,"by_ref","","",534],[10,"emit","","",533],[10,"custom_emit","","",533],[10,"fmt","syntax::owned_slice","",254],[10,"drop","","",254],[10,"empty","","",254],[10,"from_vec","","",254],[10,"into_vec","","",254],[10,"as_slice","","",254],[10,"get","","",254],[10,"iter","","",254],[10,"map","","",254],[10,"default","","",254],[10,"clone","","",254],[10,"clone_from","","",254],[10,"hash","","",254],[10,"eq","","",254],[10,"ne","","",254],[10,"assert_receiver_is_total_eq","","",254],[10,"len","","",254],[10,"is_empty","","",254],[10,"from_iter","","",254],[10,"encode","","",254],[10,"decode","","",254],[10,"eq","syntax::print::pp","",535],[10,"ne","","",535],[10,"ne","","",535],[10,"clone","","",535],[10,"clone_from","","",535],[10,"clone","","",536],[10,"clone_from","","",536],[10,"clone","","",537],[10,"clone_from","","",537],[10,"clone","","",538],[10,"clone_from","","",538],[10,"is_eof","","",538],[10,"is_hardbreak_tok","","",538],[10,"last_token","","",539],[10,"replace_last_token","","",539],[10,"pretty_print","","",539],[10,"check_stream","","",539],[10,"scan_push","","",539],[10,"scan_pop","","",539],[10,"scan_top","","",539],[10,"scan_pop_bottom","","",539],[10,"advance_right","","",539],[10,"advance_left","","",539],[10,"check_stack","","",539],[10,"print_newline","","",539],[10,"indent","","",539],[10,"get_top","","",539],[10,"print_str","","",539],[10,"print","","",539],[10,"pre","syntax::print::pprust","",540],[10,"post","","",540],[10,"ibox","","",541],[10,"end","","",541],[10,"cbox","","",541],[10,"rbox","","",541],[10,"nbsp","","",541],[10,"word_nbsp","","",541],[10,"word_space","","",541],[10,"popen","","",541],[10,"pclose","","",541],[10,"head","","",541],[10,"bopen","","",541],[10,"bclose_","","",541],[10,"bclose_maybe_open","","",541],[10,"bclose","","",541],[10,"is_begin","","",541],[10,"is_end","","",541],[10,"is_bol","","",541],[10,"in_cbox","","",541],[10,"hardbreak_if_not_bol","","",541],[10,"space_if_not_bol","","",541],[10,"break_offset_if_not_bol","","",541],[10,"synth_comment","","",541],[10,"commasep","","",541],[10,"commasep_cmnt","","",541],[10,"commasep_exprs","","",541],[10,"print_mod","","",541],[10,"print_foreign_mod","","",541],[10,"print_opt_lifetime","","",541],[10,"print_type","","",541],[10,"print_type_ref","","",541],[10,"print_foreign_item","","",541],[10,"print_item","","Pretty-print an item",541],[10,"print_enum_def","","",541],[10,"print_variants","","",541],[10,"print_visibility","","",541],[10,"print_struct","","",541],[10,"print_tt","","This doesn't deserve to be called \"pretty\" printing, but it should be\nmeaning-preserving. A quick hack that might help would be to look at the\nspans embedded in the TTs to decide where to put spaces and newlines.\nBut it'd be better to parse these according to the grammar of the\nappropriate macro, transcribe back into the grammar we just parsed from,\nand then pretty-print the resulting AST nodes (so, e.g., we print\nexpression arguments as expressions). It can be done! I think.",541],[10,"print_tts","","",541],[10,"print_variant","","",541],[10,"print_ty_method","","",541],[10,"print_trait_method","","",541],[10,"print_method","","",541],[10,"print_outer_attributes","","",541],[10,"print_inner_attributes","","",541],[10,"print_attribute","","",541],[10,"print_stmt","","",541],[10,"print_block","","",541],[10,"print_block_unclosed","","",541],[10,"print_block_unclosed_indent","","",541],[10,"print_block_with_attrs","","",541],[10,"print_block_maybe_unclosed","","",541],[10,"print_if","","",541],[10,"print_mac","","",541],[10,"print_expr_vstore","","",541],[10,"print_expr_maybe_paren","","",541],[10,"print_expr","","",541],[10,"print_local_decl","","",541],[10,"print_decl","","",541],[10,"print_ident","","",541],[10,"print_name","","",541],[10,"print_for_decl","","",541],[10,"print_pat","","",541],[10,"print_fn","","",541],[10,"print_fn_args","","",541],[10,"print_fn_args_and_ret","","",541],[10,"print_fn_block_args","","",541],[10,"print_proc_args","","",541],[10,"print_bounds","","",541],[10,"print_lifetime","","",541],[10,"print_generics","","",541],[10,"print_meta_item","","",541],[10,"print_view_path","","",541],[10,"print_view_item","","",541],[10,"print_mutability","","",541],[10,"print_mt","","",541],[10,"print_arg","","",541],[10,"print_ty_fn","","",541],[10,"maybe_print_trailing_comment","","",541],[10,"print_remaining_comments","","",541],[10,"print_literal","","",541],[10,"next_lit","","",541],[10,"maybe_print_comment","","",541],[10,"print_comment","","",541],[10,"print_string","","",541],[10,"next_comment","","",541],[10,"print_opt_fn_style","","",541],[10,"print_opt_abi_and_extern_if_nondefault","","",541],[10,"print_extern_opt_abi","","",541],[10,"print_fn_header_info","","",541],[10,"print_fn_style","","",541],[10,"print_onceness","","",541],[2,"RenderSpan","rustc::driver::diagnostic",""],[12,"FullSpan","","A FullSpan renders with both with an initial line for the\nmessage, prefixed by file:linenum, followed by a summary of\nthe source code covered by the span.",528],[12,"FileLine","","A FileLine renders with just a line for the message prefixed\nby file:linenum.",528],[2,"ColorConfig","",""],[12,"Auto","","",529],[12,"Always","","",529],[12,"Never","","",529],[6,"Emitter","",""],[9,"emit","","",542],[9,"custom_emit","","",542],[1,"FatalError","","This structure is used to signify that a task has failed with a fatal error\nfrom the diagnostics. You can use this with the `Any` trait to figure out\nhow a rustc task died (if so desired)."],[1,"ExplicitBug","","Signifies that the compiler died with an explicit call to `.bug`\nor `.span_bug` rather than a failed assertion, etc."],[1,"SpanHandler","","A span-handler is like a handler but also\naccepts span information for source-location\nreporting."],[11,"handler","","",530],[11,"cm","","",530],[1,"Handler","","A handler deals with errors; certain errors\n(fatal, bug, unimpl) may cause immediate exit,\nothers log errors for later reporting."],[3,"mk_span_handler","",""],[3,"default_handler","",""],[3,"mk_handler","",""],[2,"Level","",""],[12,"Bug","","",532],[12,"Fatal","","",532],[12,"Error","","",532],[12,"Warning","","",532],[12,"Note","","",532],[1,"EmitterWriter","",""],[3,"expect","",""],[0,"plugin","rustc","Infrastructure for compiler plugins."],[0,"registry","rustc::plugin","Used by plugin crates to tell `rustc` about the plugins they provide."],[1,"Registry","rustc::plugin::registry","Structure used to register plugins."],[10,"register_syntax_extension","","Register a syntax extension of any kind.",543],[10,"register_macro","","Register a macro of the usual kind.",543],[10,"register_lint_pass","","Register a compiler lint pass.",543],[0,"load","rustc::plugin","Used by `rustc` when loading a plugin."],[1,"PluginMetadata","rustc::plugin::load","Plugin-related crate metadata."],[11,"macros","","Source code of macros exported by the crate.",544],[11,"lib","","Path to the shared library file.",544],[11,"registrar_symbol","","Symbol name of the plugin registrar function.",544],[1,"Plugins","","Information about loaded plugins."],[11,"macros","","Source code of exported macros.",545],[11,"registrars","","Registrars, as function pointers.",545],[3,"load_plugins","","Read plugin metadata and dynamically load registrar functions."],[4,"PluginRegistrarFun","","Pointer to a registrar function."],[0,"build","rustc::plugin","Used by `rustc` when compiling a plugin crate."],[3,"find_plugin_registrar","rustc::plugin::build","Find the function marked with `#[plugin_registrar]`, if any."],[0,"lint","rustc","Lints, aka compiler warnings."],[1,"Context","rustc::lint","Context for lint checking."],[11,"tcx","","Type context we're checking in.",546],[11,"krate","","The crate being checked.",546],[11,"exported_items","","Items exported from the crate being checked.",546],[1,"LintStore","","Information about the registered lints."],[1,"Lint","","Specification of a single lint."],[11,"name","","A string identifier for the lint.",547],[11,"default_level","","Default level for the lint.",547],[11,"desc","","Description of the lint or the issue it detects.",547],[1,"LintId","","Identifies a lint known to the compiler."],[2,"Level","","Setting for how to handle a lint."],[12,"Allow","","",548],[12,"Warn","","",548],[12,"Deny","","",548],[12,"Forbid","","",548],[2,"LintSource","","How a lint level was set."],[12,"Default","","Lint is at the default level as declared\nin rustc or a plugin.",549],[12,"Node","","Lint level was set by an attribute.",549],[12,"CommandLine","","Lint level was set by a command-line flag.",549],[3,"raw_emit_lint","","Emit a lint as a warning or an error (or not at all)\naccording to `level`."],[3,"check_crate","","Perform lint checking on a crate."],[3,"gather_attrs","","Parse the lint attributes into a vector, with `Err`s for malformed lint\nattributes. Writing this as an iterator is an enormous mess."],[0,"builtin","","Lints built in to rustc."],[1,"WhileTrue","rustc::lint::builtin",""],[1,"UnusedCasts","",""],[1,"TypeLimits","",""],[1,"CTypes","",""],[1,"HeapMemory","",""],[1,"RawPointerDeriving","",""],[1,"UnusedAttribute","",""],[1,"PathStatement","",""],[1,"UnusedResult","",""],[1,"NonCamelCaseTypes","",""],[1,"NonSnakeCaseFunctions","",""],[1,"NonUppercaseStatics","",""],[1,"NonUppercasePatternStatics","",""],[1,"UppercaseVariables","",""],[1,"UnnecessaryParens","",""],[1,"UnusedUnsafe","",""],[1,"UnsafeBlock","",""],[1,"UnusedMut","",""],[1,"UnnecessaryAllocation","",""],[1,"MissingDoc","",""],[1,"Stability","","Checks for use of items with `#[deprecated]`, `#[experimental]` and\n`#[unstable]` attributes, or no stability attribute."],[1,"HardwiredLints","","Does nothing as a lint pass, but registers some `Lint`s\nwhich are used by other parts of the compiler."],[5,"UNUSED_IMPORTS","",""],[5,"UNNECESSARY_QUALIFICATION","",""],[5,"UNRECOGNIZED_LINT","",""],[5,"UNUSED_VARIABLE","",""],[5,"DEAD_ASSIGNMENT","",""],[5,"DEAD_CODE","",""],[5,"VISIBLE_PRIVATE_TYPES","",""],[5,"UNREACHABLE_CODE","",""],[5,"WARNINGS","",""],[5,"UNKNOWN_FEATURES","",""],[5,"UNKNOWN_CRATE_TYPE","",""],[5,"VARIANT_SIZE_DIFFERENCE","",""],[10,"get_lints","","",550],[10,"check_expr","","",550],[10,"get_lints","","",551],[10,"check_expr","","",551],[10,"new","","",552],[10,"get_lints","","",552],[10,"check_expr","","",552],[10,"get_lints","","",553],[10,"check_item","","",553],[10,"get_lints","","",554],[10,"check_item","","",554],[10,"check_expr","","",554],[10,"new","","",555],[10,"get_lints","","",555],[10,"check_item","","",555],[10,"get_lints","","",556],[10,"check_attribute","","",556],[10,"get_lints","","",557],[10,"check_stmt","","",557],[10,"get_lints","","",558],[10,"check_stmt","","",558],[10,"get_lints","","",559],[10,"check_item","","",559],[10,"get_lints","","",560],[10,"check_fn","","",560],[10,"check_ty_method","","",560],[10,"get_lints","","",561],[10,"check_item","","",561],[10,"get_lints","","",562],[10,"check_pat","","",562],[10,"get_lints","","",563],[10,"check_pat","","",563],[10,"check_struct_def","","",563],[10,"get_lints","","",564],[10,"check_expr","","",564],[10,"check_stmt","","",564],[10,"get_lints","","",565],[10,"check_expr","","",565],[10,"get_lints","","",566],[10,"check_expr","","",566],[10,"get_lints","","",567],[10,"check_expr","","",567],[10,"check_stmt","","",567],[10,"check_fn","","",567],[10,"get_lints","","",568],[10,"check_expr","","",568],[10,"new","","",569],[10,"get_lints","","",569],[10,"enter_lint_attrs","","",569],[10,"exit_lint_attrs","","",569],[10,"check_struct_def","","",569],[10,"check_struct_def_post","","",569],[10,"check_crate","","",569],[10,"check_item","","",569],[10,"check_fn","","",569],[10,"check_ty_method","","",569],[10,"check_struct_field","","",569],[10,"check_variant","","",569],[10,"get_lints","","",570],[10,"check_expr","","",570],[10,"get_lints","","",571],[4,"LintArray","rustc::lint",""],[4,"LintPassObject","","A lint pass boxed up as a trait object."],[4,"LevelSource","",""],[6,"LintPass","","Trait for types providing lint checks."],[9,"get_lints","","Get descriptions of the lints this `LintPass` object can emit.",572],[10,"check_crate","","",572],[10,"check_ident","","",572],[10,"check_mod","","",572],[10,"check_view_item","","",572],[10,"check_foreign_item","","",572],[10,"check_item","","",572],[10,"check_local","","",572],[10,"check_block","","",572],[10,"check_stmt","","",572],[10,"check_arm","","",572],[10,"check_pat","","",572],[10,"check_decl","","",572],[10,"check_expr","","",572],[10,"check_expr_post","","",572],[10,"check_ty","","",572],[10,"check_generics","","",572],[10,"check_fn","","",572],[10,"check_ty_method","","",572],[10,"check_trait_method","","",572],[10,"check_struct_def","","",572],[10,"check_struct_def_post","","",572],[10,"check_struct_field","","",572],[10,"check_variant","","",572],[10,"check_opt_lifetime_ref","","",572],[10,"check_lifetime_ref","","",572],[10,"check_lifetime_decl","","",572],[10,"check_explicit_self","","",572],[10,"check_mac","","",572],[10,"check_path","","",572],[10,"check_attribute","","",572],[10,"enter_lint_attrs","","Called when entering a syntax node that can have lint attributes such\nas `#[allow(...)]`. Called with *all* the attributes of that node.",572],[10,"exit_lint_attrs","","Counterpart to `enter_lint_attrs`.",572],[10,"name_lower","","Get the lint's name, with ASCII letters converted to lowercase.",547],[10,"clone","","",573],[10,"eq","","",573],[10,"hash","","",573],[10,"of","","Get the `LintId` for a `Lint`.",573],[10,"as_str","","Get the name of the lint.",573],[10,"cmp","","",548],[10,"partial_cmp","","",548],[10,"lt","","",548],[10,"le","","",548],[10,"gt","","",548],[10,"ge","","",548],[10,"eq","","",548],[10,"ne","","",548],[10,"clone","","",548],[10,"as_str","","Convert a level to a lower-case string.",548],[10,"from_str","","Convert a lower-case string to a level.",548],[10,"eq","","",549],[10,"ne","","",549],[10,"clone","","",549],[0,"util","rustc",""],[0,"common","rustc::util",""],[1,"Indenter","rustc::util::common",""],[3,"time","",""],[3,"indent","",""],[3,"indenter","",""],[3,"loop_query","",""],[3,"block_query","",""],[10,"drop","","",574],[0,"ppaux","rustc::util",""],[3,"note_and_explain_region","rustc::util::ppaux",""],[3,"explain_region_and_span","",""],[3,"bound_region_ptr_to_string","",""],[3,"bound_region_to_string","",""],[3,"region_ptr_to_string","",""],[3,"region_to_string","",""],[3,"mutability_to_string","",""],[3,"mt_to_string","",""],[3,"trait_store_to_string","",""],[3,"vec_map_to_string","",""],[3,"fn_sig_to_string","",""],[3,"trait_ref_to_string","",""],[3,"ty_to_string","",""],[3,"explicit_self_category_to_str","",""],[3,"parameterized","",""],[3,"ty_to_short_str","",""],[6,"Repr","","Produces a string suitable for debugging output."],[9,"repr","","",575],[6,"UserString","","Produces a string suitable for showing to the user."],[9,"user_string","","",576],[10,"repr","core::option","",28],[10,"repr","core::result","",577],[10,"repr","alloc::rc","",252],[10,"repr","std::gc","",387],[10,"repr","alloc::boxed","",578],[10,"repr","syntax::owned_slice","",254],[10,"repr","collections::vec","",253],[10,"repr","rustc::middle::def","",71],[10,"repr","rustc::middle::ty","",215],[10,"repr","","",216],[10,"repr","","",248],[10,"repr","","",192],[10,"repr","rustc::middle::subst","",114],[10,"repr","","",119],[10,"repr","rustc::middle::ty","",221],[10,"repr","rustc::middle::subst","",115],[10,"repr","rustc::middle::ty","",210],[10,"repr","","",208],[10,"repr","syntax::ast","",102],[10,"repr","","",418],[10,"repr","","",480],[10,"repr","","",579],[10,"repr","","",103],[10,"repr","rustc::middle::ty","",234],[10,"repr","","",232],[10,"repr","syntax::ast","",27],[10,"repr","rustc::middle::ty","",219],[10,"repr","","",217],[10,"repr","","",195],[10,"repr","","",228],[10,"repr","","",191],[10,"repr","syntax::ast","",10],[10,"repr","","",9],[10,"repr","","",460],[10,"repr","","",476],[10,"repr","rustc::middle::ty","",200],[10,"repr","","",202],[10,"repr","rustc::middle::typeck","",260],[10,"repr","","",263],[10,"repr","","",258],[10,"repr","","",259],[10,"repr","rustc::middle::ty","",226],[10,"repr","","",239],[10,"user_string","","",239],[10,"repr","rustc::util::ppaux","",255],[10,"repr","syntax::codemap","",29],[10,"user_string","alloc::rc","",252],[10,"user_string","rustc::util::ppaux","",255],[10,"user_string","rustc::middle::ty","",208],[10,"user_string","","",248],[10,"user_string","syntax::ast","",9],[10,"repr","syntax::abi","",500],[10,"user_string","","",500],[10,"repr","rustc::middle::ty","",204],[10,"repr","syntax::ast","",427],[10,"repr","rustc::middle::ty","",233],[10,"repr","","",205],[10,"repr","","",212],[10,"repr","","",213],[10,"repr","","",214],[10,"repr","","",211],[10,"repr","","",236],[10,"repr","syntax::ast","",447],[10,"repr","","",448],[10,"repr","","",319],[10,"repr","rustc::middle::typeck::infer","",284],[10,"repr","rustc::middle::typeck::infer::unify","",314],[10,"repr","rustc::middle::typeck::infer::region_inference","",306],[10,"repr","rustc::middle::ty","",245],[0,"nodemap","rustc::util","An efficient hash map for node IDs"],[1,"FnvHasher","rustc::util::nodemap","A speedy hash algorithm for node ids and def ids. The hashmap in\nlibcollections by default uses SipHash which isn't quite as speedy as we\nwant. In the compiler we're not really worried about DOS attempts, so we\njust default to a non-cryptographic hash."],[1,"FnvState","",""],[0,"FnvHashMap","",""],[3,"new","rustc::util::nodemap::FnvHashMap",""],[0,"FnvHashSet","rustc::util::nodemap",""],[3,"new","rustc::util::nodemap::FnvHashSet",""],[0,"NodeMap","rustc::util::nodemap",""],[3,"new","rustc::util::nodemap::NodeMap",""],[0,"DefIdMap","rustc::util::nodemap",""],[3,"new","rustc::util::nodemap::DefIdMap",""],[0,"NodeSet","rustc::util::nodemap",""],[3,"new","rustc::util::nodemap::NodeSet",""],[0,"DefIdSet","rustc::util::nodemap",""],[3,"new","rustc::util::nodemap::DefIdSet",""],[4,"FnvHashMap","rustc::util::nodemap",""],[4,"FnvHashSet","",""],[4,"NodeMap","",""],[4,"DefIdMap","",""],[4,"NodeSet","",""],[4,"DefIdSet","",""],[10,"clone","","",580],[10,"hash","","",580],[10,"write","","",581],[0,"fs","rustc::util",""],[3,"realpath","rustc::util::fs","Returns an absolute path in the filesystem that `path` points to. The\nreturned path does not contain any symlinks in its hierarchy."],[0,"sha2","rustc::util","This module implements only the Sha256 function since that is all that is needed for internal\nuse. This implementation is not intended for external use or for any use where security is\nimportant."],[6,"Digest","rustc::util::sha2","The Digest trait specifies an interface common to digest functions, such as SHA-1 and the SHA-2\nfamily of digest functions."],[9,"input","","Provide message data.",582],[9,"result","","Retrieve the digest result. This method may be called multiple times.",582],[9,"reset","","Reset the digest. This method must be called after result() and before supplying more\ndata.",582],[9,"output_bits","","Get the output size in bits.",582],[9,"input_str","","Convenience function that feeds a string into a digest.",582],[9,"result_bytes","","Convenience function that retrieves the result of a digest as a\nnewly allocated vec of bytes.",582],[9,"result_str","","Convenience function that retrieves the result of a digest as a\nString in hexadecimal format.",582],[1,"Sha256","","The SHA-256 hash algorithm"],[0,"lib","rustc",""],[0,"llvm","rustc::lib",""],[0,"archive_ro","rustc::lib::llvm","A wrapper around LLVM's archive (.a) code"],[10,"open","rustc_llvm::archive_ro","Opens a static archive for read-only purposes. This is more optimized\nthan the `open` method because it uses LLVM's internal `Archive` class\nrather than shelling out to `ar` for everything.",583],[10,"read","","Reads a file in the archive",583],[10,"drop","","",583],[10,"eq","rustc_llvm","",584],[10,"ne","","",584],[10,"ne","","",584],[10,"clone","","",585],[10,"clone_from","","",585],[10,"apply_llfn","","",585],[10,"apply_callsite","","",585],[10,"apply_llfn","","",586],[10,"apply_callsite","","",586],[10,"apply_llfn","","",587],[10,"apply_callsite","","",587],[10,"new","","",588],[10,"arg","","",588],[10,"ret","","",588],[10,"apply_llfn","","",588],[10,"apply_callsite","","",588],[10,"eq","","",589],[10,"ne","","",589],[10,"ne","","",589],[10,"eq","","",590],[10,"ne","","",590],[10,"ne","","",590],[10,"drop","","",591],[10,"new","","",592],[10,"drop","","",592],[10,"drop","","",593],[1,"ArchiveRO","rustc::lib::llvm::archive_ro",""],[4,"Opcode","rustc::lib::llvm",""],[4,"Bool","",""],[5,"True","",""],[5,"False","",""],[2,"CallConv","",""],[12,"CCallConv","","",584],[12,"FastCallConv","","",584],[12,"ColdCallConv","","",584],[12,"X86StdcallCallConv","","",584],[12,"X86FastcallCallConv","","",584],[12,"X86_64_Win64","","",584],[2,"Visibility","",""],[12,"LLVMDefaultVisibility","","",594],[12,"HiddenVisibility","","",594],[12,"ProtectedVisibility","","",594],[2,"Linkage","",""],[12,"ExternalLinkage","","",595],[12,"AvailableExternallyLinkage","","",595],[12,"LinkOnceAnyLinkage","","",595],[12,"LinkOnceODRLinkage","","",595],[12,"WeakAnyLinkage","","",595],[12,"WeakODRLinkage","","",595],[12,"AppendingLinkage","","",595],[12,"InternalLinkage","","",595],[12,"PrivateLinkage","","",595],[12,"ExternalWeakLinkage","","",595],[12,"CommonLinkage","","",595],[2,"Attribute","",""],[12,"ZExtAttribute","","",585],[12,"SExtAttribute","","",585],[12,"NoReturnAttribute","","",585],[12,"InRegAttribute","","",585],[12,"StructRetAttribute","","",585],[12,"NoUnwindAttribute","","",585],[12,"NoAliasAttribute","","",585],[12,"ByValAttribute","","",585],[12,"NestAttribute","","",585],[12,"ReadNoneAttribute","","",585],[12,"ReadOnlyAttribute","","",585],[12,"NoInlineAttribute","","",585],[12,"AlwaysInlineAttribute","","",585],[12,"OptimizeForSizeAttribute","","",585],[12,"StackProtectAttribute","","",585],[12,"StackProtectReqAttribute","","",585],[12,"AlignmentAttribute","","",585],[12,"NoCaptureAttribute","","",585],[12,"NoRedZoneAttribute","","",585],[12,"NoImplicitFloatAttribute","","",585],[12,"NakedAttribute","","",585],[12,"InlineHintAttribute","","",585],[12,"StackAttribute","","",585],[12,"ReturnsTwiceAttribute","","",585],[12,"UWTableAttribute","","",585],[12,"NonLazyBindAttribute","","",585],[2,"OtherAttribute","",""],[12,"SanitizeAddressAttribute","","",586],[12,"MinSizeAttribute","","",586],[12,"NoDuplicateAttribute","","",586],[12,"StackProtectStrongAttribute","","",586],[12,"SanitizeThreadAttribute","","",586],[12,"SanitizeMemoryAttribute","","",586],[12,"NoBuiltinAttribute","","",586],[12,"ReturnedAttribute","","",586],[12,"ColdAttribute","","",586],[12,"BuiltinAttribute","","",586],[12,"OptimizeNoneAttribute","","",586],[12,"InAllocaAttribute","","",586],[12,"NonNullAttribute","","",586],[2,"SpecialAttribute","",""],[12,"DereferenceableAttribute","","",587],[2,"AttributeSet","",""],[12,"ReturnIndex","","",596],[12,"FunctionIndex","","",596],[1,"AttrBuilder","",""],[2,"IntPredicate","",""],[12,"IntEQ","","",597],[12,"IntNE","","",597],[12,"IntUGT","","",597],[12,"IntUGE","","",597],[12,"IntULT","","",597],[12,"IntULE","","",597],[12,"IntSGT","","",597],[12,"IntSGE","","",597],[12,"IntSLT","","",597],[12,"IntSLE","","",597],[2,"RealPredicate","",""],[12,"RealPredicateFalse","","",598],[12,"RealOEQ","","",598],[12,"RealOGT","","",598],[12,"RealOGE","","",598],[12,"RealOLT","","",598],[12,"RealOLE","","",598],[12,"RealONE","","",598],[12,"RealORD","","",598],[12,"RealUNO","","",598],[12,"RealUEQ","","",598],[12,"RealUGT","","",598],[12,"RealUGE","","",598],[12,"RealULT","","",598],[12,"RealULE","","",598],[12,"RealUNE","","",598],[12,"RealPredicateTrue","","",598],[2,"TypeKind","",""],[12,"Void","","",589],[12,"Half","","",589],[12,"Float","","",589],[12,"Double","","",589],[12,"X86_FP80","","",589],[12,"FP128","","",589],[12,"PPC_FP128","","",589],[12,"Label","","",589],[12,"Integer","","",589],[12,"Function","","",589],[12,"Struct","","",589],[12,"Array","","",589],[12,"Pointer","","",589],[12,"Vector","","",589],[12,"Metadata","","",589],[12,"X86_MMX","","",589],[2,"AtomicBinOp","",""],[12,"Xchg","","",599],[12,"Add","","",599],[12,"Sub","","",599],[12,"And","","",599],[12,"Nand","","",599],[12,"Or","","",599],[12,"Xor","","",599],[12,"Max","","",599],[12,"Min","","",599],[12,"UMax","","",599],[12,"UMin","","",599],[2,"AtomicOrdering","",""],[12,"NotAtomic","","",600],[12,"Unordered","","",600],[12,"Monotonic","","",600],[12,"Acquire","","",600],[12,"Release","","",600],[12,"AcquireRelease","","",600],[12,"SequentiallyConsistent","","",600],[2,"FileType","",""],[12,"AssemblyFile","","",601],[12,"ObjectFile","","",601],[2,"Metadata","",""],[12,"MD_dbg","","",602],[12,"MD_tbaa","","",602],[12,"MD_prof","","",602],[12,"MD_fpmath","","",602],[12,"MD_range","","",602],[12,"MD_tbaa_struct","","",602],[2,"AsmDialect","",""],[12,"AD_ATT","","",603],[12,"AD_Intel","","",603],[2,"CodeGenOptLevel","",""],[12,"CodeGenLevelNone","","",590],[12,"CodeGenLevelLess","","",590],[12,"CodeGenLevelDefault","","",590],[12,"CodeGenLevelAggressive","","",590],[2,"RelocMode","",""],[12,"RelocDefault","","",604],[12,"RelocStatic","","",604],[12,"RelocPIC","","",604],[12,"RelocDynamicNoPic","","",604],[2,"CodeGenModel","",""],[12,"CodeModelDefault","","",605],[12,"CodeModelJITDefault","","",605],[12,"CodeModelSmall","","",605],[12,"CodeModelKernel","","",605],[12,"CodeModelMedium","","",605],[12,"CodeModelLarge","","",605],[2,"Module_opaque","",""],[4,"ModuleRef","",""],[2,"Context_opaque","",""],[4,"ContextRef","",""],[2,"Type_opaque","",""],[4,"TypeRef","",""],[2,"Value_opaque","",""],[4,"ValueRef","",""],[2,"BasicBlock_opaque","",""],[4,"BasicBlockRef","",""],[2,"Builder_opaque","",""],[4,"BuilderRef","",""],[2,"ExecutionEngine_opaque","",""],[4,"ExecutionEngineRef","",""],[2,"MemoryBuffer_opaque","",""],[4,"MemoryBufferRef","",""],[2,"PassManager_opaque","",""],[4,"PassManagerRef","",""],[2,"PassManagerBuilder_opaque","",""],[4,"PassManagerBuilderRef","",""],[2,"Use_opaque","",""],[4,"UseRef","",""],[2,"TargetData_opaque","",""],[4,"TargetDataRef","",""],[2,"ObjectFile_opaque","",""],[4,"ObjectFileRef","",""],[2,"SectionIterator_opaque","",""],[4,"SectionIteratorRef","",""],[2,"Pass_opaque","",""],[4,"PassRef","",""],[2,"TargetMachine_opaque","",""],[4,"TargetMachineRef","",""],[2,"Archive_opaque","",""],[4,"ArchiveRef","",""],[0,"debuginfo","",""],[2,"DIBuilder_opaque","rustc::lib::llvm::debuginfo",""],[4,"DIBuilderRef","",""],[4,"DIDescriptor","",""],[4,"DIScope","",""],[4,"DILocation","",""],[4,"DIFile","",""],[4,"DILexicalBlock","",""],[4,"DISubprogram","",""],[4,"DIType","",""],[4,"DIBasicType","",""],[4,"DIDerivedType","",""],[4,"DICompositeType","",""],[4,"DIVariable","",""],[4,"DIGlobalVariable","",""],[4,"DIArray","",""],[4,"DISubrange","",""],[2,"DIDescriptorFlags","",""],[12,"FlagPrivate","","",606],[12,"FlagProtected","","",606],[12,"FlagFwdDecl","","",606],[12,"FlagAppleBlock","","",606],[12,"FlagBlockByrefStruct","","",606],[12,"FlagVirtual","","",606],[12,"FlagArtificial","","",606],[12,"FlagExplicit","","",606],[12,"FlagPrototyped","","",606],[12,"FlagObjcClassComplete","","",606],[12,"FlagObjectPointer","","",606],[12,"FlagVector","","",606],[12,"FlagStaticMember","","",606],[3,"LLVMContextCreate","rustc::lib::llvm",""],[3,"LLVMContextDispose","",""],[3,"LLVMGetMDKindIDInContext","",""],[3,"LLVMModuleCreateWithNameInContext","",""],[3,"LLVMGetModuleContext","",""],[3,"LLVMDisposeModule","",""],[3,"LLVMGetDataLayout","",""],[3,"LLVMSetDataLayout","",""],[3,"LLVMGetTarget","",""],[3,"LLVMSetTarget","",""],[3,"LLVMDumpModule","",""],[3,"LLVMSetModuleInlineAsm","",""],[3,"LLVMGetTypeKind","",""],[3,"LLVMGetTypeContext","",""],[3,"LLVMInt1TypeInContext","",""],[3,"LLVMInt8TypeInContext","",""],[3,"LLVMInt16TypeInContext","",""],[3,"LLVMInt32TypeInContext","",""],[3,"LLVMInt64TypeInContext","",""],[3,"LLVMIntTypeInContext","",""],[3,"LLVMGetIntTypeWidth","",""],[3,"LLVMFloatTypeInContext","",""],[3,"LLVMDoubleTypeInContext","",""],[3,"LLVMX86FP80TypeInContext","",""],[3,"LLVMFP128TypeInContext","",""],[3,"LLVMPPCFP128TypeInContext","",""],[3,"LLVMFunctionType","",""],[3,"LLVMIsFunctionVarArg","",""],[3,"LLVMGetReturnType","",""],[3,"LLVMCountParamTypes","",""],[3,"LLVMGetParamTypes","",""],[3,"LLVMStructTypeInContext","",""],[3,"LLVMCountStructElementTypes","",""],[3,"LLVMGetStructElementTypes","",""],[3,"LLVMIsPackedStruct","",""],[3,"LLVMRustArrayType","",""],[3,"LLVMPointerType","",""],[3,"LLVMVectorType","",""],[3,"LLVMGetElementType","",""],[3,"LLVMGetArrayLength","",""],[3,"LLVMGetPointerAddressSpace","",""],[3,"LLVMGetPointerToGlobal","",""],[3,"LLVMGetVectorSize","",""],[3,"LLVMVoidTypeInContext","",""],[3,"LLVMLabelTypeInContext","",""],[3,"LLVMMetadataTypeInContext","",""],[3,"LLVMTypeOf","",""],[3,"LLVMGetValueName","",""],[3,"LLVMSetValueName","",""],[3,"LLVMDumpValue","",""],[3,"LLVMReplaceAllUsesWith","",""],[3,"LLVMHasMetadata","",""],[3,"LLVMGetMetadata","",""],[3,"LLVMSetMetadata","",""],[3,"LLVMGetFirstUse","",""],[3,"LLVMGetNextUse","",""],[3,"LLVMGetUser","",""],[3,"LLVMGetUsedValue","",""],[3,"LLVMGetNumOperands","",""],[3,"LLVMGetOperand","",""],[3,"LLVMSetOperand","",""],[3,"LLVMConstNull","",""],[3,"LLVMConstAllOnes","",""],[3,"LLVMConstICmp","",""],[3,"LLVMConstFCmp","",""],[3,"LLVMGetUndef","",""],[3,"LLVMIsConstant","",""],[3,"LLVMIsNull","",""],[3,"LLVMIsUndef","",""],[3,"LLVMConstPointerNull","",""],[3,"LLVMMDStringInContext","",""],[3,"LLVMMDNodeInContext","",""],[3,"LLVMAddNamedMetadataOperand","",""],[3,"LLVMConstInt","",""],[3,"LLVMConstIntOfString","",""],[3,"LLVMConstIntOfStringAndSize","",""],[3,"LLVMConstReal","",""],[3,"LLVMConstRealOfString","",""],[3,"LLVMConstRealOfStringAndSize","",""],[3,"LLVMConstIntGetZExtValue","",""],[3,"LLVMConstIntGetSExtValue","",""],[3,"LLVMConstStringInContext","",""],[3,"LLVMConstStructInContext","",""],[3,"LLVMConstArray","",""],[3,"LLVMConstVector","",""],[3,"LLVMAlignOf","",""],[3,"LLVMSizeOf","",""],[3,"LLVMConstNeg","",""],[3,"LLVMConstNSWNeg","",""],[3,"LLVMConstNUWNeg","",""],[3,"LLVMConstFNeg","",""],[3,"LLVMConstNot","",""],[3,"LLVMConstAdd","",""],[3,"LLVMConstNSWAdd","",""],[3,"LLVMConstNUWAdd","",""],[3,"LLVMConstFAdd","",""],[3,"LLVMConstSub","",""],[3,"LLVMConstNSWSub","",""],[3,"LLVMConstNUWSub","",""],[3,"LLVMConstFSub","",""],[3,"LLVMConstMul","",""],[3,"LLVMConstNSWMul","",""],[3,"LLVMConstNUWMul","",""],[3,"LLVMConstFMul","",""],[3,"LLVMConstUDiv","",""],[3,"LLVMConstSDiv","",""],[3,"LLVMConstExactSDiv","",""],[3,"LLVMConstFDiv","",""],[3,"LLVMConstURem","",""],[3,"LLVMConstSRem","",""],[3,"LLVMConstFRem","",""],[3,"LLVMConstAnd","",""],[3,"LLVMConstOr","",""],[3,"LLVMConstXor","",""],[3,"LLVMConstShl","",""],[3,"LLVMConstLShr","",""],[3,"LLVMConstAShr","",""],[3,"LLVMConstGEP","",""],[3,"LLVMConstInBoundsGEP","",""],[3,"LLVMConstTrunc","",""],[3,"LLVMConstSExt","",""],[3,"LLVMConstZExt","",""],[3,"LLVMConstFPTrunc","",""],[3,"LLVMConstFPExt","",""],[3,"LLVMConstUIToFP","",""],[3,"LLVMConstSIToFP","",""],[3,"LLVMConstFPToUI","",""],[3,"LLVMConstFPToSI","",""],[3,"LLVMConstPtrToInt","",""],[3,"LLVMConstIntToPtr","",""],[3,"LLVMConstBitCast","",""],[3,"LLVMConstZExtOrBitCast","",""],[3,"LLVMConstSExtOrBitCast","",""],[3,"LLVMConstTruncOrBitCast","",""],[3,"LLVMConstPointerCast","",""],[3,"LLVMConstIntCast","",""],[3,"LLVMConstFPCast","",""],[3,"LLVMConstSelect","",""],[3,"LLVMConstExtractElement","",""],[3,"LLVMConstInsertElement","",""],[3,"LLVMConstShuffleVector","",""],[3,"LLVMConstExtractValue","",""],[3,"LLVMConstInsertValue","",""],[3,"LLVMConstInlineAsm","",""],[3,"LLVMBlockAddress","",""],[3,"LLVMGetGlobalParent","",""],[3,"LLVMIsDeclaration","",""],[3,"LLVMGetLinkage","",""],[3,"LLVMSetLinkage","",""],[3,"LLVMGetSection","",""],[3,"LLVMSetSection","",""],[3,"LLVMGetVisibility","",""],[3,"LLVMSetVisibility","",""],[3,"LLVMGetAlignment","",""],[3,"LLVMSetAlignment","",""],[3,"LLVMAddGlobal","",""],[3,"LLVMAddGlobalInAddressSpace","",""],[3,"LLVMGetNamedGlobal","",""],[3,"LLVMGetFirstGlobal","",""],[3,"LLVMGetLastGlobal","",""],[3,"LLVMGetNextGlobal","",""],[3,"LLVMGetPreviousGlobal","",""],[3,"LLVMDeleteGlobal","",""],[3,"LLVMGetInitializer","",""],[3,"LLVMSetInitializer","",""],[3,"LLVMIsThreadLocal","",""],[3,"LLVMSetThreadLocal","",""],[3,"LLVMIsGlobalConstant","",""],[3,"LLVMSetGlobalConstant","",""],[3,"LLVMAddAlias","",""],[3,"LLVMAddFunction","",""],[3,"LLVMGetNamedFunction","",""],[3,"LLVMGetFirstFunction","",""],[3,"LLVMGetLastFunction","",""],[3,"LLVMGetNextFunction","",""],[3,"LLVMGetPreviousFunction","",""],[3,"LLVMDeleteFunction","",""],[3,"LLVMGetOrInsertFunction","",""],[3,"LLVMGetIntrinsicID","",""],[3,"LLVMGetFunctionCallConv","",""],[3,"LLVMSetFunctionCallConv","",""],[3,"LLVMGetGC","",""],[3,"LLVMSetGC","",""],[3,"LLVMAddDereferenceableAttr","",""],[3,"LLVMAddFunctionAttribute","",""],[3,"LLVMAddFunctionAttrString","",""],[3,"LLVMRemoveFunctionAttrString","",""],[3,"LLVMGetFunctionAttr","",""],[3,"LLVMCountParams","",""],[3,"LLVMGetParams","",""],[3,"LLVMGetParam","",""],[3,"LLVMGetParamParent","",""],[3,"LLVMGetFirstParam","",""],[3,"LLVMGetLastParam","",""],[3,"LLVMGetNextParam","",""],[3,"LLVMGetPreviousParam","",""],[3,"LLVMAddAttribute","",""],[3,"LLVMRemoveAttribute","",""],[3,"LLVMGetAttribute","",""],[3,"LLVMSetParamAlignment","",""],[3,"LLVMBasicBlockAsValue","",""],[3,"LLVMValueIsBasicBlock","",""],[3,"LLVMValueAsBasicBlock","",""],[3,"LLVMGetBasicBlockParent","",""],[3,"LLVMCountBasicBlocks","",""],[3,"LLVMGetBasicBlocks","",""],[3,"LLVMGetFirstBasicBlock","",""],[3,"LLVMGetLastBasicBlock","",""],[3,"LLVMGetNextBasicBlock","",""],[3,"LLVMGetPreviousBasicBlock","",""],[3,"LLVMGetEntryBasicBlock","",""],[3,"LLVMAppendBasicBlockInContext","",""],[3,"LLVMInsertBasicBlockInContext","",""],[3,"LLVMDeleteBasicBlock","",""],[3,"LLVMMoveBasicBlockAfter","",""],[3,"LLVMMoveBasicBlockBefore","",""],[3,"LLVMGetInstructionParent","",""],[3,"LLVMGetFirstInstruction","",""],[3,"LLVMGetLastInstruction","",""],[3,"LLVMGetNextInstruction","",""],[3,"LLVMGetPreviousInstruction","",""],[3,"LLVMInstructionEraseFromParent","",""],[3,"LLVMSetInstructionCallConv","",""],[3,"LLVMGetInstructionCallConv","",""],[3,"LLVMAddInstrAttribute","",""],[3,"LLVMRemoveInstrAttribute","",""],[3,"LLVMSetInstrParamAlignment","",""],[3,"LLVMAddCallSiteAttribute","",""],[3,"LLVMAddDereferenceableCallSiteAttr","",""],[3,"LLVMIsTailCall","",""],[3,"LLVMSetTailCall","",""],[3,"LLVMGetVolatile","",""],[3,"LLVMSetVolatile","",""],[3,"LLVMAddIncoming","",""],[3,"LLVMCountIncoming","",""],[3,"LLVMGetIncomingValue","",""],[3,"LLVMGetIncomingBlock","",""],[3,"LLVMCreateBuilderInContext","",""],[3,"LLVMPositionBuilder","",""],[3,"LLVMPositionBuilderBefore","",""],[3,"LLVMPositionBuilderAtEnd","",""],[3,"LLVMGetInsertBlock","",""],[3,"LLVMClearInsertionPosition","",""],[3,"LLVMInsertIntoBuilder","",""],[3,"LLVMInsertIntoBuilderWithName","",""],[3,"LLVMDisposeBuilder","",""],[3,"LLVMDisposeExecutionEngine","",""],[3,"LLVMSetCurrentDebugLocation","",""],[3,"LLVMGetCurrentDebugLocation","",""],[3,"LLVMSetInstDebugLocation","",""],[3,"LLVMBuildRetVoid","",""],[3,"LLVMBuildRet","",""],[3,"LLVMBuildAggregateRet","",""],[3,"LLVMBuildBr","",""],[3,"LLVMBuildCondBr","",""],[3,"LLVMBuildSwitch","",""],[3,"LLVMBuildIndirectBr","",""],[3,"LLVMBuildInvoke","",""],[3,"LLVMBuildLandingPad","",""],[3,"LLVMBuildResume","",""],[3,"LLVMBuildUnreachable","",""],[3,"LLVMAddCase","",""],[3,"LLVMAddDestination","",""],[3,"LLVMAddClause","",""],[3,"LLVMSetCleanup","",""],[3,"LLVMBuildAdd","",""],[3,"LLVMBuildNSWAdd","",""],[3,"LLVMBuildNUWAdd","",""],[3,"LLVMBuildFAdd","",""],[3,"LLVMBuildSub","",""],[3,"LLVMBuildNSWSub","",""],[3,"LLVMBuildNUWSub","",""],[3,"LLVMBuildFSub","",""],[3,"LLVMBuildMul","",""],[3,"LLVMBuildNSWMul","",""],[3,"LLVMBuildNUWMul","",""],[3,"LLVMBuildFMul","",""],[3,"LLVMBuildUDiv","",""],[3,"LLVMBuildSDiv","",""],[3,"LLVMBuildExactSDiv","",""],[3,"LLVMBuildFDiv","",""],[3,"LLVMBuildURem","",""],[3,"LLVMBuildSRem","",""],[3,"LLVMBuildFRem","",""],[3,"LLVMBuildShl","",""],[3,"LLVMBuildLShr","",""],[3,"LLVMBuildAShr","",""],[3,"LLVMBuildAnd","",""],[3,"LLVMBuildOr","",""],[3,"LLVMBuildXor","",""],[3,"LLVMBuildBinOp","",""],[3,"LLVMBuildNeg","",""],[3,"LLVMBuildNSWNeg","",""],[3,"LLVMBuildNUWNeg","",""],[3,"LLVMBuildFNeg","",""],[3,"LLVMBuildNot","",""],[3,"LLVMBuildMalloc","",""],[3,"LLVMBuildArrayMalloc","",""],[3,"LLVMBuildAlloca","",""],[3,"LLVMBuildArrayAlloca","",""],[3,"LLVMBuildFree","",""],[3,"LLVMBuildLoad","",""],[3,"LLVMBuildStore","",""],[3,"LLVMBuildGEP","",""],[3,"LLVMBuildInBoundsGEP","",""],[3,"LLVMBuildStructGEP","",""],[3,"LLVMBuildGlobalString","",""],[3,"LLVMBuildGlobalStringPtr","",""],[3,"LLVMBuildTrunc","",""],[3,"LLVMBuildZExt","",""],[3,"LLVMBuildSExt","",""],[3,"LLVMBuildFPToUI","",""],[3,"LLVMBuildFPToSI","",""],[3,"LLVMBuildUIToFP","",""],[3,"LLVMBuildSIToFP","",""],[3,"LLVMBuildFPTrunc","",""],[3,"LLVMBuildFPExt","",""],[3,"LLVMBuildPtrToInt","",""],[3,"LLVMBuildIntToPtr","",""],[3,"LLVMBuildBitCast","",""],[3,"LLVMBuildZExtOrBitCast","",""],[3,"LLVMBuildSExtOrBitCast","",""],[3,"LLVMBuildTruncOrBitCast","",""],[3,"LLVMBuildCast","",""],[3,"LLVMBuildPointerCast","",""],[3,"LLVMBuildIntCast","",""],[3,"LLVMBuildFPCast","",""],[3,"LLVMBuildICmp","",""],[3,"LLVMBuildFCmp","",""],[3,"LLVMBuildPhi","",""],[3,"LLVMBuildCall","",""],[3,"LLVMBuildSelect","",""],[3,"LLVMBuildVAArg","",""],[3,"LLVMBuildExtractElement","",""],[3,"LLVMBuildInsertElement","",""],[3,"LLVMBuildShuffleVector","",""],[3,"LLVMBuildExtractValue","",""],[3,"LLVMBuildInsertValue","",""],[3,"LLVMBuildIsNull","",""],[3,"LLVMBuildIsNotNull","",""],[3,"LLVMBuildPtrDiff","",""],[3,"LLVMBuildAtomicLoad","",""],[3,"LLVMBuildAtomicStore","",""],[3,"LLVMBuildAtomicCmpXchg","",""],[3,"LLVMBuildAtomicRMW","",""],[3,"LLVMBuildAtomicFence","",""],[3,"LLVMIsATerminatorInst","",""],[3,"LLVMIsAStoreInst","",""],[3,"LLVMWriteBitcodeToFile","",""],[3,"LLVMCreateTargetData","",""],[3,"LLVMAddTargetData","",""],[3,"LLVMStoreSizeOfType","",""],[3,"LLVMSizeOfTypeInBits","",""],[3,"LLVMABISizeOfType","",""],[3,"LLVMPreferredAlignmentOfType","",""],[3,"LLVMABIAlignmentOfType","",""],[3,"LLVMOffsetOfElement","",""],[3,"LLVMCallFrameAlignmentOfType","",""],[3,"LLVMDisposeTargetData","",""],[3,"LLVMCreatePassManager","",""],[3,"LLVMCreateFunctionPassManagerForModule","",""],[3,"LLVMDisposePassManager","",""],[3,"LLVMRunPassManager","",""],[3,"LLVMRunFunctionPassManager","",""],[3,"LLVMInitializeFunctionPassManager","",""],[3,"LLVMFinalizeFunctionPassManager","",""],[3,"LLVMInitializePasses","",""],[3,"LLVMAddVerifierPass","",""],[3,"LLVMAddGlobalOptimizerPass","",""],[3,"LLVMAddIPSCCPPass","",""],[3,"LLVMAddDeadArgEliminationPass","",""],[3,"LLVMAddInstructionCombiningPass","",""],[3,"LLVMAddCFGSimplificationPass","",""],[3,"LLVMAddFunctionInliningPass","",""],[3,"LLVMAddFunctionAttrsPass","",""],[3,"LLVMAddScalarReplAggregatesPass","",""],[3,"LLVMAddScalarReplAggregatesPassSSA","",""],[3,"LLVMAddJumpThreadingPass","",""],[3,"LLVMAddConstantPropagationPass","",""],[3,"LLVMAddReassociatePass","",""],[3,"LLVMAddLoopRotatePass","",""],[3,"LLVMAddLICMPass","",""],[3,"LLVMAddLoopUnswitchPass","",""],[3,"LLVMAddLoopDeletionPass","",""],[3,"LLVMAddLoopUnrollPass","",""],[3,"LLVMAddGVNPass","",""],[3,"LLVMAddMemCpyOptPass","",""],[3,"LLVMAddSCCPPass","",""],[3,"LLVMAddDeadStoreEliminationPass","",""],[3,"LLVMAddStripDeadPrototypesPass","",""],[3,"LLVMAddConstantMergePass","",""],[3,"LLVMAddArgumentPromotionPass","",""],[3,"LLVMAddTailCallEliminationPass","",""],[3,"LLVMAddIndVarSimplifyPass","",""],[3,"LLVMAddAggressiveDCEPass","",""],[3,"LLVMAddGlobalDCEPass","",""],[3,"LLVMAddCorrelatedValuePropagationPass","",""],[3,"LLVMAddPruneEHPass","",""],[3,"LLVMAddSimplifyLibCallsPass","",""],[3,"LLVMAddLoopIdiomPass","",""],[3,"LLVMAddEarlyCSEPass","",""],[3,"LLVMAddTypeBasedAliasAnalysisPass","",""],[3,"LLVMAddBasicAliasAnalysisPass","",""],[3,"LLVMPassManagerBuilderCreate","",""],[3,"LLVMPassManagerBuilderDispose","",""],[3,"LLVMPassManagerBuilderSetOptLevel","",""],[3,"LLVMPassManagerBuilderSetSizeLevel","",""],[3,"LLVMPassManagerBuilderSetDisableUnitAtATime","",""],[3,"LLVMPassManagerBuilderSetDisableUnrollLoops","",""],[3,"LLVMPassManagerBuilderSetDisableSimplifyLibCalls","",""],[3,"LLVMPassManagerBuilderUseInlinerWithThreshold","",""],[3,"LLVMPassManagerBuilderPopulateModulePassManager","",""],[3,"LLVMPassManagerBuilderPopulateFunctionPassManager","",""],[3,"LLVMPassManagerBuilderPopulateLTOPassManager","",""],[3,"LLVMDisposeMemoryBuffer","",""],[3,"LLVMCreateObjectFile","",""],[3,"LLVMDisposeObjectFile","",""],[3,"LLVMGetSections","",""],[3,"LLVMDisposeSectionIterator","",""],[3,"LLVMIsSectionIteratorAtEnd","",""],[3,"LLVMMoveToNextSection","",""],[3,"LLVMGetSectionSize","",""],[3,"LLVMGetSectionContents","",""],[3,"LLVMRustCreateMemoryBufferWithContentsOfFile","",""],[3,"LLVMCreateMemoryBufferWithMemoryRange","",""],[3,"LLVMCreateMemoryBufferWithMemoryRangeCopy","",""],[3,"LLVMIsMultithreaded","",""],[3,"LLVMStartMultithreaded","",""],[3,"LLVMRustGetLastError","",""],[3,"LLVMRustPrintPassTimings","",""],[3,"LLVMStructCreateNamed","",""],[3,"LLVMStructSetBody","",""],[3,"LLVMConstNamedStruct","",""],[3,"LLVMSetDebug","",""],[3,"LLVMInlineAsm","",""],[5,"LLVMRustDebugMetadataVersion","",""],[3,"LLVMRustAddModuleFlag","",""],[3,"LLVMDIBuilderCreate","",""],[3,"LLVMDIBuilderDispose","",""],[3,"LLVMDIBuilderFinalize","",""],[3,"LLVMDIBuilderCreateCompileUnit","",""],[3,"LLVMDIBuilderCreateFile","",""],[3,"LLVMDIBuilderCreateSubroutineType","",""],[3,"LLVMDIBuilderCreateFunction","",""],[3,"LLVMDIBuilderCreateBasicType","",""],[3,"LLVMDIBuilderCreatePointerType","",""],[3,"LLVMDIBuilderCreateStructType","",""],[3,"LLVMDIBuilderCreateMemberType","",""],[3,"LLVMDIBuilderCreateLexicalBlock","",""],[3,"LLVMDIBuilderCreateStaticVariable","",""],[3,"LLVMDIBuilderCreateLocalVariable","",""],[3,"LLVMDIBuilderCreateArrayType","",""],[3,"LLVMDIBuilderCreateVectorType","",""],[3,"LLVMDIBuilderGetOrCreateSubrange","",""],[3,"LLVMDIBuilderGetOrCreateArray","",""],[3,"LLVMDIBuilderInsertDeclareAtEnd","",""],[3,"LLVMDIBuilderInsertDeclareBefore","",""],[3,"LLVMDIBuilderCreateEnumerator","",""],[3,"LLVMDIBuilderCreateEnumerationType","",""],[3,"LLVMDIBuilderCreateUnionType","",""],[3,"LLVMSetUnnamedAddr","",""],[3,"LLVMDIBuilderCreateTemplateTypeParameter","",""],[3,"LLVMDIBuilderCreateOpDeref","",""],[3,"LLVMDIBuilderCreateOpPlus","",""],[3,"LLVMDIBuilderCreateComplexVariable","",""],[3,"LLVMDIBuilderCreateNameSpace","",""],[3,"LLVMDICompositeTypeSetTypeArray","",""],[3,"LLVMTypeToString","",""],[3,"LLVMValueToString","",""],[3,"LLVMIsAArgument","",""],[3,"LLVMIsAAllocaInst","",""],[3,"LLVMInitializeX86TargetInfo","",""],[3,"LLVMInitializeX86Target","",""],[3,"LLVMInitializeX86TargetMC","",""],[3,"LLVMInitializeX86AsmPrinter","",""],[3,"LLVMInitializeX86AsmParser","",""],[3,"LLVMInitializeARMTargetInfo","",""],[3,"LLVMInitializeARMTarget","",""],[3,"LLVMInitializeARMTargetMC","",""],[3,"LLVMInitializeARMAsmPrinter","",""],[3,"LLVMInitializeARMAsmParser","",""],[3,"LLVMInitializeMipsTargetInfo","",""],[3,"LLVMInitializeMipsTarget","",""],[3,"LLVMInitializeMipsTargetMC","",""],[3,"LLVMInitializeMipsAsmPrinter","",""],[3,"LLVMInitializeMipsAsmParser","",""],[3,"LLVMRustAddPass","",""],[3,"LLVMRustCreateTargetMachine","",""],[3,"LLVMRustDisposeTargetMachine","",""],[3,"LLVMRustAddAnalysisPasses","",""],[3,"LLVMRustAddBuilderLibraryInfo","",""],[3,"LLVMRustAddLibraryInfo","",""],[3,"LLVMRustRunFunctionPassManager","",""],[3,"LLVMRustWriteOutputFile","",""],[3,"LLVMRustPrintModule","",""],[3,"LLVMRustSetLLVMOptions","",""],[3,"LLVMRustPrintPasses","",""],[3,"LLVMRustSetNormalizedTarget","",""],[3,"LLVMRustAddAlwaysInlinePass","",""],[3,"LLVMRustLinkInExternalBitcode","",""],[3,"LLVMRustRunRestrictionPass","",""],[3,"LLVMRustMarkAllFunctionsNounwind","",""],[3,"LLVMRustOpenArchive","",""],[3,"LLVMRustArchiveReadSection","",""],[3,"LLVMRustDestroyArchive","",""],[3,"LLVMRustSetDLLExportStorageClass","",""],[3,"LLVMVersionMajor","",""],[3,"LLVMVersionMinor","",""],[3,"LLVMRustGetSectionName","",""],[3,"SetInstructionCallConv","",""],[3,"SetFunctionCallConv","",""],[3,"SetLinkage","",""],[3,"SetUnnamedAddr","",""],[3,"set_thread_local","",""],[3,"ConstICmp","",""],[3,"ConstFCmp","",""],[3,"SetFunctionAttribute","",""],[1,"TargetData","",""],[11,"lltd","","",591],[3,"mk_target_data","",""],[1,"ObjectFile","",""],[11,"llof","","",592],[1,"SectionIter","",""],[11,"llsi","","",593],[3,"mk_section_iter","",""],[3,"get_param","","Safe wrapper around `LLVMGetParam`, because segfaults are no fun."],[3,"static_link_hack_this_sucks","",""],[5,"DIAGNOSTICS","rustc",""],[15,"lint_initializer!","","Build a `Lint` initializer."],[15,"declare_lint!","","Declare a static item of type `&'static Lint`."],[15,"lint_array!","","Declare a static `LintArray` and return it as an expression."],[10,"tr","rustc::middle::def","",71],[10,"tr","rustc::middle::ty","",196],[10,"tr","","",230],[10,"tr","","",232],[10,"tr","","",234],[10,"tr","","",226],[10,"tr","rustc::middle::freevars","",79],[10,"tr","rustc::middle::typeck","",263],[10,"ty_str_ctxt","rustc::metadata::encoder","",339],[10,"is_reg_ty","rustc::middle::trans::type_","",172],[10,"fold_with","rustc::middle::typeck","",265],[10,"anon_regions","rustc::middle::typeck::infer","",285],[10,"combine_fields","rustc::middle::typeck::infer::lub","",300],[10,"bnd","","",300],[10,"with_bnd","","",300],[10,"ty_bot","","",300]],"paths":[[2,"OutputType"],[1,"Archive"],[1,"ArchiveBuilder"],[1,"FixedBuffer64"],[1,"Sha256"],[1,"Svh"],[2,"SawAbiComponent"],[2,"SawExprComponent"],[2,"SawStmtComponent"],[1,"Ident"],[1,"Name"],[1,"StrictVersionHashVisitor"],[1,"ArchiveConfig"],[1,"RPathConfig"],[1,"t"],[6,"tr"],[6,"tr_intern"],[6,"def_id_encoder_helpers"],[6,"def_id_decoder_helpers"],[6,"rbml_decoder_helper"],[6,"read_method_callee_helper"],[6,"vtable_decoder_helpers"],[6,"get_ty_str_ctxt"],[6,"rbml_writer_helpers"],[6,"write_tag_and_id"],[6,"doc_decoder_helpers"],[6,"rbml_decoder_decoder_helpers"],[1,"DefId"],[2,"Option"],[1,"Span"],[1,"Decoder"],[4,"Encoder"],[1,"Doc"],[1,"AnalysisData"],[1,"FnPartsWithCFG"],[2,"PartialTotal"],[2,"LoanPath"],[2,"LoanPathElem"],[2,"bckerr_code"],[2,"AliasableViolationKind"],[2,"MovedValueUseKind"],[1,"DataflowLabeller"],[2,"Variant"],[1,"MoveData"],[1,"FlowedMoveData"],[1,"MovePath"],[1,"Move"],[1,"Assignment"],[2,"MoveKind"],[1,"MovePathIndex"],[1,"MoveIndex"],[1,"MoveDataFlowOperator"],[1,"AssignDataFlowOperator"],[1,"LoanDataFlowOperator"],[1,"BorrowckCtxt"],[1,"Loan"],[1,"BckError"],[1,"CFG"],[1,"CFGNodeData"],[1,"CFGEdgeData"],[1,"LabelledCFG"],[1,"CheckCrateVisitor"],[1,"MatchCheckCtxt"],[1,"StaticInliner"],[2,"Constructor"],[2,"constness"],[2,"const_val"],[2,"EntryOrExit"],[6,"BitwiseOperator"],[6,"DataFlowOperator"],[1,"DataFlowContext"],[2,"Def"],[2,"MethodProvenance"],[2,"LoanCause"],[2,"ConsumeMode"],[2,"MoveReason"],[2,"MutateMode"],[6,"Delegate"],[1,"ExprUseVisitor"],[1,"freevar_entry"],[2,"CaptureMode"],[1,"Node"],[1,"Edge"],[1,"NodeIndex"],[1,"EdgeIndex"],[1,"Graph"],[1,"Context"],[1,"LanguageItems"],[2,"LangItem"],[1,"CopiedUpvar"],[1,"cmt_"],[2,"categorization"],[2,"PointerKind"],[2,"InteriorKind"],[2,"FieldName"],[2,"ElementKind"],[2,"MutabilityCategory"],[2,"deref_kind"],[2,"InteriorSafety"],[2,"AliasableReason"],[6,"ast_node"],[6,"Typer"],[1,"Expr"],[1,"Pat"],[1,"MemCategorizationContext"],[1,"Context"],[1,"RegionMaps"],[1,"Export2"],[1,"CrateMap"],[2,"LastPrivate"],[2,"PrivateDep"],[2,"ImportUse"],[2,"DefRegion"],[1,"Index"],[1,"Substs"],[2,"RegionSubsts"],[2,"ParamSpace"],[6,"HomogeneousTuple3"],[6,"Subst"],[1,"VecPerParamSpace"],[1,"MonoParamId"],[1,"MonoId"],[1,"Datum"],[1,"DatumBlock"],[1,"Rvalue"],[2,"Expr"],[2,"RvalueMode"],[6,"KindOps"],[1,"Lvalue"],[1,"MethodData"],[1,"Callee"],[2,"CalleeData"],[2,"CallArgs"],[2,"AutorefArg"],[2,"Dest"],[2,"cast_kind"],[1,"tydesc_info"],[1,"NodeInfo"],[1,"BuilderRef_res"],[1,"param_substs"],[1,"FunctionContext"],[1,"Block"],[1,"Result"],[2,"HandleItemsFlag"],[2,"ExprOrMethodCall"],[6,"SubstP"],[1,"Stats"],[1,"CrateContext"],[2,"named_ty"],[1,"Builder"],[1,"TransItemVisitor"],[2,"scalar_type"],[2,"IsUnboxedClosureFlag"],[1,"_InsnCtxt"],[1,"StatRecorder"],[1,"BindingInfo"],[2,"VecLenOpt"],[2,"opt_result"],[2,"TransBindingMode"],[2,"branch_kind"],[1,"EnvValue"],[1,"VecTypes"],[1,"ArgType"],[1,"FnType"],[2,"ArgKind"],[6,"TypeMethods"],[6,"ClassList"],[1,"Reflector"],[1,"CrateDebugContext"],[1,"Struct"],[2,"Repr"],[2,"PointerField"],[1,"Type"],[1,"TypeNames"],[1,"Value"],[1,"Use"],[1,"Users"],[1,"BasicBlock"],[6,"LlvmRepr"],[4,"ValueRef"],[2,"CleanupScopeKind"],[2,"EarlyExitLabel"],[2,"ScopeId"],[2,"Heap"],[6,"Cleanup"],[6,"CleanupMethods"],[6,"CleanupHelperMethods"],[1,"DropValue"],[1,"FreeValue"],[1,"LifetimeEnd"],[1,"field"],[1,"Method"],[1,"mt"],[1,"field_ty"],[1,"creader_cache_key"],[1,"ItemVariances"],[1,"AutoDerefRef"],[1,"TransmuteRestriction"],[1,"ctxt"],[1,"t_box_"],[1,"BareFnTy"],[1,"ClosureTy"],[1,"FnSig"],[1,"ParamTy"],[1,"UpvarId"],[1,"UpvarBorrow"],[1,"FreeRegion"],[1,"TyTrait"],[1,"TraitRef"],[1,"expected_found"],[1,"ParamBounds"],[1,"TyVid"],[1,"IntVid"],[1,"FloatVid"],[1,"RegionVid"],[1,"TypeParameterDef"],[1,"RegionParameterDef"],[1,"Generics"],[1,"ParameterEnvironment"],[1,"Polytype"],[1,"TraitDef"],[1,"ItemSubsts"],[1,"TypeContents"],[1,"VariantInfo"],[1,"UnboxedClosureUpvar"],[2,"MethodContainer"],[2,"TraitStore"],[2,"ast_ty_to_ty_cache_entry"],[2,"Variance"],[2,"AutoAdjustment"],[2,"AutoRef"],[2,"tbox_flag"],[2,"Region"],[2,"BorrowKind"],[2,"BoundRegion"],[2,"sty"],[2,"IntVarValue"],[2,"terr_vstore_kind"],[2,"type_err"],[2,"BuiltinBound"],[2,"InferTy"],[2,"InferRegion"],[2,"Representability"],[2,"ExprKind"],[2,"DtorKind"],[2,"ExplicitSelfCategory"],[6,"ExprTyProvider"],[1,"intern_key"],[1,"t"],[1,"BottomUpFolder"],[6,"TypeFoldable"],[6,"TypeFolder"],[1,"Rc"],[1,"Vec"],[1,"OwnedSlice"],[4,"BuiltinBounds"],[1,"RegionFolder"],[1,"param_index"],[1,"MethodParam"],[1,"MethodObject"],[1,"MethodCallee"],[1,"MethodCall"],[1,"TypeAndSubsts"],[2,"MethodOrigin"],[2,"ExprAdjustment"],[2,"vtable_origin"],[1,"FnStyleState"],[2,"LvaluePreference"],[2,"DerefArgs"],[1,"pat_ctxt"],[2,"PointerKind"],[1,"VtableContext"],[6,"ResolveIn"],[1,"Rcx"],[2,"CheckTraitsFlag"],[2,"AutoderefReceiverFlag"],[2,"StaticMethodsFlag"],[2,"RcvrMatchCondition"],[1,"FnCtxt"],[1,"ImpliedSingleRscope"],[6,"RegionScope"],[1,"ExplicitRscope"],[1,"BindingRscope"],[6,"AstConv"],[1,"Bounds"],[1,"InferCtxt"],[2,"TypeOrigin"],[2,"ValuePairs"],[2,"SubregionOrigin"],[2,"RegionVariableOrigin"],[2,"fixup_err"],[1,"CombineFields"],[6,"Combine"],[1,"Glb"],[2,"LatticeVarResult"],[6,"LatticeValue"],[6,"CombineFieldsLatticeMethods"],[6,"CombineFieldsLatticeMethods2"],[6,"LatticeDir"],[6,"TyLatticeDir"],[1,"Lub"],[1,"SameRegions"],[2,"Constraint"],[2,"UndoLogEntry"],[2,"CombineMapType"],[2,"RegionResolutionError"],[2,"VarValue"],[1,"TwoRegions"],[1,"RegionSnapshot"],[1,"RegionMark"],[1,"RegionVarBindings"],[1,"ResolveState"],[1,"Sub"],[1,"Node"],[2,"VarValue"],[6,"UnifyKey"],[6,"SimplyUnifiable"],[6,"InferCtxtMethodsForSimplyUnifiableTypes"],[1,"UnificationTable"],[2,"FloatTy"],[1,"Coerce"],[6,"ErrorReporting"],[6,"ErrorReportingHelpers"],[6,"Resolvable"],[6,"then"],[6,"ToUres"],[6,"CresCompare"],[1,"TypeTrace"],[4,"ures"],[4,"cres"],[6,"ToTy"],[1,"CrateCtxt"],[6,"Xform"],[1,"Features"],[1,"LinkMeta"],[2,"astencode_tag"],[1,"ctxt"],[2,"DefIdSource"],[1,"EncodeParams"],[1,"EncodeContext"],[2,"InlinedItemRef"],[1,"CrateDep"],[2,"DefLike"],[1,"PluginMetadataReader"],[1,"crate_metadata"],[1,"CrateSource"],[1,"CStore"],[2,"MetadataBlob"],[2,"LinkagePreference"],[2,"NativeLibaryKind"],[1,"StaticMethodInfo"],[2,"found_ast"],[1,"Context"],[1,"Library"],[1,"CratePaths"],[1,"ArchiveMetadata"],[1,"FileSearch"],[2,"FileMatch"],[2,"PpMode"],[1,"CrateAnalysis"],[1,"CrateTranslation"],[1,"OutputFilenames"],[2,"Input"],[1,"Session"],[1,"Config"],[1,"Options"],[1,"CodegenOptions"],[2,"OptLevel"],[2,"DebugInfoLevel"],[2,"EntryFnType"],[2,"CrateType"],[1,"Interner"],[1,"RcStr"],[1,"StrInterner"],[1,"SmallVector"],[1,"MoveItems"],[1,"Registry"],[1,"BasicMacroExpander"],[1,"BasicIdentMacroExpander"],[1,"MacExpr"],[1,"MacPat"],[1,"MacItem"],[1,"DummyResult"],[1,"BlockInfo"],[1,"ExtCtxt"],[1,"SyntaxEnv"],[1,"Duplicator"],[1,"Gc"],[2,"PtrTy"],[1,"Path"],[2,"Ty"],[1,"LifetimeBounds"],[1,"TraitDef"],[2,"StructType"],[1,"PatIdentFinder"],[1,"IdentRenamer"],[1,"PatIdentRenamer"],[1,"MacroExpander"],[1,"Marker"],[1,"MacroExterminator"],[2,"ArgumentType"],[2,"SyntaxContext_"],[2,"TokenTree"],[1,"Spanned"],[1,"Ty"],[1,"Block"],[1,"Arg"],[1,"Generics"],[1,"Arm"],[1,"Attribute_"],[1,"TtFrame"],[1,"TtReader"],[2,"LockstepIterSize"],[1,"MatcherPos"],[1,"ParserAnyMacro"],[1,"MacroRulesMacroExpander"],[1,"MacroRulesDefiner"],[1,"Lifetime"],[1,"Path"],[1,"PathSegment"],[2,"TyParamBound"],[1,"TyParam"],[1,"Crate"],[2,"MetaItem_"],[1,"FieldPat"],[2,"BindingMode"],[2,"Pat_"],[2,"Mutability"],[2,"ExprVstore"],[2,"BinOp"],[2,"UnOp"],[2,"Stmt_"],[2,"LocalSource"],[1,"Local"],[2,"Decl_"],[1,"Field"],[2,"BlockCheckMode"],[2,"UnsafeSource"],[2,"Expr_"],[2,"Matcher_"],[2,"Mac_"],[2,"StrStyle"],[2,"Lit_"],[1,"MutTy"],[1,"TypeField"],[1,"TypeMethod"],[2,"TraitMethod"],[2,"IntTy"],[2,"UintTy"],[2,"PrimTy"],[2,"Onceness"],[1,"ClosureTy"],[1,"BareFnTy"],[1,"UnboxedFnTy"],[2,"Ty_"],[2,"AsmDialect"],[1,"InlineAsm"],[1,"FnDecl"],[2,"FnStyle"],[2,"RetStyle"],[2,"ExplicitSelf_"],[1,"Method"],[2,"Method_"],[1,"Mod"],[1,"ForeignMod"],[1,"VariantArg"],[2,"VariantKind"],[1,"EnumDef"],[1,"Variant_"],[2,"PathListItem_"],[2,"ViewPath_"],[1,"ViewItem"],[2,"ViewItem_"],[2,"AttrStyle"],[1,"AttrId"],[1,"TraitRef"],[2,"Visibility"],[1,"StructField_"],[2,"StructFieldKind"],[1,"StructDef"],[1,"Item"],[2,"Item_"],[1,"ForeignItem"],[2,"ForeignItem_"],[2,"InlinedItem"],[2,"CommentStyle"],[1,"Comment"],[1,"Literal"],[1,"TokenAndSpan"],[1,"StringReader"],[2,"restriction"],[2,"PathParsingMode"],[1,"Parser"],[2,"BinOp"],[2,"Token"],[2,"Nonterminal"],[2,"Keyword"],[1,"InternedString"],[2,"ObsoleteSyntax"],[2,"Os"],[2,"Abi"],[2,"Architecture"],[2,"Code"],[1,"FnLikeNode"],[2,"PathElem"],[1,"LinkedPathNode"],[1,"Values"],[2,"Node"],[2,"MapEntry"],[1,"Map"],[1,"Ctx"],[1,"IdRange"],[1,"IdVisitor"],[1,"IdRangeComputingVisitor"],[1,"EachViewItemData"],[2,"InlineAttr"],[1,"Stability"],[2,"StabilityLevel"],[2,"ReprAttr"],[2,"IntType"],[1,"BytePos"],[1,"CharPos"],[2,"MacroFormat"],[1,"NameAndSpan"],[1,"ExpnInfo"],[1,"FileMap"],[1,"CodeMap"],[1,"CrateId"],[2,"RenderSpan"],[2,"ColorConfig"],[1,"SpanHandler"],[1,"Handler"],[2,"Level"],[1,"EmitterWriter"],[2,"Destination"],[2,"Breaks"],[1,"BreakToken"],[1,"BeginToken"],[2,"Token"],[1,"Printer"],[1,"NoAnn"],[1,"State"],[6,"Emitter"],[1,"Registry"],[1,"PluginMetadata"],[1,"Plugins"],[1,"Context"],[1,"Lint"],[2,"Level"],[2,"LintSource"],[1,"WhileTrue"],[1,"UnusedCasts"],[1,"TypeLimits"],[1,"CTypes"],[1,"HeapMemory"],[1,"RawPointerDeriving"],[1,"UnusedAttribute"],[1,"PathStatement"],[1,"UnusedResult"],[1,"NonCamelCaseTypes"],[1,"NonSnakeCaseFunctions"],[1,"NonUppercaseStatics"],[1,"NonUppercasePatternStatics"],[1,"UppercaseVariables"],[1,"UnnecessaryParens"],[1,"UnusedUnsafe"],[1,"UnsafeBlock"],[1,"UnusedMut"],[1,"UnnecessaryAllocation"],[1,"MissingDoc"],[1,"Stability"],[1,"HardwiredLints"],[6,"LintPass"],[1,"LintId"],[1,"Indenter"],[6,"Repr"],[6,"UserString"],[2,"Result"],[1,"Box"],[2,"Stmt"],[1,"FnvHasher"],[1,"FnvState"],[6,"Digest"],[1,"ArchiveRO"],[2,"CallConv"],[2,"Attribute"],[2,"OtherAttribute"],[2,"SpecialAttribute"],[1,"AttrBuilder"],[2,"TypeKind"],[2,"CodeGenOptLevel"],[1,"TargetData"],[1,"ObjectFile"],[1,"SectionIter"],[2,"Visibility"],[2,"Linkage"],[2,"AttributeSet"],[2,"IntPredicate"],[2,"RealPredicate"],[2,"AtomicBinOp"],[2,"AtomicOrdering"],[2,"FileType"],[2,"Metadata"],[2,"AsmDialect"],[2,"RelocMode"],[2,"CodeGenModel"],[2,"DIDescriptorFlags"]]};
searchIndex['rustc_back'] = {"items":[[0,"","rustc_back","Some stuff used by rustc that doesn't have many dependencies"],[0,"abi","",""],[5,"box_field_refcnt","rustc_back::abi",""],[5,"box_field_tydesc","",""],[5,"box_field_body","",""],[5,"tydesc_field_visit_glue","",""],[5,"fn_field_code","",""],[5,"fn_field_box","",""],[5,"trt_field_vtable","",""],[5,"trt_field_box","",""],[5,"vec_elt_fill","",""],[5,"vec_elt_alloc","",""],[5,"vec_elt_elems","",""],[5,"slice_elt_base","",""],[5,"slice_elt_len","",""],[0,"archive","rustc_back","A helper class for dealing with static archives"],[1,"ArchiveConfig","rustc_back::archive",""],[11,"handler","","",0],[11,"dst","","",0],[11,"lib_search_paths","","",0],[11,"os","","",0],[11,"maybe_ar_prog","","",0],[1,"Archive","",""],[1,"ArchiveBuilder","","Helper for adding many files to an archive with a single invocation of\n`ar`."],[5,"METADATA_FILENAME","",""],[10,"open","","Opens an existing static archive",1],[10,"remove_file","","Removes a file from this archive",1],[10,"files","","Lists all files in an archive",1],[10,"extend","","Creates an `ArchiveBuilder` for adding files to this archive.",1],[10,"create","","Create a new static archive, ready for adding files.",2],[10,"add_native_library","","Adds all of the contents of a native library to this archive. This will\nsearch in the relevant locations for a library named `name`.",2],[10,"add_rlib","","Adds all of the contents of the rlib at the specified path to this\narchive.",2],[10,"add_file","","Adds an arbitrary file to this archive",2],[10,"update_symbols","","Indicate that the next call to `build` should updates all symbols in\nthe archive (run 'ar s' over it).",2],[10,"build","","Combine the provided files, rlibs, and native libraries into a single\n`Archive`.",2],[0,"arm","rustc_back",""],[3,"get_target_strs","rustc_back::arm",""],[0,"fs","rustc_back",""],[3,"realpath","rustc_back::fs","Returns an absolute path in the filesystem that `path` points to. The\nreturned path does not contain any symlinks in its hierarchy."],[0,"mips","rustc_back",""],[3,"get_target_strs","rustc_back::mips",""],[0,"mipsel","rustc_back",""],[3,"get_target_strs","rustc_back::mipsel",""],[0,"rpath","rustc_back",""],[1,"RPathConfig","rustc_back::rpath",""],[11,"os","","",3],[11,"used_crates","","",3],[11,"out_filename","","",3],[11,"get_install_prefix_lib_path","","",3],[11,"realpath","","",3],[3,"get_rpath_flags","",""],[0,"sha2","rustc_back","This module implements only the Sha256 function since that is all that is needed for internal\nuse. This implementation is not intended for external use or for any use where security is\nimportant."],[1,"Sha256","rustc_back::sha2","The SHA-256 hash algorithm"],[6,"ToBits","",""],[9,"to_bits","","Convert the value in bytes to the number of bits, a tuple where the 1st item is the\nhigh-order value and the 2nd item is the low order value.",4],[6,"FixedBuffer","","A FixedBuffer, likes its name implies, is a fixed size buffer. When the buffer becomes full, it\nmust be processed. The input() method takes care of processing and then clearing the buffer\nautomatically. However, other methods do not and require the caller to process the buffer. Any\nmethod that modifies the buffer directory or provides the caller with bytes that can be modified\nresults in those bytes being marked as used by the buffer."],[9,"input","","Input a vector of bytes. If the buffer becomes full, process it with the provided\nfunction and then clear the buffer.",5],[9,"reset","","Reset the buffer.",5],[9,"zero_until","","Zero the buffer up until the specified index. The buffer position currently must not be\ngreater than that index.",5],[9,"next","","Get a slice of the buffer of the specified size. There must be at least that many bytes\nremaining in the buffer.",5],[9,"full_buffer","","Get the current buffer. The buffer must already be full. This clears the buffer as well.",5],[9,"position","","Get the current position of the buffer.",5],[9,"remaining","","Get the number of bytes remaining in the buffer until it is full.",5],[9,"size","","Get the size of the buffer",5],[6,"StandardPadding","","The StandardPadding trait adds a method useful for Sha256 to a FixedBuffer struct."],[9,"standard_padding","","Add padding to the buffer. The buffer must not be full when this method is called and is\nguaranteed to have exactly rem remaining bytes when it returns. If there are not at least\nrem bytes available, the buffer will be zero padded, processed, cleared, and then filled\nwith zeros again until only rem bytes are remaining.",6],[6,"Digest","","The Digest trait specifies an interface common to digest functions, such as SHA-1 and the SHA-2\nfamily of digest functions."],[9,"input","","Provide message data.",7],[9,"result","","Retrieve the digest result. This method may be called multiple times.",7],[9,"reset","","Reset the digest. This method must be called after result() and before supplying more\ndata.",7],[9,"output_bits","","Get the output size in bits.",7],[10,"input_str","","Convenience function that feeds a string into a digest.",7],[10,"result_bytes","","Convenience function that retrieves the result of a digest as a\nnewly allocated vec of bytes.",7],[10,"result_str","","Convenience function that retrieves the result of a digest as a\nString in hexadecimal format.",7],[10,"new","","Construct a new instance of a SHA-256 digest.",8],[10,"input","","",8],[10,"result","","",8],[10,"reset","","",8],[10,"output_bits","","",8],[0,"svh","rustc_back","Calculation and management of a Strict Version Hash for crates"],[1,"Svh","rustc_back::svh",""],[10,"eq","","",9],[10,"ne","","",9],[10,"clone","","",9],[10,"new","","",9],[10,"as_str","","",9],[10,"calculate","","",9],[10,"fmt","","",9],[0,"target_strs","rustc_back",""],[1,"t","rustc_back::target_strs",""],[11,"module_asm","","",10],[11,"data_layout","","",10],[11,"target_triple","","",10],[11,"cc_args","","",10],[0,"x86","rustc_back",""],[3,"get_target_strs","rustc_back::x86",""],[0,"x86_64","rustc_back",""],[3,"get_target_strs","rustc_back::x86_64",""]],"paths":[[1,"ArchiveConfig"],[1,"Archive"],[1,"ArchiveBuilder"],[1,"RPathConfig"],[6,"ToBits"],[6,"FixedBuffer"],[6,"StandardPadding"],[6,"Digest"],[1,"Sha256"],[1,"Svh"],[1,"t"]]};

searchIndex['rustc_llvm'] = {"items":[[0,"","rustc_llvm",""],[1,"AttrBuilder","",""],[1,"TargetData","",""],[11,"lltd","","",0],[1,"ObjectFile","",""],[11,"llof","","",1],[1,"SectionIter","",""],[11,"llsi","","",2],[2,"CallConv","",""],[12,"CCallConv","","",3],[12,"FastCallConv","","",3],[12,"ColdCallConv","","",3],[12,"X86StdcallCallConv","","",3],[12,"X86FastcallCallConv","","",3],[12,"X86_64_Win64","","",3],[2,"Visibility","",""],[12,"LLVMDefaultVisibility","","",4],[12,"HiddenVisibility","","",4],[12,"ProtectedVisibility","","",4],[2,"Linkage","",""],[12,"ExternalLinkage","","",5],[12,"AvailableExternallyLinkage","","",5],[12,"LinkOnceAnyLinkage","","",5],[12,"LinkOnceODRLinkage","","",5],[12,"WeakAnyLinkage","","",5],[12,"WeakODRLinkage","","",5],[12,"AppendingLinkage","","",5],[12,"InternalLinkage","","",5],[12,"PrivateLinkage","","",5],[12,"ExternalWeakLinkage","","",5],[12,"CommonLinkage","","",5],[2,"Attribute","",""],[12,"ZExtAttribute","","",6],[12,"SExtAttribute","","",6],[12,"NoReturnAttribute","","",6],[12,"InRegAttribute","","",6],[12,"StructRetAttribute","","",6],[12,"NoUnwindAttribute","","",6],[12,"NoAliasAttribute","","",6],[12,"ByValAttribute","","",6],[12,"NestAttribute","","",6],[12,"ReadNoneAttribute","","",6],[12,"ReadOnlyAttribute","","",6],[12,"NoInlineAttribute","","",6],[12,"AlwaysInlineAttribute","","",6],[12,"OptimizeForSizeAttribute","","",6],[12,"StackProtectAttribute","","",6],[12,"StackProtectReqAttribute","","",6],[12,"AlignmentAttribute","","",6],[12,"NoCaptureAttribute","","",6],[12,"NoRedZoneAttribute","","",6],[12,"NoImplicitFloatAttribute","","",6],[12,"NakedAttribute","","",6],[12,"InlineHintAttribute","","",6],[12,"StackAttribute","","",6],[12,"ReturnsTwiceAttribute","","",6],[12,"UWTableAttribute","","",6],[12,"NonLazyBindAttribute","","",6],[2,"OtherAttribute","",""],[12,"SanitizeAddressAttribute","","",7],[12,"MinSizeAttribute","","",7],[12,"NoDuplicateAttribute","","",7],[12,"StackProtectStrongAttribute","","",7],[12,"SanitizeThreadAttribute","","",7],[12,"SanitizeMemoryAttribute","","",7],[12,"NoBuiltinAttribute","","",7],[12,"ReturnedAttribute","","",7],[12,"ColdAttribute","","",7],[12,"BuiltinAttribute","","",7],[12,"OptimizeNoneAttribute","","",7],[12,"InAllocaAttribute","","",7],[12,"NonNullAttribute","","",7],[2,"SpecialAttribute","",""],[12,"DereferenceableAttribute","","",8],[2,"AttributeSet","",""],[12,"ReturnIndex","","",9],[12,"FunctionIndex","","",9],[2,"IntPredicate","",""],[12,"IntEQ","","",10],[12,"IntNE","","",10],[12,"IntUGT","","",10],[12,"IntUGE","","",10],[12,"IntULT","","",10],[12,"IntULE","","",10],[12,"IntSGT","","",10],[12,"IntSGE","","",10],[12,"IntSLT","","",10],[12,"IntSLE","","",10],[2,"RealPredicate","",""],[12,"RealPredicateFalse","","",11],[12,"RealOEQ","","",11],[12,"RealOGT","","",11],[12,"RealOGE","","",11],[12,"RealOLT","","",11],[12,"RealOLE","","",11],[12,"RealONE","","",11],[12,"RealORD","","",11],[12,"RealUNO","","",11],[12,"RealUEQ","","",11],[12,"RealUGT","","",11],[12,"RealUGE","","",11],[12,"RealULT","","",11],[12,"RealULE","","",11],[12,"RealUNE","","",11],[12,"RealPredicateTrue","","",11],[2,"TypeKind","",""],[12,"Void","","",12],[12,"Half","","",12],[12,"Float","","",12],[12,"Double","","",12],[12,"X86_FP80","","",12],[12,"FP128","","",12],[12,"PPC_FP128","","",12],[12,"Label","","",12],[12,"Integer","","",12],[12,"Function","","",12],[12,"Struct","","",12],[12,"Array","","",12],[12,"Pointer","","",12],[12,"Vector","","",12],[12,"Metadata","","",12],[12,"X86_MMX","","",12],[2,"AtomicBinOp","",""],[12,"Xchg","","",13],[12,"Add","","",13],[12,"Sub","","",13],[12,"And","","",13],[12,"Nand","","",13],[12,"Or","","",13],[12,"Xor","","",13],[12,"Max","","",13],[12,"Min","","",13],[12,"UMax","","",13],[12,"UMin","","",13],[2,"AtomicOrdering","",""],[12,"NotAtomic","","",14],[12,"Unordered","","",14],[12,"Monotonic","","",14],[12,"Acquire","","",14],[12,"Release","","",14],[12,"AcquireRelease","","",14],[12,"SequentiallyConsistent","","",14],[2,"FileType","",""],[12,"AssemblyFile","","",15],[12,"ObjectFile","","",15],[2,"Metadata","",""],[12,"MD_dbg","","",16],[12,"MD_tbaa","","",16],[12,"MD_prof","","",16],[12,"MD_fpmath","","",16],[12,"MD_range","","",16],[12,"MD_tbaa_struct","","",16],[2,"AsmDialect","",""],[12,"AD_ATT","","",17],[12,"AD_Intel","","",17],[2,"CodeGenOptLevel","",""],[12,"CodeGenLevelNone","","",18],[12,"CodeGenLevelLess","","",18],[12,"CodeGenLevelDefault","","",18],[12,"CodeGenLevelAggressive","","",18],[2,"RelocMode","",""],[12,"RelocDefault","","",19],[12,"RelocStatic","","",19],[12,"RelocPIC","","",19],[12,"RelocDynamicNoPic","","",19],[2,"CodeGenModel","",""],[12,"CodeModelDefault","","",20],[12,"CodeModelJITDefault","","",20],[12,"CodeModelSmall","","",20],[12,"CodeModelKernel","","",20],[12,"CodeModelMedium","","",20],[12,"CodeModelLarge","","",20],[2,"Module_opaque","",""],[2,"Context_opaque","",""],[2,"Type_opaque","",""],[2,"Value_opaque","",""],[2,"BasicBlock_opaque","",""],[2,"Builder_opaque","",""],[2,"ExecutionEngine_opaque","",""],[2,"MemoryBuffer_opaque","",""],[2,"PassManager_opaque","",""],[2,"PassManagerBuilder_opaque","",""],[2,"Use_opaque","",""],[2,"TargetData_opaque","",""],[2,"ObjectFile_opaque","",""],[2,"SectionIterator_opaque","",""],[2,"Pass_opaque","",""],[2,"TargetMachine_opaque","",""],[2,"Archive_opaque","",""],[3,"SetInstructionCallConv","",""],[3,"SetFunctionCallConv","",""],[3,"SetLinkage","",""],[3,"SetUnnamedAddr","",""],[3,"set_thread_local","",""],[3,"ConstICmp","",""],[3,"ConstFCmp","",""],[3,"SetFunctionAttribute","",""],[3,"mk_target_data","",""],[3,"mk_section_iter","",""],[3,"get_param","","Safe wrapper around `LLVMGetParam`, because segfaults are no fun."],[3,"static_link_hack_this_sucks","",""],[13,"LLVMContextCreate","",""],[13,"LLVMContextDispose","",""],[13,"LLVMGetMDKindIDInContext","",""],[13,"LLVMModuleCreateWithNameInContext","",""],[13,"LLVMGetModuleContext","",""],[13,"LLVMDisposeModule","",""],[13,"LLVMGetDataLayout","","Data layout. See Module::getDataLayout."],[13,"LLVMSetDataLayout","",""],[13,"LLVMGetTarget","","Target triple. See Module::getTargetTriple."],[13,"LLVMSetTarget","",""],[13,"LLVMDumpModule","","See Module::dump."],[13,"LLVMSetModuleInlineAsm","","See Module::setModuleInlineAsm."],[13,"LLVMGetTypeKind","","See llvm::LLVMTypeKind::getTypeID."],[13,"LLVMGetTypeContext","","See llvm::LLVMType::getContext."],[13,"LLVMInt1TypeInContext","",""],[13,"LLVMInt8TypeInContext","",""],[13,"LLVMInt16TypeInContext","",""],[13,"LLVMInt32TypeInContext","",""],[13,"LLVMInt64TypeInContext","",""],[13,"LLVMIntTypeInContext","",""],[13,"LLVMGetIntTypeWidth","",""],[13,"LLVMFloatTypeInContext","",""],[13,"LLVMDoubleTypeInContext","",""],[13,"LLVMX86FP80TypeInContext","",""],[13,"LLVMFP128TypeInContext","",""],[13,"LLVMPPCFP128TypeInContext","",""],[13,"LLVMFunctionType","",""],[13,"LLVMIsFunctionVarArg","",""],[13,"LLVMGetReturnType","",""],[13,"LLVMCountParamTypes","",""],[13,"LLVMGetParamTypes","",""],[13,"LLVMStructTypeInContext","",""],[13,"LLVMCountStructElementTypes","",""],[13,"LLVMGetStructElementTypes","",""],[13,"LLVMIsPackedStruct","",""],[13,"LLVMRustArrayType","",""],[13,"LLVMPointerType","",""],[13,"LLVMVectorType","",""],[13,"LLVMGetElementType","",""],[13,"LLVMGetArrayLength","",""],[13,"LLVMGetPointerAddressSpace","",""],[13,"LLVMGetPointerToGlobal","",""],[13,"LLVMGetVectorSize","",""],[13,"LLVMVoidTypeInContext","",""],[13,"LLVMLabelTypeInContext","",""],[13,"LLVMMetadataTypeInContext","",""],[13,"LLVMTypeOf","",""],[13,"LLVMGetValueName","",""],[13,"LLVMSetValueName","",""],[13,"LLVMDumpValue","",""],[13,"LLVMReplaceAllUsesWith","",""],[13,"LLVMHasMetadata","",""],[13,"LLVMGetMetadata","",""],[13,"LLVMSetMetadata","",""],[13,"LLVMGetFirstUse","",""],[13,"LLVMGetNextUse","",""],[13,"LLVMGetUser","",""],[13,"LLVMGetUsedValue","",""],[13,"LLVMGetNumOperands","",""],[13,"LLVMGetOperand","",""],[13,"LLVMSetOperand","",""],[13,"LLVMConstNull","",""],[13,"LLVMConstAllOnes","",""],[13,"LLVMConstICmp","",""],[13,"LLVMConstFCmp","",""],[13,"LLVMGetUndef","",""],[13,"LLVMIsConstant","",""],[13,"LLVMIsNull","",""],[13,"LLVMIsUndef","",""],[13,"LLVMConstPointerNull","",""],[13,"LLVMMDStringInContext","",""],[13,"LLVMMDNodeInContext","",""],[13,"LLVMAddNamedMetadataOperand","",""],[13,"LLVMConstInt","",""],[13,"LLVMConstIntOfString","",""],[13,"LLVMConstIntOfStringAndSize","",""],[13,"LLVMConstReal","",""],[13,"LLVMConstRealOfString","",""],[13,"LLVMConstRealOfStringAndSize","",""],[13,"LLVMConstIntGetZExtValue","",""],[13,"LLVMConstIntGetSExtValue","",""],[13,"LLVMConstStringInContext","",""],[13,"LLVMConstStructInContext","",""],[13,"LLVMConstArray","",""],[13,"LLVMConstVector","",""],[13,"LLVMAlignOf","",""],[13,"LLVMSizeOf","",""],[13,"LLVMConstNeg","",""],[13,"LLVMConstNSWNeg","",""],[13,"LLVMConstNUWNeg","",""],[13,"LLVMConstFNeg","",""],[13,"LLVMConstNot","",""],[13,"LLVMConstAdd","",""],[13,"LLVMConstNSWAdd","",""],[13,"LLVMConstNUWAdd","",""],[13,"LLVMConstFAdd","",""],[13,"LLVMConstSub","",""],[13,"LLVMConstNSWSub","",""],[13,"LLVMConstNUWSub","",""],[13,"LLVMConstFSub","",""],[13,"LLVMConstMul","",""],[13,"LLVMConstNSWMul","",""],[13,"LLVMConstNUWMul","",""],[13,"LLVMConstFMul","",""],[13,"LLVMConstUDiv","",""],[13,"LLVMConstSDiv","",""],[13,"LLVMConstExactSDiv","",""],[13,"LLVMConstFDiv","",""],[13,"LLVMConstURem","",""],[13,"LLVMConstSRem","",""],[13,"LLVMConstFRem","",""],[13,"LLVMConstAnd","",""],[13,"LLVMConstOr","",""],[13,"LLVMConstXor","",""],[13,"LLVMConstShl","",""],[13,"LLVMConstLShr","",""],[13,"LLVMConstAShr","",""],[13,"LLVMConstGEP","",""],[13,"LLVMConstInBoundsGEP","",""],[13,"LLVMConstTrunc","",""],[13,"LLVMConstSExt","",""],[13,"LLVMConstZExt","",""],[13,"LLVMConstFPTrunc","",""],[13,"LLVMConstFPExt","",""],[13,"LLVMConstUIToFP","",""],[13,"LLVMConstSIToFP","",""],[13,"LLVMConstFPToUI","",""],[13,"LLVMConstFPToSI","",""],[13,"LLVMConstPtrToInt","",""],[13,"LLVMConstIntToPtr","",""],[13,"LLVMConstBitCast","",""],[13,"LLVMConstZExtOrBitCast","",""],[13,"LLVMConstSExtOrBitCast","",""],[13,"LLVMConstTruncOrBitCast","",""],[13,"LLVMConstPointerCast","",""],[13,"LLVMConstIntCast","",""],[13,"LLVMConstFPCast","",""],[13,"LLVMConstSelect","",""],[13,"LLVMConstExtractElement","",""],[13,"LLVMConstInsertElement","",""],[13,"LLVMConstShuffleVector","",""],[13,"LLVMConstExtractValue","",""],[13,"LLVMConstInsertValue","",""],[13,"LLVMConstInlineAsm","",""],[13,"LLVMBlockAddress","",""],[13,"LLVMGetGlobalParent","",""],[13,"LLVMIsDeclaration","",""],[13,"LLVMGetLinkage","",""],[13,"LLVMSetLinkage","",""],[13,"LLVMGetSection","",""],[13,"LLVMSetSection","",""],[13,"LLVMGetVisibility","",""],[13,"LLVMSetVisibility","",""],[13,"LLVMGetAlignment","",""],[13,"LLVMSetAlignment","",""],[13,"LLVMAddGlobal","",""],[13,"LLVMAddGlobalInAddressSpace","",""],[13,"LLVMGetNamedGlobal","",""],[13,"LLVMGetFirstGlobal","",""],[13,"LLVMGetLastGlobal","",""],[13,"LLVMGetNextGlobal","",""],[13,"LLVMGetPreviousGlobal","",""],[13,"LLVMDeleteGlobal","",""],[13,"LLVMGetInitializer","",""],[13,"LLVMSetInitializer","",""],[13,"LLVMIsThreadLocal","",""],[13,"LLVMSetThreadLocal","",""],[13,"LLVMIsGlobalConstant","",""],[13,"LLVMSetGlobalConstant","",""],[13,"LLVMAddAlias","",""],[13,"LLVMAddFunction","",""],[13,"LLVMGetNamedFunction","",""],[13,"LLVMGetFirstFunction","",""],[13,"LLVMGetLastFunction","",""],[13,"LLVMGetNextFunction","",""],[13,"LLVMGetPreviousFunction","",""],[13,"LLVMDeleteFunction","",""],[13,"LLVMGetOrInsertFunction","",""],[13,"LLVMGetIntrinsicID","",""],[13,"LLVMGetFunctionCallConv","",""],[13,"LLVMSetFunctionCallConv","",""],[13,"LLVMGetGC","",""],[13,"LLVMSetGC","",""],[13,"LLVMAddDereferenceableAttr","",""],[13,"LLVMAddFunctionAttribute","",""],[13,"LLVMAddFunctionAttrString","",""],[13,"LLVMRemoveFunctionAttrString","",""],[13,"LLVMGetFunctionAttr","",""],[13,"LLVMCountParams","",""],[13,"LLVMGetParams","",""],[13,"LLVMGetParam","",""],[13,"LLVMGetParamParent","",""],[13,"LLVMGetFirstParam","",""],[13,"LLVMGetLastParam","",""],[13,"LLVMGetNextParam","",""],[13,"LLVMGetPreviousParam","",""],[13,"LLVMAddAttribute","",""],[13,"LLVMRemoveAttribute","",""],[13,"LLVMGetAttribute","",""],[13,"LLVMSetParamAlignment","",""],[13,"LLVMBasicBlockAsValue","",""],[13,"LLVMValueIsBasicBlock","",""],[13,"LLVMValueAsBasicBlock","",""],[13,"LLVMGetBasicBlockParent","",""],[13,"LLVMCountBasicBlocks","",""],[13,"LLVMGetBasicBlocks","",""],[13,"LLVMGetFirstBasicBlock","",""],[13,"LLVMGetLastBasicBlock","",""],[13,"LLVMGetNextBasicBlock","",""],[13,"LLVMGetPreviousBasicBlock","",""],[13,"LLVMGetEntryBasicBlock","",""],[13,"LLVMAppendBasicBlockInContext","",""],[13,"LLVMInsertBasicBlockInContext","",""],[13,"LLVMDeleteBasicBlock","",""],[13,"LLVMMoveBasicBlockAfter","",""],[13,"LLVMMoveBasicBlockBefore","",""],[13,"LLVMGetInstructionParent","",""],[13,"LLVMGetFirstInstruction","",""],[13,"LLVMGetLastInstruction","",""],[13,"LLVMGetNextInstruction","",""],[13,"LLVMGetPreviousInstruction","",""],[13,"LLVMInstructionEraseFromParent","",""],[13,"LLVMSetInstructionCallConv","",""],[13,"LLVMGetInstructionCallConv","",""],[13,"LLVMAddInstrAttribute","",""],[13,"LLVMRemoveInstrAttribute","",""],[13,"LLVMSetInstrParamAlignment","",""],[13,"LLVMAddCallSiteAttribute","",""],[13,"LLVMAddDereferenceableCallSiteAttr","",""],[13,"LLVMIsTailCall","",""],[13,"LLVMSetTailCall","",""],[13,"LLVMGetVolatile","",""],[13,"LLVMSetVolatile","",""],[13,"LLVMAddIncoming","",""],[13,"LLVMCountIncoming","",""],[13,"LLVMGetIncomingValue","",""],[13,"LLVMGetIncomingBlock","",""],[13,"LLVMCreateBuilderInContext","",""],[13,"LLVMPositionBuilder","",""],[13,"LLVMPositionBuilderBefore","",""],[13,"LLVMPositionBuilderAtEnd","",""],[13,"LLVMGetInsertBlock","",""],[13,"LLVMClearInsertionPosition","",""],[13,"LLVMInsertIntoBuilder","",""],[13,"LLVMInsertIntoBuilderWithName","",""],[13,"LLVMDisposeBuilder","",""],[13,"LLVMDisposeExecutionEngine","",""],[13,"LLVMSetCurrentDebugLocation","",""],[13,"LLVMGetCurrentDebugLocation","",""],[13,"LLVMSetInstDebugLocation","",""],[13,"LLVMBuildRetVoid","",""],[13,"LLVMBuildRet","",""],[13,"LLVMBuildAggregateRet","",""],[13,"LLVMBuildBr","",""],[13,"LLVMBuildCondBr","",""],[13,"LLVMBuildSwitch","",""],[13,"LLVMBuildIndirectBr","",""],[13,"LLVMBuildInvoke","",""],[13,"LLVMBuildLandingPad","",""],[13,"LLVMBuildResume","",""],[13,"LLVMBuildUnreachable","",""],[13,"LLVMAddCase","",""],[13,"LLVMAddDestination","",""],[13,"LLVMAddClause","",""],[13,"LLVMSetCleanup","",""],[13,"LLVMBuildAdd","",""],[13,"LLVMBuildNSWAdd","",""],[13,"LLVMBuildNUWAdd","",""],[13,"LLVMBuildFAdd","",""],[13,"LLVMBuildSub","",""],[13,"LLVMBuildNSWSub","",""],[13,"LLVMBuildNUWSub","",""],[13,"LLVMBuildFSub","",""],[13,"LLVMBuildMul","",""],[13,"LLVMBuildNSWMul","",""],[13,"LLVMBuildNUWMul","",""],[13,"LLVMBuildFMul","",""],[13,"LLVMBuildUDiv","",""],[13,"LLVMBuildSDiv","",""],[13,"LLVMBuildExactSDiv","",""],[13,"LLVMBuildFDiv","",""],[13,"LLVMBuildURem","",""],[13,"LLVMBuildSRem","",""],[13,"LLVMBuildFRem","",""],[13,"LLVMBuildShl","",""],[13,"LLVMBuildLShr","",""],[13,"LLVMBuildAShr","",""],[13,"LLVMBuildAnd","",""],[13,"LLVMBuildOr","",""],[13,"LLVMBuildXor","",""],[13,"LLVMBuildBinOp","",""],[13,"LLVMBuildNeg","",""],[13,"LLVMBuildNSWNeg","",""],[13,"LLVMBuildNUWNeg","",""],[13,"LLVMBuildFNeg","",""],[13,"LLVMBuildNot","",""],[13,"LLVMBuildMalloc","",""],[13,"LLVMBuildArrayMalloc","",""],[13,"LLVMBuildAlloca","",""],[13,"LLVMBuildArrayAlloca","",""],[13,"LLVMBuildFree","",""],[13,"LLVMBuildLoad","",""],[13,"LLVMBuildStore","",""],[13,"LLVMBuildGEP","",""],[13,"LLVMBuildInBoundsGEP","",""],[13,"LLVMBuildStructGEP","",""],[13,"LLVMBuildGlobalString","",""],[13,"LLVMBuildGlobalStringPtr","",""],[13,"LLVMBuildTrunc","",""],[13,"LLVMBuildZExt","",""],[13,"LLVMBuildSExt","",""],[13,"LLVMBuildFPToUI","",""],[13,"LLVMBuildFPToSI","",""],[13,"LLVMBuildUIToFP","",""],[13,"LLVMBuildSIToFP","",""],[13,"LLVMBuildFPTrunc","",""],[13,"LLVMBuildFPExt","",""],[13,"LLVMBuildPtrToInt","",""],[13,"LLVMBuildIntToPtr","",""],[13,"LLVMBuildBitCast","",""],[13,"LLVMBuildZExtOrBitCast","",""],[13,"LLVMBuildSExtOrBitCast","",""],[13,"LLVMBuildTruncOrBitCast","",""],[13,"LLVMBuildCast","",""],[13,"LLVMBuildPointerCast","",""],[13,"LLVMBuildIntCast","",""],[13,"LLVMBuildFPCast","",""],[13,"LLVMBuildICmp","",""],[13,"LLVMBuildFCmp","",""],[13,"LLVMBuildPhi","",""],[13,"LLVMBuildCall","",""],[13,"LLVMBuildSelect","",""],[13,"LLVMBuildVAArg","",""],[13,"LLVMBuildExtractElement","",""],[13,"LLVMBuildInsertElement","",""],[13,"LLVMBuildShuffleVector","",""],[13,"LLVMBuildExtractValue","",""],[13,"LLVMBuildInsertValue","",""],[13,"LLVMBuildIsNull","",""],[13,"LLVMBuildIsNotNull","",""],[13,"LLVMBuildPtrDiff","",""],[13,"LLVMBuildAtomicLoad","",""],[13,"LLVMBuildAtomicStore","",""],[13,"LLVMBuildAtomicCmpXchg","",""],[13,"LLVMBuildAtomicRMW","",""],[13,"LLVMBuildAtomicFence","",""],[13,"LLVMIsATerminatorInst","",""],[13,"LLVMIsAStoreInst","",""],[13,"LLVMWriteBitcodeToFile","","Writes a module to the specified path. Returns 0 on success."],[13,"LLVMCreateTargetData","","Creates target data from a target layout string."],[13,"LLVMAddTargetData","","Adds the target data to the given pass manager. The pass manager\nreferences the target data only weakly."],[13,"LLVMStoreSizeOfType","","Number of bytes clobbered when doing a Store to *T."],[13,"LLVMSizeOfTypeInBits","","Number of bytes clobbered when doing a Store to *T."],[13,"LLVMABISizeOfType","","Distance between successive elements in an array of T.\nIncludes ABI padding. "],[13,"LLVMPreferredAlignmentOfType","","Returns the preferred alignment of a type."],[13,"LLVMABIAlignmentOfType","","Returns the minimum alignment of a type."],[13,"LLVMOffsetOfElement","","Computes the byte offset of the indexed struct element for a\ntarget."],[13,"LLVMCallFrameAlignmentOfType","","Returns the minimum alignment of a type when part of a call frame."],[13,"LLVMDisposeTargetData","","Disposes target data."],[13,"LLVMCreatePassManager","","Creates a pass manager."],[13,"LLVMCreateFunctionPassManagerForModule","","Creates a function-by-function pass manager"],[13,"LLVMDisposePassManager","","Disposes a pass manager."],[13,"LLVMRunPassManager","","Runs a pass manager on a module."],[13,"LLVMRunFunctionPassManager","","Runs the function passes on the provided function."],[13,"LLVMInitializeFunctionPassManager","","Initializes all the function passes scheduled in the manager"],[13,"LLVMFinalizeFunctionPassManager","","Finalizes all the function passes scheduled in the manager"],[13,"LLVMInitializePasses","",""],[13,"LLVMAddVerifierPass","","Adds a verification pass."],[13,"LLVMAddGlobalOptimizerPass","",""],[13,"LLVMAddIPSCCPPass","",""],[13,"LLVMAddDeadArgEliminationPass","",""],[13,"LLVMAddInstructionCombiningPass","",""],[13,"LLVMAddCFGSimplificationPass","",""],[13,"LLVMAddFunctionInliningPass","",""],[13,"LLVMAddFunctionAttrsPass","",""],[13,"LLVMAddScalarReplAggregatesPass","",""],[13,"LLVMAddScalarReplAggregatesPassSSA","",""],[13,"LLVMAddJumpThreadingPass","",""],[13,"LLVMAddConstantPropagationPass","",""],[13,"LLVMAddReassociatePass","",""],[13,"LLVMAddLoopRotatePass","",""],[13,"LLVMAddLICMPass","",""],[13,"LLVMAddLoopUnswitchPass","",""],[13,"LLVMAddLoopDeletionPass","",""],[13,"LLVMAddLoopUnrollPass","",""],[13,"LLVMAddGVNPass","",""],[13,"LLVMAddMemCpyOptPass","",""],[13,"LLVMAddSCCPPass","",""],[13,"LLVMAddDeadStoreEliminationPass","",""],[13,"LLVMAddStripDeadPrototypesPass","",""],[13,"LLVMAddConstantMergePass","",""],[13,"LLVMAddArgumentPromotionPass","",""],[13,"LLVMAddTailCallEliminationPass","",""],[13,"LLVMAddIndVarSimplifyPass","",""],[13,"LLVMAddAggressiveDCEPass","",""],[13,"LLVMAddGlobalDCEPass","",""],[13,"LLVMAddCorrelatedValuePropagationPass","",""],[13,"LLVMAddPruneEHPass","",""],[13,"LLVMAddSimplifyLibCallsPass","",""],[13,"LLVMAddLoopIdiomPass","",""],[13,"LLVMAddEarlyCSEPass","",""],[13,"LLVMAddTypeBasedAliasAnalysisPass","",""],[13,"LLVMAddBasicAliasAnalysisPass","",""],[13,"LLVMPassManagerBuilderCreate","",""],[13,"LLVMPassManagerBuilderDispose","",""],[13,"LLVMPassManagerBuilderSetOptLevel","",""],[13,"LLVMPassManagerBuilderSetSizeLevel","",""],[13,"LLVMPassManagerBuilderSetDisableUnitAtATime","",""],[13,"LLVMPassManagerBuilderSetDisableUnrollLoops","",""],[13,"LLVMPassManagerBuilderSetDisableSimplifyLibCalls","",""],[13,"LLVMPassManagerBuilderUseInlinerWithThreshold","",""],[13,"LLVMPassManagerBuilderPopulateModulePassManager","",""],[13,"LLVMPassManagerBuilderPopulateFunctionPassManager","",""],[13,"LLVMPassManagerBuilderPopulateLTOPassManager","",""],[13,"LLVMDisposeMemoryBuffer","","Destroys a memory buffer."],[13,"LLVMCreateObjectFile","","Opens an object file."],[13,"LLVMDisposeObjectFile","","Closes an object file."],[13,"LLVMGetSections","","Enumerates the sections in an object file."],[13,"LLVMDisposeSectionIterator","","Destroys a section iterator."],[13,"LLVMIsSectionIteratorAtEnd","","Returns true if the section iterator is at the end of the section\nlist: "],[13,"LLVMMoveToNextSection","","Moves the section iterator to point to the next section."],[13,"LLVMGetSectionSize","","Returns the current section size."],[13,"LLVMGetSectionContents","","Returns the current section contents as a string buffer."],[13,"LLVMRustCreateMemoryBufferWithContentsOfFile","","Reads the given file and returns it as a memory buffer. Use\nLLVMDisposeMemoryBuffer() to get rid of it. "],[13,"LLVMCreateMemoryBufferWithMemoryRange","","Borrows the contents of the memory buffer (doesn't copy it)"],[13,"LLVMCreateMemoryBufferWithMemoryRangeCopy","",""],[13,"LLVMIsMultithreaded","",""],[13,"LLVMStartMultithreaded","",""],[13,"LLVMRustGetLastError","","Returns a string describing the last error caused by an LLVMRust*\ncall. "],[13,"LLVMRustPrintPassTimings","","Print the pass timings since static dtors aren't picking them up."],[13,"LLVMStructCreateNamed","",""],[13,"LLVMStructSetBody","",""],[13,"LLVMConstNamedStruct","",""],[13,"LLVMSetDebug","","Enables LLVM debug output."],[13,"LLVMInlineAsm","","Prepares inline assembly."],[14,"LLVMRustDebugMetadataVersion","",""],[13,"LLVMRustAddModuleFlag","",""],[13,"LLVMDIBuilderCreate","",""],[13,"LLVMDIBuilderDispose","",""],[13,"LLVMDIBuilderFinalize","",""],[13,"LLVMDIBuilderCreateCompileUnit","",""],[13,"LLVMDIBuilderCreateFile","",""],[13,"LLVMDIBuilderCreateSubroutineType","",""],[13,"LLVMDIBuilderCreateFunction","",""],[13,"LLVMDIBuilderCreateBasicType","",""],[13,"LLVMDIBuilderCreatePointerType","",""],[13,"LLVMDIBuilderCreateStructType","",""],[13,"LLVMDIBuilderCreateMemberType","",""],[13,"LLVMDIBuilderCreateLexicalBlock","",""],[13,"LLVMDIBuilderCreateStaticVariable","",""],[13,"LLVMDIBuilderCreateLocalVariable","",""],[13,"LLVMDIBuilderCreateArrayType","",""],[13,"LLVMDIBuilderCreateVectorType","",""],[13,"LLVMDIBuilderGetOrCreateSubrange","",""],[13,"LLVMDIBuilderGetOrCreateArray","",""],[13,"LLVMDIBuilderInsertDeclareAtEnd","",""],[13,"LLVMDIBuilderInsertDeclareBefore","",""],[13,"LLVMDIBuilderCreateEnumerator","",""],[13,"LLVMDIBuilderCreateEnumerationType","",""],[13,"LLVMDIBuilderCreateUnionType","",""],[13,"LLVMSetUnnamedAddr","",""],[13,"LLVMDIBuilderCreateTemplateTypeParameter","",""],[13,"LLVMDIBuilderCreateOpDeref","",""],[13,"LLVMDIBuilderCreateOpPlus","",""],[13,"LLVMDIBuilderCreateComplexVariable","",""],[13,"LLVMDIBuilderCreateNameSpace","",""],[13,"LLVMDICompositeTypeSetTypeArray","",""],[13,"LLVMTypeToString","",""],[13,"LLVMValueToString","",""],[13,"LLVMIsAArgument","",""],[13,"LLVMIsAAllocaInst","",""],[13,"LLVMInitializeX86TargetInfo","",""],[13,"LLVMInitializeX86Target","",""],[13,"LLVMInitializeX86TargetMC","",""],[13,"LLVMInitializeX86AsmPrinter","",""],[13,"LLVMInitializeX86AsmParser","",""],[13,"LLVMInitializeARMTargetInfo","",""],[13,"LLVMInitializeARMTarget","",""],[13,"LLVMInitializeARMTargetMC","",""],[13,"LLVMInitializeARMAsmPrinter","",""],[13,"LLVMInitializeARMAsmParser","",""],[13,"LLVMInitializeMipsTargetInfo","",""],[13,"LLVMInitializeMipsTarget","",""],[13,"LLVMInitializeMipsTargetMC","",""],[13,"LLVMInitializeMipsAsmPrinter","",""],[13,"LLVMInitializeMipsAsmParser","",""],[13,"LLVMRustAddPass","",""],[13,"LLVMRustCreateTargetMachine","",""],[13,"LLVMRustDisposeTargetMachine","",""],[13,"LLVMRustAddAnalysisPasses","",""],[13,"LLVMRustAddBuilderLibraryInfo","",""],[13,"LLVMRustAddLibraryInfo","",""],[13,"LLVMRustRunFunctionPassManager","",""],[13,"LLVMRustWriteOutputFile","",""],[13,"LLVMRustPrintModule","",""],[13,"LLVMRustSetLLVMOptions","",""],[13,"LLVMRustPrintPasses","",""],[13,"LLVMRustSetNormalizedTarget","",""],[13,"LLVMRustAddAlwaysInlinePass","",""],[13,"LLVMRustLinkInExternalBitcode","",""],[13,"LLVMRustRunRestrictionPass","",""],[13,"LLVMRustMarkAllFunctionsNounwind","",""],[13,"LLVMRustOpenArchive","",""],[13,"LLVMRustArchiveReadSection","",""],[13,"LLVMRustDestroyArchive","",""],[13,"LLVMRustSetDLLExportStorageClass","",""],[13,"LLVMVersionMajor","",""],[13,"LLVMVersionMinor","",""],[13,"LLVMRustGetSectionName","",""],[0,"archive_ro","","A wrapper around LLVM's archive (.a) code"],[1,"ArchiveRO","rustc_llvm::archive_ro",""],[10,"open","","Opens a static archive for read-only purposes. This is more optimized\nthan the `open` method because it uses LLVM's internal `Archive` class\nrather than shelling out to `ar` for everything.",21],[10,"read","","Reads a file in the archive",21],[10,"drop","","",21],[0,"debuginfo","rustc_llvm",""],[2,"DIBuilder_opaque","rustc_llvm::debuginfo",""],[2,"DIDescriptorFlags","",""],[12,"FlagPrivate","","",22],[12,"FlagProtected","","",22],[12,"FlagFwdDecl","","",22],[12,"FlagAppleBlock","","",22],[12,"FlagBlockByrefStruct","","",22],[12,"FlagVirtual","","",22],[12,"FlagArtificial","","",22],[12,"FlagExplicit","","",22],[12,"FlagPrototyped","","",22],[12,"FlagObjcClassComplete","","",22],[12,"FlagObjectPointer","","",22],[12,"FlagVector","","",22],[12,"FlagStaticMember","","",22],[4,"DIBuilderRef","",""],[4,"DIDescriptor","",""],[4,"DIScope","",""],[4,"DILocation","",""],[4,"DIFile","",""],[4,"DILexicalBlock","",""],[4,"DISubprogram","",""],[4,"DIType","",""],[4,"DIBasicType","",""],[4,"DIDerivedType","",""],[4,"DICompositeType","",""],[4,"DIVariable","",""],[4,"DIGlobalVariable","",""],[4,"DIArray","",""],[4,"DISubrange","",""],[4,"Opcode","rustc_llvm",""],[4,"Bool","",""],[4,"ModuleRef","",""],[4,"ContextRef","",""],[4,"TypeRef","",""],[4,"ValueRef","",""],[4,"BasicBlockRef","",""],[4,"BuilderRef","",""],[4,"ExecutionEngineRef","",""],[4,"MemoryBufferRef","",""],[4,"PassManagerRef","",""],[4,"PassManagerBuilderRef","",""],[4,"UseRef","",""],[4,"TargetDataRef","",""],[4,"ObjectFileRef","",""],[4,"SectionIteratorRef","",""],[4,"PassRef","",""],[4,"TargetMachineRef","",""],[4,"ArchiveRef","",""],[5,"True","",""],[5,"False","",""],[6,"AttrHelper","",""],[9,"apply_llfn","","",23],[9,"apply_callsite","","",23],[10,"eq","","",3],[10,"ne","","",3],[10,"clone","","",6],[10,"apply_llfn","","",6],[10,"apply_callsite","","",6],[10,"apply_llfn","","",7],[10,"apply_callsite","","",7],[10,"apply_llfn","","",8],[10,"apply_callsite","","",8],[10,"new","","",24],[10,"arg","","",24],[10,"ret","","",24],[10,"apply_llfn","","",24],[10,"apply_callsite","","",24],[10,"eq","","",12],[10,"ne","","",12],[10,"eq","","",18],[10,"ne","","",18],[10,"drop","","",0],[10,"new","","",1],[10,"drop","","",1],[10,"drop","","",2]],"paths":[[1,"TargetData"],[1,"ObjectFile"],[1,"SectionIter"],[2,"CallConv"],[2,"Visibility"],[2,"Linkage"],[2,"Attribute"],[2,"OtherAttribute"],[2,"SpecialAttribute"],[2,"AttributeSet"],[2,"IntPredicate"],[2,"RealPredicate"],[2,"TypeKind"],[2,"AtomicBinOp"],[2,"AtomicOrdering"],[2,"FileType"],[2,"Metadata"],[2,"AsmDialect"],[2,"CodeGenOptLevel"],[2,"RelocMode"],[2,"CodeGenModel"],[1,"ArchiveRO"],[2,"DIDescriptorFlags"],[6,"AttrHelper"],[1,"AttrBuilder"]]};

searchIndex['fmt_macros'] = {"items":[[0,"","fmt_macros","Macro support for format strings"],[1,"Argument","","Representation of an argument specification."],[11,"position","","Where to find this argument",0],[11,"format","","How to format the argument",0],[1,"FormatSpec","","Specification for the formatting of an argument in the format string."],[11,"fill","","Optionally specified character to fill alignment with",1],[11,"align","","Optionally specified alignment",1],[11,"flags","","Packed version of various flags provided",1],[11,"precision","","The integer precision to use",1],[11,"width","","The string width requested for the resulting format",1],[11,"ty","","The descriptor string representing the name of the format desired for\nthis argument, this can be empty or any number of characters, although\nit is required to be one word.",1],[1,"Parser","","The parser structure for interpreting the input format string. This is\nmodelled as an iterator over `Piece` structures to form a stream of tokens\nbeing output."],[11,"errors","","Error messages accumulated during parsing",2],[2,"Piece","","A piece is a portion of the format string which represents the next part\nto emit. These are emitted as a stream by the `Parser` class."],[12,"String","","A literal string which should directly be emitted",3],[12,"Argument","","This describes that formatting should process the next argument (as\nspecified inside) for emission.",3],[2,"Position","","Enum describing where an argument for a format can be located."],[12,"ArgumentNext","","The argument will be in the next position. This is the default.",4],[12,"ArgumentIs","","The argument is located at a specific index.",4],[12,"ArgumentNamed","","The argument has a name.",4],[2,"Alignment","","Enum of alignments which are supported."],[12,"AlignLeft","","The value will be aligned to the left.",5],[12,"AlignRight","","The value will be aligned to the right.",5],[12,"AlignUnknown","","The value will take on a default alignment.",5],[2,"Flag","","Various flags which can be applied to format strings. The meaning of these\nflags is defined by the formatters themselves."],[12,"FlagSignPlus","","A `+` will be used to denote positive numbers.",6],[12,"FlagSignMinus","","A `-` will be used to denote negative numbers. This is the default.",6],[12,"FlagAlternate","","An alternate form will be used for the value. In the case of numbers,\nthis means that the number will be prefixed with the supplied string.",6],[12,"FlagSignAwareZeroPad","","For numbers, this means that the number will be padded with zeroes,\nand the sign (`+` or `-`) will precede them.",6],[2,"Count","","A count is used for the precision and width parameters of an integer, and\ncan reference either an argument or a literal integer."],[12,"CountIs","","The count is specified explicitly.",7],[12,"CountIsName","","The count is specified by the argument with the given name.",7],[12,"CountIsParam","","The count is specified by the argument at the given index.",7],[12,"CountIsNextParam","","The count is specified by the next parameter.",7],[12,"CountImplied","","The count is implied and cannot be explicitly specified.",7],[10,"eq","","",3],[10,"ne","","",3],[10,"eq","","",0],[10,"ne","","",0],[10,"eq","","",1],[10,"ne","","",1],[10,"eq","","",4],[10,"ne","","",4],[10,"eq","","",5],[10,"ne","","",5],[10,"eq","","",6],[10,"ne","","",6],[10,"eq","","",7],[10,"ne","","",7],[10,"next","","",2],[10,"new","","Creates a new parser for the given format string",2]],"paths":[[1,"Argument"],[1,"FormatSpec"],[1,"Parser"],[2,"Piece"],[2,"Position"],[2,"Alignment"],[2,"Flag"],[2,"Count"]]};

searchIndex['regex_macros'] = {"items":[[0,"","regex_macros","This crate provides the `regex!` macro. Its use is documented in the\n`regex` crate."]],"paths":[]};

searchIndex['hexfloat'] = {"items":[[0,"","hexfloat","Syntax extension to create floating point literals from hexadecimal strings"],[3,"plugin_registrar","",""],[3,"expand_syntax_ext","",""]],"paths":[]};

searchIndex['fourcc'] = {"items":[[0,"","fourcc","Syntax extension to generate FourCCs."],[3,"plugin_registrar","",""],[3,"expand_syntax_ext","",""]],"paths":[]};

searchIndex['rustdoc'] = {"items":[[0,"","rustdoc",""],[3,"main","",""],[3,"opts","",""],[3,"usage","",""],[3,"main_args","",""],[0,"clean","","This module contains the \"cleaned\" pieces of the AST, and the functions\nthat clean them."],[1,"Crate","rustdoc::clean",""],[11,"name","","",0],[11,"module","","",0],[11,"externs","","",0],[11,"primitives","","",0],[1,"ExternalCrate","",""],[11,"name","","",1],[11,"attrs","","",1],[11,"primitives","","",1],[1,"Item","","Anything with a source location and set of attributes and, optionally, a\nname. That is, anything that can be documented. This doesn't correspond\ndirectly to the AST's concept of an item; it's a strict superset."],[11,"source","","Stringified span",2],[11,"name","","Not everything has a name. E.g., impls",2],[11,"attrs","","",2],[11,"inner","","",2],[11,"visibility","","",2],[11,"def_id","","",2],[11,"stability","","",2],[1,"Module","",""],[11,"items","","",3],[11,"is_crate","","",3],[1,"TyParam","",""],[11,"name","","",4],[11,"did","","",4],[11,"bounds","","",4],[11,"default","","",4],[1,"Lifetime","",""],[1,"Generics","",""],[11,"lifetimes","","",5],[11,"type_params","","",5],[1,"Method","",""],[11,"generics","","",6],[11,"self_","","",6],[11,"fn_style","","",6],[11,"decl","","",6],[1,"TyMethod","",""],[11,"fn_style","","",7],[11,"decl","","",7],[11,"generics","","",7],[11,"self_","","",7],[1,"Function","",""],[11,"decl","","",8],[11,"generics","","",8],[11,"fn_style","","",8],[1,"ClosureDecl","",""],[11,"lifetimes","","",9],[11,"decl","","",9],[11,"onceness","","",9],[11,"fn_style","","",9],[11,"bounds","","",9],[1,"FnDecl","",""],[11,"inputs","","",10],[11,"output","","",10],[11,"cf","","",10],[11,"attrs","","",10],[1,"Arguments","",""],[11,"values","","",11],[1,"Argument","",""],[11,"type_","","",12],[11,"name","","",12],[11,"id","","",12],[1,"Trait","",""],[11,"methods","","",13],[11,"generics","","",13],[11,"parents","","",13],[1,"Struct","",""],[11,"struct_type","","",14],[11,"generics","","",14],[11,"fields","","",14],[11,"fields_stripped","","",14],[1,"VariantStruct","","This is a more limited form of the standard Struct, different in that\nit lacks the things most items have (name, id, parameterization). Found\nonly as a variant in an enum."],[11,"struct_type","","",15],[11,"fields","","",15],[11,"fields_stripped","","",15],[1,"Enum","",""],[11,"variants","","",16],[11,"generics","","",16],[11,"variants_stripped","","",16],[1,"Variant","",""],[11,"kind","","",17],[1,"Span","",""],[11,"filename","","",18],[11,"loline","","",18],[11,"locol","","",18],[11,"hiline","","",18],[11,"hicol","","",18],[1,"Path","",""],[11,"global","","",19],[11,"segments","","",19],[1,"PathSegment","",""],[11,"name","","",20],[11,"lifetimes","","",20],[11,"types","","",20],[1,"Typedef","",""],[11,"type_","","",21],[11,"generics","","",21],[1,"BareFunctionDecl","",""],[11,"fn_style","","",22],[11,"generics","","",22],[11,"decl","","",22],[11,"abi","","",22],[1,"Static","",""],[11,"type_","","",23],[11,"mutability","","",23],[11,"expr","","It's useful to have the value of a static documented, but I have no\ndesire to represent expressions (that'd basically be all of the AST,\nwhich is huge!). So, have a string.",23],[1,"Impl","",""],[11,"generics","","",24],[11,"trait_","","",24],[11,"for_","","",24],[11,"methods","","",24],[11,"derived","","",24],[1,"ViewItem","",""],[11,"inner","","",25],[1,"ImportSource","",""],[11,"path","","",26],[11,"did","","",26],[1,"ViewListIdent","",""],[11,"name","","",27],[11,"source","","",27],[1,"Macro","",""],[11,"source","","",28],[1,"Stability","",""],[11,"level","","",29],[11,"text","","",29],[2,"ItemEnum","",""],[12,"StructItem","","",30],[12,"EnumItem","","",30],[12,"FunctionItem","","",30],[12,"ModuleItem","","",30],[12,"TypedefItem","","",30],[12,"StaticItem","","",30],[12,"TraitItem","","",30],[12,"ImplItem","","",30],[12,"ViewItemItem","","`use` and `extern crate`",30],[12,"TyMethodItem","","A method signature only. Used for required methods in traits (ie,\nnon-default-methods).",30],[12,"MethodItem","","A method with a body.",30],[12,"StructFieldItem","","",30],[12,"VariantItem","","",30],[12,"ForeignFunctionItem","","`fn`s from an extern block",30],[12,"ForeignStaticItem","","`static`s from an extern block",30],[12,"MacroItem","","",30],[12,"PrimitiveItem","","",30],[2,"Attribute","",""],[12,"Word","","",31],[12,"List","","",31],[12,"NameValue","","",31],[2,"TyParamBound","",""],[12,"RegionBound","","",32],[12,"TraitBound","","",32],[2,"SelfTy","",""],[12,"SelfStatic","","",33],[12,"SelfValue","","",33],[12,"SelfBorrowed","","",33],[12,"SelfExplicit","","",33],[2,"RetStyle","",""],[12,"NoReturn","","",34],[12,"Return","","",34],[2,"TraitMethod","",""],[12,"Required","","",35],[12,"Provided","","",35],[2,"Type","","A representation of a Type suitable for hyperlinking purposes. Ideally one can get the original\ntype out of the AST/ty::ctxt given one of these, if more information is needed. Most importantly\nit does not preserve mutability or boxes."],[12,"ResolvedPath","","structs/enums/traits (anything that'd be an ast::TyPath)",36],[11,"path","rustdoc::clean::Type","",36],[11,"typarams","","",36],[11,"did","","",36],[12,"TyParamBinder","rustdoc::clean","",36],[12,"Generic","","For parameterized types, so the consumer of the JSON don't go looking\nfor types which don't exist anywhere.",36],[12,"Self","","For references to self",36],[12,"Primitive","","Primitives are just the fixed-size numeric types (plus int/uint/float), and char.",36],[12,"Closure","","",36],[12,"Proc","","",36],[12,"BareFunction","","extern \"ABI\" fn",36],[12,"Tuple","","",36],[12,"Vector","","",36],[12,"FixedVector","","",36],[12,"Bottom","","aka TyBot",36],[12,"Unique","","",36],[12,"Managed","","",36],[12,"RawPointer","","",36],[12,"BorrowedRef","","",36],[11,"lifetime","rustdoc::clean::Type","",36],[11,"mutability","","",36],[11,"type_","","",36],[2,"Primitive","rustdoc::clean",""],[12,"Int","","",37],[12,"I8","","",37],[12,"I16","","",37],[12,"I32","","",37],[12,"I64","","",37],[12,"Uint","","",37],[12,"U8","","",37],[12,"U16","","",37],[12,"U32","","",37],[12,"U64","","",37],[12,"F32","","",37],[12,"F64","","",37],[12,"Char","","",37],[12,"Bool","","",37],[12,"Unit","","",37],[12,"Str","","",37],[12,"Slice","","",37],[12,"PrimitiveTuple","","",37],[2,"TypeKind","",""],[12,"TypeEnum","","",38],[12,"TypeFunction","","",38],[12,"TypeModule","","",38],[12,"TypeStatic","","",38],[12,"TypeStruct","","",38],[12,"TypeTrait","","",38],[12,"TypeVariant","","",38],[2,"StructField","",""],[12,"HiddenStructField","","",39],[12,"TypedStructField","","",39],[2,"VariantKind","",""],[12,"CLikeVariant","","",40],[12,"TupleVariant","","",40],[12,"StructVariant","","",40],[2,"Mutability","",""],[12,"Mutable","","",41],[12,"Immutable","","",41],[2,"ViewItemInner","",""],[12,"ExternCrate","","",42],[12,"Import","","",42],[2,"ViewPath","",""],[12,"SimpleImport","","",43],[12,"GlobImport","","",43],[12,"ImportList","","",43],[4,"Visibility","",""],[5,"SCHEMA_VERSION","","A stable identifier to the particular version of JSON output.\nIncrement this when the `Crate` and related structures change."],[6,"Clean","",""],[9,"clean","","",44],[6,"ToSource","",""],[9,"to_src","","",45],[10,"clean","collections::vec","",46],[10,"clean","rustc::middle::subst","",47],[10,"clean","std::gc","",48],[10,"clean","alloc::rc","",49],[10,"clean","core::option","",50],[10,"clean","syntax::owned_slice","",51],[10,"decode","rustdoc::clean","",0],[10,"encode","","",0],[10,"clone","","",0],[10,"decode","","",1],[10,"encode","","",1],[10,"clone","","",1],[10,"clean","rustc::metadata::cstore","",52],[10,"decode","rustdoc::clean","",2],[10,"encode","","",2],[10,"clone","","",2],[10,"doc_list","","Finds the `doc` attribute as a List and returns the list of attributes\nnested inside.",2],[10,"doc_value","","Finds the `doc` attribute as a NameValue and returns the corresponding\nvalue found.",2],[10,"is_hidden_from_doc","","",2],[10,"is_mod","","",2],[10,"is_trait","","",2],[10,"is_struct","","",2],[10,"is_enum","","",2],[10,"is_fn","","",2],[10,"decode","","",30],[10,"encode","","",30],[10,"clone","","",30],[10,"decode","","",3],[10,"encode","","",3],[10,"clone","","",3],[10,"eq","","",31],[10,"ne","","",31],[10,"decode","","",31],[10,"encode","","",31],[10,"clone","","",31],[10,"clean","syntax::ast","",53],[10,"clean","","",54],[10,"name","rustdoc::clean","",31],[10,"value_str","","",31],[10,"meta_item_list","","",31],[10,"eq","","",4],[10,"ne","","",4],[10,"decode","","",4],[10,"encode","","",4],[10,"clone","","",4],[10,"clean","syntax::ast","",55],[10,"clean","rustc::middle::ty","",56],[10,"eq","rustdoc::clean","",32],[10,"ne","","",32],[10,"decode","","",32],[10,"encode","","",32],[10,"clone","","",32],[10,"clean","syntax::ast","",57],[10,"clean","rustc::middle::ty","",58],[10,"clean","","",59],[10,"clean","","",60],[10,"clean","rustc::middle::subst","",61],[10,"eq","rustdoc::clean","",62],[10,"ne","","",62],[10,"decode","","",62],[10,"encode","","",62],[10,"clone","","",62],[10,"get_ref","","",62],[10,"clean","syntax::ast","",63],[10,"clean","rustc::middle::ty","",64],[10,"clean","","",65],[10,"eq","rustdoc::clean","",5],[10,"ne","","",5],[10,"decode","","",5],[10,"encode","","",5],[10,"clone","","",5],[10,"clean","syntax::ast","",66],[10,"decode","rustdoc::clean","",6],[10,"encode","","",6],[10,"clone","","",6],[10,"clean","syntax::ast","",67],[10,"decode","rustdoc::clean","",7],[10,"encode","","",7],[10,"clone","","",7],[10,"clean","syntax::ast","",68],[10,"eq","rustdoc::clean","",33],[10,"ne","","",33],[10,"decode","","",33],[10,"encode","","",33],[10,"clone","","",33],[10,"clean","syntax::ast","",69],[10,"decode","rustdoc::clean","",8],[10,"encode","","",8],[10,"clone","","",8],[10,"eq","","",9],[10,"ne","","",9],[10,"decode","","",9],[10,"encode","","",9],[10,"clone","","",9],[10,"clean","syntax::ast","",70],[10,"eq","rustdoc::clean","",10],[10,"ne","","",10],[10,"decode","","",10],[10,"encode","","",10],[10,"clone","","",10],[10,"eq","","",11],[10,"ne","","",11],[10,"decode","","",11],[10,"encode","","",11],[10,"clone","","",11],[10,"clean","syntax::ast","",71],[10,"eq","rustdoc::clean","",12],[10,"ne","","",12],[10,"decode","","",12],[10,"encode","","",12],[10,"clone","","",12],[10,"clean","syntax::ast","",72],[10,"eq","rustdoc::clean","",34],[10,"ne","","",34],[10,"decode","","",34],[10,"encode","","",34],[10,"clone","","",34],[10,"clean","syntax::ast","",73],[10,"decode","rustdoc::clean","",13],[10,"encode","","",13],[10,"clone","","",13],[10,"clean","syntax::ast","",74],[10,"decode","rustdoc::clean","",35],[10,"encode","","",35],[10,"clone","","",35],[10,"is_req","","",35],[10,"is_def","","",35],[10,"item","","",35],[10,"clean","syntax::ast","",75],[10,"clean","rustc::middle::ty","",76],[10,"eq","rustdoc::clean","",36],[10,"ne","","",36],[10,"decode","","",36],[10,"encode","","",36],[10,"clone","","",36],[10,"hash","","",37],[10,"eq","","",37],[10,"ne","","",37],[10,"decode","","",37],[10,"encode","","",37],[10,"clone","","",37],[10,"decode","","",38],[10,"encode","","",38],[10,"clone","","",38],[10,"to_string","","",37],[10,"to_url_str","","",37],[10,"to_node_id","","Creates a rustdoc-specific node id for primitive types.",37],[10,"clean","syntax::ast","",77],[10,"clean","rustc::middle::ty","",78],[10,"decode","rustdoc::clean","",39],[10,"encode","","",39],[10,"clone","","",39],[10,"clean","syntax::ast","",79],[10,"clean","rustc::middle::ty","",80],[10,"clean","syntax::ast","",81],[10,"decode","rustdoc::clean","",14],[10,"encode","","",14],[10,"clone","","",14],[10,"decode","","",15],[10,"encode","","",15],[10,"clone","","",15],[10,"clean","syntax::ast","",82],[10,"decode","rustdoc::clean","",16],[10,"encode","","",16],[10,"clone","","",16],[10,"decode","","",17],[10,"encode","","",17],[10,"clone","","",17],[10,"clean","rustc::middle::ty","",83],[10,"decode","rustdoc::clean","",40],[10,"encode","","",40],[10,"clone","","",40],[10,"clean","syntax::ast","",84],[10,"decode","rustdoc::clean","",18],[10,"encode","","",18],[10,"clone","","",18],[10,"clean","syntax::codemap","",85],[10,"eq","rustdoc::clean","",19],[10,"ne","","",19],[10,"decode","","",19],[10,"encode","","",19],[10,"clone","","",19],[10,"clean","syntax::ast","",86],[10,"eq","rustdoc::clean","",20],[10,"ne","","",20],[10,"decode","","",20],[10,"encode","","",20],[10,"clone","","",20],[10,"clean","syntax::ast","",87],[10,"clean","","",88],[10,"clean","","",89],[10,"decode","rustdoc::clean","",21],[10,"encode","","",21],[10,"clone","","",21],[10,"eq","","",22],[10,"ne","","",22],[10,"decode","","",22],[10,"encode","","",22],[10,"clone","","",22],[10,"clean","syntax::ast","",90],[10,"decode","rustdoc::clean","",23],[10,"encode","","",23],[10,"clone","","",23],[10,"eq","","",41],[10,"ne","","",41],[10,"decode","","",41],[10,"encode","","",41],[10,"clone","","",41],[10,"fmt","","",41],[10,"clean","syntax::ast","",91],[10,"decode","rustdoc::clean","",24],[10,"encode","","",24],[10,"clone","","",24],[10,"decode","","",25],[10,"encode","","",25],[10,"clone","","",25],[10,"clean","syntax::ast","",92],[10,"decode","rustdoc::clean","",42],[10,"encode","","",42],[10,"clone","","",42],[10,"clean","syntax::ast","",93],[10,"decode","rustdoc::clean","",43],[10,"encode","","",43],[10,"clone","","",43],[10,"decode","","",26],[10,"encode","","",26],[10,"clone","","",26],[10,"clean","syntax::ast","",94],[10,"decode","rustdoc::clean","",27],[10,"encode","","",27],[10,"clone","","",27],[10,"clean","syntax::ast","",95],[10,"clean","","",96],[10,"clean","","",97],[10,"to_src","syntax::codemap","",85],[10,"decode","rustdoc::clean","",28],[10,"encode","","",28],[10,"clone","","",28],[10,"decode","","",29],[10,"encode","","",29],[10,"clone","","",29],[10,"clean","syntax::attr","",98],[0,"core","rustdoc",""],[1,"DocContext","rustdoc::core",""],[11,"krate","","",99],[11,"maybe_typed","","",99],[11,"src","","",99],[11,"external_paths","","",99],[11,"external_traits","","",99],[11,"external_typarams","","",99],[11,"inlined","","",99],[11,"populated_crate_impls","","",99],[1,"CrateAnalysis","",""],[11,"exported_items","","",100],[11,"public_items","","",100],[11,"external_paths","","",100],[11,"external_traits","","",100],[11,"external_typarams","","",100],[11,"inlined","","",100],[2,"MaybeTyped","","Are we generating documentation (`Typed`) or tests (`NotTyped`)?"],[12,"Typed","","",101],[12,"NotTyped","","",101],[3,"run_core","",""],[4,"ExternalPaths","",""],[4,"Externs","",""],[10,"sess","","",99],[10,"tcx_opt","","",99],[10,"tcx","","",99],[0,"doctree","rustdoc","This module is used to store stuff from Rust's AST in a more convenient\nmanner (and with prettier names) before cleaning."],[1,"Module","rustdoc::doctree",""],[11,"name","","",102],[11,"attrs","","",102],[11,"where_outer","","",102],[11,"where_inner","","",102],[11,"structs","","",102],[11,"enums","","",102],[11,"fns","","",102],[11,"mods","","",102],[11,"id","","",102],[11,"typedefs","","",102],[11,"statics","","",102],[11,"traits","","",102],[11,"vis","","",102],[11,"stab","","",102],[11,"impls","","",102],[11,"foreigns","","",102],[11,"view_items","","",102],[11,"macros","","",102],[11,"is_crate","","",102],[1,"Struct","",""],[11,"vis","","",103],[11,"stab","","",103],[11,"id","","",103],[11,"struct_type","","",103],[11,"name","","",103],[11,"generics","","",103],[11,"attrs","","",103],[11,"fields","","",103],[11,"where","","",103],[1,"Enum","",""],[11,"vis","","",104],[11,"stab","","",104],[11,"variants","","",104],[11,"generics","","",104],[11,"attrs","","",104],[11,"id","","",104],[11,"where","","",104],[11,"name","","",104],[1,"Variant","",""],[11,"name","","",105],[11,"attrs","","",105],[11,"kind","","",105],[11,"id","","",105],[11,"vis","","",105],[11,"stab","","",105],[11,"where","","",105],[1,"Function","",""],[11,"decl","","",106],[11,"attrs","","",106],[11,"id","","",106],[11,"name","","",106],[11,"vis","","",106],[11,"stab","","",106],[11,"fn_style","","",106],[11,"where","","",106],[11,"generics","","",106],[1,"Typedef","",""],[11,"ty","","",107],[11,"gen","","",107],[11,"name","","",107],[11,"id","","",107],[11,"attrs","","",107],[11,"where","","",107],[11,"vis","","",107],[11,"stab","","",107],[1,"Static","",""],[11,"type_","","",108],[11,"mutability","","",108],[11,"expr","","",108],[11,"name","","",108],[11,"attrs","","",108],[11,"vis","","",108],[11,"stab","","",108],[11,"id","","",108],[11,"where","","",108],[1,"Trait","",""],[11,"name","","",109],[11,"methods","","",109],[11,"generics","","",109],[11,"parents","","",109],[11,"attrs","","",109],[11,"id","","",109],[11,"where","","",109],[11,"vis","","",109],[11,"stab","","",109],[1,"Impl","",""],[11,"generics","","",110],[11,"trait_","","",110],[11,"for_","","",110],[11,"methods","","",110],[11,"attrs","","",110],[11,"where","","",110],[11,"vis","","",110],[11,"stab","","",110],[11,"id","","",110],[1,"Macro","",""],[11,"name","","",111],[11,"id","","",111],[11,"attrs","","",111],[11,"where","","",111],[11,"stab","","",111],[2,"StructType","",""],[12,"Plain","","A normal struct",112],[12,"Tuple","","A tuple struct",112],[12,"Newtype","","A newtype struct (tuple struct with one element)",112],[12,"Unit","","A unit struct",112],[2,"TypeBound","",""],[12,"RegionBound","","",113],[12,"TraitBound","","",113],[3,"struct_type_from_def","",""],[10,"new","","",102],[10,"decode","","",112],[10,"encode","","",112],[10,"clone","","",112],[10,"fmt","","",112],[0,"externalfiles","rustdoc",""],[1,"ExternalHtml","rustdoc::externalfiles",""],[11,"in_header","","",114],[11,"before_content","","",114],[11,"after_content","","",114],[3,"load_string","",""],[3,"load_external_files","",""],[10,"clone","","",114],[10,"load","","",114],[0,"fold","rustdoc",""],[6,"DocFolder","rustdoc::fold",""],[10,"fold_item","","",115],[10,"fold_item_recur","","don't override!",115],[10,"fold_mod","","",115],[10,"fold_crate","","",115],[0,"html","rustdoc",""],[0,"highlight","rustdoc::html","Basic html highlighting functionality"],[3,"highlight","rustdoc::html::highlight","Highlights some source code, returning the HTML output."],[0,"escape","rustdoc::html","HTML Escaping"],[1,"Escape","rustdoc::html::escape","Wrapper struct which will emit the HTML-escaped version of the contained\nstring when passed to a format string."],[10,"fmt","","",116],[0,"item_type","rustdoc::html","Item types."],[2,"ItemType","rustdoc::html::item_type","Item type. Corresponds to `clean::ItemEnum` variants."],[12,"Module","","",117],[12,"Struct","","",117],[12,"Enum","","",117],[12,"Function","","",117],[12,"Typedef","","",117],[12,"Static","","",117],[12,"Trait","","",117],[12,"Impl","","",117],[12,"ViewItem","","",117],[12,"TyMethod","","",117],[12,"Method","","",117],[12,"StructField","","",117],[12,"Variant","","",117],[12,"ForeignFunction","","",117],[12,"ForeignStatic","","",117],[12,"Macro","","",117],[12,"Primitive","","",117],[3,"shortty","",""],[10,"clone","","",117],[10,"eq","","",117],[10,"ne","","",117],[10,"to_static_str","","",117],[10,"fmt","","",117],[10,"fmt","","",117],[0,"format","rustdoc::html","HTML formatting module"],[1,"VisSpace","rustdoc::html::format","Helper to render an optional visibility with a space after it (if the\nvisibility is preset)"],[1,"FnStyleSpace","","Similarly to VisSpace, this structure is used to render a function style with a\nspace after it."],[1,"Method","","Wrapper struct for properly emitting a method declaration."],[1,"MutableSpace","","Similar to VisSpace, but used for mutability"],[1,"RawMutableSpace","","Similar to VisSpace, but used for mutability"],[1,"Stability","","Wrapper struct for properly emitting the stability level."],[1,"ConciseStability","","Wrapper struct for emitting the stability level concisely."],[10,"get","","",118],[10,"get","","",119],[10,"fmt","rustdoc::clean","",5],[10,"fmt","","",62],[10,"fmt","","",32],[10,"fmt","","",19],[10,"fmt","","",36],[10,"fmt","","",11],[10,"fmt","","",10],[10,"fmt","rustdoc::html::format","",120],[10,"fmt","","",118],[10,"fmt","","",119],[10,"fmt","rustdoc::clean","",43],[10,"fmt","","",26],[10,"fmt","","",27],[10,"fmt","rustdoc::html::format","",121],[10,"fmt","","",122],[10,"fmt","","",123],[10,"fmt","","",124],[0,"layout","rustdoc::html",""],[1,"Layout","rustdoc::html::layout",""],[11,"logo","","",125],[11,"favicon","","",125],[11,"external_html","","",125],[11,"krate","","",125],[11,"playground_url","","",125],[1,"Page","",""],[11,"title","","",126],[11,"ty","","",126],[11,"root_path","","",126],[3,"render","",""],[3,"redirect","",""],[10,"clone","","",125],[0,"markdown","rustdoc::html","Markdown formatting for rustdoc"],[1,"Markdown","rustdoc::html::markdown","A unit struct which has the `fmt::Show` trait implemented. When\nformatted, this struct will emit the HTML corresponding to the rendered\nversion of the contained markdown string."],[1,"MarkdownWithToc","","A unit struct like `Markdown`, that renders the markdown with a\ntable of contents."],[3,"render","",""],[3,"find_testable_code","",""],[3,"reset_headers","","By default this markdown renderer generates anchors for each header in the\nrendered document. The anchor name is the contents of the header separated\nby hyphens, and a task-local map is used to disambiguate among duplicate\nheaders (numbers are appended)."],[5,"playground_krate","",""],[10,"fmt","","",127],[10,"fmt","","",128],[0,"render","rustdoc::html","Rustdoc's HTML Rendering module"],[1,"NameDoc","rustdoc::html::render","A pair of name and its optional document."],[1,"Context","","Major driving force in all rustdoc rendering. This contains information\nabout where in the tree-like hierarchy rendering is occurring and controls\nhow the current page is being rendered."],[11,"current","","Current hierarchy of components leading down to what's currently being\nrendered",129],[11,"root_path","","String representation of how to get back to the root path of the 'doc/'\nfolder in terms of a relative URL.",129],[11,"dst","","The current destination folder of where HTML artifacts should be placed.\nThis changes as the context descends into the module hierarchy.",129],[11,"layout","","This describes the layout of each page, and is not modified after\ncreation of the context (contains info like the favicon and added html).",129],[11,"sidebar","","This map is a list of what should be displayed on the sidebar of the\ncurrent page. The key is the section header (traits, modules,\nfunctions), and the value is the list of containers belonging to this\nheader. This map will change depending on the surrounding context of the\npage.",129],[11,"include_sources","","This flag indicates whether [src] links should be generated or not. If\nthe source files are present in the html rendering, then this will be\n`true`.",129],[11,"render_redirect_pages","","A flag, which when turned off, will render pages which redirect to the\nreal location of an item. This is used to allow external links to\npublicly reused items to redirect to the right location.",129],[1,"Implementor","","Metadata about an implementor of a trait."],[1,"Impl","","Metadata about implementations for a type."],[1,"Cache","","This cache is used to store information about the `clean::Crate` being\nrendered in order to provide more useful documentation. This contains\ninformation like all implementors of a trait, all traits a type implements,\ndocumentation for all known traits, etc."],[11,"typarams","","Mapping of typaram ids to the name of the type parameter. This is used\nwhen pretty-printing a type (so pretty printing doesn't have to\npainfully maintain a context like this)",130],[11,"impls","","Maps a type id to all known implementations for that type. This is only\nrecognized for intra-crate `ResolvedPath` types, and is used to print\nout extra documentation on the page of an enum/struct.",130],[11,"paths","","Maintains a mapping of local crate node ids to the fully qualified name\nand \"short type description\" of that node. This is used when generating\nURLs when a type is being linked to. External paths are not located in\nthis map because the `External` type itself has all the information\nnecessary.",130],[11,"external_paths","","Similar to `paths`, but only holds external paths. This is only used for\ngenerating explicit hyperlinks to other crates.",130],[11,"traits","","This map contains information about all known traits of this crate.\nImplementations of a crate should inherit the documentation of the\nparent trait if no extra documentation is specified, and default methods\nshould show up in documentation about trait implementations.",130],[11,"implementors","","When rendering traits, it's often useful to be able to list all\nimplementors of the trait, and this mapping is exactly, that: a mapping\nof trait ids to the list of known implementors of the trait",130],[11,"extern_locations","","Cache of where external crate documentation can be found.",130],[11,"primitive_locations","","Cache of where documentation for primitives can be found.",130],[11,"inlined","","Set of definitions which have been inlined from external crates.",130],[2,"ExternalLocation","","Indicates where an external crate can be found."],[12,"Remote","","Remote URL root of the external crate",131],[12,"Local","","This external crate can be found in the local doc/ folder",131],[12,"Unknown","","The external crate could not be found.",131],[3,"run","","Generates the documentation for `crate` into the directory `dst`"],[5,"cache_key","",""],[5,"current_location_key","",""],[10,"cmp","","",132],[10,"clone","","",132],[10,"partial_cmp","","",132],[10,"eq","","",132],[10,"clone","","",129],[10,"clone","","",133],[10,"fold_item","","",130],[0,"toc","rustdoc::html","Table-of-contents creation."],[1,"Toc","rustdoc::html::toc","A (recursive) table of contents"],[1,"TocEntry","",""],[1,"TocBuilder","","Progressive construction of a table of contents."],[10,"eq","","",134],[10,"ne","","",134],[10,"eq","","",135],[10,"ne","","",135],[10,"eq","","",136],[10,"ne","","",136],[10,"new","","",136],[10,"into_toc","","Convert into a true `Toc` struct.",136],[10,"push","","Push a level `level` heading into the appropriate place in the\nhierarchy, returning a string containing the section number in\n`<num>.<num>.<num>` format.",136],[10,"fmt","","",134],[0,"markdown","rustdoc",""],[3,"render","rustdoc::markdown","Render `input` (e.g. \"foo.md\") into an HTML file in `output`\n(e.g. output = \"bar\" => \"bar/foo.html\")."],[3,"test","","Run any tests/code examples in the markdown file `input`."],[0,"passes","rustdoc",""],[3,"strip_hidden","rustdoc::passes","Strip items marked `#[doc(hidden)]`"],[3,"strip_private","","Strip private items from the point of view of a crate or externally from a\ncrate, specified by the `xcrate` flag."],[3,"unindent_comments","",""],[3,"collapse_docs","",""],[3,"unindent","",""],[0,"plugins","rustdoc",""],[1,"PluginManager","rustdoc::plugins","Manages loading and running of plugins"],[11,"prefix","","The directory plugins will be loaded from",137],[4,"PluginJson","",""],[4,"PluginResult","",""],[4,"PluginCallback","",""],[10,"new","","Create a new plugin manager",137],[10,"load_plugin","","Load a plugin with the given name.",137],[10,"add_plugin","","Load a normal Rust function as a plugin.",137],[10,"run_plugins","","Run all the loaded plugins over the crate, returning their results",137],[0,"stability_summary","rustdoc","This module crawls a `clean::Crate` and produces a summarization of the\nstability levels within the crate. The summary contains the module\nhierarchy, with item counts for every stability level per module. A parent\nmodule's count includes its childrens's."],[1,"Counts","rustdoc::stability_summary","The counts for each stability level."],[11,"deprecated","","",138],[11,"experimental","","",138],[11,"unstable","","",138],[11,"stable","","",138],[11,"frozen","","",138],[11,"locked","","",138],[11,"unmarked","","No stability level, inherited or otherwise.",138],[1,"ModuleSummary","","A summarized module, which includes total counts and summarized chilcren\nmodules."],[11,"name","","",139],[11,"counts","","",139],[11,"submodules","","",139],[3,"build","","Summarizes the stability levels in a crate."],[10,"eq","","",138],[10,"ne","","",138],[10,"decode","","",138],[10,"encode","","",138],[10,"zero","","",138],[10,"is_zero","","",138],[10,"add","","",138],[10,"total","","",138],[10,"eq","","",139],[10,"ne","","",139],[10,"decode","","",139],[10,"encode","","",139],[10,"partial_cmp","","",139],[10,"cmp","","",139],[0,"visit_ast","rustdoc","Rust AST Visitor. Extracts useful information and massages it into a form\nusable for clean"],[1,"RustdocVisitor","rustdoc::visit_ast",""],[11,"module","","",140],[11,"attrs","","",140],[11,"cx","","",140],[11,"analysis","","",140],[10,"new","","",140],[10,"visit","","",140],[10,"visit_struct_def","","",140],[10,"visit_enum_def","","",140],[10,"visit_fn","","",140],[10,"visit_mod_contents","","",140],[10,"visit_view_item","","",140],[10,"visit_item","","",140],[0,"test","rustdoc",""],[1,"Collector","rustdoc::test",""],[11,"tests","","",141],[3,"run","",""],[3,"maketest","",""],[10,"new","","",141],[10,"add_test","","",141],[10,"register_header","","",141],[10,"fold_item","","",141],[5,"ctxtkey","rustdoc",""],[5,"analysiskey","",""],[10,"clean","rustdoc::visit_ast","",140],[10,"clean","rustdoc::doctree","",102],[10,"clean","","",106],[10,"clean","","",109],[10,"clean","","",103],[10,"clean","","",104],[10,"clean","","",105],[10,"clean","","",107],[10,"clean","","",108],[10,"clean","","",110],[10,"clean","","",111],[10,"fmt","rustdoc::stability_summary","",139]],"paths":[[1,"Crate"],[1,"ExternalCrate"],[1,"Item"],[1,"Module"],[1,"TyParam"],[1,"Generics"],[1,"Method"],[1,"TyMethod"],[1,"Function"],[1,"ClosureDecl"],[1,"FnDecl"],[1,"Arguments"],[1,"Argument"],[1,"Trait"],[1,"Struct"],[1,"VariantStruct"],[1,"Enum"],[1,"Variant"],[1,"Span"],[1,"Path"],[1,"PathSegment"],[1,"Typedef"],[1,"BareFunctionDecl"],[1,"Static"],[1,"Impl"],[1,"ViewItem"],[1,"ImportSource"],[1,"ViewListIdent"],[1,"Macro"],[1,"Stability"],[2,"ItemEnum"],[2,"Attribute"],[2,"TyParamBound"],[2,"SelfTy"],[2,"RetStyle"],[2,"TraitMethod"],[2,"Type"],[2,"Primitive"],[2,"TypeKind"],[2,"StructField"],[2,"VariantKind"],[2,"Mutability"],[2,"ViewItemInner"],[2,"ViewPath"],[6,"Clean"],[6,"ToSource"],[1,"Vec"],[1,"VecPerParamSpace"],[1,"Gc"],[1,"Rc"],[2,"Option"],[1,"OwnedSlice"],[1,"crate_metadata"],[2,"MetaItem"],[2,"Attribute"],[1,"TyParam"],[1,"TypeParameterDef"],[2,"TyParamBound"],[2,"BuiltinBound"],[1,"TraitRef"],[1,"ParamBounds"],[1,"Substs"],[1,"Lifetime"],[1,"Lifetime"],[1,"RegionParameterDef"],[2,"Region"],[1,"Generics"],[1,"Method"],[1,"TypeMethod"],[2,"ExplicitSelf_"],[1,"ClosureTy"],[1,"FnDecl"],[1,"Arg"],[2,"RetStyle"],[1,"TraitRef"],[2,"TraitMethod"],[1,"Method"],[1,"Ty"],[1,"t"],[2,"StructField"],[1,"field_ty"],[2,"Visibility"],[1,"StructDef"],[1,"VariantInfo"],[2,"VariantKind"],[1,"Span"],[1,"Path"],[1,"PathSegment"],[1,"Ident"],[1,"Name"],[1,"BareFnTy"],[2,"Mutability"],[1,"ViewItem"],[2,"ViewItem_"],[2,"ViewPath"],[2,"PathListItem"],[1,"ForeignMod"],[1,"ForeignItem"],[1,"Stability"],[1,"DocContext"],[1,"CrateAnalysis"],[2,"MaybeTyped"],[1,"Module"],[1,"Struct"],[1,"Enum"],[1,"Variant"],[1,"Function"],[1,"Typedef"],[1,"Static"],[1,"Trait"],[1,"Impl"],[1,"Macro"],[2,"StructType"],[2,"TypeBound"],[1,"ExternalHtml"],[6,"DocFolder"],[1,"Escape"],[2,"ItemType"],[1,"VisSpace"],[1,"FnStyleSpace"],[1,"Method"],[1,"MutableSpace"],[1,"RawMutableSpace"],[1,"Stability"],[1,"ConciseStability"],[1,"Layout"],[1,"Page"],[1,"Markdown"],[1,"MarkdownWithToc"],[1,"Context"],[1,"Cache"],[2,"ExternalLocation"],[1,"NameDoc"],[1,"Impl"],[1,"Toc"],[1,"TocEntry"],[1,"TocBuilder"],[1,"PluginManager"],[1,"Counts"],[1,"ModuleSummary"],[1,"RustdocVisitor"],[1,"Collector"]]};

searchIndex['unicode'] = {"items":[[0,"","unicode","# The Unicode Library"],[0,"regex","",""],[5,"UNICODE_CLASSES","unicode::regex",""],[5,"PERLD","",""],[5,"PERLS","",""],[5,"PERLW","",""],[0,"char","unicode","Character manipulation (`char` type, Unicode Scalar Value)"],[3,"decompose_canonical","unicode::char","Compute canonical Unicode decomposition for character"],[3,"decompose_compatible","","Compute canonical or compatible Unicode decomposition for character"],[3,"canonical_combining_class","",""],[3,"is_alphabetic","","Returns whether the specified `char` is considered a Unicode alphabetic\ncode point"],[3,"is_XID_start","","Returns whether the specified `char` satisfies the 'XID_Start' Unicode property"],[3,"is_XID_continue","","Returns whether the specified `char` satisfies the 'XID_Continue' Unicode property"],[3,"is_lowercase","","\nIndicates whether a `char` is in lower case"],[3,"is_uppercase","","\nIndicates whether a `char` is in upper case"],[3,"is_whitespace","","\nIndicates whether a `char` is whitespace"],[3,"is_alphanumeric","","\nIndicates whether a `char` is alphanumeric"],[3,"is_control","","\nIndicates whether a `char` is a control code point"],[3,"is_digit","","Indicates whether the `char` is numeric (Nd, Nl, or No)"],[3,"to_uppercase","","Convert a char to its uppercase equivalent"],[3,"to_lowercase","","Convert a char to its lowercase equivalent"],[3,"width","","Returns this character's displayed width in columns, or `None` if it is a\ncontrol character other than `'\\x00'`."],[6,"UnicodeChar","","Useful functions for Unicode characters."],[9,"is_alphabetic","","Returns whether the specified character is considered a Unicode\nalphabetic code point.",0],[9,"is_XID_start","","Returns whether the specified character satisfies the 'XID_Start'\nUnicode property.",0],[9,"is_XID_continue","","Returns whether the specified `char` satisfies the 'XID_Continue'\nUnicode property.",0],[9,"is_lowercase","","Indicates whether a character is in lowercase.",0],[9,"is_uppercase","","Indicates whether a character is in uppercase.",0],[9,"is_whitespace","","Indicates whether a character is whitespace.",0],[9,"is_alphanumeric","","Indicates whether a character is alphanumeric.",0],[9,"is_control","","Indicates whether a character is a control code point.",0],[9,"is_digit","","Indicates whether the character is numeric (Nd, Nl, or No).",0],[9,"to_lowercase","","Converts a character to its lowercase equivalent.",0],[9,"to_uppercase","","Converts a character to its uppercase equivalent.",0],[9,"width","","Returns this character's displayed width in columns, or `None` if it is a\ncontrol character other than `'\\x00'`.",0],[5,"MAX","",""],[3,"from_u32","","Converts from `u32` to a `char`"],[3,"is_digit_radix","","\nChecks if a `char` parses as a numeric digit in the given radix"],[3,"to_digit","","\nConverts a `char` to the corresponding digit"],[3,"from_digit","","\nConverts a number to the character representing it"],[3,"escape_unicode","","\nReturns the hexadecimal Unicode escape of a `char`"],[3,"escape_default","","\nReturns a 'default' ASCII and C++11-like literal escape of a `char`"],[3,"len_utf8_bytes","","Returns the amount of bytes this `char` would need if encoded in UTF-8"],[6,"Char","","Basic `char` manipulations."],[9,"is_digit_radix","","Checks if a `char` parses as a numeric digit in the given radix.",1],[9,"to_digit","","Converts a character to the corresponding digit.",1],[9,"from_digit","","Converts a number to the character representing it.",1],[9,"escape_unicode","","Returns the hexadecimal Unicode escape of a character.",1],[9,"escape_default","","Returns a 'default' ASCII and C++11-like literal escape of a\ncharacter.",1],[9,"len_utf8_bytes","","Returns the amount of bytes this character would need if encoded in\nUTF-8.",1],[9,"encode_utf8","","Encodes this character as UTF-8 into the provided byte buffer.",1],[9,"encode_utf16","","Encodes this character as UTF-16 into the provided `u16` buffer.",1],[0,"str","unicode",""],[1,"Graphemes","unicode::str","External iterator for a string's\n[grapheme clusters](http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries)."],[1,"GraphemeIndices","","External iterator for grapheme clusters and byte offsets."],[4,"Words","","An iterator over the words of a string, separated by a sequence of whitespace"],[6,"UnicodeStrSlice","","Methods for Unicode string slices"],[9,"graphemes","","Returns an iterator over the\n[grapheme clusters](http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries)\nof the string.",2],[9,"grapheme_indices","","Returns an iterator over the grapheme clusters of self and their byte offsets.\nSee `graphemes()` method for more information.",2],[9,"words","","An iterator over the words of a string (subsequences separated\nby any sequence of whitespace). Sequences of whitespace are\ncollapsed, so empty \"words\" are not included.",2],[9,"is_whitespace","","Returns true if the string contains only whitespace.",2],[9,"is_alphanumeric","","Returns true if the string contains only alphanumeric code\npoints.",2],[9,"width","","Returns a string's displayed width in columns, treating control\ncharacters as zero-width.",2],[9,"trim","","Returns a string with leading and trailing whitespace removed.",2],[9,"trim_left","","Returns a string with leading whitespace removed.",2],[9,"trim_right","","Returns a string with trailing whitespace removed.",2]],"paths":[[6,"UnicodeChar"],[6,"Char"],[6,"UnicodeStrSlice"]]};

searchIndex['rustrt'] = {"items":[[0,"","rustrt",""],[1,"Stdio","",""],[3,"init","","One-time runtime initialization."],[3,"at_exit","","Enqueues a procedure to run when the runtime is cleaned up"],[3,"cleanup","","One-time runtime cleanup."],[0,"args","","Global storage for command line arguments"],[3,"init","rustrt::args","One-time global initialization."],[3,"cleanup","","One-time global cleanup."],[3,"take","","Take the global arguments from global storage."],[3,"put","","Give the global arguments to global storage."],[3,"clone","","Make a clone of the global arguments."],[0,"bookkeeping","rustrt","Task bookkeeping"],[1,"Token","rustrt::bookkeeping",""],[3,"increment","","Increment the number of live tasks, returning a token which will decrement\nthe count when dropped."],[3,"decrement","",""],[3,"wait_for_other_tasks","","Waits for all other native tasks in the system to exit. This is only used by\nthe entry points of native programs"],[10,"drop","","",0],[0,"c_str","rustrt","C-string manipulation and management"],[1,"CString","rustrt::c_str","The representation of a C String."],[1,"CChars","","External iterator for a CString's bytes."],[3,"from_c_multistring","","Parses a C \"multistring\", eg windows env values or\nthe req->ptr result in a uv_fs_readdir() call."],[6,"ToCStr","","A generic trait for converting a value to a CString."],[9,"to_c_str","","Copy the receiver into a CString.",1],[9,"to_c_str_unchecked","","Unsafe variant of `to_c_str()` that doesn't check for nulls.",1],[10,"with_c_str","","Work with a temporary CString constructed from the receiver.\nThe provided `*libc::c_char` will be freed immediately upon return.",1],[10,"with_c_str_unchecked","","Unsafe variant of `with_c_str()` that doesn't check for nulls.",1],[10,"clone","","Clone this CString into a new, uniquely owned CString. For safety\nreasons, this is always a deep clone, rather than the usual shallow\nclone.",2],[10,"eq","","",2],[10,"partial_cmp","","",2],[10,"hash","","",2],[10,"new","","Create a C String from a pointer.",2],[10,"as_ptr","","Return a pointer to the NUL-terminated string data.",2],[10,"as_mut_ptr","","Return a mutable pointer to the NUL-terminated string data.",2],[10,"with_ref","","Calls a closure with a reference to the underlying `*libc::c_char`.",2],[10,"with_mut_ref","","Calls a closure with a mutable reference to the underlying `*libc::c_char`.",2],[10,"is_null","","Returns true if the CString is a null.",2],[10,"is_not_null","","Returns true if the CString is not null.",2],[10,"owns_buffer","","Returns whether or not the `CString` owns the buffer.",2],[10,"as_bytes","","Converts the CString into a `&[u8]` without copying.\nIncludes the terminating NUL byte.",2],[10,"as_bytes_no_nul","","Converts the CString into a `&[u8]` without copying.\nDoes not include the terminating NUL byte.",2],[10,"as_str","","Converts the CString into a `&str` without copying.\nReturns None if the CString is not UTF-8.",2],[10,"iter","","Return a CString iterator.",2],[10,"unwrap","","Unwraps the wrapped `*libc::c_char` from the `CString` wrapper.",2],[10,"drop","","",2],[10,"len","","Return the number of bytes in the CString (not including the NUL terminator).",2],[10,"fmt","","",2],[10,"to_c_str","collections::string","",3],[10,"to_c_str_unchecked","","",3],[10,"with_c_str","","",3],[10,"with_c_str_unchecked","","",3],[10,"next","rustrt::c_str","",4],[0,"exclusive","rustrt",""],[1,"Exclusive","rustrt::exclusive","An OS mutex over some data."],[1,"ExclusiveGuard","","An RAII guard returned via `lock`"],[10,"new","","Creates a new `Exclusive` which will protect the data provided.",5],[10,"lock","","Acquires this lock, returning a guard which the data is accessed through\nand from which that lock will be unlocked.",5],[10,"signal","","",6],[10,"wait","","",6],[10,"deref","","",6],[10,"deref_mut","","",6],[0,"local","rustrt",""],[6,"Local","rustrt::local","Encapsulates some task-local data."],[9,"put","","",7],[9,"take","","",7],[9,"try_take","","",7],[9,"exists","","",7],[9,"borrow","","",7],[9,"unsafe_take","","",7],[9,"unsafe_borrow","","",7],[9,"try_unsafe_borrow","","",7],[0,"local_data","rustrt","Task local data management"],[1,"Ref","rustrt::local_data","A RAII immutable reference to a task-local value."],[2,"KeyValue","",""],[12,"Key","","",8],[4,"Key","","Indexes a task-local data slot. This pointer is used for comparison to\ndifferentiate keys from one another. The actual type `T` is not used anywhere\nas a member of this type, except that it is parameterized with it to define\nthe type of each key's value."],[10,"replace","","Replaces a value in task local data.",8],[10,"get","","Borrows a value from TLD.",8],[10,"deref","","",9],[10,"fmt","","",9],[10,"eq","","",9],[10,"ne","","",9],[10,"partial_cmp","","",9],[10,"lt","","",9],[10,"le","","",9],[10,"gt","","",9],[10,"ge","","",9],[10,"cmp","","",9],[10,"drop","","",9],[0,"local_heap","rustrt","The local, garbage collected heap"],[1,"MemoryRegion","rustrt::local_heap",""],[1,"LocalHeap","",""],[3,"local_malloc_","",""],[3,"local_malloc","",""],[3,"local_free_","",""],[3,"local_free","",""],[4,"Box","",""],[10,"new","","",10],[10,"alloc","","",10],[10,"realloc","","",10],[10,"free","","",10],[10,"immortalize","","Immortalize all pending allocations, forcing them to live forever.",10],[10,"drop","","",10],[10,"drop","","",11],[0,"mutex","rustrt","A native mutex and condition variable type."],[1,"StaticNativeMutex","rustrt::mutex","A native mutex suitable for storing in statics (that is, it has\nthe `destroy` method rather than a destructor)."],[1,"NativeMutex","","A native mutex with a destructor for clean-up."],[1,"LockGuard","","Automatically unlocks the mutex that it was created from on\ndestruction."],[5,"NATIVE_MUTEX_INIT","",""],[10,"new","","Creates a new mutex.",12],[10,"lock","","Acquires this lock. This assumes that the current thread does not\nalready hold the lock.",12],[10,"trylock","","Attempts to acquire the lock. The value returned is `Some` if\nthe attempt succeeded.",12],[10,"lock_noguard","","Acquire the lock without creating a `LockGuard`.",12],[10,"trylock_noguard","","Attempts to acquire the lock without creating a\n`LockGuard`. The value returned is whether the lock was\nacquired or not.",12],[10,"unlock_noguard","","Unlocks the lock. This assumes that the current thread already holds the\nlock.",12],[10,"wait_noguard","","Block on the internal condition variable.",12],[10,"signal_noguard","","Signals a thread in `wait` to wake up",12],[10,"destroy","","This function is especially unsafe because there are no guarantees made\nthat no other thread is currently holding the lock or waiting on the\ncondition variable contained inside.",12],[10,"new","","Creates a new mutex.",13],[10,"lock","","Acquires this lock. This assumes that the current thread does not\nalready hold the lock.",13],[10,"trylock","","Attempts to acquire the lock. The value returned is `Some` if\nthe attempt succeeded.",13],[10,"lock_noguard","","Acquire the lock without creating a `LockGuard`.",13],[10,"trylock_noguard","","Attempts to acquire the lock without creating a\n`LockGuard`. The value returned is whether the lock was\nacquired or not.",13],[10,"unlock_noguard","","Unlocks the lock. This assumes that the current thread already holds the\nlock.",13],[10,"wait_noguard","","Block on the internal condition variable.",13],[10,"signal_noguard","","Signals a thread in `wait` to wake up",13],[10,"drop","","",13],[10,"wait","","Block on the internal condition variable.",14],[10,"signal","","Signals a thread in `wait` to wake up.",14],[10,"drop","","",14],[0,"rtio","rustrt","The EventLoop and internal synchronous I/O interface."],[1,"ProcessConfig","rustrt::rtio","Data needed to spawn a process. Serializes the `std::io::process::Command`\nbuilder."],[11,"program","","Path to the program to run.",15],[11,"args","","Arguments to pass to the program (doesn't include the program itself).",15],[11,"env","","Optional environment to specify for the program. If this is None, then\nit will inherit the current process's environment.",15],[11,"cwd","","Optional working directory for the new process. If this is None, then\nthe current directory of the running process is inherited.",15],[11,"stdin","","Configuration for the child process's stdin handle (file descriptor 0).\nThis field defaults to `CreatePipe(true, false)` so the input can be\nwritten to.",15],[11,"stdout","","Configuration for the child process's stdout handle (file descriptor 1).\nThis field defaults to `CreatePipe(false, true)` so the output can be\ncollected.",15],[11,"stderr","","Configuration for the child process's stdout handle (file descriptor 2).\nThis field defaults to `CreatePipe(false, true)` so the output can be\ncollected.",15],[11,"extra_io","","Any number of streams/file descriptors/pipes may be attached to this\nprocess. This list enumerates the file descriptors and such for the\nprocess to be spawned, and the file descriptors inherited will start at\n3 and go to the length of this array. The first three file descriptors\n(stdin/stdout/stderr) are configured with the `stdin`, `stdout`, and\n`stderr` fields.",15],[11,"uid","","Sets the child process's user id. This translates to a `setuid` call in\nthe child process. Setting this value on windows will cause the spawn to\nfail. Failure in the `setuid` call on unix will also cause the spawn to\nfail.",15],[11,"gid","","Similar to `uid`, but sets the group id of the child process. This has\nthe same semantics as the `uid` field.",15],[11,"detach","","If true, the child process is spawned in a detached state. On unix, this\nmeans that the child is the leader of a new process group.",15],[1,"LocalIo","",""],[1,"IoError","",""],[11,"code","","",16],[11,"extra","","",16],[11,"detail","","",16],[1,"SocketAddr","",""],[11,"ip","","",17],[11,"port","","",17],[1,"FileStat","",""],[11,"size","","",18],[11,"kind","","",18],[11,"perm","","",18],[11,"created","","",18],[11,"modified","","",18],[11,"accessed","","",18],[11,"device","","",18],[11,"inode","","",18],[11,"rdev","","",18],[11,"nlink","","",18],[11,"uid","","",18],[11,"gid","","",18],[11,"blksize","","",18],[11,"blocks","","",18],[11,"flags","","",18],[11,"gen","","",18],[1,"AddrinfoHint","",""],[11,"family","","",19],[11,"socktype","","",19],[11,"protocol","","",19],[11,"flags","","",19],[1,"AddrinfoInfo","",""],[11,"address","","",20],[11,"family","","",20],[11,"socktype","","",20],[11,"protocol","","",20],[11,"flags","","",20],[2,"CloseBehavior","","Description of what to do when a file handle is closed"],[12,"DontClose","","Do not close this handle when the object is destroyed",21],[12,"CloseSynchronously","","Synchronously close the handle, meaning that the task will block when\nthe handle is destroyed until it has been fully closed.",21],[12,"CloseAsynchronously","","Asynchronously closes a handle, meaning that the task will *not* block\nwhen the handle is destroyed, but the handle will still get deallocated\nand cleaned up (but this will happen asynchronously on the local event\nloop).",21],[2,"IpAddr","",""],[12,"Ipv4Addr","","",22],[12,"Ipv6Addr","","",22],[2,"StdioContainer","",""],[12,"Ignored","","",23],[12,"InheritFd","","",23],[12,"CreatePipe","","",23],[2,"ProcessExit","",""],[12,"ExitStatus","","",24],[12,"ExitSignal","","",24],[2,"FileMode","",""],[12,"Open","","",25],[12,"Append","","",25],[12,"Truncate","","",25],[2,"FileAccess","",""],[12,"Read","","",26],[12,"Write","","",26],[12,"ReadWrite","","",26],[2,"SeekStyle","",""],[12,"SeekSet","","",27],[12,"SeekEnd","","",27],[12,"SeekCur","","",27],[4,"IoResult","",""],[6,"EventLoop","",""],[9,"run","","",28],[9,"callback","","",28],[9,"pausable_idle_callback","","",28],[9,"remote_callback","","",28],[9,"io","","The asynchronous I/O services. Not all event loops may provide one.",28],[9,"has_active_io","","",28],[6,"Callback","",""],[9,"call","","",29],[6,"RemoteCallback","",""],[9,"fire","","Trigger the remote callback. Note that the number of times the\ncallback is run is not guaranteed. All that is guaranteed is\nthat, after calling 'fire', the callback will be called at\nleast once, but multiple callbacks may be coalesced and\ncallbacks may be called more often requested. Destruction also\ntriggers the callback.",30],[6,"IoFactory","",""],[9,"tcp_connect","","",31],[9,"tcp_bind","","",31],[9,"udp_bind","","",31],[9,"unix_bind","","",31],[9,"unix_connect","","",31],[9,"get_host_addresses","","",31],[9,"fs_from_raw_fd","","",31],[9,"fs_open","","",31],[9,"fs_unlink","","",31],[9,"fs_stat","","",31],[9,"fs_mkdir","","",31],[9,"fs_chmod","","",31],[9,"fs_rmdir","","",31],[9,"fs_rename","","",31],[9,"fs_readdir","","",31],[9,"fs_lstat","","",31],[9,"fs_chown","","",31],[9,"fs_readlink","","",31],[9,"fs_symlink","","",31],[9,"fs_link","","",31],[9,"fs_utime","","",31],[9,"timer_init","","",31],[9,"spawn","","",31],[9,"kill","","",31],[9,"pipe_open","","",31],[9,"tty_open","","",31],[9,"signal","","",31],[6,"RtioTcpListener","",""],[9,"listen","","",32],[6,"RtioTcpAcceptor","",""],[9,"accept","","",33],[9,"accept_simultaneously","","",33],[9,"dont_accept_simultaneously","","",33],[9,"set_timeout","","",33],[6,"RtioTcpStream","",""],[9,"read","","",34],[9,"write","","",34],[9,"peer_name","","",34],[9,"control_congestion","","",34],[9,"nodelay","","",34],[9,"keepalive","","",34],[9,"letdie","","",34],[9,"clone","","",34],[9,"close_write","","",34],[9,"close_read","","",34],[9,"set_timeout","","",34],[9,"set_read_timeout","","",34],[9,"set_write_timeout","","",34],[6,"RtioSocket","",""],[9,"socket_name","","",35],[6,"RtioUdpSocket","",""],[9,"recv_from","","",36],[9,"send_to","","",36],[9,"join_multicast","","",36],[9,"leave_multicast","","",36],[9,"loop_multicast_locally","","",36],[9,"dont_loop_multicast_locally","","",36],[9,"multicast_time_to_live","","",36],[9,"time_to_live","","",36],[9,"hear_broadcasts","","",36],[9,"ignore_broadcasts","","",36],[9,"clone","","",36],[9,"set_timeout","","",36],[9,"set_read_timeout","","",36],[9,"set_write_timeout","","",36],[6,"RtioTimer","",""],[9,"sleep","","",37],[9,"oneshot","","",37],[9,"period","","",37],[6,"RtioFileStream","",""],[9,"read","","",38],[9,"write","","",38],[9,"pread","","",38],[9,"pwrite","","",38],[9,"seek","","",38],[9,"tell","","",38],[9,"fsync","","",38],[9,"datasync","","",38],[9,"truncate","","",38],[9,"fstat","","",38],[6,"RtioProcess","",""],[9,"id","","",39],[9,"kill","","",39],[9,"wait","","",39],[9,"set_timeout","","",39],[6,"RtioPipe","",""],[9,"read","","",40],[9,"write","","",40],[9,"clone","","",40],[9,"close_write","","",40],[9,"close_read","","",40],[9,"set_timeout","","",40],[9,"set_read_timeout","","",40],[9,"set_write_timeout","","",40],[6,"RtioUnixListener","",""],[9,"listen","","",41],[6,"RtioUnixAcceptor","",""],[9,"accept","","",42],[9,"set_timeout","","",42],[6,"RtioTTY","",""],[9,"read","","",43],[9,"write","","",43],[9,"set_raw","","",43],[9,"get_winsize","","",43],[9,"isatty","","",43],[6,"PausableIdleCallback","",""],[9,"pause","","",44],[9,"resume","","",44],[6,"RtioSignal","",""],[10,"drop","","",45],[10,"borrow","","Returns the local I/O: either the local scheduler's I/O services or\nthe native I/O services.",45],[10,"maybe_raise","","",45],[10,"new","","",45],[10,"get","","Returns the underlying I/O factory as a trait reference.",45],[10,"eq","","",22],[10,"ne","","",22],[10,"fmt","","",22],[10,"eq","","",17],[10,"ne","","",17],[0,"stack","rustrt","Rust stack-limit management"],[3,"record_stack_bounds","rustrt::stack",""],[3,"record_sp_limit","","Records the current limit of the stack as specified by `end`."],[3,"get_sp_limit","","The counterpart of the function above, this function will fetch the current\nstack limit stored in TLS."],[5,"RED_ZONE","",""],[0,"task","rustrt","Language-level runtime services that should reasonably expected\nto be available 'everywhere'. Local heaps, GC, unwinding,\nlocal storage, and logging. Even a 'freestanding' Rust would likely want\nto implement this."],[1,"Task","rustrt::task","State associated with Rust tasks."],[11,"heap","","",46],[11,"gc","","",46],[11,"storage","","",46],[11,"unwinder","","",46],[11,"death","","",46],[11,"name","","",46],[1,"TaskOpts","",""],[11,"on_exit","","Invoke this procedure with the result of the task when it finishes.",47],[11,"name","","A name for the task-to-be, for identification in failure messages",47],[11,"stack_size","","The size of the stack for the spawned task",47],[1,"GarbageCollector","",""],[1,"LocalStorage","",""],[1,"Death","","Per-task state related to task death, killing, failure, etc."],[11,"on_exit","","",48],[1,"BlockedTasks","",""],[2,"BlockedTask","","A handle to a blocked task. Usually this means having the Box<Task>\npointer by ownership, but if the task is killable, a killer can steal it\nat any time."],[12,"Owned","","",49],[12,"Shared","","",49],[4,"Result","","Indicates the manner in which a task exited."],[10,"new","","Creates a new uninitialized task.",46],[10,"run","","Consumes ownership of a task, runs some code, and returns the task back.",46],[10,"destroy","","Destroy all associated resources of this task.",46],[10,"is_destroyed","","Queries whether this can be destroyed or not.",46],[10,"put_runtime","","Inserts a runtime object into this task, transferring ownership to the\ntask. It is illegal to replace a previous runtime object in this task\nwith this argument.",46],[10,"take_runtime","","Removes the runtime from this task, transferring ownership to the\ncaller.",46],[10,"maybe_take_runtime","","Attempts to extract the runtime as a specific type. If the runtime does\nnot have the provided type, then the runtime is not removed. If the\nruntime does have the specified type, then it is removed and returned\n(transfer of ownership).",46],[10,"spawn_sibling","","Spawns a sibling to this task. The newly spawned task is configured with\nthe `opts` structure and will run `f` as the body of its code.",46],[10,"deschedule","","Deschedules the current task, invoking `f` `amt` times. It is not\nrecommended to use this function directly, but rather communication\nprimitives in `std::comm` should be used.",46],[10,"reawaken","","Wakes up a previously blocked task, optionally specifying whether the\ncurrent task can accept a change in scheduling. This function can only\nbe called on tasks that were previously blocked in `deschedule`.",46],[10,"yield_now","","Yields control of this task to another task. This function will\neventually return, but possibly not immediately. This is used as an\nopportunity to allow other tasks a chance to run.",46],[10,"maybe_yield","","Similar to `yield_now`, except that this function may immediately return\nwithout yielding (depending on what the runtime decides to do).",46],[10,"local_io","","Acquires a handle to the I/O factory that this task contains, normally\nstored in the task's runtime. This factory may not always be available,\nwhich is why the return type is `Option`",46],[10,"stack_bounds","","Returns the stack bounds for this task in (lo, hi) format. The stack\nbounds may not be known for all tasks, so the return value may be\n`None`.",46],[10,"can_block","","Returns whether it is legal for this task to block the OS thread that it\nis running on.",46],[10,"drop","","Consume this task, flagging it as a candidate for destruction.",46],[10,"drop","","",46],[10,"new","","",47],[10,"next","","",50],[10,"wake","","Returns Some if the task was successfully woken; None if already killed.",49],[10,"reawaken","","Reawakens this task if ownership is acquired. If finer-grained control\nis desired, use `wake` instead.",49],[10,"trash","","",49],[10,"block","","Create a blocked task, unless the task was already killed.",49],[10,"make_selectable","","Converts one blocked task handle to a list of many handles to the same.",49],[10,"cast_to_uint","","Convert to an unsafe uint value. Useful for storing in a pipe's state\nflag.",49],[10,"cast_from_uint","","Convert from an unsafe uint value. Useful for retrieving a pipe's state\nflag.",49],[10,"new","","",48],[0,"thread","rustrt","Native os-thread management"],[1,"Thread","rustrt::thread","This struct represents a native thread's state. This is used to join on an\nexisting thread created in the join-able state."],[10,"start","","Starts execution of a new OS thread.",51],[10,"start_stack","","Performs the same functionality as `start`, but specifies an explicit\nstack size for the new thread.",51],[10,"spawn","","This will spawn a new thread, but it will not wait for the thread to\nfinish, nor is it possible to wait for the thread to finish.",51],[10,"spawn_stack","","Performs the same functionality as `spawn`, but explicitly specifies a\nstack size for the new thread.",51],[10,"yield_now","","Relinquishes the CPU slot that this OS-thread is currently using,\nallowing another thread to run for awhile.",51],[10,"join","","Wait for this thread to finish, returning the result of the thread's\ncalculation.",51],[10,"drop","","",51],[0,"unwind","rustrt","Implementation of Rust stack unwinding"],[1,"Unwinder","rustrt::unwind",""],[3,"try","","Invoke a closure, capturing the cause of failure if one occurs."],[3,"rust_begin_unwind","",""],[3,"begin_unwind_fmt","","The entry point for unwinding with a formatted message."],[3,"begin_unwind","","This is the entry point of unwinding for fail!() and assert!()."],[3,"register","","Register a callback to be invoked when a task unwinds."],[4,"Callback","",""],[10,"new","","",52],[10,"unwinding","","",52],[5,"Stdout","rustrt",""],[5,"Stderr","",""],[5,"DEFAULT_ERROR_CODE","","The default error code of the rust runtime if the main task fails instead\nof exiting cleanly."],[6,"Runtime","","The interface to the current runtime."],[9,"yield_now","","",53],[9,"maybe_yield","","",53],[9,"deschedule","","",53],[9,"reawaken","","",53],[9,"spawn_sibling","","",53],[9,"local_io","","",53],[9,"stack_bounds","","The (low, high) edges of the current stack.",53],[9,"can_block","","",53],[9,"wrap","","",53],[10,"put","rustrt::task","",46],[10,"take","","",46],[10,"try_take","","",46],[10,"exists","","",46],[10,"borrow","","",46],[10,"unsafe_take","","",46],[10,"unsafe_borrow","","",46],[10,"try_unsafe_borrow","","",46]],"paths":[[1,"Token"],[6,"ToCStr"],[1,"CString"],[1,"String"],[1,"CChars"],[1,"Exclusive"],[1,"ExclusiveGuard"],[6,"Local"],[2,"KeyValue"],[1,"Ref"],[1,"LocalHeap"],[1,"MemoryRegion"],[1,"StaticNativeMutex"],[1,"NativeMutex"],[1,"LockGuard"],[1,"ProcessConfig"],[1,"IoError"],[1,"SocketAddr"],[1,"FileStat"],[1,"AddrinfoHint"],[1,"AddrinfoInfo"],[2,"CloseBehavior"],[2,"IpAddr"],[2,"StdioContainer"],[2,"ProcessExit"],[2,"FileMode"],[2,"FileAccess"],[2,"SeekStyle"],[6,"EventLoop"],[6,"Callback"],[6,"RemoteCallback"],[6,"IoFactory"],[6,"RtioTcpListener"],[6,"RtioTcpAcceptor"],[6,"RtioTcpStream"],[6,"RtioSocket"],[6,"RtioUdpSocket"],[6,"RtioTimer"],[6,"RtioFileStream"],[6,"RtioProcess"],[6,"RtioPipe"],[6,"RtioUnixListener"],[6,"RtioUnixAcceptor"],[6,"RtioTTY"],[6,"PausableIdleCallback"],[1,"LocalIo"],[1,"Task"],[1,"TaskOpts"],[1,"Death"],[2,"BlockedTask"],[1,"BlockedTasks"],[1,"Thread"],[1,"Unwinder"],[6,"Runtime"]]};

searchIndex['debug'] = {"items":[[0,"","debug","Debugging utilities for Rust programs"],[0,"fmt","","Implementation of the `{:?}` format qualifier"],[6,"Poly","debug::fmt","Format trait for the `?` character"],[9,"fmt","","Formats the value using the given formatter.",0],[0,"reflect","debug","Runtime type reflection"],[1,"MovePtrAdaptor","debug::reflect","Adaptor to wrap around visitors implementing MovePtr."],[3,"align","","Helper function for alignment calculation."],[6,"MovePtr","","Trait for visitor that wishes to reflect on data."],[9,"move_ptr","","",1],[9,"push_ptr","","",1],[9,"pop_ptr","","",1],[10,"new","","",2],[10,"bump","","",2],[10,"align","","",2],[10,"align_to","","",2],[10,"bump_past","","",2],[10,"unwrap","","",2],[10,"visit_bot","","",2],[10,"visit_nil","","",2],[10,"visit_bool","","",2],[10,"visit_int","","",2],[10,"visit_i8","","",2],[10,"visit_i16","","",2],[10,"visit_i32","","",2],[10,"visit_i64","","",2],[10,"visit_uint","","",2],[10,"visit_u8","","",2],[10,"visit_u16","","",2],[10,"visit_u32","","",2],[10,"visit_u64","","",2],[10,"visit_f32","","",2],[10,"visit_f64","","",2],[10,"visit_char","","",2],[10,"visit_estr_slice","","",2],[10,"visit_estr_fixed","","",2],[10,"visit_box","","",2],[10,"visit_uniq","","",2],[10,"visit_ptr","","",2],[10,"visit_rptr","","",2],[10,"visit_evec_slice","","",2],[10,"visit_evec_fixed","","",2],[10,"visit_enter_rec","","",2],[10,"visit_rec_field","","",2],[10,"visit_leave_rec","","",2],[10,"visit_enter_class","","",2],[10,"visit_class_field","","",2],[10,"visit_leave_class","","",2],[10,"visit_enter_tup","","",2],[10,"visit_tup_field","","",2],[10,"visit_leave_tup","","",2],[10,"visit_enter_fn","","",2],[10,"visit_fn_input","","",2],[10,"visit_fn_output","","",2],[10,"visit_leave_fn","","",2],[10,"visit_enter_enum","","",2],[10,"visit_enter_enum_variant","","",2],[10,"visit_enum_variant_field","","",2],[10,"visit_leave_enum_variant","","",2],[10,"visit_leave_enum","","",2],[10,"visit_trait","","",2],[10,"visit_param","","",2],[10,"visit_self","","",2],[0,"repr","debug","More runtime type reflection"],[1,"ReprVisitor","debug::repr",""],[3,"write_repr","",""],[3,"repr_to_string","",""],[6,"Repr","","Representations"],[9,"write_repr","","",3],[10,"move_ptr","","",4],[10,"push_ptr","","",4],[10,"pop_ptr","","",4],[10,"new","","",4],[10,"get","","",4],[10,"visit_inner","","",4],[10,"visit_ptr_inner","","",4],[10,"write","","",4],[10,"write_escaped_slice","","",4],[10,"write_mut_qualifier","","",4],[10,"write_vec_range","","",4],[10,"visit_bot","","",4],[10,"visit_nil","","",4],[10,"visit_bool","","",4],[10,"visit_int","","",4],[10,"visit_i8","","",4],[10,"visit_i16","","",4],[10,"visit_i32","","",4],[10,"visit_i64","","",4],[10,"visit_uint","","",4],[10,"visit_u8","","",4],[10,"visit_u16","","",4],[10,"visit_u32","","",4],[10,"visit_u64","","",4],[10,"visit_f32","","",4],[10,"visit_f64","","",4],[10,"visit_char","","",4],[10,"visit_estr_slice","","",4],[10,"visit_estr_fixed","","",4],[10,"visit_box","","",4],[10,"visit_uniq","","",4],[10,"visit_ptr","","",4],[10,"visit_rptr","","",4],[10,"visit_evec_slice","","",4],[10,"visit_evec_fixed","","",4],[10,"visit_enter_rec","","",4],[10,"visit_rec_field","","",4],[10,"visit_leave_rec","","",4],[10,"visit_enter_class","","",4],[10,"visit_class_field","","",4],[10,"visit_leave_class","","",4],[10,"visit_enter_tup","","",4],[10,"visit_tup_field","","",4],[10,"visit_leave_tup","","",4],[10,"visit_enter_enum","","",4],[10,"visit_enter_enum_variant","","",4],[10,"visit_enum_variant_field","","",4],[10,"visit_leave_enum_variant","","",4],[10,"visit_leave_enum","","",4],[10,"visit_enter_fn","","",4],[10,"visit_fn_input","","",4],[10,"visit_fn_output","","",4],[10,"visit_leave_fn","","",4],[10,"visit_trait","","",4],[10,"visit_param","","",4],[10,"visit_self","","",4]],"paths":[[6,"Poly"],[6,"MovePtr"],[1,"MovePtrAdaptor"],[6,"Repr"],[1,"ReprVisitor"]]};

searchIndex['alloc'] = {"items":[[0,"","alloc","Rust's core allocation library"],[0,"heap","",""],[3,"allocate","alloc::heap","Return a pointer to `size` bytes of memory."],[3,"reallocate","","Extend or shrink the allocation referenced by `ptr` to `size` bytes of\nmemory."],[3,"reallocate_inplace","","Extend or shrink the allocation referenced by `ptr` to `size` bytes of\nmemory in-place."],[3,"deallocate","","Deallocate the memory referenced by `ptr`."],[3,"usable_size","","Return the usable size of an allocation created with the specified the\n`size` and `align`."],[3,"stats_print","","Print implementation-defined allocator statistics."],[5,"EMPTY","",""],[0,"libc_heap","alloc","The global (exchange) heap."],[3,"malloc_raw","alloc::libc_heap","A wrapper around libc::malloc, aborting on out-of-memory"],[3,"realloc_raw","","A wrapper around libc::realloc, aborting on out-of-memory"],[0,"boxed","alloc","A unique pointer type"],[1,"Box","alloc::boxed","A type that represents a uniquely-owned value."],[5,"HEAP","","A value that represents the global exchange heap. This is the default\nplace that the `box` keyword allocates into when no place is supplied."],[6,"BoxAny","","Extension methods for an owning `Any` trait object"],[9,"downcast","","Returns the boxed value if it is of type `T`, or\n`Err(Self)` if it isn't.",0],[10,"move","","Deprecated; this method has been renamed to `downcast`.",0],[10,"default","","",1],[10,"clone","","Return a copy of the owned box.",1],[10,"clone_from","","Perform copy-assignment from `source` by reusing the existing allocation.",1],[10,"eq","","",1],[10,"ne","","",1],[10,"partial_cmp","","",1],[10,"lt","","",1],[10,"le","","",1],[10,"ge","","",1],[10,"gt","","",1],[10,"cmp","","",1],[10,"downcast","","",1],[10,"fmt","","",1],[10,"fmt","","",1],[0,"arc","alloc","Concurrency-enabled mechanisms for sharing mutable and/or immutable state\nbetween tasks."],[1,"Arc","alloc::arc","An atomically reference counted wrapper for shared state."],[1,"Weak","","A weak pointer to an `Arc`."],[10,"new","","Create an atomically reference counted wrapper.",2],[10,"downgrade","","Downgrades a strong pointer to a weak pointer",2],[10,"clone","","Duplicate an atomically reference counted wrapper.",2],[10,"deref","","",2],[10,"make_unique","","Acquires a mutable pointer to the inner contents by guaranteeing that\nthe reference count is one (no sharing is possible).",2],[10,"drop","","",2],[10,"upgrade","","Attempts to upgrade this weak reference to a strong reference.",3],[10,"clone","","",3],[10,"drop","","",3],[0,"rc","alloc","Task-local reference-counted boxes (`Rc` type)"],[1,"Rc","alloc::rc","Immutable reference counted pointer type"],[1,"Weak","","Weak reference to a reference-counted box"],[3,"is_unique","","Returns true if the `Rc` currently has unique ownership."],[3,"try_unwrap","","Unwraps the contained value if the `Rc` has unique ownership."],[3,"get_mut","","Returns a mutable reference to the contained value if the `Rc` has\nunique ownership."],[10,"new","","Construct a new reference-counted box",4],[10,"downgrade","","Downgrade the reference-counted pointer to a weak reference",4],[10,"make_unique","","Acquires a mutable pointer to the inner contents by guaranteeing that\nthe reference count is one (no sharing is possible).",4],[10,"deref","","Borrow the value contained in the reference-counted box",4],[10,"drop","","",4],[10,"clone","","",4],[10,"default","","",4],[10,"eq","","",4],[10,"ne","","",4],[10,"partial_cmp","","",4],[10,"lt","","",4],[10,"le","","",4],[10,"gt","","",4],[10,"ge","","",4],[10,"cmp","","",4],[10,"fmt","","",4],[10,"upgrade","","Upgrade a weak reference to a strong reference",5],[10,"drop","","",5],[10,"clone","","",5]],"paths":[[6,"BoxAny"],[1,"Box"],[1,"Arc"],[1,"Weak"],[1,"Rc"],[1,"Weak"]]};

searchIndex['rlibc'] = {"items":[[0,"","rlibc","A bare-metal library supplying functions rustc may lower code to"],[3,"memcpy","",""],[3,"memmove","",""],[3,"memset","",""],[3,"memcmp","",""]],"paths":[]};

searchIndex['rbml'] = {"items":[[0,"","rbml","Really Bad Markup Language (rbml) is a temporary measure until we migrate\nthe rust object metadata to a better serialization format. It is not\nintended to be used by users."],[1,"Doc","","Common data structures"],[11,"data","","",0],[11,"start","","",0],[11,"end","","",0],[1,"TaggedDoc","",""],[11,"doc","","",1],[2,"EbmlEncoderTag","",""],[12,"EsUint","","",2],[12,"EsU64","","",2],[12,"EsU32","","",2],[12,"EsU16","","",2],[12,"EsU8","","",2],[12,"EsInt","","",2],[12,"EsI64","","",2],[12,"EsI32","","",2],[12,"EsI16","","",2],[12,"EsI8","","",2],[12,"EsBool","","",2],[12,"EsChar","","",2],[12,"EsStr","","",2],[12,"EsF64","","",2],[12,"EsF32","","",2],[12,"EsFloat","","",2],[12,"EsEnum","","",2],[12,"EsEnumVid","","",2],[12,"EsEnumBody","","",2],[12,"EsVec","","",2],[12,"EsVecLen","","",2],[12,"EsVecElt","","",2],[12,"EsMap","","",2],[12,"EsMapLen","","",2],[12,"EsMapKey","","",2],[12,"EsMapVal","","",2],[12,"EsOpaque","","",2],[12,"EsLabel","","",2],[2,"Error","",""],[12,"IntTooBig","","",3],[12,"Expected","","",3],[12,"IoError","","",3],[12,"ApplicationError","","",3],[0,"io","",""],[1,"SeekableMemWriter","rbml::io","Writes to an owned, growable byte vector that supports seeking."],[10,"new","","Create a new `SeekableMemWriter`.",4],[10,"with_capacity","","Create a new `SeekableMemWriter`, allocating at least `n` bytes for\nthe internal buffer.",4],[10,"get_ref","","Acquires an immutable reference to the underlying buffer of this\n`SeekableMemWriter`.",4],[10,"unwrap","","Unwraps this `SeekableMemWriter`, returning the underlying buffer",4],[10,"write","","",4],[10,"tell","","",4],[10,"seek","","",4],[0,"reader","rbml",""],[1,"Res","rbml::reader",""],[11,"val","","",5],[11,"next","","",5],[1,"Decoder","",""],[3,"vuint_at","",""],[3,"doc_at","",""],[3,"maybe_get_doc","",""],[3,"get_doc","",""],[3,"docs","",""],[3,"tagged_docs","",""],[3,"with_doc_data","",""],[3,"doc_as_u8","",""],[3,"doc_as_u16","",""],[3,"doc_as_u32","",""],[3,"doc_as_u64","",""],[3,"doc_as_i8","",""],[3,"doc_as_i16","",""],[3,"doc_as_i32","",""],[3,"doc_as_i64","",""],[4,"DecodeResult","",""],[10,"new","","",6],[10,"read_opaque","","",6],[10,"read_nil","","",6],[10,"read_u64","","",6],[10,"read_u32","","",6],[10,"read_u16","","",6],[10,"read_u8","","",6],[10,"read_uint","","",6],[10,"read_i64","","",6],[10,"read_i32","","",6],[10,"read_i16","","",6],[10,"read_i8","","",6],[10,"read_int","","",6],[10,"read_bool","","",6],[10,"read_f64","","",6],[10,"read_f32","","",6],[10,"read_char","","",6],[10,"read_str","","",6],[10,"read_enum","","",6],[10,"read_enum_variant","","",6],[10,"read_enum_variant_arg","","",6],[10,"read_enum_struct_variant","","",6],[10,"read_enum_struct_variant_field","","",6],[10,"read_struct","","",6],[10,"read_struct_field","","",6],[10,"read_tuple","","",6],[10,"read_tuple_arg","","",6],[10,"read_tuple_struct","","",6],[10,"read_tuple_struct_arg","","",6],[10,"read_option","","",6],[10,"read_seq","","",6],[10,"read_seq_elt","","",6],[10,"read_map","","",6],[10,"read_map_elt_key","","",6],[10,"read_map_elt_val","","",6],[10,"error","","",6],[0,"writer","rbml",""],[1,"Encoder","rbml::writer",""],[11,"writer","","",7],[4,"EncodeResult","",""],[10,"new","","",7],[10,"unsafe_clone","","FIXME(pcwalton): Workaround for badness in trans. DO NOT USE ME.",7],[10,"start_tag","","",7],[10,"end_tag","","",7],[10,"wr_tag","","",7],[10,"wr_tagged_bytes","","",7],[10,"wr_tagged_u64","","",7],[10,"wr_tagged_u32","","",7],[10,"wr_tagged_u16","","",7],[10,"wr_tagged_u8","","",7],[10,"wr_tagged_i64","","",7],[10,"wr_tagged_i32","","",7],[10,"wr_tagged_i16","","",7],[10,"wr_tagged_i8","","",7],[10,"wr_tagged_str","","",7],[10,"wr_bytes","","",7],[10,"wr_str","","",7],[10,"emit_opaque","","",7],[10,"emit_nil","","",7],[10,"emit_uint","","",7],[10,"emit_u64","","",7],[10,"emit_u32","","",7],[10,"emit_u16","","",7],[10,"emit_u8","","",7],[10,"emit_int","","",7],[10,"emit_i64","","",7],[10,"emit_i32","","",7],[10,"emit_i16","","",7],[10,"emit_i8","","",7],[10,"emit_bool","","",7],[10,"emit_f64","","",7],[10,"emit_f32","","",7],[10,"emit_char","","",7],[10,"emit_str","","",7],[10,"emit_enum","","",7],[10,"emit_enum_variant","","",7],[10,"emit_enum_variant_arg","","",7],[10,"emit_enum_struct_variant","","",7],[10,"emit_enum_struct_variant_field","","",7],[10,"emit_struct","","",7],[10,"emit_struct_field","","",7],[10,"emit_tuple","","",7],[10,"emit_tuple_arg","","",7],[10,"emit_tuple_struct","","",7],[10,"emit_tuple_struct_arg","","",7],[10,"emit_option","","",7],[10,"emit_option_none","","",7],[10,"emit_option_some","","",7],[10,"emit_seq","","",7],[10,"emit_seq_elt","","",7],[10,"emit_map","","",7],[10,"emit_map_elt_key","","",7],[10,"emit_map_elt_val","","",7],[10,"clone","rbml","",0],[10,"new","","",0],[10,"get","","",0],[10,"as_str_slice","","",0],[10,"as_str","","",0],[10,"fmt","","",2],[10,"fmt","","",3]],"paths":[[1,"Doc"],[1,"TaggedDoc"],[2,"EbmlEncoderTag"],[2,"Error"],[1,"SeekableMemWriter"],[1,"Res"],[1,"Decoder"],[1,"Encoder"]]};

searchIndex['core'] = {"items":[[0,"","core","# The Rust Core Library"],[0,"int","","Operations and constants for architecture-sized signed integers (`int` type)"],[5,"BITS","core::int",""],[5,"BYTES","",""],[5,"MIN","",""],[5,"MAX","",""],[16,"int","","Operations and constants for architecture-sized signed integers (`int` type)"],[0,"i8","core","Operations and constants for signed 8-bits integers (`i8` type)"],[5,"BITS","core::i8",""],[5,"BYTES","",""],[5,"MIN","",""],[5,"MAX","",""],[16,"i8","","Operations and constants for signed 8-bits integers (`i8` type)"],[0,"i16","core","Operations and constants for signed 16-bits integers (`i16` type)"],[5,"BITS","core::i16",""],[5,"BYTES","",""],[5,"MIN","",""],[5,"MAX","",""],[16,"i16","","Operations and constants for signed 16-bits integers (`i16` type)"],[0,"i32","core","Operations and constants for signed 32-bits integers (`i32` type)"],[5,"BITS","core::i32",""],[5,"BYTES","",""],[5,"MIN","",""],[5,"MAX","",""],[16,"i32","","Operations and constants for signed 32-bits integers (`i32` type)"],[0,"i64","core","Operations and constants for signed 64-bits integers (`i64` type)"],[5,"BITS","core::i64",""],[5,"BYTES","",""],[5,"MIN","",""],[5,"MAX","",""],[16,"i64","","Operations and constants for signed 64-bits integers (`i64` type)"],[0,"uint","core","Operations and constants for architecture-sized unsigned integers (`uint` type)"],[5,"BITS","core::uint",""],[5,"BYTES","",""],[5,"MIN","",""],[5,"MAX","",""],[16,"uint","","Operations and constants for architecture-sized unsigned integers (`uint` type)"],[0,"u8","core","Operations and constants for unsigned 8-bits integers (`u8` type)"],[5,"BITS","core::u8",""],[5,"BYTES","",""],[5,"MIN","",""],[5,"MAX","",""],[16,"u8","","Operations and constants for unsigned 8-bits integers (`u8` type)"],[0,"u16","core","Operations and constants for unsigned 16-bits integers (`u16` type)"],[5,"BITS","core::u16",""],[5,"BYTES","",""],[5,"MIN","",""],[5,"MAX","",""],[16,"u16","","Operations and constants for unsigned 16-bits integers (`u16` type)"],[0,"u32","core","Operations and constants for unsigned 32-bits integers (`u32` type)"],[5,"BITS","core::u32",""],[5,"BYTES","",""],[5,"MIN","",""],[5,"MAX","",""],[16,"u32","","Operations and constants for unsigned 32-bits integers (`u32` type)"],[0,"u64","core","Operations and constants for unsigned 64-bits integer (`u64` type)"],[5,"BITS","core::u64",""],[5,"BYTES","",""],[5,"MIN","",""],[5,"MAX","",""],[16,"u64","","Operations and constants for unsigned 64-bits integer (`u64` type)"],[0,"f32","core","Operations and constants for 32-bits floats (`f32` type)"],[0,"consts","core::f32","Various useful constants."],[5,"PI","core::f32::consts","Archimedes' constant"],[5,"PI_2","","pi * 2.0"],[5,"FRAC_PI_2","","pi/2.0"],[5,"FRAC_PI_3","","pi/3.0"],[5,"FRAC_PI_4","","pi/4.0"],[5,"FRAC_PI_6","","pi/6.0"],[5,"FRAC_PI_8","","pi/8.0"],[5,"FRAC_1_PI","","1.0/pi"],[5,"FRAC_2_PI","","2.0/pi"],[5,"FRAC_2_SQRTPI","","2.0/sqrt(pi)"],[5,"SQRT2","","sqrt(2.0)"],[5,"FRAC_1_SQRT2","","1.0/sqrt(2.0)"],[5,"E","","Euler's number"],[5,"LOG2_E","","log2(e)"],[5,"LOG10_E","","log10(e)"],[5,"LN_2","","ln(2.0)"],[5,"LN_10","","ln(10.0)"],[5,"RADIX","core::f32",""],[5,"MANTISSA_DIGITS","",""],[5,"DIGITS","",""],[5,"EPSILON","",""],[5,"MIN_VALUE","","Smallest finite f32 value"],[5,"MIN_POS_VALUE","","Smallest positive, normalized f32 value"],[5,"MAX_VALUE","","Largest finite f32 value"],[5,"MIN_EXP","",""],[5,"MAX_EXP","",""],[5,"MIN_10_EXP","",""],[5,"MAX_10_EXP","",""],[5,"NAN","",""],[5,"INFINITY","",""],[5,"NEG_INFINITY","",""],[16,"f32","","Operations and constants for 32-bits floats (`f32` type)"],[0,"f64","core","Operations and constants for 64-bits floats (`f64` type)"],[0,"consts","core::f64","Various useful constants."],[5,"PI","core::f64::consts","Archimedes' constant"],[5,"PI_2","","pi * 2.0"],[5,"FRAC_PI_2","","pi/2.0"],[5,"FRAC_PI_3","","pi/3.0"],[5,"FRAC_PI_4","","pi/4.0"],[5,"FRAC_PI_6","","pi/6.0"],[5,"FRAC_PI_8","","pi/8.0"],[5,"FRAC_1_PI","","1.0/pi"],[5,"FRAC_2_PI","","2.0/pi"],[5,"FRAC_2_SQRTPI","","2.0/sqrt(pi)"],[5,"SQRT2","","sqrt(2.0)"],[5,"FRAC_1_SQRT2","","1.0/sqrt(2.0)"],[5,"E","","Euler's number"],[5,"LOG2_E","","log2(e)"],[5,"LOG10_E","","log10(e)"],[5,"LN_2","","ln(2.0)"],[5,"LN_10","","ln(10.0)"],[5,"RADIX","core::f64",""],[5,"MANTISSA_DIGITS","",""],[5,"DIGITS","",""],[5,"EPSILON","",""],[5,"MIN_VALUE","","Smallest finite f64 value"],[5,"MIN_POS_VALUE","","Smallest positive, normalized f64 value"],[5,"MAX_VALUE","","Largest finite f64 value"],[5,"MIN_EXP","",""],[5,"MAX_EXP","",""],[5,"MIN_10_EXP","",""],[5,"MAX_10_EXP","",""],[5,"NAN","",""],[5,"INFINITY","",""],[5,"NEG_INFINITY","",""],[16,"f64","","Operations and constants for 64-bits floats (`f64` type)"],[0,"num","core","Numeric traits and functions for generic mathematics"],[2,"FPCategory","core::num","Used for representing the classification of floating point numbers"],[12,"FPNaN","","\"Not a Number\", often obtained by dividing by zero",0],[12,"FPInfinite","","Positive or negative infinity",0],[12,"FPZero","","Positive or negative zero",0],[12,"FPSubnormal","","De-normalized floating point representation (less precise than `FPNormal`)",0],[12,"FPNormal","","A regular floating point number",0],[3,"div_rem","","Simultaneous division and remainder"],[3,"zero","","Returns the additive identity, `0`."],[3,"one","","Returns the multiplicative identity, `1`."],[3,"abs","","Computes the absolute value."],[3,"abs_sub","","The positive difference of two numbers."],[3,"signum","","Returns the sign of the number."],[3,"pow","","Raises a value to the power of exp, using exponentiation by squaring."],[3,"next_power_of_two","","Returns the smallest power of 2 greater than or equal to `n`."],[3,"is_power_of_two","",""],[3,"checked_next_power_of_two","","Returns the smallest power of 2 greater than or equal to `n`. If the next\npower of two is greater than the type's maximum value, `None` is returned,\notherwise the power of 2 is wrapped in `Some`."],[3,"from_int","","A utility function that just calls `FromPrimitive::from_int`."],[3,"from_i8","","A utility function that just calls `FromPrimitive::from_i8`."],[3,"from_i16","","A utility function that just calls `FromPrimitive::from_i16`."],[3,"from_i32","","A utility function that just calls `FromPrimitive::from_i32`."],[3,"from_i64","","A utility function that just calls `FromPrimitive::from_i64`."],[3,"from_uint","","A utility function that just calls `FromPrimitive::from_uint`."],[3,"from_u8","","A utility function that just calls `FromPrimitive::from_u8`."],[3,"from_u16","","A utility function that just calls `FromPrimitive::from_u16`."],[3,"from_u32","","A utility function that just calls `FromPrimitive::from_u32`."],[3,"from_u64","","A utility function that just calls `FromPrimitive::from_u64`."],[3,"from_f32","","A utility function that just calls `FromPrimitive::from_f32`."],[3,"from_f64","","A utility function that just calls `FromPrimitive::from_f64`."],[3,"cast","","Cast from one machine scalar to another."],[6,"Num","","The base trait for numeric types"],[6,"Zero","","Defines an additive identity element for `Self`."],[9,"zero","","Returns the additive identity element of `Self`, `0`.",1],[9,"is_zero","","Returns `true` if `self` is equal to the additive identity.",1],[6,"One","","Defines a multiplicative identity element for `Self`."],[9,"one","","Returns the multiplicative identity element of `Self`, `1`.",2],[6,"Signed","","Useful functions for signed numbers (i.e. numbers that can be negative)."],[9,"abs","","Computes the absolute value.",3],[9,"abs_sub","","The positive difference of two numbers.",3],[9,"signum","","Returns the sign of the number.",3],[9,"is_positive","","Returns true if the number is positive and false if the number is zero or negative.",3],[9,"is_negative","","Returns true if the number is negative and false if the number is zero or positive.",3],[6,"Unsigned","","A trait for values which cannot be negative"],[6,"Bounded","","Numbers which have upper and lower bounds"],[9,"min_value","","returns the smallest finite number this type can represent",4],[9,"max_value","","returns the largest finite number this type can represent",4],[6,"Primitive","","Specifies the available operations common to all of Rust's core numeric primitives.\nThese may not always make sense from a purely mathematical point of view, but\nmay be useful for systems programming."],[6,"Int","","A primitive signed or unsigned integer equipped with various bitwise\noperators, bit counting methods, and endian conversion functions."],[9,"count_ones","","Returns the number of ones in the binary representation of the integer.",5],[10,"count_zeros","","Returns the number of zeros in the binary representation of the integer.",5],[9,"leading_zeros","","Returns the number of leading zeros in the binary representation\nof the integer.",5],[9,"trailing_zeros","","Returns the number of trailing zeros in the binary representation\nof the integer.",5],[9,"rotate_left","","Shifts the bits to the left by a specified amount amount, `n`, wrapping\nthe truncated bits to the end of the resulting integer.",5],[9,"rotate_right","","Shifts the bits to the right by a specified amount amount, `n`, wrapping\nthe truncated bits to the beginning of the resulting integer.",5],[9,"swap_bytes","","Reverses the byte order of the integer.",5],[10,"from_be","","Convert a integer from big endian to the target's endianness.",5],[10,"from_le","","Convert a integer from little endian to the target's endianness.",5],[10,"to_be","","Convert the integer to big endian from the target's endianness.",5],[10,"to_le","","Convert the integer to little endian from the target's endianness.",5],[6,"ToPrimitive","","A generic trait for converting a value to a number."],[10,"to_int","","Converts the value of `self` to an `int`.",6],[10,"to_i8","","Converts the value of `self` to an `i8`.",6],[10,"to_i16","","Converts the value of `self` to an `i16`.",6],[10,"to_i32","","Converts the value of `self` to an `i32`.",6],[9,"to_i64","","Converts the value of `self` to an `i64`.",6],[10,"to_uint","","Converts the value of `self` to an `uint`.",6],[10,"to_u8","","Converts the value of `self` to an `u8`.",6],[10,"to_u16","","Converts the value of `self` to an `u16`.",6],[10,"to_u32","","Converts the value of `self` to an `u32`.",6],[9,"to_u64","","Converts the value of `self` to an `u64`.",6],[10,"to_f32","","Converts the value of `self` to an `f32`.",6],[10,"to_f64","","Converts the value of `self` to an `f64`.",6],[6,"FromPrimitive","","A generic trait for converting a number to a value."],[10,"from_int","","Convert an `int` to return an optional value of this type. If the\nvalue cannot be represented by this value, the `None` is returned.",7],[10,"from_i8","","Convert an `i8` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",7],[10,"from_i16","","Convert an `i16` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",7],[10,"from_i32","","Convert an `i32` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",7],[9,"from_i64","","Convert an `i64` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",7],[10,"from_uint","","Convert an `uint` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",7],[10,"from_u8","","Convert an `u8` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",7],[10,"from_u16","","Convert an `u16` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",7],[10,"from_u32","","Convert an `u32` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",7],[9,"from_u64","","Convert an `u64` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",7],[10,"from_f32","","Convert a `f32` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",7],[10,"from_f64","","Convert a `f64` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",7],[6,"NumCast","","An interface for casting between machine scalars."],[9,"from","","Creates a number from another value that can be converted into a primitive via the\n`ToPrimitive` trait.",8],[6,"Saturating","","Saturating math operations"],[9,"saturating_add","","Saturating addition operator.\nReturns a+b, saturating at the numeric bounds instead of overflowing.",9],[9,"saturating_sub","","Saturating subtraction operator.\nReturns a-b, saturating at the numeric bounds instead of overflowing.",9],[6,"CheckedAdd","","Performs addition that returns `None` instead of wrapping around on overflow."],[9,"checked_add","","Adds two numbers, checking for overflow. If overflow happens, `None` is returned.",10],[6,"CheckedSub","","Performs subtraction that returns `None` instead of wrapping around on underflow."],[9,"checked_sub","","Subtracts two numbers, checking for underflow. If underflow happens, `None` is returned.",11],[6,"CheckedMul","","Performs multiplication that returns `None` instead of wrapping around on underflow or\noverflow."],[9,"checked_mul","","Multiplies two numbers, checking for underflow or overflow. If underflow or overflow\nhappens, `None` is returned.",12],[6,"CheckedDiv","","Performs division that returns `None` instead of wrapping around on underflow or overflow."],[9,"checked_div","","Divides two numbers, checking for underflow or overflow. If underflow or overflow happens,\n`None` is returned.",13],[6,"Float","","Operations on primitive floating point numbers."],[9,"nan","","Returns the NaN value.",14],[9,"infinity","","Returns the infinite value.",14],[9,"neg_infinity","","Returns the negative infinite value.",14],[9,"neg_zero","","Returns -0.0.",14],[9,"is_nan","","Returns true if this value is NaN and false otherwise.",14],[9,"is_infinite","","Returns true if this value is positive infinity or negative infinity and\nfalse otherwise.",14],[9,"is_finite","","Returns true if this number is neither infinite nor NaN.",14],[9,"is_normal","","Returns true if this number is neither zero, infinite, denormal, or NaN.",14],[9,"classify","","Returns the category that this number falls into.",14],[9,"mantissa_digits","","Returns the number of binary digits of mantissa that this type supports.",14],[9,"digits","","Returns the number of base-10 digits of precision that this type supports.",14],[9,"epsilon","","Returns the difference between 1.0 and the smallest representable number larger than 1.0.",14],[9,"min_exp","","Returns the minimum binary exponent that this type can represent.",14],[9,"max_exp","","Returns the maximum binary exponent that this type can represent.",14],[9,"min_10_exp","","Returns the minimum base-10 exponent that this type can represent.",14],[9,"max_10_exp","","Returns the maximum base-10 exponent that this type can represent.",14],[9,"min_pos_value","","Returns the smallest normalized positive number that this type can represent.",14],[9,"integer_decode","","Returns the mantissa, exponent and sign as integers, respectively.",14],[9,"floor","","Return the largest integer less than or equal to a number.",14],[9,"ceil","","Return the smallest integer greater than or equal to a number.",14],[9,"round","","Return the nearest integer to a number. Round half-way cases away from\n`0.0`.",14],[9,"trunc","","Return the integer part of a number.",14],[9,"fract","","Return the fractional part of a number.",14],[9,"mul_add","","Fused multiply-add. Computes `(self * a) + b` with only one rounding\nerror. This produces a more accurate result with better performance than\na separate multiplication operation followed by an add.",14],[9,"recip","","Take the reciprocal (inverse) of a number, `1/x`.",14],[9,"powi","","Raise a number to an integer power.",14],[9,"powf","","Raise a number to a floating point power.",14],[9,"sqrt2","","sqrt(2.0).",14],[9,"frac_1_sqrt2","","1.0 / sqrt(2.0).",14],[9,"sqrt","","Take the square root of a number.",14],[9,"rsqrt","","Take the reciprocal (inverse) square root of a number, `1/sqrt(x)`.",14],[9,"pi","","Archimedes' constant.",14],[9,"two_pi","","2.0 * pi.",14],[9,"frac_pi_2","","pi / 2.0.",14],[9,"frac_pi_3","","pi / 3.0.",14],[9,"frac_pi_4","","pi / 4.0.",14],[9,"frac_pi_6","","pi / 6.0.",14],[9,"frac_pi_8","","pi / 8.0.",14],[9,"frac_1_pi","","1.0 / pi.",14],[9,"frac_2_pi","","2.0 / pi.",14],[9,"frac_2_sqrtpi","","2.0 / sqrt(pi).",14],[9,"e","","Euler's number.",14],[9,"log2_e","","log2(e).",14],[9,"log10_e","","log10(e).",14],[9,"ln_2","","ln(2.0).",14],[9,"ln_10","","ln(10.0).",14],[9,"exp","","Returns `e^(self)`, (the exponential function).",14],[9,"exp2","","Returns 2 raised to the power of the number, `2^(self)`.",14],[9,"ln","","Returns the natural logarithm of the number.",14],[9,"log","","Returns the logarithm of the number with respect to an arbitrary base.",14],[9,"log2","","Returns the base 2 logarithm of the number.",14],[9,"log10","","Returns the base 10 logarithm of the number.",14],[9,"to_degrees","","Convert radians to degrees.",14],[9,"to_radians","","Convert degrees to radians.",14],[10,"fmt","","",0],[10,"eq","","",0],[10,"ne","","",0],[0,"prelude","core","The core prelude"],[0,"intrinsics","","rustc compiler intrinsics."],[1,"TyDesc","core::intrinsics",""],[11,"size","","",15],[11,"align","","",15],[11,"drop_glue","","",15],[11,"visit_glue","","",15],[11,"name","","",15],[1,"TypeId","","`TypeId` represents a globally unique identifier for a type"],[2,"Opaque","",""],[13,"atomic_cxchg","",""],[13,"atomic_cxchg_acq","",""],[13,"atomic_cxchg_rel","",""],[13,"atomic_cxchg_acqrel","",""],[13,"atomic_cxchg_relaxed","",""],[13,"atomic_load","",""],[13,"atomic_load_acq","",""],[13,"atomic_load_relaxed","",""],[13,"atomic_store","",""],[13,"atomic_store_rel","",""],[13,"atomic_store_relaxed","",""],[13,"atomic_xchg","",""],[13,"atomic_xchg_acq","",""],[13,"atomic_xchg_rel","",""],[13,"atomic_xchg_acqrel","",""],[13,"atomic_xchg_relaxed","",""],[13,"atomic_xadd","",""],[13,"atomic_xadd_acq","",""],[13,"atomic_xadd_rel","",""],[13,"atomic_xadd_acqrel","",""],[13,"atomic_xadd_relaxed","",""],[13,"atomic_xsub","",""],[13,"atomic_xsub_acq","",""],[13,"atomic_xsub_rel","",""],[13,"atomic_xsub_acqrel","",""],[13,"atomic_xsub_relaxed","",""],[13,"atomic_and","",""],[13,"atomic_and_acq","",""],[13,"atomic_and_rel","",""],[13,"atomic_and_acqrel","",""],[13,"atomic_and_relaxed","",""],[13,"atomic_nand","",""],[13,"atomic_nand_acq","",""],[13,"atomic_nand_rel","",""],[13,"atomic_nand_acqrel","",""],[13,"atomic_nand_relaxed","",""],[13,"atomic_or","",""],[13,"atomic_or_acq","",""],[13,"atomic_or_rel","",""],[13,"atomic_or_acqrel","",""],[13,"atomic_or_relaxed","",""],[13,"atomic_xor","",""],[13,"atomic_xor_acq","",""],[13,"atomic_xor_rel","",""],[13,"atomic_xor_acqrel","",""],[13,"atomic_xor_relaxed","",""],[13,"atomic_max","",""],[13,"atomic_max_acq","",""],[13,"atomic_max_rel","",""],[13,"atomic_max_acqrel","",""],[13,"atomic_max_relaxed","",""],[13,"atomic_min","",""],[13,"atomic_min_acq","",""],[13,"atomic_min_rel","",""],[13,"atomic_min_acqrel","",""],[13,"atomic_min_relaxed","",""],[13,"atomic_umin","",""],[13,"atomic_umin_acq","",""],[13,"atomic_umin_rel","",""],[13,"atomic_umin_acqrel","",""],[13,"atomic_umin_relaxed","",""],[13,"atomic_umax","",""],[13,"atomic_umax_acq","",""],[13,"atomic_umax_rel","",""],[13,"atomic_umax_acqrel","",""],[13,"atomic_umax_relaxed","",""],[13,"atomic_fence","",""],[13,"atomic_fence_acq","",""],[13,"atomic_fence_rel","",""],[13,"atomic_fence_acqrel","",""],[13,"abort","","Abort the execution of the process."],[13,"breakpoint","","Execute a breakpoint trap, for inspection by a debugger."],[13,"size_of","","The size of a type in bytes."],[13,"move_val_init","","Move a value to an uninitialized memory location."],[13,"min_align_of","",""],[13,"pref_align_of","",""],[13,"get_tydesc","","Get a static pointer to a type descriptor."],[13,"type_id","","Gets an identifier which is globally unique to the specified type. This\nfunction will return the same value for a type regardless of whichever\ncrate it is invoked in."],[13,"init","","Create a value initialized to zero."],[13,"uninit","","Create an uninitialized value."],[13,"forget","","Move a value out of scope without running drop glue."],[13,"transmute","","Unsafely transforms a value of one type into a value of another type."],[13,"needs_drop","","Returns `true` if a type requires drop glue."],[13,"owns_managed","","Returns `true` if a type is managed (will be allocated on the local heap)"],[13,"visit_tydesc","",""],[13,"offset","","Calculates the offset from a pointer. The offset *must* be in-bounds of\nthe object, or one-byte-past-the-end. An arithmetic overflow is also\nundefined behaviour."],[13,"copy_nonoverlapping_memory","","Copies data from one location to another."],[13,"copy_memory","","Copies data from one location to another."],[13,"set_memory","","Invokes memset on the specified pointer, setting `count * size_of::<T>()`\nbytes of memory starting at `dst` to `c`."],[13,"volatile_copy_nonoverlapping_memory","","Equivalent to the appropriate `llvm.memcpy.p0i8.0i8.*` intrinsic, with\na size of `count` * `size_of::<T>()` and an alignment of\n`min_align_of::<T>()`"],[13,"volatile_copy_memory","","Equivalent to the appropriate `llvm.memmove.p0i8.0i8.*` intrinsic, with\na size of `count` * `size_of::<T>()` and an alignment of\n`min_align_of::<T>()`"],[13,"volatile_set_memory","","Equivalent to the appropriate `llvm.memset.p0i8.*` intrinsic, with a\nsize of `count` * `size_of::<T>()` and an alignment of\n`min_align_of::<T>()`."],[13,"volatile_load","","Perform a volatile load from the `src` pointer."],[13,"volatile_store","","Perform a volatile store to the `dst` pointer."],[13,"sqrtf32","","Returns the square root of an `f32`"],[13,"sqrtf64","","Returns the square root of an `f64`"],[13,"powif32","","Raises an `f32` to an integer power."],[13,"powif64","","Raises an `f64` to an integer power."],[13,"sinf32","","Returns the sine of an `f32`."],[13,"sinf64","","Returns the sine of an `f64`."],[13,"cosf32","","Returns the cosine of an `f32`."],[13,"cosf64","","Returns the cosine of an `f64`."],[13,"powf32","","Raises an `f32` to an `f32` power."],[13,"powf64","","Raises an `f64` to an `f64` power."],[13,"expf32","","Returns the exponential of an `f32`."],[13,"expf64","","Returns the exponential of an `f64`."],[13,"exp2f32","","Returns 2 raised to the power of an `f32`."],[13,"exp2f64","","Returns 2 raised to the power of an `f64`."],[13,"logf32","","Returns the natural logarithm of an `f32`."],[13,"logf64","","Returns the natural logarithm of an `f64`."],[13,"log10f32","","Returns the base 10 logarithm of an `f32`."],[13,"log10f64","","Returns the base 10 logarithm of an `f64`."],[13,"log2f32","","Returns the base 2 logarithm of an `f32`."],[13,"log2f64","","Returns the base 2 logarithm of an `f64`."],[13,"fmaf32","","Returns `a * b + c` for `f32` values."],[13,"fmaf64","","Returns `a * b + c` for `f64` values."],[13,"fabsf32","","Returns the absolute value of an `f32`."],[13,"fabsf64","","Returns the absolute value of an `f64`."],[13,"copysignf32","","Copies the sign from `y` to `x` for `f32` values."],[13,"copysignf64","","Copies the sign from `y` to `x` for `f64` values."],[13,"floorf32","","Returns the largest integer less than or equal to an `f32`."],[13,"floorf64","","Returns the largest integer less than or equal to an `f64`."],[13,"ceilf32","","Returns the smallest integer greater than or equal to an `f32`."],[13,"ceilf64","","Returns the smallest integer greater than or equal to an `f64`."],[13,"truncf32","","Returns the integer part of an `f32`."],[13,"truncf64","","Returns the integer part of an `f64`."],[13,"rintf32","","Returns the nearest integer to an `f32`. May raise an inexact floating-point exception\nif the argument is not an integer."],[13,"rintf64","","Returns the nearest integer to an `f64`. May raise an inexact floating-point exception\nif the argument is not an integer."],[13,"nearbyintf32","","Returns the nearest integer to an `f32`."],[13,"nearbyintf64","","Returns the nearest integer to an `f64`."],[13,"roundf32","","Returns the nearest integer to an `f32`. Rounds half-way cases away from zero."],[13,"roundf64","","Returns the nearest integer to an `f64`. Rounds half-way cases away from zero."],[13,"ctpop8","","Returns the number of bits set in a `u8`."],[13,"ctpop16","","Returns the number of bits set in a `u16`."],[13,"ctpop32","","Returns the number of bits set in a `u32`."],[13,"ctpop64","","Returns the number of bits set in a `u64`."],[13,"ctlz8","","Returns the number of leading bits unset in a `u8`."],[13,"ctlz16","","Returns the number of leading bits unset in a `u16`."],[13,"ctlz32","","Returns the number of leading bits unset in a `u32`."],[13,"ctlz64","","Returns the number of leading bits unset in a `u64`."],[13,"cttz8","","Returns the number of trailing bits unset in a `u8`."],[13,"cttz16","","Returns the number of trailing bits unset in a `u16`."],[13,"cttz32","","Returns the number of trailing bits unset in a `u32`."],[13,"cttz64","","Returns the number of trailing bits unset in a `u64`."],[13,"bswap16","","Reverses the bytes in a `u16`."],[13,"bswap32","","Reverses the bytes in a `u32`."],[13,"bswap64","","Reverses the bytes in a `u64`."],[13,"i8_add_with_overflow","","Performs checked `i8` addition."],[13,"i16_add_with_overflow","","Performs checked `i16` addition."],[13,"i32_add_with_overflow","","Performs checked `i32` addition."],[13,"i64_add_with_overflow","","Performs checked `i64` addition."],[13,"u8_add_with_overflow","","Performs checked `u8` addition."],[13,"u16_add_with_overflow","","Performs checked `u16` addition."],[13,"u32_add_with_overflow","","Performs checked `u32` addition."],[13,"u64_add_with_overflow","","Performs checked `u64` addition."],[13,"i8_sub_with_overflow","","Performs checked `i8` subtraction."],[13,"i16_sub_with_overflow","","Performs checked `i16` subtraction."],[13,"i32_sub_with_overflow","","Performs checked `i32` subtraction."],[13,"i64_sub_with_overflow","","Performs checked `i64` subtraction."],[13,"u8_sub_with_overflow","","Performs checked `u8` subtraction."],[13,"u16_sub_with_overflow","","Performs checked `u16` subtraction."],[13,"u32_sub_with_overflow","","Performs checked `u32` subtraction."],[13,"u64_sub_with_overflow","","Performs checked `u64` subtraction."],[13,"i8_mul_with_overflow","","Performs checked `i8` multiplication."],[13,"i16_mul_with_overflow","","Performs checked `i16` multiplication."],[13,"i32_mul_with_overflow","","Performs checked `i32` multiplication."],[13,"i64_mul_with_overflow","","Performs checked `i64` multiplication."],[13,"u8_mul_with_overflow","","Performs checked `u8` multiplication."],[13,"u16_mul_with_overflow","","Performs checked `u16` multiplication."],[13,"u32_mul_with_overflow","","Performs checked `u32` multiplication."],[13,"u64_mul_with_overflow","","Performs checked `u64` multiplication."],[4,"GlueFn","",""],[4,"Disr","",""],[6,"TyVisitor","",""],[9,"visit_bot","","",16],[9,"visit_nil","","",16],[9,"visit_bool","","",16],[9,"visit_int","","",16],[9,"visit_i8","","",16],[9,"visit_i16","","",16],[9,"visit_i32","","",16],[9,"visit_i64","","",16],[9,"visit_uint","","",16],[9,"visit_u8","","",16],[9,"visit_u16","","",16],[9,"visit_u32","","",16],[9,"visit_u64","","",16],[9,"visit_f32","","",16],[9,"visit_f64","","",16],[9,"visit_char","","",16],[9,"visit_estr_slice","","",16],[9,"visit_estr_fixed","","",16],[9,"visit_box","","",16],[9,"visit_uniq","","",16],[9,"visit_ptr","","",16],[9,"visit_rptr","","",16],[9,"visit_evec_slice","","",16],[9,"visit_evec_fixed","","",16],[9,"visit_enter_rec","","",16],[9,"visit_rec_field","","",16],[9,"visit_leave_rec","","",16],[9,"visit_enter_class","","",16],[9,"visit_class_field","","",16],[9,"visit_leave_class","","",16],[9,"visit_enter_tup","","",16],[9,"visit_tup_field","","",16],[9,"visit_leave_tup","","",16],[9,"visit_enter_enum","","",16],[9,"visit_enter_enum_variant","","",16],[9,"visit_enum_variant_field","","",16],[9,"visit_leave_enum_variant","","",16],[9,"visit_leave_enum","","",16],[9,"visit_enter_fn","","",16],[9,"visit_fn_input","","",16],[9,"visit_fn_output","","",16],[9,"visit_leave_fn","","",16],[9,"visit_trait","","",16],[9,"visit_param","","",16],[9,"visit_self","","",16],[10,"fmt","","",17],[10,"eq","","",17],[10,"ne","","",17],[10,"of","","Returns the `TypeId` of the type this generic function has been instantiated with",17],[10,"hash","","",17],[0,"mem","core","Basic functions for dealing with memory"],[3,"size_of","core::mem","Returns the size of a type in bytes."],[3,"size_of_val","","Returns the size of the type that `_val` points to in bytes."],[3,"nonzero_size_of","","Deprecated, this function will be removed soon"],[3,"nonzero_size_of_val","","Deprecated, this function will be removed soon"],[3,"min_align_of","","Returns the ABI-required minimum alignment of a type"],[3,"min_align_of_val","","Returns the ABI-required minimum alignment of the type of the value that\n`_val` points to"],[3,"align_of","","Returns the alignment in memory for a type."],[3,"align_of_val","","Returns the alignment of the type of the value that `_val` points to."],[3,"pref_align_of","","Deprecated, this function has been renamed to align_of"],[3,"pref_align_of_val","","Deprecated, this function has been renamed to align_of_val"],[3,"zeroed","","Create a value initialized to zero."],[3,"init","","Deprecated, use zeroed() instead"],[3,"uninitialized","","Create an uninitialized value."],[3,"uninit","","Deprecated, use `uninitialized` instead."],[3,"overwrite","","Unsafely overwrite a memory location with the given value without destroying\nthe old value."],[3,"move_val_init","","Deprecated, use `overwrite` instead"],[3,"to_le16","","Convert an u16 to little endian from the target's endianness."],[3,"to_le32","","Convert an u32 to little endian from the target's endianness."],[3,"to_le64","","Convert an u64 to little endian from the target's endianness."],[3,"to_be16","","Convert an u16 to big endian from the target's endianness."],[3,"to_be32","","Convert an u32 to big endian from the target's endianness."],[3,"to_be64","","Convert an u64 to big endian from the target's endianness."],[3,"from_le16","","Convert an u16 from little endian to the target's endianness."],[3,"from_le32","","Convert an u32 from little endian to the target's endianness."],[3,"from_le64","","Convert an u64 from little endian to the target's endianness."],[3,"from_be16","","Convert an u16 from big endian to the target's endianness."],[3,"from_be32","","Convert an u32 from big endian to the target's endianness."],[3,"from_be64","","Convert an u64 from big endian to the target's endianness."],[3,"swap","","Swap the values at two mutable locations of the same type, without\ndeinitialising or copying either one."],[3,"replace","","Replace the value at a mutable location with a new one, returning the old\nvalue, without deinitialising or copying either one."],[3,"drop","","Disposes of a value."],[3,"forget","","Moves a thing into the void."],[3,"transmute_copy","","Interprets `src` as `&U`, and then reads `src` without moving the contained\nvalue."],[3,"copy_lifetime","","Transforms lifetime of the second pointer to match the first."],[3,"copy_mut_lifetime","","Transforms lifetime of the second mutable pointer to match the first."],[0,"ptr","core","Operations on unsafe pointers, `*const T`, and `*mut T`."],[3,"null","core::ptr","Create a null pointer."],[3,"mut_null","","Create an unsafe mutable null pointer."],[3,"zero_memory","","Zeroes out `count * size_of::<T>` bytes of memory at `dst`"],[3,"swap","","Swap the values at two mutable locations of the same type, without\ndeinitialising either. They may overlap."],[3,"replace","","Replace the value at a mutable location with a new one, returning the old\nvalue, without deinitialising either."],[3,"read","","Reads the value from `*src` and returns it."],[3,"read_and_zero","","Reads the value from `*src` and nulls it out.\nThis currently prevents destructors from executing."],[3,"write","","Unsafely overwrite a memory location with the given value without destroying\nthe old value."],[3,"array_each_with_len","","Given a *const *const T (pointer to an array of pointers),\niterate through each *const T, up to the provided `len`,\npassing to the provided callback function"],[3,"array_each","","Given a null-pointer-terminated *const *const T (pointer to\nan array of pointers), iterate through each *const T,\npassing to the provided callback function"],[3,"buf_len","","Return the offset of the first null pointer in `buf`."],[3,"position","","Return the first offset `i` such that `f(buf[i]) == true`."],[6,"RawPtr","","Methods on raw pointers"],[9,"null","","Returns the null pointer.",18],[9,"is_null","","Returns true if the pointer is equal to the null pointer.",18],[10,"is_not_null","","Returns true if the pointer is not equal to the null pointer.",18],[9,"to_uint","","Returns the value of this pointer (ie, the address it points to)",18],[9,"to_option","","Returns `None` if the pointer is null, or else returns the value wrapped\nin `Some`.",18],[9,"offset","","Calculates the offset from a pointer. The offset *must* be in-bounds of\nthe object, or one-byte-past-the-end.  `count` is in units of T; e.g. a\n`count` of 3 represents a pointer offset of `3 * sizeof::<T>()` bytes.",18],[0,"kinds","core","Primitive traits representing basic 'kinds' of types"],[0,"marker","core::kinds","Marker types are special types that are used with unsafe code to\ninform the compiler of special constraints. Marker types should\nonly be needed when you are creating an abstraction that is\nimplemented using unsafe code. In that case, you may want to embed\nsome of the marker types below into your type."],[1,"CovariantType","core::kinds::marker","A marker type whose type parameter `T` is considered to be\ncovariant with respect to the type itself. This is (typically)\nused to indicate that an instance of the type `T` is being stored\ninto memory and read from, even though that may not be apparent."],[1,"ContravariantType","","A marker type whose type parameter `T` is considered to be\ncontravariant with respect to the type itself. This is (typically)\nused to indicate that an instance of the type `T` will be consumed\n(but not read from), even though that may not be apparent."],[1,"InvariantType","","A marker type whose type parameter `T` is considered to be\ninvariant with respect to the type itself. This is (typically)\nused to indicate that instances of the type `T` may be read or\nwritten, even though that may not be apparent."],[1,"CovariantLifetime","","As `CovariantType`, but for lifetime parameters. Using\n`CovariantLifetime<'a>` indicates that it is ok to substitute\na *longer* lifetime for `'a` than the one you originally\nstarted with (e.g., you could convert any lifetime `'foo` to\n`'static`). You almost certainly want `ContravariantLifetime`\ninstead, or possibly `InvariantLifetime`. The only case where\nit would be appropriate is that you have a (type-casted, and\nhence hidden from the type system) function pointer with a\nsignature like `fn(&'a T)` (and no other uses of `'a`). In\nthis case, it is ok to substitute a larger lifetime for `'a`\n(e.g., `fn(&'static T)`), because the function is only\nbecoming more selective in terms of what it accepts as\nargument."],[1,"ContravariantLifetime","","As `ContravariantType`, but for lifetime parameters. Using\n`ContravariantLifetime<'a>` indicates that it is ok to\nsubstitute a *shorter* lifetime for `'a` than the one you\noriginally started with (e.g., you could convert `'static` to\nany lifetime `'foo`). This is appropriate for cases where you\nhave an unsafe pointer that is actually a pointer into some\nmemory with lifetime `'a`, and thus you want to limit the\nlifetime of your data structure to `'a`. An example of where\nthis is used is the iterator for vectors."],[1,"InvariantLifetime","","As `InvariantType`, but for lifetime parameters. Using\n`InvariantLifetime<'a>` indicates that it is not ok to\nsubstitute any other lifetime for `'a` besides its original\nvalue. This is appropriate for cases where you have an unsafe\npointer that is actually a pointer into memory with lifetime `'a`,\nand this pointer is itself stored in an inherently mutable\nlocation (such as a `Cell`)."],[1,"NoSend","","A type which is considered \"not sendable\", meaning that it cannot\nbe safely sent between tasks, even if it is owned. This is\ntypically embedded in other types, such as `Gc`, to ensure that\ntheir instances remain thread-local."],[1,"NoCopy","","A type which is considered \"not POD\", meaning that it is not\nimplicitly copyable. This is typically embedded in other types to\nensure that they are never copied, even if they lack a destructor."],[1,"NoShare","","A type which is considered \"not shareable\", meaning that\nits contents are not threadsafe, hence they cannot be\nshared between tasks."],[1,"Managed","","A type which is considered managed by the GC. This is typically\nembedded in other types."],[10,"clone","","",19],[10,"eq","","",19],[10,"ne","","",19],[10,"clone","","",20],[10,"eq","","",20],[10,"ne","","",20],[10,"clone","","",21],[10,"eq","","",21],[10,"ne","","",21],[10,"clone","","",22],[10,"eq","","",22],[10,"ne","","",22],[10,"clone","","",23],[10,"eq","","",23],[10,"ne","","",23],[10,"clone","","",24],[10,"eq","","",24],[10,"ne","","",24],[10,"clone","","",25],[10,"eq","","",25],[10,"ne","","",25],[10,"clone","","",26],[10,"eq","","",26],[10,"ne","","",26],[10,"clone","","",27],[10,"eq","","",27],[10,"ne","","",27],[10,"clone","","",28],[10,"eq","","",28],[10,"ne","","",28],[6,"Send","core::kinds","Types able to be transferred across task boundaries."],[6,"Sized","","Types with a constant size known at compile-time."],[6,"Copy","","Types that can be copied by simply copying bits (i.e. `memcpy`)."],[6,"Share","","Types that can be safely shared between tasks when aliased."],[0,"ops","core","\nOverloadable operators"],[6,"Drop","core::ops","\nThe `Drop` trait is used to run some code when a value goes out of scope. This\nis sometimes called a 'destructor'."],[9,"drop","","The `drop` method, called when the value goes out of scope.",29],[6,"Add","","\nThe `Add` trait is used to specify the functionality of `+`."],[9,"add","","The method for the `+` operator",30],[6,"Sub","","\nThe `Sub` trait is used to specify the functionality of `-`."],[9,"sub","","The method for the `-` operator",31],[6,"Mul","","\nThe `Mul` trait is used to specify the functionality of `*`."],[9,"mul","","The method for the `*` operator",32],[6,"Div","","\nThe `Div` trait is used to specify the functionality of `/`."],[9,"div","","The method for the `/` operator",33],[6,"Rem","","\nThe `Rem` trait is used to specify the functionality of `%`."],[9,"rem","","The method for the `%` operator",34],[6,"Neg","","\nThe `Neg` trait is used to specify the functionality of unary `-`."],[9,"neg","","The method for the unary `-` operator",35],[6,"Not","","\nThe `Not` trait is used to specify the functionality of unary `!`."],[9,"not","","The method for the unary `!` operator",36],[6,"BitAnd","","\nThe `BitAnd` trait is used to specify the functionality of `&`."],[9,"bitand","","The method for the `&` operator",37],[6,"BitOr","","\nThe `BitOr` trait is used to specify the functionality of `|`."],[9,"bitor","","The method for the `|` operator",38],[6,"BitXor","","\nThe `BitXor` trait is used to specify the functionality of `^`."],[9,"bitxor","","The method for the `^` operator",39],[6,"Shl","","\nThe `Shl` trait is used to specify the functionality of `<<`."],[9,"shl","","The method for the `<<` operator",40],[6,"Shr","","\nThe `Shr` trait is used to specify the functionality of `>>`."],[9,"shr","","The method for the `>>` operator",41],[6,"Index","","\nThe `Index` trait is used to specify the functionality of indexing operations\nlike `arr[idx]` when used in an immutable context."],[9,"index","","The method for the indexing (`Foo[Bar]`) operation",42],[6,"IndexMut","","\nThe `IndexMut` trait is used to specify the functionality of indexing\noperations like `arr[idx]`, when used in a mutable context."],[9,"index_mut","","The method for the indexing (`Foo[Bar]`) operation",43],[6,"Deref","","\nThe `Deref` trait is used to specify the functionality of dereferencing\noperations like `*v`."],[9,"deref","","The method called to dereference a value",44],[6,"DerefMut","","\nThe `DerefMut` trait is used to specify the functionality of dereferencing\nmutably like `*v = 1;`"],[9,"deref_mut","","The method called to mutably dereference a value",45],[6,"Fn","","A version of the call operator that takes an immutable receiver."],[9,"call","","This is called when the call operator is used.",46],[6,"FnMut","","A version of the call operator that takes a mutable receiver."],[9,"call_mut","","This is called when the call operator is used.",47],[6,"FnOnce","","A version of the call operator that takes a by-value receiver."],[9,"call_once","","This is called when the call operator is used.",48],[0,"cmp","core","Defines the `PartialOrd` and `PartialEq` comparison traits."],[2,"Ordering","core::cmp","An ordering is, e.g, a result of a comparison between two values."],[12,"Less","","An ordering where a compared value is less [than another].",49],[12,"Equal","","An ordering where a compared value is equal [to another].",49],[12,"Greater","","An ordering where a compared value is greater [than another].",49],[3,"lexical_ordering","","Combine orderings, lexically."],[3,"min","","Compare and return the minimum of two values."],[3,"max","","Compare and return the maximum of two values."],[6,"PartialEq","","Trait for values that can be compared for equality and inequality."],[9,"eq","","This method tests for `self` and `other` values to be equal, and is used by `==`.",50],[10,"ne","","This method tests for `!=`.",50],[6,"Eq","","Trait for equality comparisons which are [equivalence relations](\nhttps://en.wikipedia.org/wiki/Equivalence_relation)."],[6,"Ord","","Trait for types that form a [total order](\nhttps://en.wikipedia.org/wiki/Total_order)."],[9,"cmp","","This method returns an ordering between `self` and `other` values.",51],[6,"PartialOrd","","Trait for values that can be compared for a sort-order."],[9,"partial_cmp","","This method returns an ordering between `self` and `other` values\nif one exists.",52],[10,"lt","","This method tests less than (for `self` and `other`) and is used by the `<` operator.",52],[10,"le","","This method tests less than or equal to (`<=`).",52],[10,"gt","","This method tests greater than (`>`).",52],[10,"ge","","This method tests greater than or equal to (`>=`).",52],[6,"Equiv","","The equivalence relation. Two values may be equivalent even if they are\nof different types. The most common use case for this relation is\ncontainer types; e.g. it is often desirable to be able to use `&str`\nvalues to look up entries in a container with `String` keys."],[9,"equiv","","Implement this function to decide equivalent values.",53],[10,"fmt","","",49],[10,"eq","","",49],[10,"ne","","",49],[10,"clone","","",49],[10,"cmp","","",49],[10,"partial_cmp","","",49],[0,"clone","core","The `Clone` trait for types that cannot be 'implicitly copied'"],[6,"Clone","core::clone","A common trait for cloning an object."],[9,"clone","","Returns a copy of the value. The contents of owned pointers\nare copied to maintain uniqueness, while the contents of\nmanaged pointers are not copied.",54],[10,"clone_from","","Perform copy-assignment from `source`.",54],[0,"default","core","The `Default` trait for types which may have meaningful default values"],[6,"Default","core::default","A trait that types which have a useful default value should implement."],[9,"default","","Return the \"default value\" for a type.",55],[0,"collections","core","Traits for generic collections"],[6,"Collection","core::collections","A trait to represent the abstract idea of a container. The only concrete\nknowledge known is the number of elements contained within."],[9,"len","","Return the number of elements in the container",56],[10,"is_empty","","Return true if the container contains no elements",56],[0,"ty","core","Deprecated module in favor of `std::cell`"],[0,"any","","Traits for dynamic typing of any `'static` type (through runtime reflection)"],[2,"Void","core::any","A type with no inhabitants"],[6,"Any","","The `Any` trait is implemented by all `'static` types, and can be used for\ndynamic typing"],[6,"AnyPrivate","","An inner trait to ensure that only this module can call `get_type_id()`."],[9,"get_type_id","","Get the `TypeId` of `self`",57],[6,"AnyRefExt","","Extension methods for a referenced `Any` trait object"],[9,"is","","Returns true if the boxed type is the same as `T`",58],[9,"downcast_ref","","Returns some reference to the boxed value if it is of type `T`, or\n`None` if it isn't.",58],[10,"as_ref","","Returns some reference to the boxed value if it is of type `T`, or\n`None` if it isn't.",58],[6,"AnyMutRefExt","","Extension methods for a mutable referenced `Any` trait object"],[9,"downcast_mut","","Returns some mutable reference to the boxed value if it is of type `T`, or\n`None` if it isn't.",59],[10,"as_mut","","Returns some mutable reference to the boxed value if it is of type `T`, or\n`None` if it isn't.",59],[0,"atomics","core","Core atomic primitives"],[1,"AtomicBool","core::atomics","An atomic boolean type."],[1,"AtomicInt","","A signed atomic integer type, supporting basic atomic arithmetic operations"],[1,"AtomicUint","","An unsigned atomic integer type, supporting basic atomic arithmetic operations"],[1,"AtomicPtr","","An unsafe atomic pointer. Only supports basic atomic operations"],[2,"Ordering","","Atomic memory orderings"],[12,"Relaxed","","No ordering constraints, only atomic operations",60],[12,"Release","","When coupled with a store, all previous writes become visible\nto another thread that performs a load with `Acquire` ordering\non the same value",60],[12,"Acquire","","When coupled with a load, all subsequent loads will see data\nwritten before a store with `Release` ordering on the same value\nin another thread",60],[12,"AcqRel","","When coupled with a load, uses `Acquire` ordering, and with a store\n`Release` ordering",60],[12,"SeqCst","","Like `AcqRel` with the additional guarantee that all threads see all\nsequentially consistent operations in the same order.",60],[3,"fence","","An atomic fence."],[5,"INIT_ATOMIC_BOOL","","An `AtomicBool` initialized to `false`"],[5,"INIT_ATOMIC_INT","","An `AtomicInt` initialized to `0`"],[5,"INIT_ATOMIC_UINT","","An `AtomicUint` initialized to `0`"],[10,"new","","Create a new `AtomicBool`",61],[10,"load","","Load the value",61],[10,"store","","Store the value",61],[10,"swap","","Store a value, returning the old value",61],[10,"compare_and_swap","","If the current value is the same as expected, store a new value",61],[10,"fetch_and","","A logical \"and\" operation",61],[10,"fetch_nand","","A logical \"nand\" operation",61],[10,"fetch_or","","A logical \"or\" operation",61],[10,"fetch_xor","","A logical \"xor\" operation",61],[10,"new","","Create a new `AtomicInt`",62],[10,"load","","Load the value",62],[10,"store","","Store the value",62],[10,"swap","","Store a value, returning the old value",62],[10,"compare_and_swap","","If the current value is the same as expected, store a new value",62],[10,"fetch_add","","Add to the current value, returning the previous",62],[10,"fetch_sub","","Subtract from the current value, returning the previous",62],[10,"fetch_and","","Bitwise and with the current value, returning the previous",62],[10,"fetch_or","","Bitwise or with the current value, returning the previous",62],[10,"fetch_xor","","Bitwise xor with the current value, returning the previous",62],[10,"new","","Create a new `AtomicUint`",63],[10,"load","","Load the value",63],[10,"store","","Store the value",63],[10,"swap","","Store a value, returning the old value",63],[10,"compare_and_swap","","If the current value is the same as expected, store a new value",63],[10,"fetch_add","","Add to the current value, returning the previous",63],[10,"fetch_sub","","Subtract from the current value, returning the previous",63],[10,"fetch_and","","Bitwise and with the current value, returning the previous",63],[10,"fetch_or","","Bitwise or with the current value, returning the previous",63],[10,"fetch_xor","","Bitwise xor with the current value, returning the previous",63],[10,"new","","Create a new `AtomicPtr`",64],[10,"load","","Load the value",64],[10,"store","","Store the value",64],[10,"swap","","Store a value, returning the old value",64],[10,"compare_and_swap","","If the current value is the same as expected, store a new value",64],[0,"bool","core","The boolean type"],[16,"bool","core::bool","The boolean type"],[0,"cell","core","Shareable mutable containers."],[1,"Cell","core::cell","A mutable memory location that admits only `Copy` data."],[1,"RefCell","","A mutable memory location with dynamically checked borrow rules"],[1,"Ref","","Wraps a borrowed reference to a value in a `RefCell` box."],[1,"RefMut","","Wraps a mutable borrowed reference to a value in a `RefCell` box."],[1,"UnsafeCell","","The core primitive for interior mutability in Rust."],[11,"value","","Wrapped value",65],[3,"clone_ref","","Copy a `Ref`."],[10,"new","","Creates a new `Cell` containing the given value.",66],[10,"get","","Returns a copy of the contained value.",66],[10,"set","","Sets the contained value.",66],[10,"clone","","",66],[10,"eq","","",66],[10,"new","","Create a new `RefCell` containing `value`",67],[10,"unwrap","","Consumes the `RefCell`, returning the wrapped value.",67],[10,"try_borrow","","Attempts to immutably borrow the wrapped value.",67],[10,"borrow","","Immutably borrows the wrapped value.",67],[10,"try_borrow_mut","","Mutably borrows the wrapped value.",67],[10,"borrow_mut","","Mutably borrows the wrapped value.",67],[10,"clone","","",67],[10,"eq","","",67],[10,"drop","","",68],[10,"deref","","",68],[10,"drop","","",69],[10,"deref","","",69],[10,"deref_mut","","",69],[10,"new","","Construct a new instance of `UnsafeCell` which will wrapp the specified\nvalue.",65],[10,"get","","Gets a mutable pointer to the wrapped value.",65],[10,"unwrap","","Unwraps the value",65],[0,"char","core","Character manipulation."],[3,"from_u32","core::char","Converts from `u32` to a `char`"],[3,"is_digit_radix","","\nChecks if a `char` parses as a numeric digit in the given radix"],[3,"to_digit","","\nConverts a `char` to the corresponding digit"],[3,"from_digit","","\nConverts a number to the character representing it"],[3,"escape_unicode","","\nReturns the hexadecimal Unicode escape of a `char`"],[3,"escape_default","","\nReturns a 'default' ASCII and C++11-like literal escape of a `char`"],[3,"len_utf8_bytes","","Returns the amount of bytes this `char` would need if encoded in UTF-8"],[5,"MAX","","The highest valid code point"],[6,"Char","","Basic `char` manipulations."],[9,"is_digit_radix","","Checks if a `char` parses as a numeric digit in the given radix.",70],[9,"to_digit","","Converts a character to the corresponding digit.",70],[9,"from_digit","","Converts a number to the character representing it.",70],[9,"escape_unicode","","Returns the hexadecimal Unicode escape of a character.",70],[9,"escape_default","","Returns a 'default' ASCII and C++11-like literal escape of a\ncharacter.",70],[9,"len_utf8_bytes","","Returns the amount of bytes this character would need if encoded in\nUTF-8.",70],[9,"encode_utf8","","Encodes this character as UTF-8 into the provided byte buffer.",70],[9,"encode_utf16","","Encodes this character as UTF-16 into the provided `u16` buffer.",70],[16,"char","","Character manipulation."],[0,"failure","core","Failure support for libcore"],[3,"begin_unwind","core::failure",""],[0,"finally","core","The Finally trait provides a method, `finally` on\nstack closures that emulates Java-style try/finally blocks."],[3,"try_finally","core::finally","The most general form of the `finally` functions. The function\n`try_fn` will be invoked first; whether or not it fails, the\nfunction `finally_fn` will be invoked next. The two parameters\n`mutate` and `drop` are used to thread state through the two\nclosures. `mutate` is used for any shared, mutable state that both\nclosures require access to; `drop` is used for any state that the\n`try_fn` requires ownership of."],[6,"Finally","","A trait for executing a destructor unconditionally after a block of code,\nregardless of whether the blocked fails."],[9,"finally","","Executes this object, unconditionally running `dtor` after this block of\ncode has run.",71],[0,"iter","core","Composable external iterators"],[1,"Rev","core::iter","An double-ended iterator with the direction inverted"],[1,"ByRef","","A mutable reference to an iterator"],[1,"Cycle","","An iterator that repeats endlessly"],[1,"Chain","","An iterator which strings two iterators together"],[1,"Zip","","An iterator which iterates two other iterators simultaneously"],[1,"Map","","An iterator which maps the values of `iter` with `f`"],[1,"Filter","","An iterator which filters the elements of `iter` with `predicate`"],[1,"FilterMap","","An iterator which uses `f` to both filter and map elements from `iter`"],[1,"Enumerate","","An iterator which yields the current count and the element during iteration"],[1,"Peekable","","An iterator with a `peek()` that returns an optional reference to the next element."],[1,"SkipWhile","","An iterator which rejects elements while `predicate` is true"],[1,"TakeWhile","","An iterator which only accepts elements while `predicate` is true"],[1,"Skip","","An iterator which skips over `n` elements of `iter`."],[1,"Take","","An iterator which only iterates over the first `n` iterations of `iter`."],[1,"Scan","","An iterator to maintain state while iterating another iterator"],[11,"state","","The current internal state to be passed to the closure next.",72],[1,"FlatMap","","An iterator that maps each element to an iterator,\nand yields the elements of the produced iterators\n"],[1,"Fuse","","An iterator that yields `None` forever after the underlying iterator\nyields `None` once."],[1,"Inspect","","An iterator that calls a function with a reference to each\nelement before yielding it."],[1,"Unfold","","An iterator which just modifies the contained state throughout iteration."],[11,"state","","Internal state that will be yielded on the next iteration",73],[1,"Counter","","An infinite iterator starting at `start` and advancing by `step` with each\niteration"],[1,"Range","","An iterator over the range [start, stop)"],[1,"RangeInclusive","","An iterator over the range [start, stop]"],[1,"RangeStep","","An iterator over the range [start, stop) by `step`. It handles overflow by stopping."],[1,"RangeStepInclusive","","An iterator over the range [start, stop] by `step`. It handles overflow by stopping."],[1,"Repeat","","An iterator that repeats an element endlessly"],[2,"MinMaxResult","","`MinMaxResult` is an enum returned by `min_max`. See `OrdIterator::min_max` for more detail."],[12,"NoElements","","Empty iterator",74],[12,"OneElement","","Iterator with one element, so the minimum and maximum are the same",74],[12,"MinMax","","More than one element in the iterator, the first element is not larger than the second",74],[3,"count","","Creates a new counter with the specified start/step"],[3,"range","","Returns an iterator over the given range [start, stop) (that is, starting\nat start (inclusive), and ending at stop (exclusive))."],[3,"range_inclusive","","Return an iterator over the range [start, stop]"],[3,"range_step","","Return an iterator over the range [start, stop) by `step`. It handles overflow by stopping."],[3,"range_step_inclusive","","Return an iterator over the range [start, stop] by `step`. It handles overflow by stopping."],[3,"iterate","","Creates a new iterator that produces an infinite sequence of\nrepeated applications of the given function `f`."],[0,"order","","Functions for lexicographical ordering of sequences."],[3,"equals","core::iter::order","Compare `a` and `b` for equality using `Eq`"],[3,"cmp","","Order `a` and `b` lexicographically using `Ord`"],[3,"partial_cmp","","Order `a` and `b` lexicographically using `PartialOrd`"],[3,"eq","","Compare `a` and `b` for equality (Using partial equality, `PartialEq`)"],[3,"ne","","Compare `a` and `b` for nonequality (Using partial equality, `PartialEq`)"],[3,"lt","","Return `a` < `b` lexicographically (Using partial order, `PartialOrd`)"],[3,"le","","Return `a` <= `b` lexicographically (Using partial order, `PartialOrd`)"],[3,"gt","","Return `a` > `b` lexicographically (Using partial order, `PartialOrd`)"],[3,"ge","","Return `a` >= `b` lexicographically (Using partial order, `PartialOrd`)"],[4,"Iterate","core::iter","An iterator that repeatedly applies a given function, starting\nfrom a given seed value."],[6,"FromIterator","","Conversion from an `Iterator`"],[9,"from_iter","","Build a container with elements from an external iterator.",75],[6,"Extendable","","A type growable from an `Iterator` implementation"],[9,"extend","","Extend a container with the elements yielded by an iterator",76],[6,"Iterator","","An interface for dealing with \"external iterators\". These types of iterators\ncan be resumed at any time as all state is stored internally as opposed to\nbeing located on the call stack."],[9,"next","","Advance the iterator and return the next value. Return `None` when the end is reached.",77],[10,"size_hint","","Returns a lower and upper bound on the remaining length of the iterator.",77],[10,"chain","","Chain this iterator with another, returning a new iterator which will\nfinish iterating over the current iterator, and then it will iterate\nover the other specified iterator.",77],[10,"zip","","Creates an iterator which iterates over both this and the specified\niterators simultaneously, yielding the two elements as pairs. When\neither iterator returns None, all further invocations of next() will\nreturn None.",77],[10,"map","","Creates a new iterator which will apply the specified function to each\nelement returned by the first, yielding the mapped element instead.",77],[10,"filter","","Creates an iterator which applies the predicate to each element returned\nby this iterator. Only elements which have the predicate evaluate to\n`true` will be yielded.",77],[10,"filter_map","","Creates an iterator which both filters and maps elements.\nIf the specified function returns None, the element is skipped.\nOtherwise the option is unwrapped and the new value is yielded.",77],[10,"enumerate","","Creates an iterator which yields a pair of the value returned by this\niterator plus the current index of iteration.",77],[10,"peekable","","Creates an iterator that has a `.peek()` method\nthat returns an optional reference to the next element.",77],[10,"skip_while","","Creates an iterator which invokes the predicate on elements until it\nreturns false. Once the predicate returns false, all further elements are\nyielded.",77],[10,"take_while","","Creates an iterator which yields elements so long as the predicate\nreturns true. After the predicate returns false for the first time, no\nfurther elements will be yielded.",77],[10,"skip","","Creates an iterator which skips the first `n` elements of this iterator,\nand then it yields all further items.",77],[10,"take","","Creates an iterator which yields the first `n` elements of this\niterator, and then it will always return None.",77],[10,"scan","","Creates a new iterator which behaves in a similar fashion to fold.\nThere is a state which is passed between each iteration and can be\nmutated as necessary. The yielded values from the closure are yielded\nfrom the Scan instance when not None.",77],[10,"flat_map","","Creates an iterator that maps each element to an iterator,\nand yields the elements of the produced iterators",77],[10,"fuse","","Creates an iterator that yields `None` forever after the underlying\niterator yields `None`. Random-access iterator behavior is not\naffected, only single and double-ended iterator behavior.",77],[10,"inspect","","Creates an iterator that calls a function with a reference to each\nelement before yielding it. This is often useful for debugging an\niterator pipeline.",77],[10,"by_ref","","Creates a wrapper around a mutable reference to the iterator.",77],[10,"advance","","Apply a function to each element, or stop iterating if the\nfunction returns `false`.",77],[10,"collect","","Loops through the entire iterator, collecting all of the elements into\na container implementing `FromIterator`.",77],[10,"nth","","Loops through `n` iterations, returning the `n`th element of the\niterator.",77],[10,"last","","Loops through the entire iterator, returning the last element of the\niterator.",77],[10,"fold","","Performs a fold operation over the entire iterator, returning the\neventual state at the end of the iteration.",77],[10,"count","","Counts the number of elements in this iterator.",77],[10,"all","","Tests whether the predicate holds true for all elements in the iterator.",77],[10,"any","","Tests whether any element of an iterator satisfies the specified\npredicate.",77],[10,"find","","Return the first element satisfying the specified predicate",77],[10,"position","","Return the index of the first element satisfying the specified predicate",77],[10,"max_by","","Return the element that gives the maximum value from the\nspecified function.",77],[10,"min_by","","Return the element that gives the minimum value from the\nspecified function.",77],[6,"DoubleEndedIterator","","A range iterator able to yield elements from both ends"],[9,"next_back","","Yield an element from the end of the range, returning `None` if the range is empty.",78],[10,"rev","","Change the direction of the iterator",78],[6,"MutableDoubleEndedIterator","","A double-ended iterator yielding mutable references"],[9,"reverse_","","Use an iterator to reverse a container in-place",79],[6,"RandomAccessIterator","","An object implementing random access indexing by `uint`"],[9,"indexable","","Return the number of indexable elements. At most `std::uint::MAX`\nelements are indexable, even if the iterator represents a longer range.",80],[9,"idx","","Return an element at an index, or `None` if the index is out of bounds",80],[6,"ExactSize","","An iterator that knows its exact length"],[10,"rposition","","Return the index of the last element satisfying the specified predicate",81],[10,"len","","Return the exact length of the iterator.",81],[6,"AdditiveIterator","","A trait for iterators over elements which can be added together"],[9,"sum","","Iterates over the entire iterator, summing up all the elements",82],[6,"MultiplicativeIterator","","A trait for iterators over elements whose elements can be multiplied\ntogether."],[9,"product","","Iterates over the entire iterator, multiplying all the elements",83],[6,"OrdIterator","","A trait for iterators over elements which can be compared to one another.\nThe type of each element must ascribe to the `PartialOrd` trait."],[9,"max","","Consumes the entire iterator to return the maximum element.",84],[9,"min","","Consumes the entire iterator to return the minimum element.",84],[9,"min_max","","`min_max` finds the minimum and maximum elements in the iterator.",84],[6,"CloneableIterator","","A trait for iterators that are cloneable."],[9,"cycle","","Repeats an iterator endlessly",85],[10,"clone","","",86],[10,"next","","",86],[10,"size_hint","","",86],[10,"next_back","","",86],[10,"indexable","","",86],[10,"idx","","",86],[10,"next","","",87],[10,"size_hint","","",87],[10,"next_back","","",87],[10,"fmt","","",74],[10,"eq","","",74],[10,"ne","","",74],[10,"clone","","",74],[10,"into_option","","`into_option` creates an `Option` of type `(T,T)`. The returned `Option` has variant\n`None` if and only if the `MinMaxResult` has variant `NoElements`. Otherwise variant\n`Some(x,y)` is returned where `x <= y`. If `MinMaxResult` has variant `OneElement(x)`,\nperforming this operation will make one clone of `x`.",74],[10,"clone","","",88],[10,"next","","",88],[10,"size_hint","","",88],[10,"indexable","","",88],[10,"idx","","",88],[10,"clone","","",89],[10,"next","","",89],[10,"size_hint","","",89],[10,"next_back","","",89],[10,"indexable","","",89],[10,"idx","","",89],[10,"clone","","",90],[10,"next","","",90],[10,"size_hint","","",90],[10,"next_back","","",90],[10,"indexable","","",90],[10,"idx","","",90],[10,"next","","",91],[10,"size_hint","","",91],[10,"next_back","","",91],[10,"indexable","","",91],[10,"idx","","",91],[10,"next","","",92],[10,"size_hint","","",92],[10,"next_back","","",92],[10,"next","","",93],[10,"size_hint","","",93],[10,"next_back","","",93],[10,"clone","","",94],[10,"next","","",94],[10,"size_hint","","",94],[10,"next_back","","",94],[10,"indexable","","",94],[10,"idx","","",94],[10,"next","","",95],[10,"size_hint","","",95],[10,"peek","","Return a reference to the next element of the iterator with out advancing it,\nor None if the iterator is exhausted.",95],[10,"is_empty","","Check whether peekable iterator is empty or not.",95],[10,"next","","",96],[10,"size_hint","","",96],[10,"next","","",97],[10,"size_hint","","",97],[10,"clone","","",98],[10,"next","","",98],[10,"size_hint","","",98],[10,"indexable","","",98],[10,"idx","","",98],[10,"clone","","",99],[10,"next","","",99],[10,"size_hint","","",99],[10,"indexable","","",99],[10,"idx","","",99],[10,"next","","",72],[10,"size_hint","","",72],[10,"next","","",100],[10,"size_hint","","",100],[10,"next_back","","",100],[10,"clone","","",101],[10,"next","","",101],[10,"size_hint","","",101],[10,"next_back","","",101],[10,"indexable","","",101],[10,"idx","","",101],[10,"reset_fuse","","Resets the fuse such that the next call to .next() or .next_back() will\ncall the underlying iterator again even if it previously returned None.",101],[10,"next","","",102],[10,"size_hint","","",102],[10,"next_back","","",102],[10,"indexable","","",102],[10,"idx","","",102],[10,"new","","Creates a new iterator with the specified closure as the \"iterator\nfunction\" and an initial state to eventually pass to the iterator",73],[10,"next","","",73],[10,"size_hint","","",73],[10,"clone","","",103],[10,"next","","",103],[10,"size_hint","","",103],[10,"clone","","",104],[10,"next","","",104],[10,"size_hint","","",104],[10,"next_back","","",104],[10,"clone","","",105],[10,"next","","",105],[10,"size_hint","","",105],[10,"next_back","","",105],[10,"clone","","",106],[10,"next","","",106],[10,"clone","","",107],[10,"next","","",107],[10,"clone","","",108],[10,"new","","Create a new `Repeat` that endlessly repeats the element `elt`.",108],[10,"next","","",108],[10,"size_hint","","",108],[10,"next_back","","",108],[10,"indexable","","",108],[10,"idx","","",108],[0,"option","core","Optional values"],[1,"Item","core::option","An `Option` iterator that yields either one or zero elements"],[2,"Option","","The `Option` type."],[12,"None","","No value",109],[12,"Some","","Some value `T`",109],[3,"collect","","Takes each element in the `Iterator`: if it is `None`, no further\nelements are taken, and the `None` is returned. Should no `None` occur, a\nvector containing the values of each `Option` is returned."],[10,"fmt","","",109],[10,"cmp","","",109],[10,"partial_cmp","","",109],[10,"lt","","",109],[10,"le","","",109],[10,"gt","","",109],[10,"ge","","",109],[10,"eq","","",109],[10,"ne","","",109],[10,"clone","","",109],[10,"is_some","","Returns `true` if the option is a `Some` value",109],[10,"is_none","","Returns `true` if the option is a `None` value",109],[10,"as_ref","","Convert from `Option<T>` to `Option<&T>`",109],[10,"as_mut","","Convert from `Option<T>` to `Option<&mut T>`",109],[10,"as_mut_slice","","Convert from `Option<T>` to `&mut [T]` (without copying)",109],[10,"expect","","Unwraps an option, yielding the content of a `Some`",109],[10,"unwrap","","Moves a value out of an option type and returns it, consuming the `Option`.",109],[10,"unwrap_or","","Returns the contained value or a default.",109],[10,"unwrap_or_else","","Returns the contained value or computes it from a closure.",109],[10,"map","","Maps an `Option<T>` to `Option<U>` by applying a function to a contained value",109],[10,"map_or","","Applies a function to the contained value or returns a default.",109],[10,"mutate","","Applies a function to the contained value or does nothing.\nReturns true if the contained value was mutated.",109],[10,"mutate_or_set","","Applies a function to the contained value or sets it to a default.\nReturns true if the contained value was mutated, or false if set to the default.",109],[10,"iter","","Returns an iterator over the possibly contained value.",109],[10,"mut_iter","","Returns a mutable iterator over the possibly contained value.",109],[10,"move_iter","","Returns a consuming iterator over the possibly contained value.",109],[10,"and","","Returns `None` if the option is `None`, otherwise returns `optb`.",109],[10,"and_then","","Returns `None` if the option is `None`, otherwise calls `f` with the\nwrapped value and returns the result.",109],[10,"or","","Returns the option if it contains a value, otherwise returns `optb`.",109],[10,"or_else","","Returns the option if it contains a value, otherwise calls `f` and\nreturns the result.",109],[10,"take","","Takes the value out of the option, leaving a `None` in its place.",109],[10,"filtered","","Filters an optional value using a given function.",109],[10,"while_some","","Applies a function zero or more times until the result is `None`.",109],[10,"take_unwrap","","The option dance. Moves a value out of an option type and returns it,\nreplacing the original with `None`.",109],[10,"get_ref","","Gets an immutable reference to the value inside an option.",109],[10,"get_mut_ref","","Gets a mutable reference to the value inside an option.",109],[10,"unwrap_or_default","","Returns the contained value or a default",109],[10,"as_slice","","Convert from `Option<T>` to `&[T]` (without copying)",109],[10,"default","","",109],[10,"clone","","",110],[10,"next","","",110],[10,"size_hint","","",110],[10,"next_back","","",110],[0,"raw","core","Contains struct definitions for the layout of compiler built-in types."],[1,"Box","core::raw","The representation of a Rust managed box"],[11,"ref_count","","",111],[11,"drop_glue","","",111],[11,"prev","","",111],[11,"next","","",111],[11,"data","","",111],[1,"Slice","","The representation of a Rust slice"],[11,"data","","",112],[11,"len","","",112],[1,"Closure","","The representation of a Rust closure"],[11,"code","","",113],[11,"env","","",113],[1,"Procedure","","The representation of a Rust procedure (`proc()`)"],[11,"code","","",114],[11,"env","","",114],[1,"TraitObject","","The representation of a Rust trait object."],[11,"vtable","","",115],[11,"data","","",115],[6,"Repr","","This trait is meant to map equivalences between raw structs and their\ncorresponding rust values."],[10,"repr","","This function \"unwraps\" a rust value (without consuming it) into its raw\nstruct representation. This can be used to read/write different values\nfor the struct. This is a safe method because by default it does not\nenable write-access to the fields of the return value in safe code.",116],[0,"result","core","Error handling with the `Result` type"],[2,"Result","core::result","`Result` is a type that represents either success (`Ok`) or failure (`Err`)."],[12,"Ok","","Contains the success value",117],[12,"Err","","Contains the error value",117],[3,"collect","","Takes each element in the `Iterator`: if it is an `Err`, no further\nelements are taken, and the `Err` is returned. Should no `Err` occur, a\nvector containing the values of each `Result` is returned."],[3,"fold","","Perform a fold operation over the result values from an iterator."],[3,"fold_","","Perform a trivial fold operation over the result values\nfrom an iterator."],[10,"fmt","","",117],[10,"cmp","","",117],[10,"partial_cmp","","",117],[10,"lt","","",117],[10,"le","","",117],[10,"gt","","",117],[10,"ge","","",117],[10,"eq","","",117],[10,"ne","","",117],[10,"clone","","",117],[10,"is_ok","","Returns true if the result is `Ok`",117],[10,"is_err","","Returns true if the result is `Err`",117],[10,"ok","","Convert from `Result<T, E>` to `Option<T>`",117],[10,"err","","Convert from `Result<T, E>` to `Option<E>`",117],[10,"as_ref","","Convert from `Result<T, E>` to `Result<&T, &E>`",117],[10,"as_mut","","Convert from `Result<T, E>` to `Result<&mut T, &mut E>`",117],[10,"map","","Maps a `Result<T, E>` to `Result<U, E>` by applying a function to an\ncontained `Ok` value, leaving an `Err` value untouched.",117],[10,"map_err","","Maps a `Result<T, E>` to `Result<T, F>` by applying a function to an\ncontained `Err` value, leaving an `Ok` value untouched.",117],[10,"and","","Returns `res` if the result is `Ok`, otherwise returns the `Err` value of `self`.",117],[10,"and_then","","Calls `op` if the result is `Ok`, otherwise returns the `Err` value of `self`.",117],[10,"or","","Returns `res` if the result is `Err`, otherwise returns the `Ok` value of `self`.",117],[10,"or_else","","Calls `op` if the result is `Err`, otherwise returns the `Ok` value of `self`.",117],[10,"unwrap_or","","Unwraps a result, yielding the content of an `Ok`.\nElse it returns `optb`.",117],[10,"unwrap_or_else","","Unwraps a result, yielding the content of an `Ok`.\nIf the value is an `Err` then it calls `op` with its value.",117],[10,"unwrap_or_handle","","Deprecated name for `unwrap_or_else()`.",117],[10,"unwrap","","Unwraps a result, yielding the content of an `Ok`.",117],[10,"unwrap_err","","Unwraps a result, yielding the content of an `Err`.",117],[0,"simd","core","SIMD vectors."],[1,"i8x16","core::simd",""],[1,"i16x8","",""],[1,"i32x4","",""],[1,"i64x2","",""],[1,"u8x16","",""],[1,"u16x8","",""],[1,"u32x4","",""],[1,"u64x2","",""],[1,"f32x4","",""],[1,"f64x2","",""],[10,"fmt","","",118],[10,"fmt","","",119],[10,"fmt","","",120],[10,"fmt","","",121],[10,"fmt","","",122],[10,"fmt","","",123],[10,"fmt","","",124],[10,"fmt","","",125],[10,"fmt","","",126],[10,"fmt","","",127],[0,"slice","core","Slice management and manipulation"],[1,"Items","core::slice","Immutable slice iterator"],[1,"MutItems","","Mutable slice iterator"],[1,"Splits","","An iterator over the slices of a vector separated by elements that\nmatch a predicate function."],[1,"MutSplits","","An iterator over the subslices of the vector which are separated\nby elements that match `pred`."],[1,"SplitsN","","An iterator over the slices of a vector separated by elements that\nmatch a predicate function, splitting at most a fixed number of times."],[1,"Windows","","An iterator over the (overlapping) slices of length `size` within\na vector."],[1,"Chunks","","An iterator over a vector in (non-overlapping) chunks (`size`\nelements at a time)."],[1,"MutChunks","","An iterator over a vector in (non-overlapping) mutable chunks (`size`  elements at a time). When\nthe vector len is not evenly divided by the chunk size, the last slice of the iteration will be\nthe remainder."],[3,"ref_slice","","Converts a pointer to A into a slice of length 1 (without copying)."],[3,"mut_ref_slice","","Converts a pointer to A into a slice of length 1 (without copying)."],[0,"raw","","Unsafe operations"],[3,"buf_as_slice","core::slice::raw","Form a slice from a pointer and length (as a number of units,\nnot bytes)."],[3,"mut_buf_as_slice","","Form a slice from a pointer and length (as a number of units,\nnot bytes)."],[3,"shift_ptr","","Returns a pointer to first element in slice and adjusts\nslice so it no longer contains that element. Returns None\nif the slice is empty. O(1)."],[3,"pop_ptr","","Returns a pointer to last element in slice and adjusts\nslice so it no longer contains that element. Returns None\nif the slice is empty. O(1)."],[0,"bytes","core::slice","Operations on `[u8]`."],[3,"copy_memory","core::slice::bytes","Copies data from `src` to `dst`"],[6,"MutableByteVector","","A trait for operations on mutable `[u8]`s."],[9,"set_memory","","Sets all bytes of the receiver to the given value.",128],[6,"ImmutableVector","core::slice","Extension methods for vectors"],[9,"slice","","Returns a slice of self spanning the interval [`start`, `end`).",129],[9,"slice_from","","Returns a slice of self from `start` to the end of the vec.",129],[9,"slice_to","","Returns a slice of self from the start of the vec to `end`.",129],[9,"iter","","Returns an iterator over the vector",129],[9,"split","","Returns an iterator over the subslices of the vector which are\nseparated by elements that match `pred`.  The matched element\nis not contained in the subslices.",129],[9,"splitn","","Returns an iterator over the subslices of the vector which are\nseparated by elements that match `pred`, limited to splitting\nat most `n` times.  The matched element is not contained in\nthe subslices.",129],[9,"rsplitn","","Returns an iterator over the subslices of the vector which are\nseparated by elements that match `pred` limited to splitting\nat most `n` times. This starts at the end of the vector and\nworks backwards.  The matched element is not contained in the\nsubslices.",129],[9,"windows","","Returns an iterator over all contiguous windows of length\n`size`. The windows overlap. If the vector is shorter than\n`size`, the iterator returns no values.",129],[9,"chunks","","\nReturns an iterator over `size` elements of the vector at a\ntime. The chunks do not overlap. If `size` does not divide the\nlength of the vector, then the last chunk will not have length\n`size`.",129],[9,"get","","Returns the element of a vector at the given index, or `None` if the\nindex is out of bounds",129],[9,"head","","Returns the first element of a vector, or `None` if it is empty",129],[9,"tail","","Returns all but the first element of a vector",129],[9,"tailn","","Returns all but the first `n' elements of a vector",129],[9,"init","","Returns all but the last element of a vector",129],[9,"initn","","Returns all but the last `n' elements of a vector",129],[9,"last","","Returns the last element of a vector, or `None` if it is empty.",129],[9,"unsafe_ref","","Returns a pointer to the element at the given index, without doing\nbounds checking.",129],[9,"as_ptr","","Returns an unsafe pointer to the vector's buffer",129],[9,"bsearch","","Binary search a sorted vector with a comparator function.",129],[9,"shift_ref","","Returns an immutable reference to the first element in this slice\nand adjusts the slice in place so that it no longer contains\nthat element. O(1).",129],[9,"pop_ref","","Returns an immutable reference to the last element in this slice\nand adjusts the slice in place so that it no longer contains\nthat element. O(1).",129],[6,"MutableVector","","Extension methods for vectors such that their elements are\nmutable."],[9,"get_mut","","Returns a mutable reference to the element at the given index,\nor `None` if the index is out of bounds",130],[9,"as_mut_slice","","Work with `self` as a mut slice.\nPrimarily intended for getting a &mut [T] from a [T, ..N].",130],[9,"mut_slice","","Return a slice that points into another slice.",130],[9,"mut_slice_from","","Returns a slice of self from `start` to the end of the vec.",130],[9,"mut_slice_to","","Returns a slice of self from the start of the vec to `end`.",130],[9,"mut_iter","","Returns an iterator that allows modifying each value",130],[9,"mut_last","","Returns a mutable pointer to the last item in the vector.",130],[9,"mut_split","","Returns an iterator over the mutable subslices of the vector\nwhich are separated by elements that match `pred`.  The\nmatched element is not contained in the subslices.",130],[9,"mut_chunks","","Returns an iterator over `size` elements of the vector at a time.\nThe chunks are mutable and do not overlap. If `size` does not divide the\nlength of the vector, then the last chunk will not have length\n`size`.",130],[9,"mut_shift_ref","","Returns a mutable reference to the first element in this slice\nand adjusts the slice in place so that it no longer contains\nthat element. O(1).",130],[9,"mut_pop_ref","","Returns a mutable reference to the last element in this slice\nand adjusts the slice in place so that it no longer contains\nthat element. O(1).",130],[9,"swap","","Swaps two elements in a vector.",130],[9,"mut_split_at","","Divides one `&mut` into two at an index.",130],[9,"reverse","","Reverse the order of elements in a vector, in place.",130],[9,"unsafe_mut_ref","","Returns an unsafe mutable pointer to the element in index",130],[9,"as_mut_ptr","","Return an unsafe mutable pointer to the vector's buffer.",130],[9,"unsafe_set","","Unsafely sets the element in index to the value.",130],[9,"init_elem","","Unchecked vector index assignment.  Does not drop the\nold value and hence is only suitable when the vector\nis newly allocated.",130],[9,"copy_memory","","Copies raw bytes from `src` to `self`.",130],[6,"ImmutableEqVector","","Extension methods for vectors contain `PartialEq` elements."],[9,"position_elem","","Find the first index containing a matching value",131],[9,"rposition_elem","","Find the last index containing a matching value",131],[9,"contains","","Return true if a vector contains an element with the given value",131],[9,"starts_with","","Returns true if `needle` is a prefix of the vector.",131],[9,"ends_with","","Returns true if `needle` is a suffix of the vector.",131],[6,"ImmutableOrdVector","","Extension methods for vectors containing `Ord` elements."],[9,"bsearch_elem","","Binary search a sorted vector for a given element.",132],[6,"MutableCloneableVector","","Trait for &[T] where T is Cloneable"],[9,"copy_from","","Copies as many elements from `src` as it can into `self` (the\nshorter of `self.len()` and `src.len()`). Returns the number\nof elements copied.",133],[6,"Vector","","Any vector that can be represented as a slice."],[9,"as_slice","","Work with `self` as a slice.",134],[10,"next","","",135],[10,"size_hint","","",135],[10,"next_back","","",135],[10,"clone","","",135],[10,"indexable","","",135],[10,"idx","","",135],[10,"next","","",136],[10,"size_hint","","",136],[10,"next_back","","",136],[10,"next","","",137],[10,"size_hint","","",137],[10,"next_back","","",137],[10,"next","","",138],[10,"size_hint","","",138],[10,"next_back","","",138],[10,"next","","",139],[10,"size_hint","","",139],[10,"clone","","",140],[10,"next","","",140],[10,"size_hint","","",140],[10,"clone","","",141],[10,"next","","",141],[10,"size_hint","","",141],[10,"next_back","","",141],[10,"indexable","","",141],[10,"idx","","",141],[10,"next","","",142],[10,"size_hint","","",142],[10,"next_back","","",142],[16,"slice","","Slice management and manipulation"],[0,"str","core","String manipulation"],[1,"Chars","core::str","Iterator for the char (representing *Unicode Scalar Values*) of a string"],[1,"CharOffsets","","External iterator for a string's characters and their byte offsets.\nUse with the `std::iter` module."],[1,"CharSplits","","An iterator over the substrings of a string, separated by `sep`."],[1,"CharSplitsN","","An iterator over the substrings of a string, separated by `sep`,\nsplitting at most `count` times."],[1,"MatchIndices","","An iterator over the start and end indices of the matches of a\nsubstring within a larger string"],[1,"StrSplits","","An iterator over the substrings of a string separated by a given\nsearch string"],[1,"Utf16CodeUnits","","External iterator for a string's UTF16 codeunits.\nUse with the `std::iter` module."],[1,"Utf16Items","","An iterator that decodes UTF-16 encoded codepoints from a vector\nof `u16`s."],[1,"CharRange","","Struct that contains a `char` and the index of the first byte of\nthe next `char` in a string.  This can be used as a data structure\nfor iterating over the UTF-8 bytes of a string."],[11,"ch","","Current `char`",143],[11,"next","","Index of the first byte of the next `char`",143],[2,"Utf16Item","","The possibilities for values decoded from a `u16` stream."],[12,"ScalarValue","","A valid codepoint.",144],[12,"LoneSurrogate","","An invalid surrogate without its pair.",144],[3,"from_utf8","","Converts a vector to a string slice without performing any allocations."],[3,"eq_slice","","Bytewise slice equality\nNOTE: This function is (ab)used in rustc::middle::trans::_match\nto compare &[u8] byte slices that are not necessarily valid UTF-8."],[3,"is_utf8","","Determines if a vector of bytes contains valid UTF-8."],[3,"is_utf16","","Determines if a vector of `u16` contains valid UTF-16"],[3,"utf16_items","","Create an iterator over the UTF-16 encoded codepoints in `v`,\nreturning invalid surrogates as `LoneSurrogate`s."],[3,"truncate_utf16_at_nul","","Return a slice of `v` ending at (and not including) the first NUL\n(0)."],[3,"utf8_char_width","","Given a first byte, determine how many bytes are in this UTF-8 character"],[0,"raw","","Unsafe operations"],[3,"from_utf8","core::str::raw","Converts a slice of bytes to a string slice without checking\nthat the string contains valid UTF-8."],[3,"c_str_to_static_slice","","Form a slice from a C string. Unsafe because the caller must ensure the\nC string has the static lifetime, or else the return value may be\ninvalidated later."],[3,"slice_bytes","","Takes a bytewise (not UTF-8) slice from a string."],[3,"slice_unchecked","","Takes a bytewise (not UTF-8) slice from a string."],[0,"traits","core::str",""],[4,"Bytes","","External iterator for a string's bytes.\nUse with the `std::iter` module."],[4,"AnyLines","","An iterator over the lines of a string, separated by either `\\n` or (`\\r\\n`)."],[6,"CharEq","","Something that can be used to compare against a character"],[9,"matches","","Determine if the splitter should split at the given character",145],[9,"only_ascii","","Indicate if this is only concerned about ASCII characters,\nwhich can allow for a faster implementation.",145],[6,"Str","","Any string that can be represented as a slice"],[9,"as_slice","","Work with `self` as a slice.",146],[6,"StrSlice","","Methods for string slices"],[9,"contains","","Returns true if one string contains another",147],[9,"contains_char","","Returns true if a string contains a char.",147],[9,"chars","","An iterator over the characters of `self`. Note, this iterates\nover unicode code-points, not unicode graphemes.",147],[9,"bytes","","An iterator over the bytes of `self`",147],[9,"char_indices","","An iterator over the characters of `self` and their byte offsets.",147],[9,"split","","An iterator over substrings of `self`, separated by characters\nmatched by `sep`.",147],[9,"splitn","","An iterator over substrings of `self`, separated by characters\nmatched by `sep`, restricted to splitting at most `count`\ntimes.",147],[9,"split_terminator","","An iterator over substrings of `self`, separated by characters\nmatched by `sep`.",147],[9,"rsplitn","","An iterator over substrings of `self`, separated by characters\nmatched by `sep`, starting from the end of the string.\nRestricted to splitting at most `count` times.",147],[9,"match_indices","","An iterator over the start and end indices of the disjoint\nmatches of `sep` within `self`.",147],[9,"split_str","","An iterator over the substrings of `self` separated by `sep`.",147],[9,"lines","","An iterator over the lines of a string (subsequences separated\nby `\\n`). This does not include the empty string after a\ntrailing `\\n`.",147],[9,"lines_any","","An iterator over the lines of a string, separated by either\n`\\n` or `\\r\\n`. As with `.lines()`, this does not include an\nempty trailing line.",147],[9,"char_len","","Returns the number of Unicode code points (`char`) that a\nstring holds.",147],[9,"slice","","Returns a slice of the given string from the byte range\n[`begin`..`end`).",147],[9,"slice_from","","Returns a slice of the string from `begin` to its end.",147],[9,"slice_to","","Returns a slice of the string from the beginning to byte\n`end`.",147],[9,"slice_chars","","Returns a slice of the string from the character range\n[`begin`..`end`).",147],[9,"starts_with","","Returns true if `needle` is a prefix of the string.",147],[9,"ends_with","","Returns true if `needle` is a suffix of the string.",147],[9,"trim_chars","","Returns a string with characters that match `to_trim` removed.",147],[9,"trim_left_chars","","Returns a string with leading `chars_to_trim` removed.",147],[9,"trim_right_chars","","Returns a string with trailing `chars_to_trim` removed.",147],[9,"is_char_boundary","","Check that `index`-th byte lies at the start and/or end of a\nUTF-8 code point sequence.",147],[9,"char_range_at","","Pluck a character out of a string and return the index of the next\ncharacter.",147],[9,"char_range_at_reverse","","Given a byte position and a str, return the previous char and its position.",147],[9,"char_at","","Plucks the character starting at the `i`th byte of a string.",147],[9,"char_at_reverse","","Plucks the character ending at the `i`th byte of a string.",147],[9,"as_bytes","","Work with the byte buffer of a string as a byte slice.",147],[9,"find","","Returns the byte index of the first character of `self` that\nmatches `search`.",147],[9,"rfind","","Returns the byte index of the last character of `self` that\nmatches `search`.",147],[9,"find_str","","Returns the byte index of the first matching substring",147],[9,"slice_shift_char","","Retrieves the first character from a string slice and returns\nit. This does not allocate a new string; instead, it returns a\nslice that point one character beyond the character that was\nshifted. If the string does not contain any characters,\na tuple of None and an empty string is returned instead.",147],[9,"subslice_offset","","Returns the byte offset of an inner slice relative to an enclosing outer slice.",147],[9,"as_ptr","","Return an unsafe pointer to the strings buffer.",147],[9,"utf16_units","","Return an iterator of `u16` over the string encoded as UTF-16.",147],[10,"clone","","",148],[10,"next","","",148],[10,"size_hint","","",148],[10,"next_back","","",148],[10,"clone","","",149],[10,"next","","",149],[10,"size_hint","","",149],[10,"next_back","","",149],[10,"clone","","",150],[10,"clone","","",151],[10,"next","","",150],[10,"next_back","","",150],[10,"next","","",151],[10,"clone","","",152],[10,"clone","","",153],[10,"next","","",152],[10,"next","","",153],[10,"clone","","",154],[10,"next","","",154],[10,"size_hint","","",154],[10,"clone","","",155],[10,"fmt","","",144],[10,"clone","","",144],[10,"eq","","",144],[10,"ne","","",144],[10,"to_char_lossy","","Convert `self` to a `char`, taking `LoneSurrogate`s to the\nreplacement character (U+FFFD).",144],[10,"next","","",155],[10,"size_hint","","",155],[16,"str","","String manipulation"],[0,"tuple","core","Operations on tuples"],[6,"Tuple1","core::tuple",""],[9,"val0","","",156],[9,"ref0","","",156],[9,"mut0","","",156],[6,"Tuple2","",""],[9,"val0","","",157],[9,"ref0","","",157],[9,"mut0","","",157],[9,"val1","","",157],[9,"ref1","","",157],[9,"mut1","","",157],[6,"Tuple3","",""],[9,"val0","","",158],[9,"ref0","","",158],[9,"mut0","","",158],[9,"val1","","",158],[9,"ref1","","",158],[9,"mut1","","",158],[9,"val2","","",158],[9,"ref2","","",158],[9,"mut2","","",158],[6,"Tuple4","",""],[9,"val0","","",159],[9,"ref0","","",159],[9,"mut0","","",159],[9,"val1","","",159],[9,"ref1","","",159],[9,"mut1","","",159],[9,"val2","","",159],[9,"ref2","","",159],[9,"mut2","","",159],[9,"val3","","",159],[9,"ref3","","",159],[9,"mut3","","",159],[6,"Tuple5","",""],[9,"val0","","",160],[9,"ref0","","",160],[9,"mut0","","",160],[9,"val1","","",160],[9,"ref1","","",160],[9,"mut1","","",160],[9,"val2","","",160],[9,"ref2","","",160],[9,"mut2","","",160],[9,"val3","","",160],[9,"ref3","","",160],[9,"mut3","","",160],[9,"val4","","",160],[9,"ref4","","",160],[9,"mut4","","",160],[6,"Tuple6","",""],[9,"val0","","",161],[9,"ref0","","",161],[9,"mut0","","",161],[9,"val1","","",161],[9,"ref1","","",161],[9,"mut1","","",161],[9,"val2","","",161],[9,"ref2","","",161],[9,"mut2","","",161],[9,"val3","","",161],[9,"ref3","","",161],[9,"mut3","","",161],[9,"val4","","",161],[9,"ref4","","",161],[9,"mut4","","",161],[9,"val5","","",161],[9,"ref5","","",161],[9,"mut5","","",161],[6,"Tuple7","",""],[9,"val0","","",162],[9,"ref0","","",162],[9,"mut0","","",162],[9,"val1","","",162],[9,"ref1","","",162],[9,"mut1","","",162],[9,"val2","","",162],[9,"ref2","","",162],[9,"mut2","","",162],[9,"val3","","",162],[9,"ref3","","",162],[9,"mut3","","",162],[9,"val4","","",162],[9,"ref4","","",162],[9,"mut4","","",162],[9,"val5","","",162],[9,"ref5","","",162],[9,"mut5","","",162],[9,"val6","","",162],[9,"ref6","","",162],[9,"mut6","","",162],[6,"Tuple8","",""],[9,"val0","","",163],[9,"ref0","","",163],[9,"mut0","","",163],[9,"val1","","",163],[9,"ref1","","",163],[9,"mut1","","",163],[9,"val2","","",163],[9,"ref2","","",163],[9,"mut2","","",163],[9,"val3","","",163],[9,"ref3","","",163],[9,"mut3","","",163],[9,"val4","","",163],[9,"ref4","","",163],[9,"mut4","","",163],[9,"val5","","",163],[9,"ref5","","",163],[9,"mut5","","",163],[9,"val6","","",163],[9,"ref6","","",163],[9,"mut6","","",163],[9,"val7","","",163],[9,"ref7","","",163],[9,"mut7","","",163],[6,"Tuple9","",""],[9,"val0","","",164],[9,"ref0","","",164],[9,"mut0","","",164],[9,"val1","","",164],[9,"ref1","","",164],[9,"mut1","","",164],[9,"val2","","",164],[9,"ref2","","",164],[9,"mut2","","",164],[9,"val3","","",164],[9,"ref3","","",164],[9,"mut3","","",164],[9,"val4","","",164],[9,"ref4","","",164],[9,"mut4","","",164],[9,"val5","","",164],[9,"ref5","","",164],[9,"mut5","","",164],[9,"val6","","",164],[9,"ref6","","",164],[9,"mut6","","",164],[9,"val7","","",164],[9,"ref7","","",164],[9,"mut7","","",164],[9,"val8","","",164],[9,"ref8","","",164],[9,"mut8","","",164],[6,"Tuple10","",""],[9,"val0","","",165],[9,"ref0","","",165],[9,"mut0","","",165],[9,"val1","","",165],[9,"ref1","","",165],[9,"mut1","","",165],[9,"val2","","",165],[9,"ref2","","",165],[9,"mut2","","",165],[9,"val3","","",165],[9,"ref3","","",165],[9,"mut3","","",165],[9,"val4","","",165],[9,"ref4","","",165],[9,"mut4","","",165],[9,"val5","","",165],[9,"ref5","","",165],[9,"mut5","","",165],[9,"val6","","",165],[9,"ref6","","",165],[9,"mut6","","",165],[9,"val7","","",165],[9,"ref7","","",165],[9,"mut7","","",165],[9,"val8","","",165],[9,"ref8","","",165],[9,"mut8","","",165],[9,"val9","","",165],[9,"ref9","","",165],[9,"mut9","","",165],[6,"Tuple11","",""],[9,"val0","","",166],[9,"ref0","","",166],[9,"mut0","","",166],[9,"val1","","",166],[9,"ref1","","",166],[9,"mut1","","",166],[9,"val2","","",166],[9,"ref2","","",166],[9,"mut2","","",166],[9,"val3","","",166],[9,"ref3","","",166],[9,"mut3","","",166],[9,"val4","","",166],[9,"ref4","","",166],[9,"mut4","","",166],[9,"val5","","",166],[9,"ref5","","",166],[9,"mut5","","",166],[9,"val6","","",166],[9,"ref6","","",166],[9,"mut6","","",166],[9,"val7","","",166],[9,"ref7","","",166],[9,"mut7","","",166],[9,"val8","","",166],[9,"ref8","","",166],[9,"mut8","","",166],[9,"val9","","",166],[9,"ref9","","",166],[9,"mut9","","",166],[9,"val10","","",166],[9,"ref10","","",166],[9,"mut10","","",166],[6,"Tuple12","",""],[9,"val0","","",167],[9,"ref0","","",167],[9,"mut0","","",167],[9,"val1","","",167],[9,"ref1","","",167],[9,"mut1","","",167],[9,"val2","","",167],[9,"ref2","","",167],[9,"mut2","","",167],[9,"val3","","",167],[9,"ref3","","",167],[9,"mut3","","",167],[9,"val4","","",167],[9,"ref4","","",167],[9,"mut4","","",167],[9,"val5","","",167],[9,"ref5","","",167],[9,"mut5","","",167],[9,"val6","","",167],[9,"ref6","","",167],[9,"mut6","","",167],[9,"val7","","",167],[9,"ref7","","",167],[9,"mut7","","",167],[9,"val8","","",167],[9,"ref8","","",167],[9,"mut8","","",167],[9,"val9","","",167],[9,"ref9","","",167],[9,"mut9","","",167],[9,"val10","","",167],[9,"ref10","","",167],[9,"mut10","","",167],[9,"val11","","",167],[9,"ref11","","",167],[9,"mut11","","",167],[16,"tuple","","Operations on tuples"],[0,"unit","core","The `()` type, sometimes called \"unit\" or \"nil\"."],[16,"unit","core::unit","The `()` type, sometimes called \"unit\" or \"nil\"."],[0,"fmt","core","Utilities for formatting and printing strings"],[1,"Radix","core::fmt","A radix with in the range of `2..36`."],[1,"RadixFmt","","A helper type for formatting radixes."],[1,"Formatter","","A struct to represent both where to emit formatting strings to and how they\nshould be formatted. A mutable version of this is passed to all formatting\ntraits."],[11,"flags","","Flags for formatting (packed version of rt::Flag)",168],[11,"fill","","Character used as 'fill' whenever there is alignment",168],[11,"align","","Boolean indication of whether the output should be left-aligned",168],[11,"width","","Optionally specified integer width that the output should be",168],[11,"precision","","Optionally specified precision for numeric types",168],[1,"Argument","","This struct represents the generic \"argument\" which is taken by the Xprintf\nfamily of functions. It contains a function to format the given value. At\ncompile time it is ensured that the function and the value have the correct\ntypes, and then this struct is used to canonicalize arguments to one type."],[1,"Arguments","","This structure represents a safely precompiled version of a format string\nand its arguments. This cannot be generated at runtime because it cannot\nsafely be done so, so no constructors are given and the fields are private\nto prevent modification."],[2,"FormatError","","The error type which is returned from formatting a message into a stream."],[12,"WriteError","","A generic write error occurred during formatting, no other information\nis transmitted via this variant.",169],[3,"radix","","Constructs a radix formatter in the range of `2..36`."],[3,"write","","The `write` function takes an output stream, a precompiled format string,\nand a list of arguments. The arguments will be formatted according to the\nspecified format string into the output stream provided."],[0,"rt","","This is an internal module used by the ifmt! runtime. These structures are\nemitted to static arrays to precompile format strings ahead of time."],[2,"Alignment","core::fmt::rt","Possible alignments that can be requested as part of a formatting directive."],[12,"AlignLeft","","Indication that contents should be left-aligned.",170],[12,"AlignRight","","Indication that contents should be right-aligned.",170],[12,"AlignUnknown","","No alignment was requested.",170],[2,"Flag","","Flags which can be passed to formatting via a directive."],[12,"FlagSignPlus","","A flag which enables number formatting to always print the sign of a\nnumber.",171],[12,"FlagSignMinus","","Currently not a used flag",171],[12,"FlagAlternate","","Indicates that the \"alternate formatting\" for a type should be used.",171],[12,"FlagSignAwareZeroPad","","Indicates that padding should be done with a `0` character as well as\nbeing aware of the sign to be printed.",171],[10,"eq","","",170],[10,"ne","","",170],[4,"Result","core::fmt",""],[6,"FormatWriter","","A collection of methods that are required to format a message into a stream."],[9,"write","","Writes a slice of bytes into this writer, returning whether the write\nsucceeded.",172],[10,"write_fmt","","Glue for usage of the `write!` macro with implementers of this trait.",172],[6,"Show","","When a format is not otherwise specified, types are formatted by ascribing\nto this trait. There is not an explicit way of selecting this trait to be\nused for formatting, it is only if no other format is specified."],[9,"fmt","","Formats the value using the given formatter.",173],[6,"Bool","","Format trait for the `b` character"],[9,"fmt","","Formats the value using the given formatter.",174],[6,"Char","","Format trait for the `c` character"],[9,"fmt","","Formats the value using the given formatter.",175],[6,"Signed","","Format trait for the `i` and `d` characters"],[9,"fmt","","Formats the value using the given formatter.",176],[6,"Unsigned","","Format trait for the `u` character"],[9,"fmt","","Formats the value using the given formatter.",177],[6,"Octal","","Format trait for the `o` character"],[9,"fmt","","Formats the value using the given formatter.",178],[6,"Binary","","Format trait for the `t` character"],[9,"fmt","","Formats the value using the given formatter.",179],[6,"LowerHex","","Format trait for the `x` character"],[9,"fmt","","Formats the value using the given formatter.",180],[6,"UpperHex","","Format trait for the `X` character"],[9,"fmt","","Formats the value using the given formatter.",181],[6,"String","","Format trait for the `s` character"],[9,"fmt","","Formats the value using the given formatter.",182],[6,"Pointer","","Format trait for the `p` character"],[9,"fmt","","Formats the value using the given formatter.",183],[6,"Float","","Format trait for the `f` character"],[9,"fmt","","Formats the value using the given formatter.",184],[6,"LowerExp","","Format trait for the `e` character"],[9,"fmt","","Formats the value using the given formatter.",185],[6,"UpperExp","","Format trait for the `E` character"],[9,"fmt","","Formats the value using the given formatter.",186],[10,"fmt","","",187],[10,"pad_integral","","Performs the correct padding for an integer which has already been\nemitted into a byte-array. The byte-array should *not* contain the sign\nfor the integer, that will be added by this method.",168],[10,"pad","","This function takes a string slice and emits it to the internal buffer\nafter applying the relevant formatting flags specified. The flags\nrecognized for generic strings are:",168],[10,"write","","Writes some data to the underlying buffer contained within this\nformatter.",168],[10,"write_fmt","","Writes some formatted information into this instance",168],[10,"fmt","core::cell","",66],[10,"fmt","","",68],[10,"fmt","","",69],[15,"fail!","core","Entry point of failure, for details, see std::macros"],[15,"assert!","","Runtime assertion, for details see std::macros"],[15,"debug_assert!","","Runtime assertion, only without `--cfg ndebug`"],[15,"assert_eq!","","Runtime assertion for equality, for details see std::macros"],[15,"debug_assert_eq!","","Runtime assertion for equality, only without `--cfg ndebug`"],[15,"debug_assert!","","Runtime assertion, disableable at compile time"],[15,"try!","","Short circuiting evaluation on Err"],[15,"write!","","Writing a formatted string into a writer"],[15,"writeln!","","Writing a formatted string plus a newline into a writer"],[15,"write!","","Write some formatted data into a stream."],[15,"unreachable!","",""],[16,"int","",""],[16,"i8","",""],[16,"i16","",""],[16,"i32","",""],[16,"i64","",""],[16,"uint","",""],[16,"u8","",""],[16,"u16","",""],[16,"u32","",""],[16,"u64","",""],[16,"f32","",""],[16,"f64","",""],[16,"bool","",""],[16,"char","",""],[16,"slice","",""],[16,"str","",""],[16,"tuple","",""],[16,"unit","",""]],"paths":[[2,"FPCategory"],[6,"Zero"],[6,"One"],[6,"Signed"],[6,"Bounded"],[6,"Int"],[6,"ToPrimitive"],[6,"FromPrimitive"],[6,"NumCast"],[6,"Saturating"],[6,"CheckedAdd"],[6,"CheckedSub"],[6,"CheckedMul"],[6,"CheckedDiv"],[6,"Float"],[1,"TyDesc"],[6,"TyVisitor"],[1,"TypeId"],[6,"RawPtr"],[1,"CovariantType"],[1,"ContravariantType"],[1,"InvariantType"],[1,"CovariantLifetime"],[1,"ContravariantLifetime"],[1,"InvariantLifetime"],[1,"NoSend"],[1,"NoCopy"],[1,"NoShare"],[1,"Managed"],[6,"Drop"],[6,"Add"],[6,"Sub"],[6,"Mul"],[6,"Div"],[6,"Rem"],[6,"Neg"],[6,"Not"],[6,"BitAnd"],[6,"BitOr"],[6,"BitXor"],[6,"Shl"],[6,"Shr"],[6,"Index"],[6,"IndexMut"],[6,"Deref"],[6,"DerefMut"],[6,"Fn"],[6,"FnMut"],[6,"FnOnce"],[2,"Ordering"],[6,"PartialEq"],[6,"Ord"],[6,"PartialOrd"],[6,"Equiv"],[6,"Clone"],[6,"Default"],[6,"Collection"],[6,"AnyPrivate"],[6,"AnyRefExt"],[6,"AnyMutRefExt"],[2,"Ordering"],[1,"AtomicBool"],[1,"AtomicInt"],[1,"AtomicUint"],[1,"AtomicPtr"],[1,"UnsafeCell"],[1,"Cell"],[1,"RefCell"],[1,"Ref"],[1,"RefMut"],[6,"Char"],[6,"Finally"],[1,"Scan"],[1,"Unfold"],[2,"MinMaxResult"],[6,"FromIterator"],[6,"Extendable"],[6,"Iterator"],[6,"DoubleEndedIterator"],[6,"MutableDoubleEndedIterator"],[6,"RandomAccessIterator"],[6,"ExactSize"],[6,"AdditiveIterator"],[6,"MultiplicativeIterator"],[6,"OrdIterator"],[6,"CloneableIterator"],[1,"Rev"],[1,"ByRef"],[1,"Cycle"],[1,"Chain"],[1,"Zip"],[1,"Map"],[1,"Filter"],[1,"FilterMap"],[1,"Enumerate"],[1,"Peekable"],[1,"SkipWhile"],[1,"TakeWhile"],[1,"Skip"],[1,"Take"],[1,"FlatMap"],[1,"Fuse"],[1,"Inspect"],[1,"Counter"],[1,"Range"],[1,"RangeInclusive"],[1,"RangeStep"],[1,"RangeStepInclusive"],[1,"Repeat"],[2,"Option"],[1,"Item"],[1,"Box"],[1,"Slice"],[1,"Closure"],[1,"Procedure"],[1,"TraitObject"],[6,"Repr"],[2,"Result"],[1,"i8x16"],[1,"i16x8"],[1,"i32x4"],[1,"i64x2"],[1,"u8x16"],[1,"u16x8"],[1,"u32x4"],[1,"u64x2"],[1,"f32x4"],[1,"f64x2"],[6,"MutableByteVector"],[6,"ImmutableVector"],[6,"MutableVector"],[6,"ImmutableEqVector"],[6,"ImmutableOrdVector"],[6,"MutableCloneableVector"],[6,"Vector"],[1,"Items"],[1,"MutItems"],[1,"Splits"],[1,"MutSplits"],[1,"SplitsN"],[1,"Windows"],[1,"Chunks"],[1,"MutChunks"],[1,"CharRange"],[2,"Utf16Item"],[6,"CharEq"],[6,"Str"],[6,"StrSlice"],[1,"Chars"],[1,"CharOffsets"],[1,"CharSplits"],[1,"CharSplitsN"],[1,"MatchIndices"],[1,"StrSplits"],[1,"Utf16CodeUnits"],[1,"Utf16Items"],[6,"Tuple1"],[6,"Tuple2"],[6,"Tuple3"],[6,"Tuple4"],[6,"Tuple5"],[6,"Tuple6"],[6,"Tuple7"],[6,"Tuple8"],[6,"Tuple9"],[6,"Tuple10"],[6,"Tuple11"],[6,"Tuple12"],[1,"Formatter"],[2,"FormatError"],[2,"Alignment"],[2,"Flag"],[6,"FormatWriter"],[6,"Show"],[6,"Bool"],[6,"Char"],[6,"Signed"],[6,"Unsigned"],[6,"Octal"],[6,"Binary"],[6,"LowerHex"],[6,"UpperHex"],[6,"String"],[6,"Pointer"],[6,"Float"],[6,"LowerExp"],[6,"UpperExp"],[1,"Arguments"]]};

searchIndex['graphviz'] = {"items":[[0,"","graphviz","Generate files suitable for use with [Graphviz](http://www.graphviz.org/)"],[1,"Id","","`Id` is a Graphviz `ID`."],[2,"LabelText","","The text for a graphviz label on a node or edge."],[12,"LabelStr","","This kind of label preserves the text directly as is.",0],[12,"EscStr","","This kind of label uses the graphviz label escString type:\nhttp://www.graphviz.org/content/attrs#kescString",0],[3,"render","","Renders directed graph `g` into the writer `w` in DOT syntax.\n(Main entry point for the library.)"],[0,"maybe_owned_vec","",""],[2,"MaybeOwnedVector","graphviz::maybe_owned_vec","MaybeOwnedVector<'a,T> abstracts over `Vec<T>`, `&'a [T]`."],[12,"Growable","","",1],[12,"Borrowed","","",1],[6,"IntoMaybeOwnedVector","","Trait for moving into a `MaybeOwnedVector`"],[9,"into_maybe_owned","","Moves self into a `MaybeOwnedVector`",2],[10,"into_maybe_owned","collections::vec","",3],[10,"iter","graphviz::maybe_owned_vec","",1],[10,"eq","","",1],[10,"partial_cmp","","",1],[10,"cmp","","",1],[10,"equiv","","",1],[10,"as_slice","","",1],[10,"from_iter","","",1],[10,"fmt","","",1],[10,"to_vec","","Returns a copy of `self`.",1],[10,"into_vec","","Convert `self` into an owned slice, not making a copy if possible.",1],[10,"clone","","",1],[10,"default","","",1],[10,"len","","",1],[10,"container_as_bytes","","",1],[10,"into_vec","","Convert `self` into a growable `Vec`, not making a copy if possible.",1],[4,"Nodes","graphviz",""],[4,"Edges","",""],[6,"Labeller","","Each instance of a type that implements `Label<C>` maps to a\nunique identifier with respect to `C`, which is used to identify\nit in the generated .dot file. They can also provide more\nelaborate (and non-unique) label text that is used in the graphviz\nrendered output.\nThe graph instance is responsible for providing the DOT compatible\nidentifiers for the nodes and (optionally) rendered labels for the nodes and\nedges, as well as an identifier for the graph itself."],[9,"graph_id","","Must return a DOT compatible identifier naming the graph.",4],[9,"node_id","","Maps `n` to a unique identifier with respect to `self`. The\nimplementer is responsible for ensuring that the returned name\nis a valid DOT identifier.",4],[10,"node_label","","Maps `n` to a label that will be used in the rendered output.\nThe label need not be unique, and may be the empty string; the\ndefault is just the output from `node_id`.",4],[10,"edge_label","","Maps `e` to a label that will be used in the rendered output.\nThe label need not be unique, and may be the empty string; the\ndefault is in fact the empty string.",4],[6,"GraphWalk","","GraphWalk is an abstraction over a directed graph = (nodes,edges)\nmade up of node handles `N` and edge handles `E`, where each `E`\ncan be mapped to its source and target nodes."],[9,"nodes","","Returns all the nodes in this graph.",5],[9,"edges","","Returns all of the edges in this graph.",5],[9,"source","","The source node for `edge`.",5],[9,"target","","The target node for `edge`.",5],[10,"new","","Creates an `Id` named `name`.",6],[10,"as_slice","","",6],[10,"name","","",6],[10,"escape","","Renders text as string suitable for a label in a .dot file.",0],[10,"prefix_line","","Puts `prefix` on a line above this label, with a blank line separator.",0],[10,"suffix_line","","Puts `suffix` on a line below this label, with a blank line separator.",0]],"paths":[[2,"LabelText"],[2,"MaybeOwnedVector"],[6,"IntoMaybeOwnedVector"],[1,"Vec"],[6,"Labeller"],[6,"GraphWalk"],[1,"Id"]]};

searchIndex['regex'] = {"items":[[0,"","regex","This crate provides a native implementation of regular expressions that is\nheavily based on RE2 both in syntax and in implementation. Notably,\nbackreferences and arbitrary lookahead/lookbehind assertions are not\nprovided. In return, regular expression searching provided by this package\nhas excellent worst case performance. The specific syntax supported is\ndocumented further down."],[1,"Error","","Error corresponds to something that can go wrong while parsing\na regular expression."],[11,"pos","","The *approximate* character index of where the error occurred.",0],[11,"msg","","A message describing the error.",0],[1,"Captures","","Captures represents a group of captured strings for a single match."],[1,"SubCaptures","","An iterator over capture groups for a particular match of a regular\nexpression."],[1,"SubCapturesPos","","An iterator over capture group positions for a particular match of a\nregular expression."],[1,"FindCaptures","","An iterator that yields all non-overlapping capture groups matching a\nparticular regular expression."],[1,"FindMatches","","An iterator over all non-overlapping matches for a particular string."],[1,"NoExpand","","NoExpand indicates literal string replacement."],[1,"RegexSplits","","Yields all substrings delimited by a regular expression match."],[1,"RegexSplitsN","","Yields at most `N` substrings delimited by a regular expression match."],[2,"Regex","","A compiled regular expression"],[3,"quote","","Escapes all regular expression meta characters in `text`."],[3,"is_match","","Tests if the given regular expression matches somewhere in the text given."],[6,"Replacer","","Replacer describes types that can be used to replace matches in a string."],[9,"reg_replace","","Returns a possibly owned string that is used to replace the match\ncorresponding the the `caps` capture group.",1]],"paths":[[1,"Error"],[6,"Replacer"]]};

searchIndex['log'] = {"items":[[0,"","log","Utilities for program-wide and customizable logging"],[1,"LogLevel","","Wraps the log level with fmt implementations."],[1,"LogRecord","","A LogRecord is created by the logging macros, and passed as the only\nargument to Loggers."],[11,"module_path","","The module path of where the LogRecord originated.",0],[11,"level","","The LogLevel of this record.",0],[11,"args","","The arguments from the log line.",0],[11,"file","","The file of where the LogRecord originated.",0],[11,"line","","The line number of where the LogRecord originated.",0],[3,"set_logger","","Replaces the task-local logger with the specified logger, returning the old\nlogger."],[0,"macros","","Logging macros"],[5,"MAX_LOG_LEVEL","","Maximum logging level of a module that can be specified. Common logging\nlevels are found in the DEBUG/INFO/WARN/ERROR constants."],[5,"DEBUG","","Debug log level"],[5,"INFO","","Info log level"],[5,"WARN","","Warn log level"],[5,"ERROR","","Error log level"],[6,"Logger","","A trait used to represent an interface to a task-local logger. Each task\ncan have its own custom logger which can respond to logging messages\nhowever it likes."],[9,"log","","Logs a single message described by the `record`.",1],[10,"partial_cmp","","",2],[10,"lt","","",2],[10,"le","","",2],[10,"gt","","",2],[10,"ge","","",2],[10,"eq","","",2],[10,"ne","","",2],[10,"fmt","","",2],[10,"fmt","","",2],[10,"fmt","","",0],[15,"log!","","The standard logging macro"],[15,"error!","","A convenience macro for logging at the error log level."],[15,"warn!","","A convenience macro for logging at the warning log level."],[15,"info!","","A convenience macro for logging at the info log level."],[15,"debug!","","A convenience macro for logging at the debug log level. This macro can also\nbe omitted at compile time by passing `--cfg ndebug` to the compiler. If\nthis option is not passed, then debug statements will be compiled."],[15,"log_enabled!","","A macro to test whether a log level is enabled for the current module."]],"paths":[[1,"LogRecord"],[6,"Logger"],[1,"LogLevel"]]};

searchIndex['url'] = {"items":[[0,"","url","Types/fns concerning URLs (see RFC 3986)"],[1,"Url","","A Uniform Resource Locator (URL).  A URL is a form of URI (Uniform Resource\nIdentifier) that includes network location information, such as hostname or\nport number."],[11,"scheme","","The scheme part of a URL, such as `https` in the above example.",0],[11,"user","","A URL subcomponent for user authentication.  `username` in the above example.",0],[11,"host","","A domain name or IP address.  For example, `example.com`.",0],[11,"port","","A TCP port number, for example `8080`.",0],[11,"path","","The path component of a URL, for example `/foo/bar?baz=qux#quz`.",0],[1,"Path","",""],[11,"path","","The path component of a URL, for example `/foo/bar`.",1],[11,"query","","The query component of a URL.\n`vec![(\"baz\".to_string(), \"qux\".to_string())]` represents the fragment\n`baz=qux` in the above example.",1],[11,"fragment","","The fragment component, such as `quz`. Not including the leading `#` character.",1],[1,"UserInfo","","An optional subcomponent of a URI authority component."],[11,"user","","The user name.",2],[11,"pass","","Password or other scheme-specific authentication information.",2],[3,"from_str","",""],[3,"path_from_str","",""],[3,"encode","","Encodes a URI by replacing reserved characters with percent-encoded\ncharacter sequences."],[3,"encode_component","","Encodes a URI component by replacing reserved characters with percent-\nencoded character sequences."],[3,"decode","","Decodes a percent-encoded string representing a URI."],[3,"decode_component","","Decode a string encoded with percent encoding."],[3,"encode_form_urlencoded","","Encode a hashmap to the 'application/x-www-form-urlencoded' media type."],[3,"decode_form_urlencoded","","Decode a string encoded with the 'application/x-www-form-urlencoded' media\ntype into a hashmap."],[3,"query_to_str","","Converts an instance of a URI `Query` type to a string."],[3,"get_scheme","","Returns a tuple of the URI scheme and the rest of the URI, or a parsing error."],[4,"Query","","Represents the query component of a URI."],[4,"DecodeResult","",""],[10,"eq","","",0],[10,"ne","","",0],[10,"clone","","",0],[10,"eq","","",1],[10,"ne","","",1],[10,"clone","","",1],[10,"eq","","",2],[10,"ne","","",2],[10,"clone","","",2],[10,"new","","",0],[10,"parse","","Parses a URL, converting it from a string to a `Url` representation.",0],[10,"new","","",1],[10,"parse","","Parses a URL path, converting it from a string to a `Path` representation.",1],[10,"new","","",2],[10,"fmt","","",2],[10,"from_str","","",0],[10,"from_str","","",1],[10,"fmt","","Converts a URL from `Url` to string representation.",0],[10,"fmt","","",1],[10,"hash","","",0],[10,"hash","","",1]],"paths":[[1,"Url"],[1,"Path"],[1,"UserInfo"]]};

searchIndex['rand'] = {"items":[[0,"","rand","Interface to random number generators in Rust."],[1,"Generator","","Iterator which will generate a stream of random items."],[1,"AsciiGenerator","","Iterator which will continuously generate random ascii characters."],[1,"XorShiftRng","","An Xorshift[1] random number\ngenerator."],[1,"Open01","","A wrapper for generating floating point numbers uniformly in the\nopen interval `(0,1)` (not including either endpoint)."],[1,"Closed01","","A wrapper for generating floating point numbers uniformly in the\nclosed interval `[0,1]` (including both endpoints)."],[0,"distributions","","Sampling from random distributions."],[1,"RandSample","rand::distributions","A wrapper for generating types that implement `Rand` via the\n`Sample` & `IndependentSample` traits."],[1,"Weighted","","A value with a particular weight for use with `WeightedChoice`."],[11,"weight","","The numerical weight of this item",0],[11,"item","","The actual item which is being weighted",0],[1,"WeightedChoice","","A distribution that selects from a finite collection of weighted items."],[0,"range","","Generating numbers between two others."],[1,"Range","rand::distributions::range","Sample values uniformly between two bounds."],[6,"SampleRange","","The helper trait for types that have a sensible way to sample\nuniformly between two values. This should not be used directly,\nand is only to facilitate `Range`."],[9,"construct_range","","Construct the `Range` object that `sample_range`\nrequires. This should not ever be called directly, only via\n`Range::new`, which will check that `low < high`, so this\nfunction doesn't have to repeat the check.",1],[9,"sample_range","","Sample a value from the given `Range` with the given `Rng` as\na source of randomness.",1],[10,"new","","Create a new `Range` instance that samples uniformly from\n`[low, high)`. Fails if `low >= high`.",2],[10,"sample","","",2],[10,"ind_sample","","",2],[0,"gamma","rand::distributions","The Gamma and derived distributions."],[1,"Gamma","rand::distributions::gamma","The Gamma distribution `Gamma(shape, scale)` distribution."],[1,"ChiSquared","","The chi-squared distribution `(k)`, where `k` is the degrees of\nfreedom."],[1,"FisherF","","The Fisher F distribution `F(m, n)`."],[1,"StudentT","","The Student t distribution, `t(nu)`, where `nu` is the degrees of\nfreedom."],[10,"new","","Construct an object representing the `Gamma(shape, scale)`\ndistribution.",3],[10,"sample","","",3],[10,"ind_sample","","",3],[10,"new","","Create a new chi-squared distribution with degrees-of-freedom\n`k`. Fails if `k < 0`.",4],[10,"sample","","",4],[10,"ind_sample","","",4],[10,"new","","Create a new `FisherF` distribution, with the given\nparameter. Fails if either `m` or `n` are not positive.",5],[10,"sample","","",5],[10,"ind_sample","","",5],[10,"new","","Create a new Student t distribution with `n` degrees of\nfreedom. Fails if `n <= 0`.",6],[10,"sample","","",6],[10,"ind_sample","","",6],[0,"normal","rand::distributions","The normal and derived distributions."],[1,"StandardNormal","rand::distributions::normal","A wrapper around an `f64` to generate N(0, 1) random numbers\n(a.k.a.  a standard normal, or Gaussian)."],[1,"Normal","","The normal distribution `N(mean, std_dev**2)`."],[1,"LogNormal","","The log-normal distribution `ln N(mean, std_dev**2)`."],[10,"rand","","",7],[10,"new","","Construct a new `Normal` distribution with the given mean and\nstandard deviation. Fails if `std_dev < 0`.",8],[10,"sample","","",8],[10,"ind_sample","","",8],[10,"new","","Construct a new `LogNormal` distribution with the given mean\nand standard deviation. Fails if `std_dev < 0`.",9],[10,"sample","","",9],[10,"ind_sample","","",9],[0,"exponential","rand::distributions","The exponential distribution."],[1,"Exp1","rand::distributions::exponential","A wrapper around an `f64` to generate Exp(1) random numbers."],[1,"Exp","","The exponential distribution `Exp(lambda)`."],[10,"rand","","",10],[10,"new","","Construct a new `Exp` with the given shape parameter\n`lambda`. Fails if `lambda <= 0`.",11],[10,"sample","","",11],[10,"ind_sample","","",11],[6,"Sample","rand::distributions","Types that can be used to create a random instance of `Support`."],[9,"sample","","Generate a random value of `Support`, using `rng` as the\nsource of randomness.",12],[6,"IndependentSample","","`Sample`s that do not require keeping track of state."],[9,"ind_sample","","Generate a random value.",13],[10,"sample","","",14],[10,"ind_sample","","",14],[10,"new","","Create a new `WeightedChoice`.",15],[10,"sample","","",15],[10,"ind_sample","","",15],[0,"isaac","rand","The ISAAC random number generator."],[1,"IsaacRng","rand::isaac","A random number generator that uses the ISAAC algorithm[1]."],[1,"Isaac64Rng","","A random number generator that uses ISAAC-64[1], the 64-bit\nvariant of the ISAAC algorithm."],[10,"new_unseeded","","Create an ISAAC random number generator using the default\nfixed seed.",16],[10,"next_u32","","",16],[10,"reseed","","",16],[10,"from_seed","","Create an ISAAC random number generator with a seed. This can\nbe any length, although the maximum number of elements used is\n256 and any more will be silently ignored. A generator\nconstructed with a given seed will generate the same sequence\nof values as all other generators constructed with that seed.",16],[10,"rand","","",16],[10,"new_unseeded","","Create a 64-bit ISAAC random number generator using the\ndefault fixed seed.",17],[10,"next_u32","","",17],[10,"next_u64","","",17],[10,"reseed","","",17],[10,"from_seed","","Create an ISAAC random number generator with a seed. This can\nbe any length, although the maximum number of elements used is\n256 and any more will be silently ignored. A generator\nconstructed with a given seed will generate the same sequence\nof values as all other generators constructed with that seed.",17],[10,"rand","","",17],[0,"reseeding","rand","A wrapper around another RNG that reseeds it after it\ngenerates a certain number of random bytes."],[1,"ReseedingRng","rand::reseeding","A wrapper around any RNG which reseeds the underlying RNG after it\nhas generated a certain number of random bytes."],[11,"reseeder","","Controls the behaviour when reseeding the RNG.",18],[1,"ReseedWithDefault","","Reseed an RNG using a `Default` instance. This reseeds by\nreplacing the RNG with the result of a `Default::default` call."],[6,"Reseeder","","Something that can be used to reseed an RNG via `ReseedingRng`."],[9,"reseed","","Reseed the given RNG.",19],[10,"new","","Create a new `ReseedingRng` with the given parameters.",18],[10,"reseed_if_necessary","","Reseed the internal RNG if the number of bytes that have been\ngenerated exceed the threshold.",18],[10,"next_u32","","",18],[10,"next_u64","","",18],[10,"fill_bytes","","",18],[10,"reseed","","",18],[10,"from_seed","","Create a new `ReseedingRng` from the given reseeder and\nseed. This uses a default value for `generation_threshold`.",18],[10,"reseed","","",20],[10,"default","","",20],[6,"Rand","rand","A type that can be randomly generated using an `Rng`."],[9,"rand","","Generates a random instance of this type using the specified source of\nrandomness.",21],[6,"Rng","","A random number generator."],[9,"next_u32","","Return the next random u32.",22],[10,"next_u64","","Return the next random u64.",22],[10,"fill_bytes","","Fill `dest` with random data.",22],[10,"gen","","Return a random value of a `Rand` type.",22],[10,"gen_iter","","Return an iterator which will yield an infinite number of randomly\ngenerated items.",22],[10,"gen_range","","Generate a random value in the range [`low`, `high`). Fails if\n`low >= high`.",22],[10,"gen_weighted_bool","","Return a bool with a 1 in n chance of true",22],[10,"gen_ascii_chars","","Return an iterator of random characters from the set A-Z,a-z,0-9.",22],[10,"choose","","Return a random element from `values`.",22],[10,"choose_option","","Deprecated name for `choose()`.",22],[10,"shuffle","","Shuffle a mutable slice in place.",22],[6,"SeedableRng","","A random number generator that can be explicitly seeded to produce\nthe same stream of randomness multiple times."],[9,"reseed","","Reseed an RNG with the given seed.",23],[9,"from_seed","","Create a new RNG with the given seed.",23],[10,"next","","",24],[10,"next","","",25],[10,"new_unseeded","","Creates a new XorShiftRng instance which is not seeded.",26],[10,"next_u32","","",26],[10,"reseed","","Reseed an XorShiftRng. This will fail if `seed` is entirely 0.",26],[10,"from_seed","","Create a new XorShiftRng. This will fail if `seed` is entirely 0.",26],[10,"rand","","",26]],"paths":[[1,"Weighted"],[6,"SampleRange"],[1,"Range"],[1,"Gamma"],[1,"ChiSquared"],[1,"FisherF"],[1,"StudentT"],[1,"StandardNormal"],[1,"Normal"],[1,"LogNormal"],[1,"Exp1"],[1,"Exp"],[6,"Sample"],[6,"IndependentSample"],[1,"RandSample"],[1,"WeightedChoice"],[1,"IsaacRng"],[1,"Isaac64Rng"],[1,"ReseedingRng"],[6,"Reseeder"],[1,"ReseedWithDefault"],[6,"Rand"],[6,"Rng"],[6,"SeedableRng"],[1,"Generator"],[1,"AsciiGenerator"],[1,"XorShiftRng"]]};

searchIndex['time'] = {"items":[[0,"","time","Simple time handling."],[1,"Timespec","","A record specifying a time value in seconds and nanoseconds."],[11,"sec","","",0],[11,"nsec","","",0],[1,"Tm","","Holds a calendar date and time broken down into its components (year, month, day, and so on),\nalso called a broken-down time value."],[11,"tm_sec","","Seconds after the minute - [0, 60]",1],[11,"tm_min","","Minutes after the hour - [0, 59]",1],[11,"tm_hour","","Hours after midnight - [0, 23]",1],[11,"tm_mday","","Day of the month - [1, 31]",1],[11,"tm_mon","","Months since January - [0, 11]",1],[11,"tm_year","","Years since 1900",1],[11,"tm_wday","","Days since Sunday - [0, 6]. 0 = Sunday, 1 = Monday, ..., 6 = Saturday.",1],[11,"tm_yday","","Days since January 1 - [0, 365]",1],[11,"tm_isdst","","Daylight Saving Time flag.",1],[11,"tm_gmtoff","","Identifies the time zone that was used to compute this broken-down time value, including any\nadjustment for Daylight Saving Time. This is the number of seconds east of UTC. For example,\nfor U.S. Pacific Daylight Time, the value is -7*60*60 = -25200.",1],[11,"tm_nsec","","Nanoseconds after the second - [0, 10<sup>9</sup> - 1]",1],[3,"get_time","","Returns the current time as a `timespec` containing the seconds and\nnanoseconds since 1970-01-01T00:00:00Z."],[3,"precise_time_ns","","Returns the current value of a high-resolution performance counter\nin nanoseconds since an unspecified epoch."],[3,"precise_time_s","","Returns the current value of a high-resolution performance counter\nin seconds since an unspecified epoch."],[3,"tzset","",""],[3,"empty_tm","",""],[3,"at_utc","","Returns the specified time in UTC"],[3,"now_utc","","Returns the current time in UTC"],[3,"at","","Returns the specified time in the local timezone"],[3,"now","","Returns the current time in the local timezone"],[3,"strptime","","Parses the time from the string according to the format string."],[3,"strftime","","Formats the time according to the format string."],[10,"fmt","","",0],[10,"decode","","",0],[10,"encode","","",0],[10,"cmp","","",0],[10,"partial_cmp","","",0],[10,"lt","","",0],[10,"le","","",0],[10,"gt","","",0],[10,"ge","","",0],[10,"eq","","",0],[10,"ne","","",0],[10,"clone","","",0],[10,"new","","",0],[10,"fmt","","",1],[10,"eq","","",1],[10,"ne","","",1],[10,"clone","","",1],[10,"to_timespec","","Convert time to the seconds from January 1, 1970",1],[10,"to_local","","Convert time to the local timezone",1],[10,"to_utc","","Convert time to the UTC",1],[10,"ctime","","Returns a time string formatted according to the `asctime` format in ISO\nC, in the local timezone.",1],[10,"asctime","","Returns a time string formatted according to the `asctime` format in ISO\nC.",1],[10,"strftime","","Formats the time according to the format string.",1],[10,"rfc822","","Returns a time string formatted according to RFC 822.",1],[10,"rfc822z","","Returns a time string formatted according to RFC 822 with Zulu time.",1],[10,"rfc3339","","Returns a time string formatted according to RFC 3999. RFC 3999 is\ncompatible with ISO 8601.",1]],"paths":[[1,"Timespec"],[1,"Tm"]]};

searchIndex['test'] = {"items":[[0,"","test","Support code for rustc's built in unit-test and micro-benchmarking\nframework."],[1,"Bencher","","Manager of the benchmarking runs."],[11,"bytes","","",0],[1,"TestDesc","",""],[11,"name","","",1],[11,"ignore","","",1],[11,"should_fail","","",1],[1,"TestDescAndFn","",""],[11,"desc","","",2],[11,"testfn","","",2],[1,"Metric","",""],[1,"MetricMap","",""],[1,"TestOpts","",""],[11,"filter","","",3],[11,"run_ignored","","",3],[11,"run_tests","","",3],[11,"run_benchmarks","","",3],[11,"ratchet_metrics","","",3],[11,"ratchet_noise_percent","","",3],[11,"save_metrics","","",3],[11,"test_shard","","",3],[11,"logfile","","",3],[11,"nocapture","","",3],[11,"color","","",3],[1,"BenchSamples","",""],[2,"TestName","",""],[12,"StaticTestName","","",4],[12,"DynTestName","","",4],[2,"TestFn","",""],[12,"StaticTestFn","","",5],[12,"StaticBenchFn","","",5],[12,"StaticMetricFn","","",5],[12,"DynTestFn","","",5],[12,"DynMetricFn","","",5],[12,"DynBenchFn","","",5],[2,"MetricChange","","Analysis of a single change in metric"],[12,"LikelyNoise","","",6],[12,"MetricAdded","","",6],[12,"MetricRemoved","","",6],[12,"Improvement","","",6],[12,"Regression","","",6],[2,"ColorConfig","",""],[12,"AutoColor","","",7],[12,"AlwaysColor","","",7],[12,"NeverColor","","",7],[2,"TestResult","",""],[12,"TrOk","","",8],[12,"TrFailed","","",8],[12,"TrIgnored","","",8],[12,"TrMetrics","","",8],[12,"TrBench","","",8],[3,"test_main","",""],[3,"test_main_static","",""],[3,"parse_opts","",""],[3,"opt_shard","",""],[3,"fmt_metrics","",""],[3,"fmt_bench_samples","",""],[3,"run_tests_console","",""],[3,"filter_tests","",""],[3,"run_test","",""],[3,"black_box","","A function that is opaque to the optimizer, to allow benchmarks to\npretend to use outputs to assist in avoiding dead-code\nelimination."],[0,"test","",""],[0,"stats","",""],[1,"Summary","test::stats","Extracted collection of all the summary statistics of a sample set."],[11,"sum","","",9],[11,"min","","",9],[11,"max","","",9],[11,"mean","","",9],[11,"median","","",9],[11,"var","","",9],[11,"std_dev","","",9],[11,"std_dev_pct","","",9],[11,"median_abs_dev","","",9],[11,"median_abs_dev_pct","","",9],[11,"quartiles","","",9],[11,"iqr","","",9],[3,"winsorize","","Winsorize a set of samples, replacing values above the `100-pct` percentile and below the `pct`\npercentile with those percentiles themselves. This is a way of minimizing the effect of\noutliers, at the cost of biasing the sample. It differs from trimming in that it does not\nchange the number of samples, just changes the values of those that are outliers."],[3,"write_5_number_summary","","Render writes the min, max and quartiles of the provided `Summary` to the provided `Writer`."],[3,"write_boxplot","","Render a boxplot to the provided writer. The boxplot shows the min, max and quartiles of the\nprovided `Summary` (thus includes the mean) and is scaled to display within the range of the\nnearest multiple-of-a-power-of-ten above and below the min and max of possible values, and\ntarget `width_hint` characters of display (though it will be wider if necessary)."],[3,"freq_count","","Returns a HashMap with the number of occurrences of every element in the\nsequence that the iterator exposes."],[6,"Stats","","Trait that provides simple descriptive statistics on a univariate set of numeric samples."],[9,"sum","","Sum of the samples.",10],[9,"min","","Minimum value of the samples.",10],[9,"max","","Maximum value of the samples.",10],[9,"mean","","Arithmetic mean (average) of the samples: sum divided by sample-count.",10],[9,"median","","Median of the samples: value separating the lower half of the samples from the higher half.\nEqual to `self.percentile(50.0)`.",10],[9,"var","","Variance of the samples: bias-corrected mean of the squares of the differences of each\nsample from the sample mean. Note that this calculates the _sample variance_ rather than the\npopulation variance, which is assumed to be unknown. It therefore corrects the `(n-1)/n`\nbias that would appear if we calculated a population variance, by dividing by `(n-1)` rather\nthan `n`.",10],[9,"std_dev","","Standard deviation: the square root of the sample variance.",10],[9,"std_dev_pct","","Standard deviation as a percent of the mean value. See `std_dev` and `mean`.",10],[9,"median_abs_dev","","Scaled median of the absolute deviations of each sample from the sample median. This is a\nrobust (distribution-agnostic) estimator of sample variability. Use this in preference to\n`std_dev` if you cannot assume your sample is normally distributed. Note that this is scaled\nby the constant `1.4826` to allow its use as a consistent estimator for the standard\ndeviation.",10],[9,"median_abs_dev_pct","","Median absolute deviation as a percent of the median. See `median_abs_dev` and `median`.",10],[9,"percentile","","Percentile: the value below which `pct` percent of the values in `self` fall. For example,\npercentile(95.0) will return the value `v` such that 95% of the samples `s` in `self`\nsatisfy `s <= v`.",10],[9,"quartiles","","Quartiles of the sample: three values that divide the sample into four equal groups, each\nwith 1/4 of the data. The middle value is the median. See `median` and `percentile`. This\nfunction may calculate the 3 quartiles more efficiently than 3 calls to `percentile`, but\nis otherwise equivalent.",10],[9,"iqr","","Inter-quartile range: the difference between the 25th percentile (1st quartile) and the 75th\npercentile (3rd quartile). See `quartiles`.",10],[10,"eq","","",9],[10,"ne","","",9],[10,"clone","","",9],[10,"new","","Construct a new summary of a sample set.",9],[0,"bench","test",""],[3,"benchmark","test::bench",""],[4,"MetricDiff","test",""],[4,"OptRes","","Result of parsing the options."],[4,"MonitorMsg","",""],[6,"TDynBenchFn","","Represents a benchmark function."],[9,"run","","",11],[10,"hash","","",4],[10,"eq","","",4],[10,"ne","","",4],[10,"clone","","",4],[10,"fmt","","",4],[10,"fmt","","",5],[10,"hash","","",1],[10,"eq","","",1],[10,"ne","","",1],[10,"fmt","","",1],[10,"clone","","",1],[10,"fmt","","",2],[10,"fmt","","",12],[10,"eq","","",12],[10,"ne","","",12],[10,"decode","","",12],[10,"encode","","",12],[10,"clone","","",12],[10,"new","","",12],[10,"eq","","",13],[10,"ne","","",13],[10,"clone","","",13],[10,"fmt","","",6],[10,"eq","","",6],[10,"ne","","",6],[10,"eq","","",14],[10,"ne","","",14],[10,"clone","","",14],[10,"eq","","",8],[10,"ne","","",8],[10,"clone","","",8],[10,"to_json","","",12],[10,"new","","",13],[10,"load","","Load MetricDiff from a file.",13],[10,"save","","Write MetricDiff to a file.",13],[10,"compare_to_old","","Compare against another MetricMap. Optionally compare all\nmeasurements in the maps using the provided `noise_pct` as a\npercentage of each value to consider noise. If `None`, each\nmeasurement's noise threshold is independently chosen as the\nmaximum of that measurement's recorded noise quantity in either\nmap.",13],[10,"insert_metric","","Insert a named `value` (+/- `noise`) metric into the map. The value\nmust be non-negative. The `noise` indicates the uncertainty of the\nmetric, which doubles as the \"noise range\" of acceptable\npairwise-regressions on this named value, when comparing from one\nmetric to the next using `compare_to_old`.",13],[10,"ratchet","","Attempt to \"ratchet\" an external metric file. This involves loading\nmetrics from a metric file (if it exists), comparing against\nthe metrics in `self` using `compare_to_old`, and rewriting the\nfile to contain the metrics in `self` if none of the\n`MetricChange`s are `Regression`. Returns the diff as well\nas a boolean indicating whether the ratchet succeeded.",13],[10,"iter","","Callback for benchmark functions to run in their body.",0],[10,"ns_elapsed","","",0],[10,"ns_per_iter","","",0],[10,"bench_n","","",0],[10,"auto_bench","","",0]],"paths":[[1,"Bencher"],[1,"TestDesc"],[1,"TestDescAndFn"],[1,"TestOpts"],[2,"TestName"],[2,"TestFn"],[2,"MetricChange"],[2,"ColorConfig"],[2,"TestResult"],[1,"Summary"],[6,"Stats"],[6,"TDynBenchFn"],[1,"Metric"],[1,"MetricMap"],[1,"BenchSamples"]]};

searchIndex['num'] = {"items":[[0,"","num","Simple numerics."],[0,"bigint","","A Big integer (signed version: `BigInt`, unsigned version: `BigUint`)."],[1,"BigUint","num::bigint","A big unsigned integer type."],[1,"BigInt","","A big signed integer type."],[2,"Sign","","A Sign is a `BigInt`'s composing element."],[12,"Minus","","",0],[12,"Zero","","",0],[12,"Plus","","",0],[0,"BigDigit","",""],[3,"from_doublebigdigit","num::bigint::BigDigit","Split one `DoubleBigDigit` into two `BigDigit`s."],[3,"to_doublebigdigit","","Join two `BigDigit`s into one `DoubleBigDigit`"],[5,"bits","",""],[5,"base","",""],[4,"BigDigit","num::bigint","A `BigDigit` is a `BigUint`'s composing element."],[4,"DoubleBigDigit","","A `DoubleBigDigit` is the internal type used to do the computations.  Its\nsize is the double of the size of `BigDigit`."],[5,"ZERO_BIG_DIGIT","",""],[6,"ToBigUint","","A generic trait for converting a value to a `BigUint`."],[9,"to_biguint","","Converts the value of `self` to a `BigUint`.",1],[6,"ToBigInt","","A generic trait for converting a value to a `BigInt`."],[9,"to_bigint","","Converts the value of `self` to a `BigInt`.",2],[6,"RandBigInt","",""],[9,"gen_biguint","","Generate a random `BigUint` of the given bit size.",3],[9,"gen_bigint","","Generate a random BigInt of the given bit size.",3],[9,"gen_biguint_below","","Generate a random `BigUint` less than the given bound. Fails\nwhen the bound is zero.",3],[9,"gen_biguint_range","","Generate a random `BigUint` within the given range. The lower\nbound is inclusive; the upper bound is exclusive. Fails when\nthe upper bound is not greater than the lower bound.",3],[9,"gen_bigint_range","","Generate a random `BigInt` within the given range. The lower\nbound is inclusive; the upper bound is exclusive. Fails when\nthe upper bound is not greater than the lower bound.",3],[10,"clone","","",4],[10,"eq","","",4],[10,"partial_cmp","","",4],[10,"cmp","","",4],[10,"default","","",4],[10,"fmt","","",4],[10,"from_str","","",4],[10,"bitand","","",4],[10,"bitor","","",4],[10,"bitxor","","",4],[10,"shl","","",4],[10,"shr","","",4],[10,"zero","","",4],[10,"is_zero","","",4],[10,"one","","",4],[10,"add","","",4],[10,"sub","","",4],[10,"mul","","",4],[10,"div","","",4],[10,"rem","","",4],[10,"neg","","",4],[10,"checked_add","","",4],[10,"checked_sub","","",4],[10,"checked_mul","","",4],[10,"checked_div","","",4],[10,"div_rem","","",4],[10,"div_floor","","",4],[10,"mod_floor","","",4],[10,"div_mod_floor","","",4],[10,"gcd","","Calculates the Greatest Common Divisor (GCD) of the number and `other`.",4],[10,"lcm","","Calculates the Lowest Common Multiple (LCM) of the number and `other`.",4],[10,"divides","","Deprecated, use `is_multiple_of` instead.",4],[10,"is_multiple_of","","Returns `true` if the number is a multiple of `other`.",4],[10,"is_even","","Returns `true` if the number is divisible by `2`.",4],[10,"is_odd","","Returns `true` if the number is not divisible by `2`.",4],[10,"to_i64","","",4],[10,"to_u64","","",4],[10,"from_i64","","",4],[10,"from_u64","","",4],[10,"to_biguint","","",5],[10,"to_biguint","","",4],[10,"to_str_radix","","",4],[10,"from_str_radix","","Creates and initializes a `BigUint`.",4],[10,"new","","Creates and initializes a `BigUint`.",4],[10,"from_slice","","Creates and initializes a `BigUint`.",4],[10,"parse_bytes","","Creates and initializes a `BigUint`.",4],[10,"bits","","Determines the fewest bits necessary to express the `BigUint`.",4],[10,"fmt","","",0],[10,"clone","","",0],[10,"cmp","","",0],[10,"partial_cmp","","",0],[10,"lt","","",0],[10,"le","","",0],[10,"gt","","",0],[10,"ge","","",0],[10,"eq","","",0],[10,"ne","","",0],[10,"neg","","Negate Sign value.",0],[10,"clone","","",5],[10,"eq","","",5],[10,"partial_cmp","","",5],[10,"cmp","","",5],[10,"default","","",5],[10,"fmt","","",5],[10,"from_str","","",5],[10,"shl","","",5],[10,"shr","","",5],[10,"zero","","",5],[10,"is_zero","","",5],[10,"one","","",5],[10,"abs","","",5],[10,"abs_sub","","",5],[10,"signum","","",5],[10,"is_positive","","",5],[10,"is_negative","","",5],[10,"add","","",5],[10,"sub","","",5],[10,"mul","","",5],[10,"div","","",5],[10,"rem","","",5],[10,"neg","","",5],[10,"checked_add","","",5],[10,"checked_sub","","",5],[10,"checked_mul","","",5],[10,"checked_div","","",5],[10,"div_rem","","",5],[10,"div_floor","","",5],[10,"mod_floor","","",5],[10,"div_mod_floor","","",5],[10,"gcd","","Calculates the Greatest Common Divisor (GCD) of the number and `other`.",5],[10,"lcm","","Calculates the Lowest Common Multiple (LCM) of the number and `other`.",5],[10,"divides","","Deprecated, use `is_multiple_of` instead.",5],[10,"is_multiple_of","","Returns `true` if the number is a multiple of `other`.",5],[10,"is_even","","Returns `true` if the number is divisible by `2`.",5],[10,"is_odd","","Returns `true` if the number is not divisible by `2`.",5],[10,"to_i64","","",5],[10,"to_u64","","",5],[10,"from_i64","","",5],[10,"from_u64","","",5],[10,"to_bigint","","",5],[10,"to_bigint","","",4],[10,"to_str_radix","","",5],[10,"from_str_radix","","Creates and initializes a BigInt.",5],[10,"new","","Creates and initializes a BigInt.",5],[10,"from_biguint","","Creates and initializes a `BigInt`.",5],[10,"from_slice","","Creates and initializes a `BigInt`.",5],[10,"parse_bytes","","Creates and initializes a `BigInt`.",5],[10,"to_biguint","","Converts this `BigInt` into a `BigUint`, if it's not negative.",5],[0,"complex","num","Complex numbers."],[1,"Complex","num::complex","A complex number in Cartesian form."],[11,"re","","Real portion of the complex number",6],[11,"im","","Imaginary portion of the complex number",6],[4,"Complex32","",""],[4,"Complex64","",""],[10,"clone","","",6],[10,"eq","","",6],[10,"ne","","",6],[10,"new","","Create a new Complex",6],[10,"norm_sqr","","Returns the square of the norm (since `T` doesn't necessarily\nhave a sqrt function), i.e. `re^2 + im^2`.",6],[10,"conj","","Returns the complex conjugate. i.e. `re - i im`",6],[10,"scale","","Multiplies `self` by the scalar `t`.",6],[10,"unscale","","Divides `self` by the scalar `t`.",6],[10,"inv","","Returns `1/self`",6],[10,"norm","","Calculate |self|",6],[10,"arg","","Calculate the principal Arg of self.",6],[10,"to_polar","","Convert to polar form (r, theta), such that `self = r * exp(i\n* theta)`",6],[10,"from_polar","","Convert a polar representation into a complex number.",6],[10,"add","","",6],[10,"sub","","",6],[10,"mul","","",6],[10,"div","","",6],[10,"neg","","",6],[10,"zero","","",6],[10,"is_zero","","",6],[10,"one","","",6],[10,"fmt","","",6],[10,"to_str_radix","","",6],[0,"integer","num","Integer trait and functions."],[3,"div_rem","num::integer","Simultaneous integer division and modulus"],[3,"div_floor","","Floored integer division"],[3,"mod_floor","","Floored integer modulus"],[3,"div_mod_floor","","Simultaneous floored integer division and modulus"],[3,"gcd","","Calculates the Greatest Common Divisor (GCD) of the number and `other`. The\nresult is always positive."],[3,"lcm","","Calculates the Lowest Common Multiple (LCM) of the number and `other`."],[6,"Integer","",""],[9,"div_floor","","Floored integer division.",7],[9,"mod_floor","","Floored integer modulo, satisfying:",7],[9,"gcd","","Greatest Common Divisor (GCD).",7],[9,"lcm","","Lowest Common Multiple (LCM).",7],[9,"divides","","Deprecated, use `is_multiple_of` instead.",7],[9,"is_multiple_of","","Returns `true` if `other` is a multiple of `self`.",7],[9,"is_even","","Returns `true` if the number is even.",7],[9,"is_odd","","Returns `true` if the number is odd.",7],[10,"div_rem","","Simultaneous truncated integer division and modulus.\nReturns `(quotient, remainder)`.",7],[10,"div_mod_floor","","Simultaneous floored integer division and modulus.\nReturns `(quotient, remainder)`.",7],[0,"rational","num","Rational numbers"],[1,"Ratio","num::rational","Represents the ratio between 2 numbers."],[4,"Rational","","Alias for a `Ratio` of machine-sized integers."],[4,"Rational32","",""],[4,"Rational64","",""],[4,"BigRational","","Alias for arbitrary precision rationals."],[10,"clone","","",8],[10,"from_integer","","Creates a ratio representing the integer `t`.",8],[10,"new_raw","","Creates a ratio without checking for `denom == 0` or reducing.",8],[10,"new","","Create a new Ratio. Fails if `denom == 0`.",8],[10,"to_integer","","Converts to an integer.",8],[10,"numer","","Gets an immutable reference to the numerator.",8],[10,"denom","","Gets an immutable reference to the denominator.",8],[10,"is_integer","","Returns true if the rational number is an integer (denominator is 1).",8],[10,"reduced","","Returns a `reduce`d copy of self.",8],[10,"recip","","Returns the reciprocal.",8],[10,"floor","","Rounds towards minus infinity.",8],[10,"ceil","","Rounds towards plus infinity.",8],[10,"round","","Rounds to the nearest integer. Rounds half-way cases away from zero.",8],[10,"trunc","","Rounds towards zero.",8],[10,"fract","","Returns the fractional part of a number.",8],[10,"from_float","","Converts a float into a rational number.",8],[10,"eq","","",8],[10,"ne","","",8],[10,"lt","","",8],[10,"gt","","",8],[10,"le","","",8],[10,"ge","","",8],[10,"partial_cmp","","",8],[10,"cmp","","",8],[10,"mul","","",8],[10,"div","","",8],[10,"add","","",8],[10,"sub","","",8],[10,"rem","","",8],[10,"neg","","",8],[10,"zero","","",8],[10,"is_zero","","",8],[10,"one","","",8],[10,"abs","","",8],[10,"abs_sub","","",8],[10,"signum","","",8],[10,"is_positive","","",8],[10,"is_negative","","",8],[10,"fmt","","Renders as `numer/denom`. If denom=1, renders as numer.",8],[10,"to_str_radix","","Renders as `numer/denom` where the numbers are in base `radix`.",8],[10,"from_str","","Parses `numer/denom` or just `numer`.",8],[10,"from_str_radix","","Parses `numer/denom` where the numbers are in base `radix`.",8]],"paths":[[2,"Sign"],[6,"ToBigUint"],[6,"ToBigInt"],[6,"RandBigInt"],[1,"BigUint"],[1,"BigInt"],[1,"Complex"],[6,"Integer"],[1,"Ratio"]]};

searchIndex['collections'] = {"items":[[0,"","collections","Collection types."],[0,"bitv","","Collections implemented with bit vectors."],[1,"Bitv","collections::bitv","The bitvector type"],[1,"Bits","","An iterator for `Bitv`."],[1,"BitvSet","","An implementation of a set using a bit vector as an underlying\nrepresentation for holding unsigned numerical elements."],[1,"BitPositions","","An iterator for `BitvSet`."],[1,"TwoBitPositions","","An iterator combining wo `BitvSet` iterators."],[3,"from_bytes","","Transform a byte-vector into a `Bitv`. Each byte becomes 8 bits,\nwith the most significant bits of each byte coming first. Each\nbit becomes `true` if equal to 1 or `false` if equal to 0."],[3,"from_fn","","Create a `Bitv` of the specified length where the value at each\nindex is `f(index)`."],[10,"index","","",0],[10,"new","","Create an empty Bitv.",0],[10,"with_capacity","","Create a Bitv that holds `nbits` elements, setting each element\nto `init`.",0],[10,"get","","Retrieve the value at index `i`.",0],[10,"set","","Set the value of a bit at a index `i`.",0],[10,"set_all","","Set all bits to 1.",0],[10,"negate","","Flip all bits.",0],[10,"union","","Calculate the union of two bitvectors, acts like bitwise or.",0],[10,"intersect","","Calculate the intersection of two bitvectors, acts like bitwise and.",0],[10,"difference","","Calculate the difference between two bitvectors.",0],[10,"all","","Returns `true` if all bits are 1.",0],[10,"iter","","Return an iterator over the elements of the vector in order.",0],[10,"none","","Return `true` if all bits are 0.",0],[10,"any","","Return `true` if any bit is 1.",0],[10,"to_bytes","","Organise the bits into bytes, such that the first bit in the\n`Bitv` becomes the high-order bit of the first byte. If the\nsize of the `Bitv` is not a multiple of 8 then trailing bits\nwill be filled-in with `false`.",0],[10,"to_bools","","Transform `self` into a `Vec<bool>` by turning each bit into a `bool`.",0],[10,"eq_vec","","Compare a bitvector to a vector of `bool`.\nBoth the bitvector and vector must have the same length.\n# Failure",0],[10,"truncate","","Shorten a Bitv, dropping excess elements.",0],[10,"reserve","","Grow the vector to be able to store `size` bits without resizing.",0],[10,"capacity","","Return the capacity in bits for this bit vector. Inserting any\nelement less than this amount will not trigger a resizing.",0],[10,"grow","","Grow the `Bitv` in-place. Add `n` copies of `value` to the `Bitv`.",0],[10,"pop","","Shorten by one and return the removed element.",0],[10,"push","","Push a `bool` onto the end.",0],[10,"default","","",0],[10,"len","","",0],[10,"clear","","",0],[10,"from_iter","","",0],[10,"extend","","",0],[10,"clone","","",0],[10,"clone_from","","",0],[10,"partial_cmp","","",0],[10,"cmp","","",0],[10,"fmt","","",0],[10,"hash","","",0],[10,"eq","","",0],[10,"next","","",1],[10,"size_hint","","",1],[10,"next_back","","",1],[10,"indexable","","",1],[10,"idx","","",1],[10,"cmp","","",2],[10,"partial_cmp","","",2],[10,"lt","","",2],[10,"le","","",2],[10,"gt","","",2],[10,"ge","","",2],[10,"eq","","",2],[10,"ne","","",2],[10,"clone","","",2],[10,"default","","",2],[10,"new","","Create a new bit vector set with initially no contents.",2],[10,"with_capacity","","Create a new bit vector set with initially no contents, able to\nhold `nbits` elements without resizing.",2],[10,"from_bitv","","Create a new bit vector set from the given bit vector.",2],[10,"capacity","","Returns the capacity in bits for this bit vector. Inserting any\nelement less than this amount will not trigger a resizing.",2],[10,"reserve","","Grows the underlying vector to be able to store `size` bits.",2],[10,"unwrap","","Consume this set to return the underlying bit vector.",2],[10,"get_ref","","Return a reference to the underlying bit vector.",2],[10,"get_mut_ref","","Return a mutable reference to the underlying bit vector.",2],[10,"shrink_to_fit","","Truncate the underlying vector to the least length required.",2],[10,"iter","","Iterator over each uint stored in the BitvSet.",2],[10,"union","","Iterator over each uint stored in `self` union `other`.\nSee [union_with](#method.union_with) for an efficient in-place version.",2],[10,"intersection","","Iterator over each uint stored in `self` intersect `other`.\nSee [intersect_with](#method.intersect_with) for an efficient in-place version.",2],[10,"difference","","Iterator over each uint stored in the `self` setminus `other`.\nSee [difference_with](#method.difference_with) for an efficient in-place version.",2],[10,"symmetric_difference","","Iterator over each uint stored in the symmetric difference of `self` and `other`.\nSee [symmetric_difference_with](#method.symmetric_difference_with) for\nan efficient in-place version.",2],[10,"union_with","","Union in-place with the specified other bit vector.",2],[10,"intersect_with","","Intersect in-place with the specified other bit vector.",2],[10,"difference_with","","Difference in-place with the specified other bit vector.",2],[10,"symmetric_difference_with","","Symmetric difference in-place with the specified other bit vector.",2],[10,"fmt","","",2],[10,"hash","","",2],[10,"len","","",2],[10,"clear","","",2],[10,"contains","","",2],[10,"is_disjoint","","",2],[10,"is_subset","","",2],[10,"is_superset","","",2],[10,"insert","","",2],[10,"remove","","",2],[10,"next","","",3],[10,"size_hint","","",3],[10,"next","","",4],[10,"size_hint","","",4],[0,"btree","collections","Starting implementation of a btree for rust.\nStructure inspired by github user davidhalperin's gist."],[1,"BTree","collections::btree",""],[10,"new","","Returns new BTree with root node (leaf) and user-supplied lower bound\nThe lower bound applies to every node except the root node.",5],[10,"get","","Returns the value of a given key, which may not exist in the tree.\nCalls the root node's get method.",5],[10,"insert","","An insert method that uses the clone() feature for support.",5],[10,"clone","","Implements the Clone trait for the BTree.\nUses a helper function/constructor to produce a new BTree.",5],[10,"eq","","",5],[10,"partial_cmp","","",5],[10,"cmp","","Returns an ordering based on the root nodes of each BTree.",5],[10,"fmt","","Returns a string representation of the BTree",5],[0,"dlist","collections","A doubly-linked list with owned nodes."],[1,"DList","collections::dlist","A doubly-linked list."],[1,"Items","","Double-ended DList iterator"],[1,"MutItems","","Double-ended mutable DList iterator"],[1,"MoveItems","","DList consuming iterator"],[6,"ListInsertion","","Allow mutating the DList while iterating"],[9,"insert_next","","Insert `elt` just after to the element most recently returned by `.next()`",6],[9,"peek_next","","Provide a reference to the next element, without changing the iterator",6],[10,"clone","","",7],[10,"clone","","",8],[10,"is_empty","","O(1)",9],[10,"len","","O(1)",9],[10,"clear","","Remove all elements from the DList",9],[10,"front","","Provide a reference to the front element, or None if the list is empty",9],[10,"front_mut","","Provide a mutable reference to the front element, or None if the list is empty",9],[10,"back","","Provide a reference to the back element, or None if the list is empty",9],[10,"back_mut","","Provide a mutable reference to the back element, or None if the list is empty",9],[10,"push_front","","Add an element first in the list",9],[10,"pop_front","","Remove the first element and return it, or None if the list is empty",9],[10,"push","","",9],[10,"pop","","",9],[10,"default","","",9],[10,"new","","Create an empty DList",9],[10,"rotate_forward","","Move the last element to the front of the list.",9],[10,"rotate_backward","","Move the first element to the back of the list.",9],[10,"append","","Add all elements from `other` to the end of the list",9],[10,"prepend","","Add all elements from `other` to the beginning of the list",9],[10,"insert_when","","Insert `elt` before the first `x` in the list where `f(x, elt)` is true,\nor at the end.",9],[10,"merge","","Merge DList `other` into this DList, using the function `f`.\nIterate the both DList with `a` from self and `b` from `other`, and\nput `a` in the result if `f(a, b)` is true, else `b`.",9],[10,"iter","","Provide a forward iterator",9],[10,"mut_iter","","Provide a forward iterator with mutable references",9],[10,"move_iter","","Consume the list into an iterator yielding elements by value",9],[10,"insert_ordered","","Insert `elt` sorted in ascending order",9],[10,"drop","","",9],[10,"next","","",7],[10,"size_hint","","",7],[10,"next_back","","",7],[10,"next","","",10],[10,"size_hint","","",10],[10,"next_back","","",10],[10,"insert_next","","",10],[10,"peek_next","","",10],[10,"next","","",8],[10,"size_hint","","",8],[10,"next_back","","",8],[10,"from_iter","","",9],[10,"extend","","",9],[10,"eq","","",9],[10,"ne","","",9],[10,"partial_cmp","","",9],[10,"clone","","",9],[10,"fmt","","",9],[10,"hash","","",9],[0,"enum_set","collections","A structure for holding a set of enum variants"],[1,"EnumSet","collections::enum_set","A specialized Set implementation to use enum types."],[1,"Items","","An iterator over an EnumSet"],[6,"CLike","","An interface for casting C-like enum to uint and back."],[9,"to_uint","","Converts C-like enum to uint.",11],[9,"from_uint","","Converts uint to C-like enum.",11],[10,"fmt","","",12],[10,"hash","","",12],[10,"eq","","",12],[10,"ne","","",12],[10,"clone","","",12],[10,"empty","","Returns an empty EnumSet.",12],[10,"is_empty","","Returns true if an EnumSet is empty.",12],[10,"intersects","","Returns true if an EnumSet contains any enum of a given EnumSet",12],[10,"intersection","","Returns an intersection of both EnumSets.",12],[10,"contains","","Returns true if a given EnumSet is included in an EnumSet.",12],[10,"union","","Returns a union of both EnumSets.",12],[10,"add","","Add an enum to an EnumSet",12],[10,"contains_elem","","Returns true if an EnumSet contains a given enum",12],[10,"iter","","Returns an iterator over an EnumSet",12],[10,"sub","","",12],[10,"bitor","","",12],[10,"bitand","","",12],[10,"next","","",13],[10,"size_hint","","",13],[0,"priority_queue","collections","A priority queue implemented with a binary heap."],[1,"PriorityQueue","collections::priority_queue","A priority queue implemented with a binary heap."],[1,"Items","","PriorityQueue iterator."],[10,"clone","","",14],[10,"len","","Returns the length of the queue",14],[10,"clear","","Drop all items from the queue",14],[10,"default","","",14],[10,"new","","Create an empty PriorityQueue as a max-heap.",14],[10,"with_capacity","","Create an empty PriorityQueue with a specific capacity.\nThis preallocates enough memory for `capacity` elements,\nso that the PriorityQueue does not have to be reallocated\nuntil it contains at least that many values.",14],[10,"from_vec","","Create a PriorityQueue from a vector. This is sometimes called\n`heapifying` the vector.",14],[10,"iter","","An iterator visiting all values in underlying vector, in\narbitrary order.",14],[10,"top","","Returns the greatest item in a queue or `None` if it is empty.",14],[10,"maybe_top","","",14],[10,"capacity","","Returns the number of elements the queue can hold without reallocating.",14],[10,"reserve_exact","","Reserve capacity for exactly `n` elements in the PriorityQueue.\nDo nothing if the capacity is already sufficient.",14],[10,"reserve","","Reserve capacity for at least `n` elements in the PriorityQueue.\nDo nothing if the capacity is already sufficient.",14],[10,"pop","","Remove the greatest item from a queue and return it, or `None` if it is\nempty.",14],[10,"maybe_pop","","",14],[10,"push","","Push an item onto the queue.",14],[10,"push_pop","","Optimized version of a push followed by a pop.",14],[10,"replace","","Optimized version of a pop followed by a push. The push is done\nregardless of whether the queue is empty.",14],[10,"into_vec","","Consume the PriorityQueue and return the underlying vector\nin arbitrary order.",14],[10,"into_sorted_vec","","Consume the PriorityQueue and return a vector in sorted\n(ascending) order.",14],[10,"next","","",15],[10,"size_hint","","",15],[10,"from_iter","","",14],[10,"extend","","",14],[0,"ringbuf","collections","A double-ended queue implemented as a circular buffer"],[1,"RingBuf","collections::ringbuf","RingBuf is a circular buffer that implements Deque."],[1,"Items","","RingBuf iterator"],[1,"MutItems","","RingBuf mutable iterator"],[10,"clone","","",16],[10,"len","","Return the number of elements in the RingBuf",16],[10,"clear","","Clear the RingBuf, removing all values.",16],[10,"front","","Return a reference to the first element in the RingBuf",16],[10,"front_mut","","Return a mutable reference to the first element in the RingBuf",16],[10,"back","","Return a reference to the last element in the RingBuf",16],[10,"back_mut","","Return a mutable reference to the last element in the RingBuf",16],[10,"pop_front","","Remove and return the first element in the RingBuf, or None if it is empty",16],[10,"push_front","","Prepend an element to the RingBuf",16],[10,"push","","",16],[10,"pop","","",16],[10,"default","","",16],[10,"new","","Create an empty RingBuf",16],[10,"with_capacity","","Create an empty RingBuf with space for at least `n` elements.",16],[10,"get","","Retrieve an element in the RingBuf by index",16],[10,"get_mut","","Retrieve an element in the RingBuf by index",16],[10,"swap","","Swap elements at indices `i` and `j`",16],[10,"reserve_exact","","Reserve capacity for exactly `n` elements in the given RingBuf,\ndoing nothing if `self`'s capacity is already equal to or greater\nthan the requested capacity",16],[10,"reserve","","Reserve capacity for at least `n` elements in the given RingBuf,\nover-allocating in case the caller needs to reserve additional\nspace.",16],[10,"iter","","Front-to-back iterator.",16],[10,"mut_iter","","Front-to-back iterator which returns mutable values.",16],[10,"next","","",17],[10,"size_hint","","",17],[10,"next_back","","",17],[10,"indexable","","",17],[10,"idx","","",17],[10,"next","","",18],[10,"size_hint","","",18],[10,"next_back","","",18],[10,"eq","","",16],[10,"ne","","",16],[10,"partial_cmp","","",16],[10,"hash","","",16],[10,"from_iter","","",16],[10,"extend","","",16],[10,"fmt","","",16],[0,"smallintmap","collections","A simple map based on a vector for small integer keys. Space requirements\nare O(highest integer key)."],[1,"SmallIntMap","collections::smallintmap","A map optimized for small integer keys."],[1,"Entries","","Forward iterator over a map."],[1,"MutEntries","","Forward iterator over the key-value pairs of a map, with the\nvalues being mutable."],[4,"Keys","","Forward iterator over the keys of a map"],[4,"Values","","Forward iterator over the values of a map"],[10,"eq","","",19],[10,"ne","","",19],[10,"len","","Return the number of elements in the map.",19],[10,"is_empty","","Return `true` if there are no elements in the map.",19],[10,"clear","","Clear the map, removing all key-value pairs.",19],[10,"find","","Return a reference to the value corresponding to the key.",19],[10,"find_mut","","Return a mutable reference to the value corresponding to the key.",19],[10,"insert","","Insert a key-value pair into the map. An existing value for a\nkey is replaced by the new value. Return `true` if the key did\nnot already exist in the map.",19],[10,"remove","","Remove a key-value pair from the map. Return `true` if the key\nwas present in the map, otherwise `false`.",19],[10,"swap","","Insert a key-value pair from the map. If the key already had a value\npresent in the map, that value is returned. Otherwise `None` is returned.",19],[10,"pop","","Removes a key from the map, returning the value at the key if the key\nwas previously in the map.",19],[10,"default","","",19],[10,"clone","","",19],[10,"clone_from","","",19],[10,"hash","","",19],[10,"new","","Create an empty SmallIntMap.",19],[10,"with_capacity","","Create an empty SmallIntMap with space for at least `capacity` elements\nbefore resizing.",19],[10,"get","","Retrieves a value for the given key.\nSee [`find`](../trait.Map.html#tymethod.find) for a non-failing alternative.",19],[10,"keys","","An iterator visiting all keys in ascending order by the keys.\nIterator element type is `uint`.",19],[10,"values","","An iterator visiting all values in ascending order by the keys.\nIterator element type is `&'r V`.",19],[10,"iter","","An iterator visiting all key-value pairs in ascending order by the keys.\nIterator element type is `(uint, &'r V)`.",19],[10,"mut_iter","","An iterator visiting all key-value pairs in ascending order by the keys,\nwith mutable references to the values\nIterator element type is `(uint, &'r mut V)`.",19],[10,"move_iter","","Empties the map, moving all values into the specified closure.",19],[10,"update","","Update a value in the map. If the key already exists in the map,\nmodify the value with `ff` taking `oldval, newval`.\nOtherwise set the value to `newval`.\nReturn `true` if the key did not already exist in the map.",19],[10,"update_with_key","","Update a value in the map. If the key already exists in the map,\nmodify the value with `ff` taking `key, oldval, newval`.\nOtherwise set the value to `newval`.\nReturn `true` if the key did not already exist in the map.",19],[10,"partial_cmp","","",19],[10,"cmp","","",19],[10,"fmt","","",19],[10,"from_iter","","",19],[10,"extend","","",19],[10,"next","","",20],[10,"size_hint","","",20],[10,"next_back","","",20],[10,"next","","",21],[10,"size_hint","","",21],[10,"next_back","","",21],[0,"treemap","collections","An ordered map and set implemented as self-balancing binary search\ntrees. The only requirement for the types is that the key implements\n`Ord`."],[1,"TreeMap","collections::treemap","This is implemented as an AA tree, which is a simplified variation of\na red-black tree where red (horizontal) nodes can only be added\nas a right child. The time complexity is the same, and re-balancing\noperations are more frequent but also cheaper."],[1,"Entries","","Lazy forward iterator over a map"],[1,"RevEntries","","Lazy backward iterator over a map"],[1,"MutEntries","","Lazy forward iterator over a map that allows for the mutation of\nthe values."],[1,"RevMutEntries","","Lazy backward iterator over a map"],[1,"MoveEntries","","Lazy forward iterator over a map that consumes the map while iterating"],[1,"TreeSet","","A implementation of the `Set` trait on top of the `TreeMap` container. The\nonly requirement is that the type of the elements contained ascribes to the\n`Ord` trait."],[1,"SetItems","","Lazy forward iterator over a set"],[1,"RevSetItems","","Lazy backward iterator over a set"],[1,"DifferenceItems","","Lazy iterator producing elements in the set difference (in-order)"],[1,"SymDifferenceItems","","Lazy iterator producing elements in the set symmetric difference (in-order)"],[1,"IntersectionItems","","Lazy iterator producing elements in the set intersection (in-order)"],[1,"UnionItems","","Lazy iterator producing elements in the set union (in-order)"],[4,"Keys","","TreeMap keys iterator"],[4,"Values","","TreeMap values iterator"],[4,"MoveSetItems","","Lazy forward iterator over a set that consumes the set while iterating"],[10,"clone","","",22],[10,"eq","","",22],[10,"partial_cmp","","",22],[10,"fmt","","",22],[10,"len","","",22],[10,"clear","","",22],[10,"find","","",22],[10,"find_mut","","",22],[10,"swap","","",22],[10,"pop","","",22],[10,"default","","",22],[10,"new","","Create an empty `TreeMap`.",22],[10,"keys","","Get a lazy iterator over the keys in the map, in ascending order.",22],[10,"values","","Get a lazy iterator over the values in the map, in ascending order\nwith respect to the corresponding keys.",22],[10,"iter","","Get a lazy iterator over the key-value pairs in the map, in ascending order.",22],[10,"rev_iter","","Get a lazy reverse iterator over the key-value pairs in the map, in descending order.",22],[10,"mut_iter","","Get a lazy forward iterator over the key-value pairs in the\nmap, with the values being mutable.",22],[10,"mut_rev_iter","","Get a lazy reverse iterator over the key-value pairs in the\nmap, with the values being mutable.",22],[10,"move_iter","","Get a lazy iterator that consumes the treemap, it is not usable\nafter calling this.",22],[10,"find_with","","Return the value for which `f(key)` returns `Equal`. `f` is invoked\nwith current key and guides tree navigation. That means `f` should\nbe aware of natural ordering of the tree.",22],[10,"find_mut_with","","Return the value for which `f(key)` returns `Equal`. `f` is invoked\nwith current key and guides tree navigation. That means `f` should\nbe aware of natural ordering of the tree.",22],[10,"lower_bound","","Return a lazy iterator to the first key-value pair whose key is not less than `k`\nIf all keys in map are less than `k` an empty iterator is returned.",22],[10,"upper_bound","","Return a lazy iterator to the first key-value pair whose key is greater than `k`\nIf all keys in map are less than or equal to `k` an empty iterator is returned.",22],[10,"mut_lower_bound","","Return a lazy value iterator to the first key-value pair (with\nthe value being mutable) whose key is not less than `k`.",22],[10,"mut_upper_bound","","Return a lazy iterator to the first key-value pair (with the\nvalue being mutable) whose key is greater than `k`.",22],[10,"next","","Advance the iterator to the next node (in order) and return a\ntuple with a reference to the key and value. If there are no\nmore nodes, return `None`.",23],[10,"size_hint","","",23],[10,"next","","",24],[10,"size_hint","","",24],[10,"next","","Advance the iterator to the next node (in order) and return a\ntuple with a reference to the key and value. If there are no\nmore nodes, return `None`.",25],[10,"size_hint","","",25],[10,"next","","",26],[10,"size_hint","","",26],[10,"next","","",27],[10,"size_hint","","",27],[10,"next","","",28],[10,"next","","",29],[10,"clone","","",30],[10,"eq","","",30],[10,"partial_cmp","","",30],[10,"fmt","","",30],[10,"len","","",30],[10,"clear","","",30],[10,"contains","","",30],[10,"is_disjoint","","",30],[10,"is_subset","","",30],[10,"insert","","",30],[10,"remove","","",30],[10,"default","","",30],[10,"new","","Create an empty `TreeSet`.",30],[10,"iter","","Get a lazy iterator over the values in the set, in ascending order.",30],[10,"rev_iter","","Get a lazy iterator over the values in the set, in descending order.",30],[10,"move_iter","","Creates a consuming iterator, that is, one that moves each value out of the\nset in ascending order. The set cannot be used after calling this.",30],[10,"lower_bound","","Get a lazy iterator pointing to the first value not less than `v` (greater or equal).\nIf all elements in the set are less than `v` empty iterator is returned.",30],[10,"upper_bound","","Get a lazy iterator pointing to the first value greater than `v`.\nIf all elements in the set are less than or equal to `v` an\nempty iterator is returned.",30],[10,"difference","","Visit the values representing the difference, in ascending order.",30],[10,"symmetric_difference","","Visit the values representing the symmetric difference, in ascending order.",30],[10,"intersection","","Visit the values representing the intersection, in ascending order.",30],[10,"union","","Visit the values representing the union, in ascending order.",30],[10,"next","","",31],[10,"next","","",32],[10,"next","","",33],[10,"next","","",34],[10,"from_iter","","",22],[10,"extend","","",22],[10,"hash","","",22],[10,"from_iter","","",30],[10,"extend","","",30],[10,"hash","","",30],[0,"trie","collections","Ordered containers with unsigned integer keys,\nimplemented as radix tries (`TrieSet` and `TrieMap` types)."],[1,"TrieMap","collections::trie","A map implemented as a radix trie."],[1,"TrieSet","","A set implemented as a radix trie."],[1,"Entries","","Forward iterator over a map."],[1,"MutEntries","","Forward iterator over the key-value pairs of a map, with the\nvalues being mutable."],[1,"SetItems","","Forward iterator over a set."],[4,"Keys","","Forward iterator over the keys of a map"],[4,"Values","","Forward iterator over the values of a map"],[10,"clone","","",35],[10,"eq","","",35],[10,"partial_cmp","","",35],[10,"cmp","","",35],[10,"fmt","","",35],[10,"len","","Return the number of elements in the map.",35],[10,"clear","","Clear the map, removing all values.",35],[10,"find","","Return a reference to the value corresponding to the key.",35],[10,"find_mut","","Return a mutable reference to the value corresponding to the key.",35],[10,"swap","","Insert a key-value pair from the map. If the key already had a value\npresent in the map, that value is returned. Otherwise None is returned.",35],[10,"pop","","Removes a key from the map, returning the value at the key if the key\nwas previously in the map.",35],[10,"default","","",35],[10,"new","","Create an empty TrieMap.",35],[10,"each_reverse","","Visit all key-value pairs in reverse order. Abort traversal when f returns false.\nReturn true if f returns true for all elements.",35],[10,"keys","","Get an iterator visiting all keys in ascending order by the keys.\nIterator element type is `uint`.",35],[10,"values","","Get an iterator visiting all values in ascending order by the keys.\nIterator element type is `&'r T`.",35],[10,"iter","","Get an iterator over the key-value pairs in the map, ordered by keys.",35],[10,"mut_iter","","Get an iterator over the key-value pairs in the map, with the\nability to mutate the values.",35],[10,"lower_bound","","Get an iterator pointing to the first key-value pair whose key is not less than `key`.\nIf all keys in the map are less than `key` an empty iterator is returned.",35],[10,"upper_bound","","Get an iterator pointing to the first key-value pair whose key is greater than `key`.\nIf all keys in the map are not greater than `key` an empty iterator is returned.",35],[10,"mut_lower_bound","","Get an iterator pointing to the first key-value pair whose key is not less than `key`.\nIf all keys in the map are less than `key` an empty iterator is returned.",35],[10,"mut_upper_bound","","Get an iterator pointing to the first key-value pair whose key is greater than `key`.\nIf all keys in the map are not greater than `key` an empty iterator is returned.",35],[10,"from_iter","","",35],[10,"extend","","",35],[10,"hash","","",35],[10,"cmp","","",36],[10,"partial_cmp","","",36],[10,"lt","","",36],[10,"le","","",36],[10,"gt","","",36],[10,"ge","","",36],[10,"eq","","",36],[10,"ne","","",36],[10,"hash","","",36],[10,"clone","","",36],[10,"fmt","","",36],[10,"len","","Return the number of elements in the set.",36],[10,"clear","","Clear the set, removing all values.",36],[10,"contains","","",36],[10,"is_disjoint","","",36],[10,"is_subset","","",36],[10,"is_superset","","",36],[10,"insert","","",36],[10,"remove","","",36],[10,"default","","",36],[10,"new","","Create an empty TrieSet.",36],[10,"each_reverse","","Visit all values in reverse order. Abort traversal when `f` returns false.\nReturn `true` if `f` returns `true` for all elements.",36],[10,"iter","","Get an iterator over the values in the set, in sorted order.",36],[10,"lower_bound","","Get an iterator pointing to the first value that is not less than `val`.\nIf all values in the set are less than `val` an empty iterator is returned.",36],[10,"upper_bound","","Get an iterator pointing to the first value that key is greater than `val`.\nIf all values in the set are less than or equal to `val` an empty iterator is returned.",36],[10,"from_iter","","",36],[10,"extend","","",36],[10,"next","","",37],[10,"size_hint","","",37],[10,"next","","",38],[10,"size_hint","","",38],[10,"next","","",39],[10,"size_hint","","",39],[0,"slice","collections","Utilities for vector manipulation"],[1,"ElementSwaps","collections::slice","An Iterator that yields the element swaps needed to produce\na sequence of all possible permutations for an indexed sequence of\nelements. Each permutation is only a single swap apart."],[1,"Permutations","","An Iterator that uses `ElementSwaps` to iterate through\nall possible permutations of a vector."],[0,"raw","","Unsafe operations"],[3,"buf_as_slice","collections::slice::raw","Form a slice from a pointer and length (as a number of units,\nnot bytes)."],[3,"mut_buf_as_slice","","Form a slice from a pointer and length (as a number of units,\nnot bytes)."],[3,"shift_ptr","","Returns a pointer to first element in slice and adjusts\nslice so it no longer contains that element. Returns None\nif the slice is empty. O(1)."],[3,"pop_ptr","","Returns a pointer to last element in slice and adjusts\nslice so it no longer contains that element. Returns None\nif the slice is empty. O(1)."],[6,"VectorVector","collections::slice",""],[9,"concat_vec","","Flattens a vector of vectors of T into a single vector of T.",40],[9,"connect_vec","","Concatenate a vector of vectors, placing a given separator between each.",40],[6,"CloneableVector","","Extension methods for vector slices with cloneable elements"],[9,"to_vec","","Copy `self` into a new vector",41],[10,"to_owned","","Deprecated. Use `to_vec`",41],[9,"into_vec","","Convert `self` into an owned vector, not making a copy if possible.",41],[10,"into_owned","","Deprecated. Use `into_vec`",41],[6,"ImmutableCloneableVector","","Extension methods for vectors containing `Clone` elements."],[9,"partitioned","","Partitions the vector into two vectors `(A,B)`, where all\nelements of `A` satisfy `f` and all elements of `B` do not.",42],[9,"permutations","","Create an iterator that yields every possible permutation of the\nvector in succession.",42],[6,"MutableVectorAllocating","","Extension methods for vectors such that their elements are\nmutable."],[9,"sort_by","","Sort the vector, in place, using `compare` to compare\nelements.",43],[9,"move_from","","Consumes `src` and moves as many elements as it can into `self`\nfrom the range [start,end).",43],[6,"MutableOrdVector","","Methods for mutable vectors with orderable elements, such as\nin-place sorting."],[9,"sort","","Sort the vector, in place.",44],[9,"next_permutation","","Mutates the slice to the next lexicographic permutation.",44],[9,"prev_permutation","","Mutates the slice to the previous lexicographic permutation.",44],[10,"new","","Create an `ElementSwaps` iterator for a sequence of `length` elements",45],[10,"next","","",45],[10,"size_hint","","",45],[10,"next","","",46],[10,"size_hint","","",46],[3,"ref_slice","","Converts a pointer to A into a slice of length 1 (without copying)."],[3,"mut_ref_slice","","Converts a pointer to A into a slice of length 1 (without copying)."],[10,"fmt","core::num","",47],[10,"eq","","",47],[10,"ne","","",47],[10,"ne","","",47],[10,"fmt","core::intrinsics","",48],[10,"assert_receiver_is_total_eq","","",48],[10,"eq","","",48],[10,"ne","","",48],[10,"ne","","",48],[10,"of","","Returns the `TypeId` of the type this generic function has been instantiated with",48],[10,"hash","","",48],[10,"clone","core::kinds::marker","",49],[10,"clone_from","","",49],[10,"eq","","",49],[10,"ne","","",49],[10,"ne","","",49],[10,"clone","","",50],[10,"clone_from","","",50],[10,"eq","","",50],[10,"ne","","",50],[10,"ne","","",50],[10,"clone","","",51],[10,"clone_from","","",51],[10,"eq","","",51],[10,"ne","","",51],[10,"ne","","",51],[10,"clone","","",52],[10,"clone_from","","",52],[10,"eq","","",52],[10,"ne","","",52],[10,"ne","","",52],[10,"clone","","",53],[10,"clone_from","","",53],[10,"eq","","",53],[10,"ne","","",53],[10,"ne","","",53],[10,"clone","","",54],[10,"clone_from","","",54],[10,"eq","","",54],[10,"ne","","",54],[10,"ne","","",54],[10,"clone","","",55],[10,"clone_from","","",55],[10,"eq","","",55],[10,"ne","","",55],[10,"ne","","",55],[10,"clone","","",56],[10,"clone_from","","",56],[10,"eq","","",56],[10,"ne","","",56],[10,"ne","","",56],[10,"clone","","",57],[10,"clone_from","","",57],[10,"eq","","",57],[10,"ne","","",57],[10,"ne","","",57],[10,"clone","","",58],[10,"clone_from","","",58],[10,"eq","","",58],[10,"ne","","",58],[10,"ne","","",58],[10,"fmt","core::cmp","",59],[10,"eq","","",59],[10,"ne","","",59],[10,"ne","","",59],[10,"clone","","",59],[10,"clone_from","","",59],[10,"assert_receiver_is_total_eq","","",59],[10,"cmp","","",59],[10,"partial_cmp","","",59],[10,"lt","","",59],[10,"le","","",59],[10,"gt","","",59],[10,"ge","","",59],[10,"new","core::atomics","Create a new `AtomicBool`",60],[10,"load","","Load the value",60],[10,"store","","Store the value",60],[10,"swap","","Store a value, returning the old value",60],[10,"compare_and_swap","","If the current value is the same as expected, store a new value",60],[10,"fetch_and","","A logical \"and\" operation",60],[10,"fetch_nand","","A logical \"nand\" operation",60],[10,"fetch_or","","A logical \"or\" operation",60],[10,"fetch_xor","","A logical \"xor\" operation",60],[10,"new","","Create a new `AtomicInt`",61],[10,"load","","Load the value",61],[10,"store","","Store the value",61],[10,"swap","","Store a value, returning the old value",61],[10,"compare_and_swap","","If the current value is the same as expected, store a new value",61],[10,"fetch_add","","Add to the current value, returning the previous",61],[10,"fetch_sub","","Subtract from the current value, returning the previous",61],[10,"fetch_and","","Bitwise and with the current value, returning the previous",61],[10,"fetch_or","","Bitwise or with the current value, returning the previous",61],[10,"fetch_xor","","Bitwise xor with the current value, returning the previous",61],[10,"new","","Create a new `AtomicUint`",62],[10,"load","","Load the value",62],[10,"store","","Store the value",62],[10,"swap","","Store a value, returning the old value",62],[10,"compare_and_swap","","If the current value is the same as expected, store a new value",62],[10,"fetch_add","","Add to the current value, returning the previous",62],[10,"fetch_sub","","Subtract from the current value, returning the previous",62],[10,"fetch_and","","Bitwise and with the current value, returning the previous",62],[10,"fetch_or","","Bitwise or with the current value, returning the previous",62],[10,"fetch_xor","","Bitwise xor with the current value, returning the previous",62],[10,"new","","Create a new `AtomicPtr`",63],[10,"load","","Load the value",63],[10,"store","","Store the value",63],[10,"swap","","Store a value, returning the old value",63],[10,"compare_and_swap","","If the current value is the same as expected, store a new value",63],[10,"new","core::cell","Creates a new `Cell` containing the given value.",64],[10,"get","","Returns a copy of the contained value.",64],[10,"set","","Sets the contained value.",64],[10,"clone","","",64],[10,"clone_from","","",64],[10,"eq","","",64],[10,"ne","","",64],[10,"new","","Create a new `RefCell` containing `value`",65],[10,"unwrap","","Consumes the `RefCell`, returning the wrapped value.",65],[10,"try_borrow","","Attempts to immutably borrow the wrapped value.",65],[10,"borrow","","Immutably borrows the wrapped value.",65],[10,"try_borrow_mut","","Mutably borrows the wrapped value.",65],[10,"borrow_mut","","Mutably borrows the wrapped value.",65],[10,"clone","","",65],[10,"clone_from","","",65],[10,"eq","","",65],[10,"ne","","",65],[10,"drop","","",66],[10,"deref","","",66],[10,"drop","","",67],[10,"deref","","",67],[10,"deref_mut","","",67],[10,"new","","Construct a new instance of `UnsafeCell` which will wrapp the specified\nvalue.",68],[10,"get","","Gets a mutable pointer to the wrapped value.",68],[10,"unwrap","","Unwraps the value",68],[10,"drop","core::finally","",69],[10,"rposition","core::iter","",70],[10,"len","","",70],[10,"rposition","","",71],[10,"len","","",71],[10,"rposition","","",72],[10,"len","","",72],[10,"rposition","","",73],[10,"len","","",73],[10,"rposition","","",74],[10,"len","","",74],[10,"clone","","",72],[10,"clone_from","","",72],[10,"next","","",72],[10,"size_hint","","",72],[10,"size_hint","","",72],[10,"chain","","",72],[10,"zip","","",72],[10,"map","","",72],[10,"filter","","",72],[10,"filter_map","","",72],[10,"enumerate","","",72],[10,"peekable","","",72],[10,"skip_while","","",72],[10,"take_while","","",72],[10,"skip","","",72],[10,"take","","",72],[10,"scan","","",72],[10,"flat_map","","",72],[10,"fuse","","",72],[10,"inspect","","",72],[10,"by_ref","","",72],[10,"advance","","",72],[10,"collect","","",72],[10,"nth","","",72],[10,"last","","",72],[10,"fold","","",72],[10,"count","","",72],[10,"all","","",72],[10,"any","","",72],[10,"find","","",72],[10,"position","","",72],[10,"max_by","","",72],[10,"min_by","","",72],[10,"next_back","","",72],[10,"rev","","",72],[10,"indexable","","",72],[10,"idx","","",72],[10,"next","","",75],[10,"size_hint","","",75],[10,"size_hint","","",75],[10,"chain","","",75],[10,"zip","","",75],[10,"map","","",75],[10,"filter","","",75],[10,"filter_map","","",75],[10,"enumerate","","",75],[10,"peekable","","",75],[10,"skip_while","","",75],[10,"take_while","","",75],[10,"skip","","",75],[10,"take","","",75],[10,"scan","","",75],[10,"flat_map","","",75],[10,"fuse","","",75],[10,"inspect","","",75],[10,"by_ref","","",75],[10,"advance","","",75],[10,"collect","","",75],[10,"nth","","",75],[10,"last","","",75],[10,"fold","","",75],[10,"count","","",75],[10,"all","","",75],[10,"any","","",75],[10,"find","","",75],[10,"position","","",75],[10,"max_by","","",75],[10,"min_by","","",75],[10,"next_back","","",75],[10,"rev","","",75],[10,"fmt","","",76],[10,"eq","","",76],[10,"ne","","",76],[10,"ne","","",76],[10,"clone","","",76],[10,"clone_from","","",76],[10,"into_option","","`into_option` creates an `Option` of type `(T,T)`. The returned `Option` has variant\n`None` if and only if the `MinMaxResult` has variant `NoElements`. Otherwise variant\n`Some(x,y)` is returned where `x <= y`. If `MinMaxResult` has variant `OneElement(x)`,\nperforming this operation will make one clone of `x`.",76],[10,"clone","","",77],[10,"clone_from","","",77],[10,"next","","",77],[10,"size_hint","","",77],[10,"size_hint","","",77],[10,"chain","","",77],[10,"zip","","",77],[10,"map","","",77],[10,"filter","","",77],[10,"filter_map","","",77],[10,"enumerate","","",77],[10,"peekable","","",77],[10,"skip_while","","",77],[10,"take_while","","",77],[10,"skip","","",77],[10,"take","","",77],[10,"scan","","",77],[10,"flat_map","","",77],[10,"fuse","","",77],[10,"inspect","","",77],[10,"by_ref","","",77],[10,"advance","","",77],[10,"collect","","",77],[10,"nth","","",77],[10,"last","","",77],[10,"fold","","",77],[10,"count","","",77],[10,"all","","",77],[10,"any","","",77],[10,"find","","",77],[10,"position","","",77],[10,"max_by","","",77],[10,"min_by","","",77],[10,"indexable","","",77],[10,"idx","","",77],[10,"clone","","",78],[10,"clone_from","","",78],[10,"next","","",78],[10,"size_hint","","",78],[10,"size_hint","","",78],[10,"chain","","",78],[10,"zip","","",78],[10,"map","","",78],[10,"filter","","",78],[10,"filter_map","","",78],[10,"enumerate","","",78],[10,"peekable","","",78],[10,"skip_while","","",78],[10,"take_while","","",78],[10,"skip","","",78],[10,"take","","",78],[10,"scan","","",78],[10,"flat_map","","",78],[10,"fuse","","",78],[10,"inspect","","",78],[10,"by_ref","","",78],[10,"advance","","",78],[10,"collect","","",78],[10,"nth","","",78],[10,"last","","",78],[10,"fold","","",78],[10,"count","","",78],[10,"all","","",78],[10,"any","","",78],[10,"find","","",78],[10,"position","","",78],[10,"max_by","","",78],[10,"min_by","","",78],[10,"next_back","","",78],[10,"rev","","",78],[10,"indexable","","",78],[10,"idx","","",78],[10,"clone","","",74],[10,"clone_from","","",74],[10,"next","","",74],[10,"size_hint","","",74],[10,"size_hint","","",74],[10,"chain","","",74],[10,"zip","","",74],[10,"map","","",74],[10,"filter","","",74],[10,"filter_map","","",74],[10,"enumerate","","",74],[10,"peekable","","",74],[10,"skip_while","","",74],[10,"take_while","","",74],[10,"skip","","",74],[10,"take","","",74],[10,"scan","","",74],[10,"flat_map","","",74],[10,"fuse","","",74],[10,"inspect","","",74],[10,"by_ref","","",74],[10,"advance","","",74],[10,"collect","","",74],[10,"nth","","",74],[10,"last","","",74],[10,"fold","","",74],[10,"count","","",74],[10,"all","","",74],[10,"any","","",74],[10,"find","","",74],[10,"position","","",74],[10,"max_by","","",74],[10,"min_by","","",74],[10,"next_back","","",74],[10,"rev","","",74],[10,"indexable","","",74],[10,"idx","","",74],[10,"next","","",73],[10,"size_hint","","",73],[10,"size_hint","","",73],[10,"chain","","",73],[10,"zip","","",73],[10,"map","","",73],[10,"filter","","",73],[10,"filter_map","","",73],[10,"enumerate","","",73],[10,"peekable","","",73],[10,"skip_while","","",73],[10,"take_while","","",73],[10,"skip","","",73],[10,"take","","",73],[10,"scan","","",73],[10,"flat_map","","",73],[10,"fuse","","",73],[10,"inspect","","",73],[10,"by_ref","","",73],[10,"advance","","",73],[10,"collect","","",73],[10,"nth","","",73],[10,"last","","",73],[10,"fold","","",73],[10,"count","","",73],[10,"all","","",73],[10,"any","","",73],[10,"find","","",73],[10,"position","","",73],[10,"max_by","","",73],[10,"min_by","","",73],[10,"next_back","","",73],[10,"rev","","",73],[10,"indexable","","",73],[10,"idx","","",73],[10,"next","","",79],[10,"size_hint","","",79],[10,"size_hint","","",79],[10,"chain","","",79],[10,"zip","","",79],[10,"map","","",79],[10,"filter","","",79],[10,"filter_map","","",79],[10,"enumerate","","",79],[10,"peekable","","",79],[10,"skip_while","","",79],[10,"take_while","","",79],[10,"skip","","",79],[10,"take","","",79],[10,"scan","","",79],[10,"flat_map","","",79],[10,"fuse","","",79],[10,"inspect","","",79],[10,"by_ref","","",79],[10,"advance","","",79],[10,"collect","","",79],[10,"nth","","",79],[10,"last","","",79],[10,"fold","","",79],[10,"count","","",79],[10,"all","","",79],[10,"any","","",79],[10,"find","","",79],[10,"position","","",79],[10,"max_by","","",79],[10,"min_by","","",79],[10,"next_back","","",79],[10,"rev","","",79],[10,"next","","",80],[10,"size_hint","","",80],[10,"size_hint","","",80],[10,"chain","","",80],[10,"zip","","",80],[10,"map","","",80],[10,"filter","","",80],[10,"filter_map","","",80],[10,"enumerate","","",80],[10,"peekable","","",80],[10,"skip_while","","",80],[10,"take_while","","",80],[10,"skip","","",80],[10,"take","","",80],[10,"scan","","",80],[10,"flat_map","","",80],[10,"fuse","","",80],[10,"inspect","","",80],[10,"by_ref","","",80],[10,"advance","","",80],[10,"collect","","",80],[10,"nth","","",80],[10,"last","","",80],[10,"fold","","",80],[10,"count","","",80],[10,"all","","",80],[10,"any","","",80],[10,"find","","",80],[10,"position","","",80],[10,"max_by","","",80],[10,"min_by","","",80],[10,"next_back","","",80],[10,"rev","","",80],[10,"clone","","",70],[10,"clone_from","","",70],[10,"next","","",70],[10,"size_hint","","",70],[10,"size_hint","","",70],[10,"chain","","",70],[10,"zip","","",70],[10,"map","","",70],[10,"filter","","",70],[10,"filter_map","","",70],[10,"enumerate","","",70],[10,"peekable","","",70],[10,"skip_while","","",70],[10,"take_while","","",70],[10,"skip","","",70],[10,"take","","",70],[10,"scan","","",70],[10,"flat_map","","",70],[10,"fuse","","",70],[10,"inspect","","",70],[10,"by_ref","","",70],[10,"advance","","",70],[10,"collect","","",70],[10,"nth","","",70],[10,"last","","",70],[10,"fold","","",70],[10,"count","","",70],[10,"all","","",70],[10,"any","","",70],[10,"find","","",70],[10,"position","","",70],[10,"max_by","","",70],[10,"min_by","","",70],[10,"next_back","","",70],[10,"rev","","",70],[10,"indexable","","",70],[10,"idx","","",70],[10,"next","","",81],[10,"size_hint","","",81],[10,"size_hint","","",81],[10,"chain","","",81],[10,"zip","","",81],[10,"map","","",81],[10,"filter","","",81],[10,"filter_map","","",81],[10,"enumerate","","",81],[10,"peekable","","",81],[10,"skip_while","","",81],[10,"take_while","","",81],[10,"skip","","",81],[10,"take","","",81],[10,"scan","","",81],[10,"flat_map","","",81],[10,"fuse","","",81],[10,"inspect","","",81],[10,"by_ref","","",81],[10,"advance","","",81],[10,"collect","","",81],[10,"nth","","",81],[10,"last","","",81],[10,"fold","","",81],[10,"count","","",81],[10,"all","","",81],[10,"any","","",81],[10,"find","","",81],[10,"position","","",81],[10,"max_by","","",81],[10,"min_by","","",81],[10,"peek","","Return a reference to the next element of the iterator with out advancing it,\nor None if the iterator is exhausted.",81],[10,"is_empty","","Check whether peekable iterator is empty or not.",81],[10,"next","","",82],[10,"size_hint","","",82],[10,"size_hint","","",82],[10,"chain","","",82],[10,"zip","","",82],[10,"map","","",82],[10,"filter","","",82],[10,"filter_map","","",82],[10,"enumerate","","",82],[10,"peekable","","",82],[10,"skip_while","","",82],[10,"take_while","","",82],[10,"skip","","",82],[10,"take","","",82],[10,"scan","","",82],[10,"flat_map","","",82],[10,"fuse","","",82],[10,"inspect","","",82],[10,"by_ref","","",82],[10,"advance","","",82],[10,"collect","","",82],[10,"nth","","",82],[10,"last","","",82],[10,"fold","","",82],[10,"count","","",82],[10,"all","","",82],[10,"any","","",82],[10,"find","","",82],[10,"position","","",82],[10,"max_by","","",82],[10,"min_by","","",82],[10,"next","","",83],[10,"size_hint","","",83],[10,"size_hint","","",83],[10,"chain","","",83],[10,"zip","","",83],[10,"map","","",83],[10,"filter","","",83],[10,"filter_map","","",83],[10,"enumerate","","",83],[10,"peekable","","",83],[10,"skip_while","","",83],[10,"take_while","","",83],[10,"skip","","",83],[10,"take","","",83],[10,"scan","","",83],[10,"flat_map","","",83],[10,"fuse","","",83],[10,"inspect","","",83],[10,"by_ref","","",83],[10,"advance","","",83],[10,"collect","","",83],[10,"nth","","",83],[10,"last","","",83],[10,"fold","","",83],[10,"count","","",83],[10,"all","","",83],[10,"any","","",83],[10,"find","","",83],[10,"position","","",83],[10,"max_by","","",83],[10,"min_by","","",83],[10,"clone","","",84],[10,"clone_from","","",84],[10,"next","","",84],[10,"size_hint","","",84],[10,"size_hint","","",84],[10,"chain","","",84],[10,"zip","","",84],[10,"map","","",84],[10,"filter","","",84],[10,"filter_map","","",84],[10,"enumerate","","",84],[10,"peekable","","",84],[10,"skip_while","","",84],[10,"take_while","","",84],[10,"skip","","",84],[10,"take","","",84],[10,"scan","","",84],[10,"flat_map","","",84],[10,"fuse","","",84],[10,"inspect","","",84],[10,"by_ref","","",84],[10,"advance","","",84],[10,"collect","","",84],[10,"nth","","",84],[10,"last","","",84],[10,"fold","","",84],[10,"count","","",84],[10,"all","","",84],[10,"any","","",84],[10,"find","","",84],[10,"position","","",84],[10,"max_by","","",84],[10,"min_by","","",84],[10,"indexable","","",84],[10,"idx","","",84],[10,"clone","","",85],[10,"clone_from","","",85],[10,"next","","",85],[10,"size_hint","","",85],[10,"size_hint","","",85],[10,"chain","","",85],[10,"zip","","",85],[10,"map","","",85],[10,"filter","","",85],[10,"filter_map","","",85],[10,"enumerate","","",85],[10,"peekable","","",85],[10,"skip_while","","",85],[10,"take_while","","",85],[10,"skip","","",85],[10,"take","","",85],[10,"scan","","",85],[10,"flat_map","","",85],[10,"fuse","","",85],[10,"inspect","","",85],[10,"by_ref","","",85],[10,"advance","","",85],[10,"collect","","",85],[10,"nth","","",85],[10,"last","","",85],[10,"fold","","",85],[10,"count","","",85],[10,"all","","",85],[10,"any","","",85],[10,"find","","",85],[10,"position","","",85],[10,"max_by","","",85],[10,"min_by","","",85],[10,"indexable","","",85],[10,"idx","","",85],[10,"next","","",86],[10,"size_hint","","",86],[10,"size_hint","","",86],[10,"chain","","",86],[10,"zip","","",86],[10,"map","","",86],[10,"filter","","",86],[10,"filter_map","","",86],[10,"enumerate","","",86],[10,"peekable","","",86],[10,"skip_while","","",86],[10,"take_while","","",86],[10,"skip","","",86],[10,"take","","",86],[10,"scan","","",86],[10,"flat_map","","",86],[10,"fuse","","",86],[10,"inspect","","",86],[10,"by_ref","","",86],[10,"advance","","",86],[10,"collect","","",86],[10,"nth","","",86],[10,"last","","",86],[10,"fold","","",86],[10,"count","","",86],[10,"all","","",86],[10,"any","","",86],[10,"find","","",86],[10,"position","","",86],[10,"max_by","","",86],[10,"min_by","","",86],[10,"next","","",87],[10,"size_hint","","",87],[10,"size_hint","","",87],[10,"chain","","",87],[10,"zip","","",87],[10,"map","","",87],[10,"filter","","",87],[10,"filter_map","","",87],[10,"enumerate","","",87],[10,"peekable","","",87],[10,"skip_while","","",87],[10,"take_while","","",87],[10,"skip","","",87],[10,"take","","",87],[10,"scan","","",87],[10,"flat_map","","",87],[10,"fuse","","",87],[10,"inspect","","",87],[10,"by_ref","","",87],[10,"advance","","",87],[10,"collect","","",87],[10,"nth","","",87],[10,"last","","",87],[10,"fold","","",87],[10,"count","","",87],[10,"all","","",87],[10,"any","","",87],[10,"find","","",87],[10,"position","","",87],[10,"max_by","","",87],[10,"min_by","","",87],[10,"next_back","","",87],[10,"rev","","",87],[10,"clone","","",88],[10,"clone_from","","",88],[10,"next","","",88],[10,"size_hint","","",88],[10,"size_hint","","",88],[10,"chain","","",88],[10,"zip","","",88],[10,"map","","",88],[10,"filter","","",88],[10,"filter_map","","",88],[10,"enumerate","","",88],[10,"peekable","","",88],[10,"skip_while","","",88],[10,"take_while","","",88],[10,"skip","","",88],[10,"take","","",88],[10,"scan","","",88],[10,"flat_map","","",88],[10,"fuse","","",88],[10,"inspect","","",88],[10,"by_ref","","",88],[10,"advance","","",88],[10,"collect","","",88],[10,"nth","","",88],[10,"last","","",88],[10,"fold","","",88],[10,"count","","",88],[10,"all","","",88],[10,"any","","",88],[10,"find","","",88],[10,"position","","",88],[10,"max_by","","",88],[10,"min_by","","",88],[10,"next_back","","",88],[10,"rev","","",88],[10,"indexable","","",88],[10,"idx","","",88],[10,"reset_fuse","","Resets the fuse such that the next call to .next() or .next_back() will\ncall the underlying iterator again even if it previously returned None.",88],[10,"next","","",71],[10,"size_hint","","",71],[10,"size_hint","","",71],[10,"chain","","",71],[10,"zip","","",71],[10,"map","","",71],[10,"filter","","",71],[10,"filter_map","","",71],[10,"enumerate","","",71],[10,"peekable","","",71],[10,"skip_while","","",71],[10,"take_while","","",71],[10,"skip","","",71],[10,"take","","",71],[10,"scan","","",71],[10,"flat_map","","",71],[10,"fuse","","",71],[10,"inspect","","",71],[10,"by_ref","","",71],[10,"advance","","",71],[10,"collect","","",71],[10,"nth","","",71],[10,"last","","",71],[10,"fold","","",71],[10,"count","","",71],[10,"all","","",71],[10,"any","","",71],[10,"find","","",71],[10,"position","","",71],[10,"max_by","","",71],[10,"min_by","","",71],[10,"next_back","","",71],[10,"rev","","",71],[10,"indexable","","",71],[10,"idx","","",71],[10,"new","","Creates a new iterator with the specified closure as the \"iterator\nfunction\" and an initial state to eventually pass to the iterator",89],[10,"next","","",89],[10,"size_hint","","",89],[10,"size_hint","","",89],[10,"chain","","",89],[10,"zip","","",89],[10,"map","","",89],[10,"filter","","",89],[10,"filter_map","","",89],[10,"enumerate","","",89],[10,"peekable","","",89],[10,"skip_while","","",89],[10,"take_while","","",89],[10,"skip","","",89],[10,"take","","",89],[10,"scan","","",89],[10,"flat_map","","",89],[10,"fuse","","",89],[10,"inspect","","",89],[10,"by_ref","","",89],[10,"advance","","",89],[10,"collect","","",89],[10,"nth","","",89],[10,"last","","",89],[10,"fold","","",89],[10,"count","","",89],[10,"all","","",89],[10,"any","","",89],[10,"find","","",89],[10,"position","","",89],[10,"max_by","","",89],[10,"min_by","","",89],[10,"clone","","",90],[10,"clone_from","","",90],[10,"next","","",90],[10,"size_hint","","",90],[10,"size_hint","","",90],[10,"chain","","",90],[10,"zip","","",90],[10,"map","","",90],[10,"filter","","",90],[10,"filter_map","","",90],[10,"enumerate","","",90],[10,"peekable","","",90],[10,"skip_while","","",90],[10,"take_while","","",90],[10,"skip","","",90],[10,"take","","",90],[10,"scan","","",90],[10,"flat_map","","",90],[10,"fuse","","",90],[10,"inspect","","",90],[10,"by_ref","","",90],[10,"advance","","",90],[10,"collect","","",90],[10,"nth","","",90],[10,"last","","",90],[10,"fold","","",90],[10,"count","","",90],[10,"all","","",90],[10,"any","","",90],[10,"find","","",90],[10,"position","","",90],[10,"max_by","","",90],[10,"min_by","","",90],[10,"clone","","",91],[10,"clone_from","","",91],[10,"next","","",91],[10,"size_hint","","",91],[10,"size_hint","","",91],[10,"chain","","",91],[10,"zip","","",91],[10,"map","","",91],[10,"filter","","",91],[10,"filter_map","","",91],[10,"enumerate","","",91],[10,"peekable","","",91],[10,"skip_while","","",91],[10,"take_while","","",91],[10,"skip","","",91],[10,"take","","",91],[10,"scan","","",91],[10,"flat_map","","",91],[10,"fuse","","",91],[10,"inspect","","",91],[10,"by_ref","","",91],[10,"advance","","",91],[10,"collect","","",91],[10,"nth","","",91],[10,"last","","",91],[10,"fold","","",91],[10,"count","","",91],[10,"all","","",91],[10,"any","","",91],[10,"find","","",91],[10,"position","","",91],[10,"max_by","","",91],[10,"min_by","","",91],[10,"next_back","","",91],[10,"rev","","",91],[10,"clone","","",92],[10,"clone_from","","",92],[10,"next","","",92],[10,"size_hint","","",92],[10,"size_hint","","",92],[10,"chain","","",92],[10,"zip","","",92],[10,"map","","",92],[10,"filter","","",92],[10,"filter_map","","",92],[10,"enumerate","","",92],[10,"peekable","","",92],[10,"skip_while","","",92],[10,"take_while","","",92],[10,"skip","","",92],[10,"take","","",92],[10,"scan","","",92],[10,"flat_map","","",92],[10,"fuse","","",92],[10,"inspect","","",92],[10,"by_ref","","",92],[10,"advance","","",92],[10,"collect","","",92],[10,"nth","","",92],[10,"last","","",92],[10,"fold","","",92],[10,"count","","",92],[10,"all","","",92],[10,"any","","",92],[10,"find","","",92],[10,"position","","",92],[10,"max_by","","",92],[10,"min_by","","",92],[10,"next_back","","",92],[10,"rev","","",92],[10,"clone","","",93],[10,"clone_from","","",93],[10,"next","","",93],[10,"size_hint","","",93],[10,"chain","","",93],[10,"zip","","",93],[10,"map","","",93],[10,"filter","","",93],[10,"filter_map","","",93],[10,"enumerate","","",93],[10,"peekable","","",93],[10,"skip_while","","",93],[10,"take_while","","",93],[10,"skip","","",93],[10,"take","","",93],[10,"scan","","",93],[10,"flat_map","","",93],[10,"fuse","","",93],[10,"inspect","","",93],[10,"by_ref","","",93],[10,"advance","","",93],[10,"collect","","",93],[10,"nth","","",93],[10,"last","","",93],[10,"fold","","",93],[10,"count","","",93],[10,"all","","",93],[10,"any","","",93],[10,"find","","",93],[10,"position","","",93],[10,"max_by","","",93],[10,"min_by","","",93],[10,"clone","","",94],[10,"clone_from","","",94],[10,"next","","",94],[10,"size_hint","","",94],[10,"chain","","",94],[10,"zip","","",94],[10,"map","","",94],[10,"filter","","",94],[10,"filter_map","","",94],[10,"enumerate","","",94],[10,"peekable","","",94],[10,"skip_while","","",94],[10,"take_while","","",94],[10,"skip","","",94],[10,"take","","",94],[10,"scan","","",94],[10,"flat_map","","",94],[10,"fuse","","",94],[10,"inspect","","",94],[10,"by_ref","","",94],[10,"advance","","",94],[10,"collect","","",94],[10,"nth","","",94],[10,"last","","",94],[10,"fold","","",94],[10,"count","","",94],[10,"all","","",94],[10,"any","","",94],[10,"find","","",94],[10,"position","","",94],[10,"max_by","","",94],[10,"min_by","","",94],[10,"clone","","",95],[10,"clone_from","","",95],[10,"new","","Create a new `Repeat` that endlessly repeats the element `elt`.",95],[10,"next","","",95],[10,"size_hint","","",95],[10,"size_hint","","",95],[10,"chain","","",95],[10,"zip","","",95],[10,"map","","",95],[10,"filter","","",95],[10,"filter_map","","",95],[10,"enumerate","","",95],[10,"peekable","","",95],[10,"skip_while","","",95],[10,"take_while","","",95],[10,"skip","","",95],[10,"take","","",95],[10,"scan","","",95],[10,"flat_map","","",95],[10,"fuse","","",95],[10,"inspect","","",95],[10,"by_ref","","",95],[10,"advance","","",95],[10,"collect","","",95],[10,"nth","","",95],[10,"last","","",95],[10,"fold","","",95],[10,"count","","",95],[10,"all","","",95],[10,"any","","",95],[10,"find","","",95],[10,"position","","",95],[10,"max_by","","",95],[10,"min_by","","",95],[10,"next_back","","",95],[10,"rev","","",95],[10,"indexable","","",95],[10,"idx","","",95],[10,"fmt","core::option","",96],[10,"cmp","","",96],[10,"assert_receiver_is_total_eq","","",96],[10,"partial_cmp","","",96],[10,"lt","","",96],[10,"le","","",96],[10,"gt","","",96],[10,"ge","","",96],[10,"lt","","",96],[10,"le","","",96],[10,"gt","","",96],[10,"ge","","",96],[10,"eq","","",96],[10,"ne","","",96],[10,"ne","","",96],[10,"clone","","",96],[10,"clone_from","","",96],[10,"is_some","","Returns `true` if the option is a `Some` value",96],[10,"is_none","","Returns `true` if the option is a `None` value",96],[10,"as_ref","","Convert from `Option<T>` to `Option<&T>`",96],[10,"as_mut","","Convert from `Option<T>` to `Option<&mut T>`",96],[10,"as_mut_slice","","Convert from `Option<T>` to `&mut [T]` (without copying)",96],[10,"expect","","Unwraps an option, yielding the content of a `Some`",96],[10,"unwrap","","Moves a value out of an option type and returns it, consuming the `Option`.",96],[10,"unwrap_or","","Returns the contained value or a default.",96],[10,"unwrap_or_else","","Returns the contained value or computes it from a closure.",96],[10,"map","","Maps an `Option<T>` to `Option<U>` by applying a function to a contained value",96],[10,"map_or","","Applies a function to the contained value or returns a default.",96],[10,"mutate","","Applies a function to the contained value or does nothing.\nReturns true if the contained value was mutated.",96],[10,"mutate_or_set","","Applies a function to the contained value or sets it to a default.\nReturns true if the contained value was mutated, or false if set to the default.",96],[10,"iter","","Returns an iterator over the possibly contained value.",96],[10,"mut_iter","","Returns a mutable iterator over the possibly contained value.",96],[10,"move_iter","","Returns a consuming iterator over the possibly contained value.",96],[10,"and","","Returns `None` if the option is `None`, otherwise returns `optb`.",96],[10,"and_then","","Returns `None` if the option is `None`, otherwise calls `f` with the\nwrapped value and returns the result.",96],[10,"or","","Returns the option if it contains a value, otherwise returns `optb`.",96],[10,"or_else","","Returns the option if it contains a value, otherwise calls `f` and\nreturns the result.",96],[10,"take","","Takes the value out of the option, leaving a `None` in its place.",96],[10,"filtered","","Filters an optional value using a given function.",96],[10,"while_some","","Applies a function zero or more times until the result is `None`.",96],[10,"take_unwrap","","The option dance. Moves a value out of an option type and returns it,\nreplacing the original with `None`.",96],[10,"get_ref","","Gets an immutable reference to the value inside an option.",96],[10,"get_mut_ref","","Gets a mutable reference to the value inside an option.",96],[10,"unwrap_or_default","","Returns the contained value or a default",96],[10,"as_slice","","Convert from `Option<T>` to `&[T]` (without copying)",96],[10,"default","","",96],[10,"clone","","",97],[10,"clone_from","","",97],[10,"next","","",97],[10,"size_hint","","",97],[10,"size_hint","","",97],[10,"chain","","",97],[10,"zip","","",97],[10,"map","","",97],[10,"filter","","",97],[10,"filter_map","","",97],[10,"enumerate","","",97],[10,"peekable","","",97],[10,"skip_while","","",97],[10,"take_while","","",97],[10,"skip","","",97],[10,"take","","",97],[10,"scan","","",97],[10,"flat_map","","",97],[10,"fuse","","",97],[10,"inspect","","",97],[10,"by_ref","","",97],[10,"advance","","",97],[10,"collect","","",97],[10,"nth","","",97],[10,"last","","",97],[10,"fold","","",97],[10,"count","","",97],[10,"all","","",97],[10,"any","","",97],[10,"find","","",97],[10,"position","","",97],[10,"max_by","","",97],[10,"min_by","","",97],[10,"next_back","","",97],[10,"rev","","",97],[10,"rposition","","",97],[10,"len","","",97],[10,"fmt","core::result","",98],[10,"cmp","","",98],[10,"assert_receiver_is_total_eq","","",98],[10,"partial_cmp","","",98],[10,"lt","","",98],[10,"le","","",98],[10,"gt","","",98],[10,"ge","","",98],[10,"lt","","",98],[10,"le","","",98],[10,"gt","","",98],[10,"ge","","",98],[10,"eq","","",98],[10,"ne","","",98],[10,"ne","","",98],[10,"clone","","",98],[10,"clone_from","","",98],[10,"is_ok","","Returns true if the result is `Ok`",98],[10,"is_err","","Returns true if the result is `Err`",98],[10,"ok","","Convert from `Result<T, E>` to `Option<T>`",98],[10,"err","","Convert from `Result<T, E>` to `Option<E>`",98],[10,"as_ref","","Convert from `Result<T, E>` to `Result<&T, &E>`",98],[10,"as_mut","","Convert from `Result<T, E>` to `Result<&mut T, &mut E>`",98],[10,"map","","Maps a `Result<T, E>` to `Result<U, E>` by applying a function to an\ncontained `Ok` value, leaving an `Err` value untouched.",98],[10,"map_err","","Maps a `Result<T, E>` to `Result<T, F>` by applying a function to an\ncontained `Err` value, leaving an `Ok` value untouched.",98],[10,"and","","Returns `res` if the result is `Ok`, otherwise returns the `Err` value of `self`.",98],[10,"and_then","","Calls `op` if the result is `Ok`, otherwise returns the `Err` value of `self`.",98],[10,"or","","Returns `res` if the result is `Err`, otherwise returns the `Ok` value of `self`.",98],[10,"or_else","","Calls `op` if the result is `Err`, otherwise returns the `Ok` value of `self`.",98],[10,"unwrap_or","","Unwraps a result, yielding the content of an `Ok`.\nElse it returns `optb`.",98],[10,"unwrap_or_else","","Unwraps a result, yielding the content of an `Ok`.\nIf the value is an `Err` then it calls `op` with its value.",98],[10,"unwrap_or_handle","","Deprecated name for `unwrap_or_else()`.",98],[10,"unwrap","","Unwraps a result, yielding the content of an `Ok`.",98],[10,"unwrap_err","","Unwraps a result, yielding the content of an `Err`.",98],[10,"fmt","core::simd","",99],[10,"fmt","","",100],[10,"fmt","","",101],[10,"fmt","","",102],[10,"fmt","","",103],[10,"fmt","","",104],[10,"fmt","","",105],[10,"fmt","","",106],[10,"fmt","","",107],[10,"fmt","","",108],[10,"next","core::slice","",109],[10,"size_hint","","",109],[10,"size_hint","","",109],[10,"chain","","",109],[10,"zip","","",109],[10,"map","","",109],[10,"filter","","",109],[10,"filter_map","","",109],[10,"enumerate","","",109],[10,"peekable","","",109],[10,"skip_while","","",109],[10,"take_while","","",109],[10,"skip","","",109],[10,"take","","",109],[10,"scan","","",109],[10,"flat_map","","",109],[10,"fuse","","",109],[10,"inspect","","",109],[10,"by_ref","","",109],[10,"advance","","",109],[10,"collect","","",109],[10,"nth","","",109],[10,"last","","",109],[10,"fold","","",109],[10,"count","","",109],[10,"all","","",109],[10,"any","","",109],[10,"find","","",109],[10,"position","","",109],[10,"max_by","","",109],[10,"min_by","","",109],[10,"next_back","","",109],[10,"rev","","",109],[10,"rposition","","",109],[10,"len","","",109],[10,"clone","","",109],[10,"clone_from","","",109],[10,"indexable","","",109],[10,"idx","","",109],[10,"next","","",110],[10,"size_hint","","",110],[10,"size_hint","","",110],[10,"chain","","",110],[10,"zip","","",110],[10,"map","","",110],[10,"filter","","",110],[10,"filter_map","","",110],[10,"enumerate","","",110],[10,"peekable","","",110],[10,"skip_while","","",110],[10,"take_while","","",110],[10,"skip","","",110],[10,"take","","",110],[10,"scan","","",110],[10,"flat_map","","",110],[10,"fuse","","",110],[10,"inspect","","",110],[10,"by_ref","","",110],[10,"advance","","",110],[10,"collect","","",110],[10,"nth","","",110],[10,"last","","",110],[10,"fold","","",110],[10,"count","","",110],[10,"all","","",110],[10,"any","","",110],[10,"find","","",110],[10,"position","","",110],[10,"max_by","","",110],[10,"min_by","","",110],[10,"next_back","","",110],[10,"rev","","",110],[10,"rposition","","",110],[10,"len","","",110],[10,"next","","",111],[10,"size_hint","","",111],[10,"size_hint","","",111],[10,"chain","","",111],[10,"zip","","",111],[10,"map","","",111],[10,"filter","","",111],[10,"filter_map","","",111],[10,"enumerate","","",111],[10,"peekable","","",111],[10,"skip_while","","",111],[10,"take_while","","",111],[10,"skip","","",111],[10,"take","","",111],[10,"scan","","",111],[10,"flat_map","","",111],[10,"fuse","","",111],[10,"inspect","","",111],[10,"by_ref","","",111],[10,"advance","","",111],[10,"collect","","",111],[10,"nth","","",111],[10,"last","","",111],[10,"fold","","",111],[10,"count","","",111],[10,"all","","",111],[10,"any","","",111],[10,"find","","",111],[10,"position","","",111],[10,"max_by","","",111],[10,"min_by","","",111],[10,"next_back","","",111],[10,"rev","","",111],[10,"next","","",112],[10,"size_hint","","",112],[10,"size_hint","","",112],[10,"chain","","",112],[10,"zip","","",112],[10,"map","","",112],[10,"filter","","",112],[10,"filter_map","","",112],[10,"enumerate","","",112],[10,"peekable","","",112],[10,"skip_while","","",112],[10,"take_while","","",112],[10,"skip","","",112],[10,"take","","",112],[10,"scan","","",112],[10,"flat_map","","",112],[10,"fuse","","",112],[10,"inspect","","",112],[10,"by_ref","","",112],[10,"advance","","",112],[10,"collect","","",112],[10,"nth","","",112],[10,"last","","",112],[10,"fold","","",112],[10,"count","","",112],[10,"all","","",112],[10,"any","","",112],[10,"find","","",112],[10,"position","","",112],[10,"max_by","","",112],[10,"min_by","","",112],[10,"next_back","","",112],[10,"rev","","",112],[10,"next","","",113],[10,"size_hint","","",113],[10,"size_hint","","",113],[10,"chain","","",113],[10,"zip","","",113],[10,"map","","",113],[10,"filter","","",113],[10,"filter_map","","",113],[10,"enumerate","","",113],[10,"peekable","","",113],[10,"skip_while","","",113],[10,"take_while","","",113],[10,"skip","","",113],[10,"take","","",113],[10,"scan","","",113],[10,"flat_map","","",113],[10,"fuse","","",113],[10,"inspect","","",113],[10,"by_ref","","",113],[10,"advance","","",113],[10,"collect","","",113],[10,"nth","","",113],[10,"last","","",113],[10,"fold","","",113],[10,"count","","",113],[10,"all","","",113],[10,"any","","",113],[10,"find","","",113],[10,"position","","",113],[10,"max_by","","",113],[10,"min_by","","",113],[10,"clone","","",114],[10,"clone_from","","",114],[10,"next","","",114],[10,"size_hint","","",114],[10,"size_hint","","",114],[10,"chain","","",114],[10,"zip","","",114],[10,"map","","",114],[10,"filter","","",114],[10,"filter_map","","",114],[10,"enumerate","","",114],[10,"peekable","","",114],[10,"skip_while","","",114],[10,"take_while","","",114],[10,"skip","","",114],[10,"take","","",114],[10,"scan","","",114],[10,"flat_map","","",114],[10,"fuse","","",114],[10,"inspect","","",114],[10,"by_ref","","",114],[10,"advance","","",114],[10,"collect","","",114],[10,"nth","","",114],[10,"last","","",114],[10,"fold","","",114],[10,"count","","",114],[10,"all","","",114],[10,"any","","",114],[10,"find","","",114],[10,"position","","",114],[10,"max_by","","",114],[10,"min_by","","",114],[10,"clone","","",115],[10,"clone_from","","",115],[10,"next","","",115],[10,"size_hint","","",115],[10,"size_hint","","",115],[10,"chain","","",115],[10,"zip","","",115],[10,"map","","",115],[10,"filter","","",115],[10,"filter_map","","",115],[10,"enumerate","","",115],[10,"peekable","","",115],[10,"skip_while","","",115],[10,"take_while","","",115],[10,"skip","","",115],[10,"take","","",115],[10,"scan","","",115],[10,"flat_map","","",115],[10,"fuse","","",115],[10,"inspect","","",115],[10,"by_ref","","",115],[10,"advance","","",115],[10,"collect","","",115],[10,"nth","","",115],[10,"last","","",115],[10,"fold","","",115],[10,"count","","",115],[10,"all","","",115],[10,"any","","",115],[10,"find","","",115],[10,"position","","",115],[10,"max_by","","",115],[10,"min_by","","",115],[10,"next_back","","",115],[10,"rev","","",115],[10,"indexable","","",115],[10,"idx","","",115],[10,"next","","",116],[10,"size_hint","","",116],[10,"size_hint","","",116],[10,"chain","","",116],[10,"zip","","",116],[10,"map","","",116],[10,"filter","","",116],[10,"filter_map","","",116],[10,"enumerate","","",116],[10,"peekable","","",116],[10,"skip_while","","",116],[10,"take_while","","",116],[10,"skip","","",116],[10,"take","","",116],[10,"scan","","",116],[10,"flat_map","","",116],[10,"fuse","","",116],[10,"inspect","","",116],[10,"by_ref","","",116],[10,"advance","","",116],[10,"collect","","",116],[10,"nth","","",116],[10,"last","","",116],[10,"fold","","",116],[10,"count","","",116],[10,"all","","",116],[10,"any","","",116],[10,"find","","",116],[10,"position","","",116],[10,"max_by","","",116],[10,"min_by","","",116],[10,"next_back","","",116],[10,"rev","","",116],[10,"clone","core::str","",117],[10,"clone_from","","",117],[10,"next","","",117],[10,"size_hint","","",117],[10,"size_hint","","",117],[10,"chain","","",117],[10,"zip","","",117],[10,"map","","",117],[10,"filter","","",117],[10,"filter_map","","",117],[10,"enumerate","","",117],[10,"peekable","","",117],[10,"skip_while","","",117],[10,"take_while","","",117],[10,"skip","","",117],[10,"take","","",117],[10,"scan","","",117],[10,"flat_map","","",117],[10,"fuse","","",117],[10,"inspect","","",117],[10,"by_ref","","",117],[10,"advance","","",117],[10,"collect","","",117],[10,"nth","","",117],[10,"last","","",117],[10,"fold","","",117],[10,"count","","",117],[10,"all","","",117],[10,"any","","",117],[10,"find","","",117],[10,"position","","",117],[10,"max_by","","",117],[10,"min_by","","",117],[10,"next_back","","",117],[10,"rev","","",117],[10,"clone","","",118],[10,"clone_from","","",118],[10,"next","","",118],[10,"size_hint","","",118],[10,"size_hint","","",118],[10,"chain","","",118],[10,"zip","","",118],[10,"map","","",118],[10,"filter","","",118],[10,"filter_map","","",118],[10,"enumerate","","",118],[10,"peekable","","",118],[10,"skip_while","","",118],[10,"take_while","","",118],[10,"skip","","",118],[10,"take","","",118],[10,"scan","","",118],[10,"flat_map","","",118],[10,"fuse","","",118],[10,"inspect","","",118],[10,"by_ref","","",118],[10,"advance","","",118],[10,"collect","","",118],[10,"nth","","",118],[10,"last","","",118],[10,"fold","","",118],[10,"count","","",118],[10,"all","","",118],[10,"any","","",118],[10,"find","","",118],[10,"position","","",118],[10,"max_by","","",118],[10,"min_by","","",118],[10,"next_back","","",118],[10,"rev","","",118],[10,"clone","","",119],[10,"clone_from","","",119],[10,"clone","","",120],[10,"clone_from","","",120],[10,"next","","",119],[10,"size_hint","","",119],[10,"chain","","",119],[10,"zip","","",119],[10,"map","","",119],[10,"filter","","",119],[10,"filter_map","","",119],[10,"enumerate","","",119],[10,"peekable","","",119],[10,"skip_while","","",119],[10,"take_while","","",119],[10,"skip","","",119],[10,"take","","",119],[10,"scan","","",119],[10,"flat_map","","",119],[10,"fuse","","",119],[10,"inspect","","",119],[10,"by_ref","","",119],[10,"advance","","",119],[10,"collect","","",119],[10,"nth","","",119],[10,"last","","",119],[10,"fold","","",119],[10,"count","","",119],[10,"all","","",119],[10,"any","","",119],[10,"find","","",119],[10,"position","","",119],[10,"max_by","","",119],[10,"min_by","","",119],[10,"next_back","","",119],[10,"rev","","",119],[10,"next","","",120],[10,"size_hint","","",120],[10,"chain","","",120],[10,"zip","","",120],[10,"map","","",120],[10,"filter","","",120],[10,"filter_map","","",120],[10,"enumerate","","",120],[10,"peekable","","",120],[10,"skip_while","","",120],[10,"take_while","","",120],[10,"skip","","",120],[10,"take","","",120],[10,"scan","","",120],[10,"flat_map","","",120],[10,"fuse","","",120],[10,"inspect","","",120],[10,"by_ref","","",120],[10,"advance","","",120],[10,"collect","","",120],[10,"nth","","",120],[10,"last","","",120],[10,"fold","","",120],[10,"count","","",120],[10,"all","","",120],[10,"any","","",120],[10,"find","","",120],[10,"position","","",120],[10,"max_by","","",120],[10,"min_by","","",120],[10,"clone","","",121],[10,"clone_from","","",121],[10,"clone","","",122],[10,"clone_from","","",122],[10,"clone","","",123],[10,"clone_from","","",123],[10,"clone","","",124],[10,"clone_from","","",124],[10,"clone","","",125],[10,"clone_from","","",125],[10,"next","","",124],[10,"size_hint","","",124],[10,"chain","","",124],[10,"zip","","",124],[10,"map","","",124],[10,"filter","","",124],[10,"filter_map","","",124],[10,"enumerate","","",124],[10,"peekable","","",124],[10,"skip_while","","",124],[10,"take_while","","",124],[10,"skip","","",124],[10,"take","","",124],[10,"scan","","",124],[10,"flat_map","","",124],[10,"fuse","","",124],[10,"inspect","","",124],[10,"by_ref","","",124],[10,"advance","","",124],[10,"collect","","",124],[10,"nth","","",124],[10,"last","","",124],[10,"fold","","",124],[10,"count","","",124],[10,"all","","",124],[10,"any","","",124],[10,"find","","",124],[10,"position","","",124],[10,"max_by","","",124],[10,"min_by","","",124],[10,"next","","",125],[10,"size_hint","","",125],[10,"chain","","",125],[10,"zip","","",125],[10,"map","","",125],[10,"filter","","",125],[10,"filter_map","","",125],[10,"enumerate","","",125],[10,"peekable","","",125],[10,"skip_while","","",125],[10,"take_while","","",125],[10,"skip","","",125],[10,"take","","",125],[10,"scan","","",125],[10,"flat_map","","",125],[10,"fuse","","",125],[10,"inspect","","",125],[10,"by_ref","","",125],[10,"advance","","",125],[10,"collect","","",125],[10,"nth","","",125],[10,"last","","",125],[10,"fold","","",125],[10,"count","","",125],[10,"all","","",125],[10,"any","","",125],[10,"find","","",125],[10,"position","","",125],[10,"max_by","","",125],[10,"min_by","","",125],[10,"clone","","",126],[10,"clone_from","","",126],[10,"next","","",126],[10,"size_hint","","",126],[10,"size_hint","","",126],[10,"chain","","",126],[10,"zip","","",126],[10,"map","","",126],[10,"filter","","",126],[10,"filter_map","","",126],[10,"enumerate","","",126],[10,"peekable","","",126],[10,"skip_while","","",126],[10,"take_while","","",126],[10,"skip","","",126],[10,"take","","",126],[10,"scan","","",126],[10,"flat_map","","",126],[10,"fuse","","",126],[10,"inspect","","",126],[10,"by_ref","","",126],[10,"advance","","",126],[10,"collect","","",126],[10,"nth","","",126],[10,"last","","",126],[10,"fold","","",126],[10,"count","","",126],[10,"all","","",126],[10,"any","","",126],[10,"find","","",126],[10,"position","","",126],[10,"max_by","","",126],[10,"min_by","","",126],[10,"clone","","",127],[10,"clone_from","","",127],[10,"fmt","","",128],[10,"clone","","",128],[10,"clone_from","","",128],[10,"assert_receiver_is_total_eq","","",128],[10,"eq","","",128],[10,"ne","","",128],[10,"ne","","",128],[10,"to_char_lossy","","Convert `self` to a `char`, taking `LoneSurrogate`s to the\nreplacement character (U+FFFD).",128],[10,"next","","",127],[10,"size_hint","","",127],[10,"size_hint","","",127],[10,"chain","","",127],[10,"zip","","",127],[10,"map","","",127],[10,"filter","","",127],[10,"filter_map","","",127],[10,"enumerate","","",127],[10,"peekable","","",127],[10,"skip_while","","",127],[10,"take_while","","",127],[10,"skip","","",127],[10,"take","","",127],[10,"scan","","",127],[10,"flat_map","","",127],[10,"fuse","","",127],[10,"inspect","","",127],[10,"by_ref","","",127],[10,"advance","","",127],[10,"collect","","",127],[10,"nth","","",127],[10,"last","","",127],[10,"fold","","",127],[10,"count","","",127],[10,"all","","",127],[10,"any","","",127],[10,"find","","",127],[10,"position","","",127],[10,"max_by","","",127],[10,"min_by","","",127],[10,"eq","core::fmt::num","",129],[10,"ne","","",129],[10,"ne","","",129],[10,"clone","","",129],[10,"clone_from","","",129],[10,"eq","","",130],[10,"ne","","",130],[10,"ne","","",130],[10,"clone","","",130],[10,"clone_from","","",130],[10,"eq","","",131],[10,"ne","","",131],[10,"ne","","",131],[10,"clone","","",131],[10,"clone_from","","",131],[10,"eq","","",132],[10,"ne","","",132],[10,"ne","","",132],[10,"clone","","",132],[10,"clone_from","","",132],[10,"eq","","",133],[10,"ne","","",133],[10,"ne","","",133],[10,"clone","","",133],[10,"clone_from","","",133],[10,"eq","","",134],[10,"ne","","",134],[10,"ne","","",134],[10,"clone","","",134],[10,"clone_from","","",134],[10,"fmt","","",135],[10,"fmt","","",135],[10,"fmt","","",135],[10,"fmt","","",135],[10,"fmt","","",135],[10,"fmt","","",135],[10,"fmt","","",135],[10,"fmt","","",135],[10,"fmt","","",135],[10,"fmt","","",135],[10,"eq","core::fmt::rt","",136],[10,"ne","","",136],[10,"ne","","",136],[10,"fmt","core::fmt","",137],[10,"pad_integral","","Performs the correct padding for an integer which has already been\nemitted into a byte-array. The byte-array should *not* contain the sign\nfor the integer, that will be added by this method.",138],[10,"pad","","This function takes a string slice and emits it to the internal buffer\nafter applying the relevant formatting flags specified. The flags\nrecognized for generic strings are:",138],[10,"write","","Writes some data to the underlying buffer contained within this\nformatter.",138],[10,"write_fmt","","Writes some formatted information into this instance",138],[10,"fmt","core::cell","",64],[10,"fmt","","",66],[10,"fmt","","",67],[1,"Splits","collections::slice","An iterator over the slices of a vector separated by elements that\nmatch a predicate function."],[1,"Windows","","An iterator over the (overlapping) slices of length `size` within\na vector."],[1,"Chunks","","An iterator over a vector in (non-overlapping) chunks (`size`\nelements at a time)."],[6,"Vector","","Any vector that can be represented as a slice."],[9,"as_slice","","Work with `self` as a slice.",139],[6,"ImmutableVector","","Extension methods for vectors"],[9,"slice","","Returns a slice of self spanning the interval [`start`, `end`).",140],[9,"slice_from","","Returns a slice of self from `start` to the end of the vec.",140],[9,"slice_to","","Returns a slice of self from the start of the vec to `end`.",140],[9,"iter","","Returns an iterator over the vector",140],[9,"split","","Returns an iterator over the subslices of the vector which are\nseparated by elements that match `pred`.  The matched element\nis not contained in the subslices.",140],[9,"splitn","","Returns an iterator over the subslices of the vector which are\nseparated by elements that match `pred`, limited to splitting\nat most `n` times.  The matched element is not contained in\nthe subslices.",140],[9,"rsplitn","","Returns an iterator over the subslices of the vector which are\nseparated by elements that match `pred` limited to splitting\nat most `n` times. This starts at the end of the vector and\nworks backwards.  The matched element is not contained in the\nsubslices.",140],[9,"windows","","Returns an iterator over all contiguous windows of length\n`size`. The windows overlap. If the vector is shorter than\n`size`, the iterator returns no values.",140],[9,"chunks","","\nReturns an iterator over `size` elements of the vector at a\ntime. The chunks do not overlap. If `size` does not divide the\nlength of the vector, then the last chunk will not have length\n`size`.",140],[9,"get","","Returns the element of a vector at the given index, or `None` if the\nindex is out of bounds",140],[9,"head","","Returns the first element of a vector, or `None` if it is empty",140],[9,"tail","","Returns all but the first element of a vector",140],[9,"tailn","","Returns all but the first `n' elements of a vector",140],[9,"init","","Returns all but the last element of a vector",140],[9,"initn","","Returns all but the last `n' elements of a vector",140],[9,"last","","Returns the last element of a vector, or `None` if it is empty.",140],[9,"unsafe_ref","","Returns a pointer to the element at the given index, without doing\nbounds checking.",140],[9,"as_ptr","","Returns an unsafe pointer to the vector's buffer",140],[9,"bsearch","","Binary search a sorted vector with a comparator function.",140],[9,"shift_ref","","Returns an immutable reference to the first element in this slice\nand adjusts the slice in place so that it no longer contains\nthat element. O(1).",140],[9,"pop_ref","","Returns an immutable reference to the last element in this slice\nand adjusts the slice in place so that it no longer contains\nthat element. O(1).",140],[6,"ImmutableEqVector","","Extension methods for vectors contain `PartialEq` elements."],[9,"position_elem","","Find the first index containing a matching value",141],[9,"rposition_elem","","Find the last index containing a matching value",141],[9,"contains","","Return true if a vector contains an element with the given value",141],[9,"starts_with","","Returns true if `needle` is a prefix of the vector.",141],[9,"ends_with","","Returns true if `needle` is a suffix of the vector.",141],[6,"ImmutableOrdVector","","Extension methods for vectors containing `Ord` elements."],[9,"bsearch_elem","","Binary search a sorted vector for a given element.",142],[6,"MutableVector","","Extension methods for vectors such that their elements are\nmutable."],[9,"get_mut","","Returns a mutable reference to the element at the given index,\nor `None` if the index is out of bounds",143],[9,"as_mut_slice","","Work with `self` as a mut slice.\nPrimarily intended for getting a &mut [T] from a [T, ..N].",143],[9,"mut_slice","","Return a slice that points into another slice.",143],[9,"mut_slice_from","","Returns a slice of self from `start` to the end of the vec.",143],[9,"mut_slice_to","","Returns a slice of self from the start of the vec to `end`.",143],[9,"mut_iter","","Returns an iterator that allows modifying each value",143],[9,"mut_last","","Returns a mutable pointer to the last item in the vector.",143],[9,"mut_split","","Returns an iterator over the mutable subslices of the vector\nwhich are separated by elements that match `pred`.  The\nmatched element is not contained in the subslices.",143],[9,"mut_chunks","","Returns an iterator over `size` elements of the vector at a time.\nThe chunks are mutable and do not overlap. If `size` does not divide the\nlength of the vector, then the last chunk will not have length\n`size`.",143],[9,"mut_shift_ref","","Returns a mutable reference to the first element in this slice\nand adjusts the slice in place so that it no longer contains\nthat element. O(1).",143],[9,"mut_pop_ref","","Returns a mutable reference to the last element in this slice\nand adjusts the slice in place so that it no longer contains\nthat element. O(1).",143],[9,"swap","","Swaps two elements in a vector.",143],[9,"mut_split_at","","Divides one `&mut` into two at an index.",143],[9,"reverse","","Reverse the order of elements in a vector, in place.",143],[9,"unsafe_mut_ref","","Returns an unsafe mutable pointer to the element in index",143],[9,"as_mut_ptr","","Return an unsafe mutable pointer to the vector's buffer.",143],[9,"unsafe_set","","Unsafely sets the element in index to the value.",143],[9,"init_elem","","Unchecked vector index assignment.  Does not drop the\nold value and hence is only suitable when the vector\nis newly allocated.",143],[9,"copy_memory","","Copies raw bytes from `src` to `self`.",143],[1,"Items","","Immutable slice iterator"],[1,"MutItems","","Mutable slice iterator"],[1,"MutSplits","","An iterator over the subslices of the vector which are separated\nby elements that match `pred`."],[1,"MutChunks","","An iterator over a vector in (non-overlapping) mutable chunks (`size`  elements at a time). When\nthe vector len is not evenly divided by the chunk size, the last slice of the iteration will be\nthe remainder."],[0,"bytes","","Operations on `[u8]`."],[6,"MutableByteVector","collections::slice::bytes","A trait for operations on mutable `[u8]`s."],[9,"set_memory","","Sets all bytes of the receiver to the given value.",144],[3,"copy_memory","","Copies data from `src` to `dst`"],[6,"MutableCloneableVector","collections::slice","Trait for &[T] where T is Cloneable"],[9,"copy_from","","Copies as many elements from `src` as it can into `self` (the\nshorter of `self.len()` and `src.len()`). Returns the number\nof elements copied.",145],[16,"slice","","Utilities for vector manipulation"],[0,"str","collections","Unicode string manipulation (`str` type)"],[1,"Decompositions","collections::str","External iterator for a string's decomposition's characters.\nUse with the `std::iter` module."],[2,"MaybeOwned","","A `MaybeOwned` is a string that can hold either a `String` or a `&str`.\nThis can be useful as an optimization when an allocation is sometimes\nneeded but not always."],[12,"Slice","","A borrowed string",146],[12,"Owned","","An owned string",146],[3,"from_utf8_owned","","Deprecated. Replaced by `String::from_utf8`"],[3,"from_byte","","Deprecated. Replaced by `String::from_byte`"],[3,"from_char","","Deprecated. Use `String::from_char` or `char::to_string()` instead"],[3,"from_chars","","Deprecated. Replaced by `String::from_chars`"],[3,"replace","","Replace all occurrences of one string with another"],[3,"from_utf16","","Deprecated. Use `String::from_utf16`."],[3,"from_utf16_lossy","","Deprecated. Use `String::from_utf16_lossy`."],[3,"from_utf8_lossy","","Deprecated. Use `String::from_utf8_lossy`."],[0,"raw","","Unsafe operations"],[3,"from_buf_len","collections::str::raw","Deprecated. Replaced by `string::raw::from_buf_len`"],[3,"from_c_str","","Deprecated. Use `string::raw::from_buf`"],[3,"from_utf8_owned","","Deprecated. Replaced by `string::raw::from_utf8`"],[3,"from_byte","","Deprecated. Use `string::raw::from_utf8`"],[3,"from_utf8","","Converts a slice of bytes to a string slice without checking\nthat the string contains valid UTF-8."],[3,"c_str_to_static_slice","","Form a slice from a C string. Unsafe because the caller must ensure the\nC string has the static lifetime, or else the return value may be\ninvalidated later."],[3,"slice_bytes","","Takes a bytewise (not UTF-8) slice from a string."],[3,"slice_unchecked","","Takes a bytewise (not UTF-8) slice from a string."],[4,"SendStr","collections::str","`SendStr` is a specialization of `MaybeOwned` to be sendable"],[6,"StrVector","","Methods for vectors of strings"],[9,"concat","","Concatenate a vector of strings.",147],[9,"connect","","Concatenate a vector of strings, placing a given separator between each.",147],[6,"IntoMaybeOwned","","Trait for moving into a `MaybeOwned`"],[9,"into_maybe_owned","","Moves self into a `MaybeOwned`",148],[6,"StrAllocating","","Any string that can be represented as a slice"],[9,"into_string","","Convert `self` into a `String`, not making a copy if possible.",149],[10,"into_owned","","",149],[10,"escape_default","","Escape each char in `s` with `char::escape_default`.",149],[10,"escape_unicode","","Escape each char in `s` with `char::escape_unicode`.",149],[10,"replace","","Replace all occurrences of one string with another.",149],[10,"to_owned","","",149],[10,"to_utf16","","Converts to a vector of `u16` encoded as UTF-16.",149],[10,"repeat","","Given a string, make a new string with repeated copies of it.",149],[10,"lev_distance","","Levenshtein Distance between two strings.",149],[10,"nfd_chars","","An Iterator over the string in Unicode Normalization Form D\n(canonical decomposition).",149],[10,"nfkd_chars","","An Iterator over the string in Unicode Normalization Form KD\n(compatibility decomposition).",149],[10,"clone","","",150],[10,"next","","",150],[10,"size_hint","","",150],[10,"is_owned","","Returns `true` if this `MaybeOwned` wraps an owned string",146],[10,"is_slice","","Returns `true` if this `MaybeOwned` wraps a borrowed string",146],[10,"into_maybe_owned","","",146],[10,"eq","","",146],[10,"partial_cmp","","",146],[10,"cmp","","",146],[10,"equiv","","",146],[10,"as_slice","","",146],[10,"into_string","","",146],[10,"len","","",146],[10,"clone","","",146],[10,"default","","",146],[10,"hash","","",146],[10,"fmt","","",146],[3,"from_utf8","","Converts a vector to a string slice without performing any allocations."],[6,"CharEq","","Something that can be used to compare against a character"],[9,"matches","","Determine if the splitter should split at the given character",151],[9,"only_ascii","","Indicate if this is only concerned about ASCII characters,\nwhich can allow for a faster implementation.",151],[1,"Chars","","Iterator for the char (representing *Unicode Scalar Values*) of a string"],[1,"CharOffsets","","External iterator for a string's characters and their byte offsets.\nUse with the `std::iter` module."],[4,"Bytes","",""],[1,"CharSplits","","An iterator over the substrings of a string, separated by `sep`."],[1,"CharSplitsN","","An iterator over the substrings of a string, separated by `sep`,\nsplitting at most `count` times."],[4,"AnyLines","",""],[1,"MatchIndices","","An iterator over the start and end indices of the matches of a\nsubstring within a larger string"],[1,"StrSplits","","An iterator over the substrings of a string separated by a given\nsearch string"],[3,"eq_slice","","Bytewise slice equality\nNOTE: This function is (ab)used in rustc::middle::trans::_match\nto compare &[u8] byte slices that are not necessarily valid UTF-8."],[3,"is_utf8","","Determines if a vector of bytes contains valid UTF-8."],[3,"is_utf16","","Determines if a vector of `u16` contains valid UTF-16"],[1,"Utf16Items","","An iterator that decodes UTF-16 encoded codepoints from a vector\nof `u16`s."],[2,"Utf16Item","","The possibilities for values decoded from a `u16` stream."],[12,"ScalarValue","","A valid codepoint.",128],[12,"LoneSurrogate","","An invalid surrogate without its pair.",128],[3,"utf16_items","","Create an iterator over the UTF-16 encoded codepoints in `v`,\nreturning invalid surrogates as `LoneSurrogate`s."],[3,"truncate_utf16_at_nul","","Return a slice of `v` ending at (and not including) the first NUL\n(0)."],[3,"utf8_char_width","","Given a first byte, determine how many bytes are in this UTF-8 character"],[1,"CharRange","","Struct that contains a `char` and the index of the first byte of\nthe next `char` in a string.  This can be used as a data structure\nfor iterating over the UTF-8 bytes of a string."],[11,"ch","","Current `char`",152],[11,"next","","Index of the first byte of the next `char`",152],[6,"Str","","Any string that can be represented as a slice"],[9,"as_slice","","Work with `self` as a slice.",153],[6,"StrSlice","","Methods for string slices"],[9,"contains","","Returns true if one string contains another",154],[9,"contains_char","","Returns true if a string contains a char.",154],[9,"chars","","An iterator over the characters of `self`. Note, this iterates\nover unicode code-points, not unicode graphemes.",154],[9,"bytes","","An iterator over the bytes of `self`",154],[9,"char_indices","","An iterator over the characters of `self` and their byte offsets.",154],[9,"split","","An iterator over substrings of `self`, separated by characters\nmatched by `sep`.",154],[9,"splitn","","An iterator over substrings of `self`, separated by characters\nmatched by `sep`, restricted to splitting at most `count`\ntimes.",154],[9,"split_terminator","","An iterator over substrings of `self`, separated by characters\nmatched by `sep`.",154],[9,"rsplitn","","An iterator over substrings of `self`, separated by characters\nmatched by `sep`, starting from the end of the string.\nRestricted to splitting at most `count` times.",154],[9,"match_indices","","An iterator over the start and end indices of the disjoint\nmatches of `sep` within `self`.",154],[9,"split_str","","An iterator over the substrings of `self` separated by `sep`.",154],[9,"lines","","An iterator over the lines of a string (subsequences separated\nby `\\n`). This does not include the empty string after a\ntrailing `\\n`.",154],[9,"lines_any","","An iterator over the lines of a string, separated by either\n`\\n` or `\\r\\n`. As with `.lines()`, this does not include an\nempty trailing line.",154],[9,"char_len","","Returns the number of Unicode code points (`char`) that a\nstring holds.",154],[9,"slice","","Returns a slice of the given string from the byte range\n[`begin`..`end`).",154],[9,"slice_from","","Returns a slice of the string from `begin` to its end.",154],[9,"slice_to","","Returns a slice of the string from the beginning to byte\n`end`.",154],[9,"slice_chars","","Returns a slice of the string from the character range\n[`begin`..`end`).",154],[9,"starts_with","","Returns true if `needle` is a prefix of the string.",154],[9,"ends_with","","Returns true if `needle` is a suffix of the string.",154],[9,"trim_chars","","Returns a string with characters that match `to_trim` removed.",154],[9,"trim_left_chars","","Returns a string with leading `chars_to_trim` removed.",154],[9,"trim_right_chars","","Returns a string with trailing `chars_to_trim` removed.",154],[9,"is_char_boundary","","Check that `index`-th byte lies at the start and/or end of a\nUTF-8 code point sequence.",154],[9,"char_range_at","","Pluck a character out of a string and return the index of the next\ncharacter.",154],[9,"char_range_at_reverse","","Given a byte position and a str, return the previous char and its position.",154],[9,"char_at","","Plucks the character starting at the `i`th byte of a string.",154],[9,"char_at_reverse","","Plucks the character ending at the `i`th byte of a string.",154],[9,"as_bytes","","Work with the byte buffer of a string as a byte slice.",154],[9,"find","","Returns the byte index of the first character of `self` that\nmatches `search`.",154],[9,"rfind","","Returns the byte index of the last character of `self` that\nmatches `search`.",154],[9,"find_str","","Returns the byte index of the first matching substring",154],[9,"slice_shift_char","","Retrieves the first character from a string slice and returns\nit. This does not allocate a new string; instead, it returns a\nslice that point one character beyond the character that was\nshifted. If the string does not contain any characters,\na tuple of None and an empty string is returned instead.",154],[9,"subslice_offset","","Returns the byte offset of an inner slice relative to an enclosing outer slice.",154],[9,"as_ptr","","Return an unsafe pointer to the strings buffer.",154],[9,"utf16_units","","Return an iterator of `u16` over the string encoded as UTF-16.",154],[6,"UnicodeStrSlice","","Methods for Unicode string slices"],[9,"graphemes","","Returns an iterator over the\n[grapheme clusters](http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries)\nof the string.",155],[9,"grapheme_indices","","Returns an iterator over the grapheme clusters of self and their byte offsets.\nSee `graphemes()` method for more information.",155],[9,"words","","An iterator over the words of a string (subsequences separated\nby any sequence of whitespace). Sequences of whitespace are\ncollapsed, so empty \"words\" are not included.",155],[9,"is_whitespace","","Returns true if the string contains only whitespace.",155],[9,"is_alphanumeric","","Returns true if the string contains only alphanumeric code\npoints.",155],[9,"width","","Returns a string's displayed width in columns, treating control\ncharacters as zero-width.",155],[9,"trim","","Returns a string with leading and trailing whitespace removed.",155],[9,"trim_left","","Returns a string with leading whitespace removed.",155],[9,"trim_right","","Returns a string with trailing whitespace removed.",155],[10,"clone","unicode::tables::grapheme","",156],[10,"clone_from","","",156],[10,"clone","unicode::u_str","",157],[10,"clone_from","","",157],[10,"next","","",157],[10,"size_hint","","",157],[10,"size_hint","","",157],[10,"chain","","",157],[10,"zip","","",157],[10,"map","","",157],[10,"filter","","",157],[10,"filter_map","","",157],[10,"enumerate","","",157],[10,"peekable","","",157],[10,"skip_while","","",157],[10,"take_while","","",157],[10,"skip","","",157],[10,"take","","",157],[10,"scan","","",157],[10,"flat_map","","",157],[10,"fuse","","",157],[10,"inspect","","",157],[10,"by_ref","","",157],[10,"advance","","",157],[10,"collect","","",157],[10,"nth","","",157],[10,"last","","",157],[10,"fold","","",157],[10,"count","","",157],[10,"all","","",157],[10,"any","","",157],[10,"find","","",157],[10,"position","","",157],[10,"max_by","","",157],[10,"min_by","","",157],[10,"next_back","","",157],[10,"rev","","",157],[10,"clone","","",158],[10,"clone_from","","",158],[10,"assert_receiver_is_total_eq","","",159],[10,"eq","","",159],[10,"ne","","",159],[10,"ne","","",159],[10,"size_hint","","",158],[10,"next","","",158],[10,"size_hint","","",158],[10,"chain","","",158],[10,"zip","","",158],[10,"map","","",158],[10,"filter","","",158],[10,"filter_map","","",158],[10,"enumerate","","",158],[10,"peekable","","",158],[10,"skip_while","","",158],[10,"take_while","","",158],[10,"skip","","",158],[10,"take","","",158],[10,"scan","","",158],[10,"flat_map","","",158],[10,"fuse","","",158],[10,"inspect","","",158],[10,"by_ref","","",158],[10,"advance","","",158],[10,"collect","","",158],[10,"nth","","",158],[10,"last","","",158],[10,"fold","","",158],[10,"count","","",158],[10,"all","","",158],[10,"any","","",158],[10,"find","","",158],[10,"position","","",158],[10,"max_by","","",158],[10,"min_by","","",158],[10,"next_back","","",158],[10,"rev","","",158],[4,"Words","collections::str",""],[1,"Graphemes","","External iterator for a string's\n[grapheme clusters](http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries)."],[1,"GraphemeIndices","","External iterator for grapheme clusters and byte offsets."],[16,"str","","Unicode string manipulation (`str` type)"],[0,"string","collections","An owned, growable string that enforces that its contents are valid UTF-8."],[1,"String","collections::string","A growable string stored as a UTF-8 encoded buffer."],[0,"raw","","Unsafe operations"],[3,"from_parts","collections::string::raw","Creates a new `String` from length, capacity, and a pointer."],[3,"from_buf_len","","Create `String` from a *u8 buffer of the given length"],[3,"from_buf","","Create a `String` from a null-terminated *u8 buffer"],[3,"from_utf8","","Converts a vector of bytes to a new `String` without checking if\nit contains valid UTF-8. This is unsafe because it assumes that\nthe utf-8-ness of the vector has already been validated."],[10,"cmp","collections::string","",160],[10,"partial_cmp","","",160],[10,"lt","","",160],[10,"le","","",160],[10,"gt","","",160],[10,"ge","","",160],[10,"eq","","",160],[10,"ne","","",160],[10,"clone","","",160],[10,"new","","Creates a new string buffer initialized with the empty string.",160],[10,"with_capacity","","Creates a new string buffer with the given capacity.\nThe string will be able to hold exactly `capacity` bytes without\nreallocating. If `capacity` is 0, the string will not allocate.",160],[10,"from_str","","Creates a new string buffer from the given string.",160],[10,"from_raw_parts","","Deprecated. Replaced by `string::raw::from_parts`",160],[10,"from_owned_str","","Deprecated.",160],[10,"from_utf8","","Returns the vector as a string buffer, if possible, taking care not to\ncopy it.",160],[10,"from_utf8_lossy","","Converts a vector of bytes to a new utf-8 string.\nAny invalid utf-8 sequences are replaced with U+FFFD REPLACEMENT CHARACTER.",160],[10,"from_utf16","","Decode a UTF-16 encoded vector `v` into a `String`, returning `None`\nif `v` contains any invalid data.",160],[10,"from_utf16_lossy","","Decode a UTF-16 encoded vector `v` into a string, replacing\ninvalid data with the replacement character (U+FFFD).",160],[10,"from_chars","","Convert a vector of chars to a string.",160],[10,"into_bytes","","Return the underlying byte buffer, encoded as UTF-8.",160],[10,"append","","Pushes the given string onto this buffer; then, returns `self` so that it can be used\nagain.",160],[10,"from_char","","Creates a string buffer by repeating a character `length` times.",160],[10,"from_byte","","Convert a byte to a UTF-8 string.",160],[10,"push_str","","Pushes the given string onto this string buffer.",160],[10,"grow","","Push `ch` onto the given string `count` times.",160],[10,"byte_capacity","","Returns the number of bytes that this string buffer can hold without reallocating.",160],[10,"reserve_additional","","Reserves capacity for at least `extra` additional bytes in this string buffer.",160],[10,"reserve","","Reserves capacity for at least `capacity` bytes in this string buffer.",160],[10,"reserve_exact","","Reserves capacity for exactly `capacity` bytes in this string buffer.",160],[10,"shrink_to_fit","","Shrinks the capacity of this string buffer to match its length.",160],[10,"push_char","","Adds the given character to the end of the string.",160],[10,"push_bytes","","Pushes the given bytes onto this string buffer.\nThis is unsafe because it does not check\nto ensure that the resulting string will be valid UTF-8.",160],[10,"as_bytes","","Works with the underlying buffer as a byte slice.",160],[10,"as_mut_bytes","","Works with the underlying buffer as a mutable byte slice.",160],[10,"truncate","","Shorten a string to the specified length.",160],[10,"push_byte","","Appends a byte to this string buffer.",160],[10,"pop_byte","","Removes the last byte from the string buffer and returns it.\nReturns `None` if this string buffer is empty.",160],[10,"pop_char","","Removes the last character from the string buffer and returns it.\nReturns `None` if this string buffer is empty.",160],[10,"shift_byte","","Removes the first byte from the string buffer and returns it.\nReturns `None` if this string buffer is empty.",160],[10,"shift_char","","Removes the first character from the string buffer and returns it.\nReturns `None` if this string buffer is empty.",160],[10,"as_mut_vec","","Views the string buffer as a mutable sequence of bytes.",160],[10,"len","","",160],[10,"clear","","",160],[10,"from_iter","","",160],[10,"extend","","",160],[10,"as_slice","","",160],[10,"into_string","","",160],[10,"default","","",160],[10,"fmt","","",160],[10,"hash","","",160],[10,"equiv","","",160],[10,"add","","",160],[0,"vec","collections","An owned, growable vector."],[1,"Vec","collections::vec","An owned, growable vector."],[1,"MoveItems","","An iterator that moves out of a vector."],[3,"unzip","","Convert an iterator of pairs into a pair of vectors."],[0,"raw","","Unsafe operations"],[3,"from_buf","collections::vec::raw","Constructs a vector from an unsafe pointer to a buffer."],[10,"new","collections::vec","Constructs a new, empty `Vec`.",161],[10,"with_capacity","","Constructs a new, empty `Vec` with the specified capacity.",161],[10,"from_fn","","Creates and initializes a `Vec`.",161],[10,"from_raw_parts","","Create a `Vec<T>` directly from the raw constituents.",161],[10,"partition","","Consumes the `Vec`, partitioning it based on a predicate.",161],[10,"append","","Iterates over the `second` vector, copying each element and appending it to\nthe `first`. Afterwards, the `first` is then returned for use again.",161],[10,"from_slice","","Constructs a `Vec` by cloning elements of a slice.",161],[10,"from_elem","","Constructs a `Vec` with copies of a value.",161],[10,"push_all","","Appends all elements in a slice to the `Vec`.",161],[10,"grow","","Grows the `Vec` in-place.",161],[10,"grow_set","","Sets the value of a vector element at a given index, growing the vector\nas needed.",161],[10,"partitioned","","Partitions a vector based on a predicate.",161],[10,"clone","","",161],[10,"clone_from","","",161],[10,"index","","",161],[10,"from_iter","","",161],[10,"extend","","",161],[10,"eq","","",161],[10,"partial_cmp","","",161],[10,"equiv","","",161],[10,"cmp","","",161],[10,"len","","",161],[10,"to_vec","","",161],[10,"into_vec","","",161],[10,"capacity","","Returns the number of elements the vector can hold without\nreallocating.",161],[10,"reserve_additional","","Reserves capacity for at least `n` additional elements in the given\nvector.",161],[10,"reserve","","Reserves capacity for at least `n` elements in the given vector.",161],[10,"reserve_exact","","Reserves capacity for exactly `capacity` elements in the given vector.",161],[10,"shrink_to_fit","","Shrink the capacity of the vector as much as possible",161],[10,"append_one","","Appends one element to the vector provided. The vector itself is then\nreturned for use again.",161],[10,"truncate","","Shorten a vector, dropping excess elements.",161],[10,"as_mut_slice","","Work with `self` as a mutable slice.",161],[10,"move_iter","","Creates a consuming iterator, that is, one that moves each\nvalue out of the vector (from start to end). The vector cannot\nbe used after calling this.",161],[10,"set_len","","Sets the length of a vector.",161],[10,"get","","Returns a reference to the value at index `index`.",161],[10,"get_mut","","Returns a mutable reference to the value at index `index`.",161],[10,"iter","","Returns an iterator over references to the elements of the vector in\norder.",161],[10,"mut_iter","","Returns an iterator over mutable references to the elements of the\nvector in order.",161],[10,"sort_by","","Sort the vector, in place, using `compare` to compare elements.",161],[10,"slice","","Returns a slice of self spanning the interval [`start`, `end`).",161],[10,"tail","","Returns a slice containing all but the first element of the vector.",161],[10,"tailn","","Returns all but the first `n' elements of a vector.",161],[10,"last","","Returns a reference to the last element of a vector, or `None` if it is\nempty.",161],[10,"mut_last","","Returns a mutable reference to the last element of a vector, or `None`\nif it is empty.",161],[10,"swap_remove","","Remove an element from anywhere in the vector and return it, replacing\nit with the last element. This does not preserve ordering, but is O(1).",161],[10,"unshift","","Prepend an element to the vector.",161],[10,"shift","","Removes the first element from a vector and returns it, or `None` if\nthe vector is empty.",161],[10,"insert","","Insert an element at position `index` within the vector, shifting all\nelements after position i one position to the right.",161],[10,"remove","","Remove and return the element at position `index` within the vector,\nshifting all elements after position `index` one position to the left.\nReturns `None` if `i` is out of bounds.",161],[10,"push_all_move","","Takes ownership of the vector `other`, moving all elements into\nthe current vector. This does not copy any elements, and it is\nillegal to use the `other` vector after calling this method\n(because it is moved here).",161],[10,"mut_slice","","Returns a mutable slice of `self` between `start` and `end`.",161],[10,"mut_slice_from","","Returns a mutable slice of self from `start` to the end of the vec.",161],[10,"mut_slice_to","","Returns a mutable slice of self from the start of the vec to `end`.",161],[10,"mut_split_at","","Returns a pair of mutable slices that divides the vec at an index.",161],[10,"reverse","","Reverse the order of elements in a vector, in place.",161],[10,"slice_from","","Returns a slice of `self` from `start` to the end of the vec.",161],[10,"slice_to","","Returns a slice of self from the start of the vec to `end`.",161],[10,"init","","Returns a slice containing all but the last element of the vector.",161],[10,"as_ptr","","Returns an unsafe pointer to the vector's buffer.",161],[10,"as_mut_ptr","","Returns a mutable unsafe pointer to the vector's buffer.",161],[10,"retain","","Retains only the elements specified by the predicate.",161],[10,"grow_fn","","Expands a vector in place, initializing the new elements to the result of a function.",161],[10,"sort","","Sorts the vector in place.",161],[10,"clear","","",161],[10,"contains","","Return true if a vector contains an element with the given value",161],[10,"dedup","","Remove consecutive repeated elements in the vector.",161],[10,"as_slice","","Work with `self` as a slice.",161],[10,"add","","",161],[10,"drop","","",161],[10,"default","","",161],[10,"fmt","","",161],[10,"push","","Append an element to the back of a collection.",161],[10,"pop","","",161],[10,"next","","",162],[10,"size_hint","","",162],[10,"next_back","","",162],[10,"drop","","",162],[0,"hash","collections","Generic hashing support."],[0,"sip","collections::hash","Implementation of SipHash 2-4"],[1,"SipState","collections::hash::sip","`SipState` computes a SipHash 2-4 hash over a stream of bytes."],[1,"SipHasher","","`SipHasher` computes the SipHash algorithm from a stream of bytes."],[3,"hash","","Hash a value using the SipHash algorithm."],[3,"hash_with_keys","","Hash a value with the SipHash algorithm with the provided keys."],[10,"new","","Create a `SipState` that is keyed off the provided keys.",163],[10,"new_with_keys","","Create a `SipState` that is keyed off the provided keys.",163],[10,"reset","","Reset the state back to it's initial state.",163],[10,"result","","Return the computed hash.",163],[10,"write","","",163],[10,"clone","","",163],[10,"default","","",163],[10,"clone","","",164],[10,"new","","Create a `Sip`.",164],[10,"new_with_keys","","Create a `Sip` that is keyed off the provided keys.",164],[10,"hash","","",164],[10,"default","","",164],[6,"Hash","collections::hash","A trait that represents a hashable type. The `S` type parameter is an\nabstract hash state that is used by the `Hash` to compute the hash.\nIt defaults to `std::hash::sip::SipState`."],[9,"hash","","Compute a hash of the value.",165],[6,"Hasher","","A trait that computes a hash for a value. The main users of this trait are\ncontainers like `HashMap`, which need a generic way hash multiple types."],[9,"hash","","Compute a hash of the value.",166],[6,"Writer","",""],[9,"write","","",167],[10,"hash","collections::vec","",161],[10,"hash","alloc::boxed","",168],[10,"hash","alloc::rc","",169],[10,"hash","core::option","",96],[10,"hash","core::intrinsics","",48],[10,"hash","core::result","",98],[6,"Mutable","collections","A trait to represent mutable containers"],[9,"clear","","Clear the container, removing all values.",170],[6,"Map","","A map is a key-value store where values may be looked up by their keys. This\ntrait provides basic operations to operate on these stores."],[9,"find","","Return a reference to the value corresponding to the key.",171],[10,"contains_key","","Return true if the map contains a value for the specified key.",171],[6,"MutableMap","","This trait provides basic operations to modify the contents of a map."],[10,"insert","","Insert a key-value pair into the map. An existing value for a\nkey is replaced by the new value. Return true if the key did\nnot already exist in the map.",172],[10,"remove","","Remove a key-value pair from the map. Return true if the key\nwas present in the map, otherwise false.",172],[9,"swap","","Insert a key-value pair from the map. If the key already had a value\npresent in the map, that value is returned. Otherwise None is returned.",172],[9,"pop","","Removes a key from the map, returning the value at the key if the key\nwas previously in the map.",172],[9,"find_mut","","Return a mutable reference to the value corresponding to the key.",172],[6,"Set","","A set is a group of objects which are each distinct from one another. This\ntrait represents actions which can be performed on sets to iterate over\nthem."],[9,"contains","","Return true if the set contains a value.",173],[9,"is_disjoint","","Return true if the set has no elements in common with `other`.\nThis is equivalent to checking for an empty intersection.",173],[9,"is_subset","","Return true if the set is a subset of another.",173],[10,"is_superset","","Return true if the set is a superset of another.",173],[6,"MutableSet","","This trait represents actions which can be performed on sets to mutate\nthem."],[9,"insert","","Add a value to the set. Return true if the value was not already\npresent in the set.",174],[9,"remove","","Remove a value from the set. Return true if the value was\npresent in the set.",174],[6,"MutableSeq","",""],[9,"push","","Append an element to the back of a collection.",175],[9,"pop","","Remove the last element from a collection and return it, or `None` if it is\nempty.",175],[6,"Deque","","A double-ended sequence that allows querying, insertion and deletion at both\nends."],[9,"front","","Provide a reference to the front element, or `None` if the sequence is\nempty.",176],[9,"front_mut","","Provide a mutable reference to the front element, or `None` if the\nsequence is empty.",176],[9,"back","","Provide a reference to the back element, or `None` if the sequence is\nempty.",176],[9,"back_mut","","Provide a mutable reference to the back element, or `None` if the sequence\nis empty.",176],[9,"push_front","","Insert an element first in the sequence.",176],[10,"push_back","","Insert an element last in the sequence.",176],[10,"pop_back","","Remove the last element and return it, or `None` if the sequence is empty.",176],[9,"pop_front","","Remove the first element and return it, or `None` if the sequence is empty.",176],[6,"Collection","","A trait to represent the abstract idea of a container. The only concrete\nknowledge known is the number of elements contained within."],[9,"len","","Return the number of elements in the container",177],[9,"is_empty","","Return true if the container contains no elements",177],[16,"slice","",""],[16,"str","",""],[10,"concat","collections::vec","",161],[10,"connect","","",161],[10,"into_maybe_owned","collections::string","",160]],"paths":[[1,"Bitv"],[1,"Bits"],[1,"BitvSet"],[1,"BitPositions"],[1,"TwoBitPositions"],[1,"BTree"],[6,"ListInsertion"],[1,"Items"],[1,"MoveItems"],[1,"DList"],[1,"MutItems"],[6,"CLike"],[1,"EnumSet"],[1,"Items"],[1,"PriorityQueue"],[1,"Items"],[1,"RingBuf"],[1,"Items"],[1,"MutItems"],[1,"SmallIntMap"],[1,"Entries"],[1,"MutEntries"],[1,"TreeMap"],[1,"Entries"],[1,"RevEntries"],[1,"MutEntries"],[1,"RevMutEntries"],[1,"MoveEntries"],[1,"SetItems"],[1,"RevSetItems"],[1,"TreeSet"],[1,"DifferenceItems"],[1,"SymDifferenceItems"],[1,"IntersectionItems"],[1,"UnionItems"],[1,"TrieMap"],[1,"TrieSet"],[1,"Entries"],[1,"MutEntries"],[1,"SetItems"],[6,"VectorVector"],[6,"CloneableVector"],[6,"ImmutableCloneableVector"],[6,"MutableVectorAllocating"],[6,"MutableOrdVector"],[1,"ElementSwaps"],[1,"Permutations"],[2,"FPCategory"],[1,"TypeId"],[1,"CovariantType"],[1,"ContravariantType"],[1,"InvariantType"],[1,"CovariantLifetime"],[1,"ContravariantLifetime"],[1,"InvariantLifetime"],[1,"NoSend"],[1,"NoCopy"],[1,"NoShare"],[1,"Managed"],[2,"Ordering"],[1,"AtomicBool"],[1,"AtomicInt"],[1,"AtomicUint"],[1,"AtomicPtr"],[1,"Cell"],[1,"RefCell"],[1,"Ref"],[1,"RefMut"],[1,"UnsafeCell"],[1,"Finallyalizer"],[1,"Enumerate"],[1,"Inspect"],[1,"Rev"],[1,"Map"],[1,"Zip"],[1,"ByRef"],[2,"MinMaxResult"],[1,"Cycle"],[1,"Chain"],[1,"Filter"],[1,"FilterMap"],[1,"Peekable"],[1,"SkipWhile"],[1,"TakeWhile"],[1,"Skip"],[1,"Take"],[1,"Scan"],[1,"FlatMap"],[1,"Fuse"],[1,"Unfold"],[1,"Counter"],[1,"Range"],[1,"RangeInclusive"],[1,"RangeStep"],[1,"RangeStepInclusive"],[1,"Repeat"],[2,"Option"],[1,"Item"],[2,"Result"],[1,"i8x16"],[1,"i16x8"],[1,"i32x4"],[1,"i64x2"],[1,"u8x16"],[1,"u16x8"],[1,"u32x4"],[1,"u64x2"],[1,"f32x4"],[1,"f64x2"],[1,"Items"],[1,"MutItems"],[1,"Splits"],[1,"MutSplits"],[1,"SplitsN"],[1,"Windows"],[1,"Chunks"],[1,"MutChunks"],[1,"Chars"],[1,"CharOffsets"],[1,"CharSplits"],[1,"CharSplitsN"],[1,"NaiveSearcher"],[1,"TwoWaySearcher"],[2,"Searcher"],[1,"MatchIndices"],[1,"StrSplits"],[1,"Utf16CodeUnits"],[1,"Utf16Items"],[2,"Utf16Item"],[1,"Binary"],[1,"Octal"],[1,"Decimal"],[1,"LowerHex"],[1,"UpperHex"],[1,"Radix"],[1,"RadixFmt"],[2,"Alignment"],[1,"Arguments"],[1,"Formatter"],[6,"Vector"],[6,"ImmutableVector"],[6,"ImmutableEqVector"],[6,"ImmutableOrdVector"],[6,"MutableVector"],[6,"MutableByteVector"],[6,"MutableCloneableVector"],[2,"MaybeOwned"],[6,"StrVector"],[6,"IntoMaybeOwned"],[6,"StrAllocating"],[1,"Decompositions"],[6,"CharEq"],[1,"CharRange"],[6,"Str"],[6,"StrSlice"],[6,"UnicodeStrSlice"],[2,"GraphemeCat"],[1,"GraphemeIndices"],[1,"Graphemes"],[2,"GraphemeState"],[1,"String"],[1,"Vec"],[1,"MoveItems"],[1,"SipState"],[1,"SipHasher"],[6,"Hash"],[6,"Hasher"],[6,"Writer"],[1,"Box"],[1,"Rc"],[6,"Mutable"],[6,"Map"],[6,"MutableMap"],[6,"Set"],[6,"MutableSet"],[6,"MutableSeq"],[6,"Deque"],[6,"Collection"]]};

searchIndex['getopts'] = {"items":[[0,"","getopts","Simple getopt alternative."],[1,"Opt","","A description of a possible option."],[11,"name","","Name of the option",0],[11,"hasarg","","Whether it has an argument",0],[11,"occur","","How often it can occur",0],[11,"aliases","","Which options it aliases",0],[1,"OptGroup","","One group of options, e.g., both -h and --help, along with\ntheir shared description and properties."],[11,"short_name","","Short Name of the `OptGroup`",1],[11,"long_name","","Long Name of the `OptGroup`",1],[11,"hint","","Hint",1],[11,"desc","","Description",1],[11,"hasarg","","Whether it has an argument",1],[11,"occur","","How often it can occur",1],[1,"Matches","","The result of checking command line arguments. Contains a vector\nof matches and a vector of free strings."],[11,"free","","Free string fragments",2],[2,"Name","","Name of an option. Either a string or a single char."],[12,"Long","","A string representing the long name of an option.\nFor example: \"help\"",3],[12,"Short","","A char representing the short name of an option.\nFor example: 'h'",3],[2,"HasArg","","Describes whether an option has an argument."],[12,"Yes","","The option requires an argument.",4],[12,"No","","The option is just a flag, therefore no argument.",4],[12,"Maybe","","The option argument is optional and it could or not exist.",4],[2,"Occur","","Describes how often an option may occur."],[12,"Req","","The option occurs once.",5],[12,"Optional","","The option could or not occur.",5],[12,"Multi","","The option occurs once or multiple times.",5],[2,"Fail_","","The type returned when the command line does not conform to the\nexpected format. Use the `Show` implementation to output detailed\ninformation."],[12,"ArgumentMissing","","The option requires an argument but none was passed.",6],[12,"UnrecognizedOption","","The passed option is not declared among the possible options.",6],[12,"OptionMissing","","A required option is not present.",6],[12,"OptionDuplicated","","A single occurrence option is being used multiple times.",6],[12,"UnexpectedArgument","","There's an argument being passed to a non-argument option.",6],[2,"FailType","","The type of failure that occurred."],[12,"ArgumentMissing_","","",7],[12,"UnrecognizedOption_","","",7],[12,"OptionMissing_","","",7],[12,"OptionDuplicated_","","",7],[12,"UnexpectedArgument_","","",7],[3,"reqopt","","Create a long option that is required and takes an argument."],[3,"optopt","","Create a long option that is optional and takes an argument."],[3,"optflag","","Create a long option that is optional and does not take an argument."],[3,"optflagmulti","","Create a long option that can occur more than once and does not\ntake an argument."],[3,"optflagopt","","Create a long option that is optional and takes an optional argument."],[3,"optmulti","","Create a long option that is optional, takes an argument, and may occur\nmultiple times."],[3,"opt","","Create a generic option group, stating all parameters explicitly"],[3,"getopts","","Parse command line arguments according to the provided options."],[3,"usage","","Derive a usage message from a set of long options."],[3,"short_usage","","Derive a short one-line usage summary from a set of long options."],[4,"Result","","The result of parsing a command line with a set of options."],[10,"eq","","",3],[10,"ne","","",3],[10,"clone","","",3],[10,"eq","","",4],[10,"ne","","",4],[10,"clone","","",4],[10,"eq","","",5],[10,"ne","","",5],[10,"clone","","",5],[10,"eq","","",0],[10,"ne","","",0],[10,"clone","","",0],[10,"eq","","",1],[10,"ne","","",1],[10,"clone","","",1],[10,"eq","","",2],[10,"ne","","",2],[10,"clone","","",2],[10,"eq","","",6],[10,"ne","","",6],[10,"clone","","",6],[10,"eq","","",7],[10,"ne","","",7],[10,"long_to_short","","Translate OptGroup into Opt.\n(Both short and long names correspond to different Opts).",1],[10,"opt_present","","Returns true if an option was matched.",2],[10,"opt_count","","Returns the number of times an option was matched.",2],[10,"opts_present","","Returns true if any of several options were matched.",2],[10,"opts_str","","Returns the string argument supplied to one of several matching options or `None`.",2],[10,"opt_strs","","Returns a vector of the arguments provided to all matches of the given\noption.",2],[10,"opt_str","","Returns the string argument supplied to a matching option or `None`.",2],[10,"opt_default","","Returns the matching string, a default, or none.",2],[10,"to_err_msg","","Convert a `Fail_` enum into an error string.",6],[10,"fmt","","",6]],"paths":[[1,"Opt"],[1,"OptGroup"],[1,"Matches"],[2,"Name"],[2,"HasArg"],[2,"Occur"],[2,"Fail_"],[2,"FailType"]]};

searchIndex['sync'] = {"items":[[0,"","sync","Core concurrency-enabled mechanisms and primitives."],[1,"Mutex","","A wrapper type which provides synchronized access to the underlying data, of\ntype `T`. A mutex always provides exclusive access, and concurrent requests\nwill block while the mutex is already locked."],[1,"MutexGuard","","An guard which is created by locking a mutex. Through this guard the\nunderlying data can be accessed."],[11,"cond","","Inner condition variable connected to the locked mutex that this guard\nwas created from. This can be used for atomic-unlock-and-deschedule.",0],[1,"Condvar","","A condition variable, a mechanism for unlock-and-descheduling and\nsignaling, for use with the lock types."],[1,"Barrier","","A barrier enables multiple tasks to synchronize the beginning\nof some computation."],[1,"RWLock","","A dual-mode reader-writer lock. The data can be accessed mutably or\nimmutably, and immutably-accessing tasks may run concurrently."],[1,"RWLockReadGuard","","A guard which is created by locking an rwlock in read mode. Through this\nguard the underlying data can be accessed."],[1,"RWLockWriteGuard","","A guard which is created by locking an rwlock in write mode. Through this\nguard the underlying data can be accessed."],[11,"cond","","Inner condition variable that can be used to sleep on the write mode of\nthis rwlock.",1],[0,"atomics","","Atomic types"],[1,"AtomicOption","sync::atomics","An atomic, nullable unique pointer"],[10,"new","","Create a new `AtomicOption`",2],[10,"empty","","Create a new `AtomicOption` that doesn't contain a value",2],[10,"swap","","Store a value, returning the old value",2],[10,"take","","Remove the value, leaving the `AtomicOption` empty.",2],[10,"fill","","Replace an empty value with a non-empty value.",2],[10,"is_empty","","Returns `true` if the `AtomicOption` is empty.",2],[10,"drop","","",2],[10,"new","core::atomics","Create a new `AtomicBool`",3],[10,"load","","Load the value",3],[10,"store","","Store the value",3],[10,"swap","","Store a value, returning the old value",3],[10,"compare_and_swap","","If the current value is the same as expected, store a new value",3],[10,"fetch_and","","A logical \"and\" operation",3],[10,"fetch_nand","","A logical \"nand\" operation",3],[10,"fetch_or","","A logical \"or\" operation",3],[10,"fetch_xor","","A logical \"xor\" operation",3],[10,"fmt","core::num","",4],[10,"eq","","",4],[10,"ne","","",4],[10,"ne","","",4],[10,"fmt","core::intrinsics","",5],[10,"assert_receiver_is_total_eq","","",5],[10,"eq","","",5],[10,"ne","","",5],[10,"ne","","",5],[10,"of","","Returns the `TypeId` of the type this generic function has been instantiated with",5],[10,"hash","","",5],[10,"clone","core::kinds::marker","",6],[10,"clone_from","","",6],[10,"eq","","",6],[10,"ne","","",6],[10,"ne","","",6],[10,"clone","","",7],[10,"clone_from","","",7],[10,"eq","","",7],[10,"ne","","",7],[10,"ne","","",7],[10,"clone","","",8],[10,"clone_from","","",8],[10,"eq","","",8],[10,"ne","","",8],[10,"ne","","",8],[10,"clone","","",9],[10,"clone_from","","",9],[10,"eq","","",9],[10,"ne","","",9],[10,"ne","","",9],[10,"clone","","",10],[10,"clone_from","","",10],[10,"eq","","",10],[10,"ne","","",10],[10,"ne","","",10],[10,"clone","","",11],[10,"clone_from","","",11],[10,"eq","","",11],[10,"ne","","",11],[10,"ne","","",11],[10,"clone","","",12],[10,"clone_from","","",12],[10,"eq","","",12],[10,"ne","","",12],[10,"ne","","",12],[10,"clone","","",13],[10,"clone_from","","",13],[10,"eq","","",13],[10,"ne","","",13],[10,"ne","","",13],[10,"clone","","",14],[10,"clone_from","","",14],[10,"eq","","",14],[10,"ne","","",14],[10,"ne","","",14],[10,"clone","","",15],[10,"clone_from","","",15],[10,"eq","","",15],[10,"ne","","",15],[10,"ne","","",15],[10,"fmt","core::cmp","",16],[10,"eq","","",16],[10,"ne","","",16],[10,"ne","","",16],[10,"clone","","",16],[10,"clone_from","","",16],[10,"assert_receiver_is_total_eq","","",16],[10,"cmp","","",16],[10,"partial_cmp","","",16],[10,"lt","","",16],[10,"le","","",16],[10,"gt","","",16],[10,"ge","","",16],[10,"new","core::atomics","Create a new `AtomicInt`",17],[10,"load","","Load the value",17],[10,"store","","Store the value",17],[10,"swap","","Store a value, returning the old value",17],[10,"compare_and_swap","","If the current value is the same as expected, store a new value",17],[10,"fetch_add","","Add to the current value, returning the previous",17],[10,"fetch_sub","","Subtract from the current value, returning the previous",17],[10,"fetch_and","","Bitwise and with the current value, returning the previous",17],[10,"fetch_or","","Bitwise or with the current value, returning the previous",17],[10,"fetch_xor","","Bitwise xor with the current value, returning the previous",17],[10,"new","","Create a new `AtomicUint`",18],[10,"load","","Load the value",18],[10,"store","","Store the value",18],[10,"swap","","Store a value, returning the old value",18],[10,"compare_and_swap","","If the current value is the same as expected, store a new value",18],[10,"fetch_add","","Add to the current value, returning the previous",18],[10,"fetch_sub","","Subtract from the current value, returning the previous",18],[10,"fetch_and","","Bitwise and with the current value, returning the previous",18],[10,"fetch_or","","Bitwise or with the current value, returning the previous",18],[10,"fetch_xor","","Bitwise xor with the current value, returning the previous",18],[10,"new","","Create a new `AtomicPtr`",19],[10,"load","","Load the value",19],[10,"store","","Store the value",19],[10,"swap","","Store a value, returning the old value",19],[10,"compare_and_swap","","If the current value is the same as expected, store a new value",19],[10,"new","core::cell","Creates a new `Cell` containing the given value.",20],[10,"get","","Returns a copy of the contained value.",20],[10,"set","","Sets the contained value.",20],[10,"clone","","",20],[10,"clone_from","","",20],[10,"eq","","",20],[10,"ne","","",20],[10,"new","","Create a new `RefCell` containing `value`",21],[10,"unwrap","","Consumes the `RefCell`, returning the wrapped value.",21],[10,"try_borrow","","Attempts to immutably borrow the wrapped value.",21],[10,"borrow","","Immutably borrows the wrapped value.",21],[10,"try_borrow_mut","","Mutably borrows the wrapped value.",21],[10,"borrow_mut","","Mutably borrows the wrapped value.",21],[10,"clone","","",21],[10,"clone_from","","",21],[10,"eq","","",21],[10,"ne","","",21],[10,"drop","","",22],[10,"deref","","",22],[10,"drop","","",23],[10,"deref","","",23],[10,"deref_mut","","",23],[10,"new","","Construct a new instance of `UnsafeCell` which will wrapp the specified\nvalue.",24],[10,"get","","Gets a mutable pointer to the wrapped value.",24],[10,"unwrap","","Unwraps the value",24],[10,"drop","core::finally","",25],[10,"rposition","core::iter","",26],[10,"len","","",26],[10,"rposition","","",27],[10,"len","","",27],[10,"rposition","","",28],[10,"len","","",28],[10,"rposition","","",29],[10,"len","","",29],[10,"rposition","","",30],[10,"len","","",30],[10,"clone","","",28],[10,"clone_from","","",28],[10,"next","","",28],[10,"size_hint","","",28],[10,"size_hint","","",28],[10,"chain","","",28],[10,"zip","","",28],[10,"map","","",28],[10,"filter","","",28],[10,"filter_map","","",28],[10,"enumerate","","",28],[10,"peekable","","",28],[10,"skip_while","","",28],[10,"take_while","","",28],[10,"skip","","",28],[10,"take","","",28],[10,"scan","","",28],[10,"flat_map","","",28],[10,"fuse","","",28],[10,"inspect","","",28],[10,"by_ref","","",28],[10,"advance","","",28],[10,"collect","","",28],[10,"nth","","",28],[10,"last","","",28],[10,"fold","","",28],[10,"count","","",28],[10,"all","","",28],[10,"any","","",28],[10,"find","","",28],[10,"position","","",28],[10,"max_by","","",28],[10,"min_by","","",28],[10,"next_back","","",28],[10,"rev","","",28],[10,"indexable","","",28],[10,"idx","","",28],[10,"next","","",31],[10,"size_hint","","",31],[10,"size_hint","","",31],[10,"chain","","",31],[10,"zip","","",31],[10,"map","","",31],[10,"filter","","",31],[10,"filter_map","","",31],[10,"enumerate","","",31],[10,"peekable","","",31],[10,"skip_while","","",31],[10,"take_while","","",31],[10,"skip","","",31],[10,"take","","",31],[10,"scan","","",31],[10,"flat_map","","",31],[10,"fuse","","",31],[10,"inspect","","",31],[10,"by_ref","","",31],[10,"advance","","",31],[10,"collect","","",31],[10,"nth","","",31],[10,"last","","",31],[10,"fold","","",31],[10,"count","","",31],[10,"all","","",31],[10,"any","","",31],[10,"find","","",31],[10,"position","","",31],[10,"max_by","","",31],[10,"min_by","","",31],[10,"next_back","","",31],[10,"rev","","",31],[10,"fmt","","",32],[10,"eq","","",32],[10,"ne","","",32],[10,"ne","","",32],[10,"clone","","",32],[10,"clone_from","","",32],[10,"into_option","","`into_option` creates an `Option` of type `(T,T)`. The returned `Option` has variant\n`None` if and only if the `MinMaxResult` has variant `NoElements`. Otherwise variant\n`Some(x,y)` is returned where `x <= y`. If `MinMaxResult` has variant `OneElement(x)`,\nperforming this operation will make one clone of `x`.",32],[10,"clone","","",33],[10,"clone_from","","",33],[10,"next","","",33],[10,"size_hint","","",33],[10,"size_hint","","",33],[10,"chain","","",33],[10,"zip","","",33],[10,"map","","",33],[10,"filter","","",33],[10,"filter_map","","",33],[10,"enumerate","","",33],[10,"peekable","","",33],[10,"skip_while","","",33],[10,"take_while","","",33],[10,"skip","","",33],[10,"take","","",33],[10,"scan","","",33],[10,"flat_map","","",33],[10,"fuse","","",33],[10,"inspect","","",33],[10,"by_ref","","",33],[10,"advance","","",33],[10,"collect","","",33],[10,"nth","","",33],[10,"last","","",33],[10,"fold","","",33],[10,"count","","",33],[10,"all","","",33],[10,"any","","",33],[10,"find","","",33],[10,"position","","",33],[10,"max_by","","",33],[10,"min_by","","",33],[10,"indexable","","",33],[10,"idx","","",33],[10,"clone","","",34],[10,"clone_from","","",34],[10,"next","","",34],[10,"size_hint","","",34],[10,"size_hint","","",34],[10,"chain","","",34],[10,"zip","","",34],[10,"map","","",34],[10,"filter","","",34],[10,"filter_map","","",34],[10,"enumerate","","",34],[10,"peekable","","",34],[10,"skip_while","","",34],[10,"take_while","","",34],[10,"skip","","",34],[10,"take","","",34],[10,"scan","","",34],[10,"flat_map","","",34],[10,"fuse","","",34],[10,"inspect","","",34],[10,"by_ref","","",34],[10,"advance","","",34],[10,"collect","","",34],[10,"nth","","",34],[10,"last","","",34],[10,"fold","","",34],[10,"count","","",34],[10,"all","","",34],[10,"any","","",34],[10,"find","","",34],[10,"position","","",34],[10,"max_by","","",34],[10,"min_by","","",34],[10,"next_back","","",34],[10,"rev","","",34],[10,"indexable","","",34],[10,"idx","","",34],[10,"clone","","",30],[10,"clone_from","","",30],[10,"next","","",30],[10,"size_hint","","",30],[10,"size_hint","","",30],[10,"chain","","",30],[10,"zip","","",30],[10,"map","","",30],[10,"filter","","",30],[10,"filter_map","","",30],[10,"enumerate","","",30],[10,"peekable","","",30],[10,"skip_while","","",30],[10,"take_while","","",30],[10,"skip","","",30],[10,"take","","",30],[10,"scan","","",30],[10,"flat_map","","",30],[10,"fuse","","",30],[10,"inspect","","",30],[10,"by_ref","","",30],[10,"advance","","",30],[10,"collect","","",30],[10,"nth","","",30],[10,"last","","",30],[10,"fold","","",30],[10,"count","","",30],[10,"all","","",30],[10,"any","","",30],[10,"find","","",30],[10,"position","","",30],[10,"max_by","","",30],[10,"min_by","","",30],[10,"next_back","","",30],[10,"rev","","",30],[10,"indexable","","",30],[10,"idx","","",30],[10,"next","","",29],[10,"size_hint","","",29],[10,"size_hint","","",29],[10,"chain","","",29],[10,"zip","","",29],[10,"map","","",29],[10,"filter","","",29],[10,"filter_map","","",29],[10,"enumerate","","",29],[10,"peekable","","",29],[10,"skip_while","","",29],[10,"take_while","","",29],[10,"skip","","",29],[10,"take","","",29],[10,"scan","","",29],[10,"flat_map","","",29],[10,"fuse","","",29],[10,"inspect","","",29],[10,"by_ref","","",29],[10,"advance","","",29],[10,"collect","","",29],[10,"nth","","",29],[10,"last","","",29],[10,"fold","","",29],[10,"count","","",29],[10,"all","","",29],[10,"any","","",29],[10,"find","","",29],[10,"position","","",29],[10,"max_by","","",29],[10,"min_by","","",29],[10,"next_back","","",29],[10,"rev","","",29],[10,"indexable","","",29],[10,"idx","","",29],[10,"next","","",35],[10,"size_hint","","",35],[10,"size_hint","","",35],[10,"chain","","",35],[10,"zip","","",35],[10,"map","","",35],[10,"filter","","",35],[10,"filter_map","","",35],[10,"enumerate","","",35],[10,"peekable","","",35],[10,"skip_while","","",35],[10,"take_while","","",35],[10,"skip","","",35],[10,"take","","",35],[10,"scan","","",35],[10,"flat_map","","",35],[10,"fuse","","",35],[10,"inspect","","",35],[10,"by_ref","","",35],[10,"advance","","",35],[10,"collect","","",35],[10,"nth","","",35],[10,"last","","",35],[10,"fold","","",35],[10,"count","","",35],[10,"all","","",35],[10,"any","","",35],[10,"find","","",35],[10,"position","","",35],[10,"max_by","","",35],[10,"min_by","","",35],[10,"next_back","","",35],[10,"rev","","",35],[10,"next","","",36],[10,"size_hint","","",36],[10,"size_hint","","",36],[10,"chain","","",36],[10,"zip","","",36],[10,"map","","",36],[10,"filter","","",36],[10,"filter_map","","",36],[10,"enumerate","","",36],[10,"peekable","","",36],[10,"skip_while","","",36],[10,"take_while","","",36],[10,"skip","","",36],[10,"take","","",36],[10,"scan","","",36],[10,"flat_map","","",36],[10,"fuse","","",36],[10,"inspect","","",36],[10,"by_ref","","",36],[10,"advance","","",36],[10,"collect","","",36],[10,"nth","","",36],[10,"last","","",36],[10,"fold","","",36],[10,"count","","",36],[10,"all","","",36],[10,"any","","",36],[10,"find","","",36],[10,"position","","",36],[10,"max_by","","",36],[10,"min_by","","",36],[10,"next_back","","",36],[10,"rev","","",36],[10,"clone","","",26],[10,"clone_from","","",26],[10,"next","","",26],[10,"size_hint","","",26],[10,"size_hint","","",26],[10,"chain","","",26],[10,"zip","","",26],[10,"map","","",26],[10,"filter","","",26],[10,"filter_map","","",26],[10,"enumerate","","",26],[10,"peekable","","",26],[10,"skip_while","","",26],[10,"take_while","","",26],[10,"skip","","",26],[10,"take","","",26],[10,"scan","","",26],[10,"flat_map","","",26],[10,"fuse","","",26],[10,"inspect","","",26],[10,"by_ref","","",26],[10,"advance","","",26],[10,"collect","","",26],[10,"nth","","",26],[10,"last","","",26],[10,"fold","","",26],[10,"count","","",26],[10,"all","","",26],[10,"any","","",26],[10,"find","","",26],[10,"position","","",26],[10,"max_by","","",26],[10,"min_by","","",26],[10,"next_back","","",26],[10,"rev","","",26],[10,"indexable","","",26],[10,"idx","","",26],[10,"next","","",37],[10,"size_hint","","",37],[10,"size_hint","","",37],[10,"chain","","",37],[10,"zip","","",37],[10,"map","","",37],[10,"filter","","",37],[10,"filter_map","","",37],[10,"enumerate","","",37],[10,"peekable","","",37],[10,"skip_while","","",37],[10,"take_while","","",37],[10,"skip","","",37],[10,"take","","",37],[10,"scan","","",37],[10,"flat_map","","",37],[10,"fuse","","",37],[10,"inspect","","",37],[10,"by_ref","","",37],[10,"advance","","",37],[10,"collect","","",37],[10,"nth","","",37],[10,"last","","",37],[10,"fold","","",37],[10,"count","","",37],[10,"all","","",37],[10,"any","","",37],[10,"find","","",37],[10,"position","","",37],[10,"max_by","","",37],[10,"min_by","","",37],[10,"peek","","Return a reference to the next element of the iterator with out advancing it,\nor None if the iterator is exhausted.",37],[10,"is_empty","","Check whether peekable iterator is empty or not.",37],[10,"next","","",38],[10,"size_hint","","",38],[10,"size_hint","","",38],[10,"chain","","",38],[10,"zip","","",38],[10,"map","","",38],[10,"filter","","",38],[10,"filter_map","","",38],[10,"enumerate","","",38],[10,"peekable","","",38],[10,"skip_while","","",38],[10,"take_while","","",38],[10,"skip","","",38],[10,"take","","",38],[10,"scan","","",38],[10,"flat_map","","",38],[10,"fuse","","",38],[10,"inspect","","",38],[10,"by_ref","","",38],[10,"advance","","",38],[10,"collect","","",38],[10,"nth","","",38],[10,"last","","",38],[10,"fold","","",38],[10,"count","","",38],[10,"all","","",38],[10,"any","","",38],[10,"find","","",38],[10,"position","","",38],[10,"max_by","","",38],[10,"min_by","","",38],[10,"next","","",39],[10,"size_hint","","",39],[10,"size_hint","","",39],[10,"chain","","",39],[10,"zip","","",39],[10,"map","","",39],[10,"filter","","",39],[10,"filter_map","","",39],[10,"enumerate","","",39],[10,"peekable","","",39],[10,"skip_while","","",39],[10,"take_while","","",39],[10,"skip","","",39],[10,"take","","",39],[10,"scan","","",39],[10,"flat_map","","",39],[10,"fuse","","",39],[10,"inspect","","",39],[10,"by_ref","","",39],[10,"advance","","",39],[10,"collect","","",39],[10,"nth","","",39],[10,"last","","",39],[10,"fold","","",39],[10,"count","","",39],[10,"all","","",39],[10,"any","","",39],[10,"find","","",39],[10,"position","","",39],[10,"max_by","","",39],[10,"min_by","","",39],[10,"clone","","",40],[10,"clone_from","","",40],[10,"next","","",40],[10,"size_hint","","",40],[10,"size_hint","","",40],[10,"chain","","",40],[10,"zip","","",40],[10,"map","","",40],[10,"filter","","",40],[10,"filter_map","","",40],[10,"enumerate","","",40],[10,"peekable","","",40],[10,"skip_while","","",40],[10,"take_while","","",40],[10,"skip","","",40],[10,"take","","",40],[10,"scan","","",40],[10,"flat_map","","",40],[10,"fuse","","",40],[10,"inspect","","",40],[10,"by_ref","","",40],[10,"advance","","",40],[10,"collect","","",40],[10,"nth","","",40],[10,"last","","",40],[10,"fold","","",40],[10,"count","","",40],[10,"all","","",40],[10,"any","","",40],[10,"find","","",40],[10,"position","","",40],[10,"max_by","","",40],[10,"min_by","","",40],[10,"indexable","","",40],[10,"idx","","",40],[10,"clone","","",41],[10,"clone_from","","",41],[10,"next","","",41],[10,"size_hint","","",41],[10,"size_hint","","",41],[10,"chain","","",41],[10,"zip","","",41],[10,"map","","",41],[10,"filter","","",41],[10,"filter_map","","",41],[10,"enumerate","","",41],[10,"peekable","","",41],[10,"skip_while","","",41],[10,"take_while","","",41],[10,"skip","","",41],[10,"take","","",41],[10,"scan","","",41],[10,"flat_map","","",41],[10,"fuse","","",41],[10,"inspect","","",41],[10,"by_ref","","",41],[10,"advance","","",41],[10,"collect","","",41],[10,"nth","","",41],[10,"last","","",41],[10,"fold","","",41],[10,"count","","",41],[10,"all","","",41],[10,"any","","",41],[10,"find","","",41],[10,"position","","",41],[10,"max_by","","",41],[10,"min_by","","",41],[10,"indexable","","",41],[10,"idx","","",41],[10,"next","","",42],[10,"size_hint","","",42],[10,"size_hint","","",42],[10,"chain","","",42],[10,"zip","","",42],[10,"map","","",42],[10,"filter","","",42],[10,"filter_map","","",42],[10,"enumerate","","",42],[10,"peekable","","",42],[10,"skip_while","","",42],[10,"take_while","","",42],[10,"skip","","",42],[10,"take","","",42],[10,"scan","","",42],[10,"flat_map","","",42],[10,"fuse","","",42],[10,"inspect","","",42],[10,"by_ref","","",42],[10,"advance","","",42],[10,"collect","","",42],[10,"nth","","",42],[10,"last","","",42],[10,"fold","","",42],[10,"count","","",42],[10,"all","","",42],[10,"any","","",42],[10,"find","","",42],[10,"position","","",42],[10,"max_by","","",42],[10,"min_by","","",42],[10,"next","","",43],[10,"size_hint","","",43],[10,"size_hint","","",43],[10,"chain","","",43],[10,"zip","","",43],[10,"map","","",43],[10,"filter","","",43],[10,"filter_map","","",43],[10,"enumerate","","",43],[10,"peekable","","",43],[10,"skip_while","","",43],[10,"take_while","","",43],[10,"skip","","",43],[10,"take","","",43],[10,"scan","","",43],[10,"flat_map","","",43],[10,"fuse","","",43],[10,"inspect","","",43],[10,"by_ref","","",43],[10,"advance","","",43],[10,"collect","","",43],[10,"nth","","",43],[10,"last","","",43],[10,"fold","","",43],[10,"count","","",43],[10,"all","","",43],[10,"any","","",43],[10,"find","","",43],[10,"position","","",43],[10,"max_by","","",43],[10,"min_by","","",43],[10,"next_back","","",43],[10,"rev","","",43],[10,"clone","","",44],[10,"clone_from","","",44],[10,"next","","",44],[10,"size_hint","","",44],[10,"size_hint","","",44],[10,"chain","","",44],[10,"zip","","",44],[10,"map","","",44],[10,"filter","","",44],[10,"filter_map","","",44],[10,"enumerate","","",44],[10,"peekable","","",44],[10,"skip_while","","",44],[10,"take_while","","",44],[10,"skip","","",44],[10,"take","","",44],[10,"scan","","",44],[10,"flat_map","","",44],[10,"fuse","","",44],[10,"inspect","","",44],[10,"by_ref","","",44],[10,"advance","","",44],[10,"collect","","",44],[10,"nth","","",44],[10,"last","","",44],[10,"fold","","",44],[10,"count","","",44],[10,"all","","",44],[10,"any","","",44],[10,"find","","",44],[10,"position","","",44],[10,"max_by","","",44],[10,"min_by","","",44],[10,"next_back","","",44],[10,"rev","","",44],[10,"indexable","","",44],[10,"idx","","",44],[10,"reset_fuse","","Resets the fuse such that the next call to .next() or .next_back() will\ncall the underlying iterator again even if it previously returned None.",44],[10,"next","","",27],[10,"size_hint","","",27],[10,"size_hint","","",27],[10,"chain","","",27],[10,"zip","","",27],[10,"map","","",27],[10,"filter","","",27],[10,"filter_map","","",27],[10,"enumerate","","",27],[10,"peekable","","",27],[10,"skip_while","","",27],[10,"take_while","","",27],[10,"skip","","",27],[10,"take","","",27],[10,"scan","","",27],[10,"flat_map","","",27],[10,"fuse","","",27],[10,"inspect","","",27],[10,"by_ref","","",27],[10,"advance","","",27],[10,"collect","","",27],[10,"nth","","",27],[10,"last","","",27],[10,"fold","","",27],[10,"count","","",27],[10,"all","","",27],[10,"any","","",27],[10,"find","","",27],[10,"position","","",27],[10,"max_by","","",27],[10,"min_by","","",27],[10,"next_back","","",27],[10,"rev","","",27],[10,"indexable","","",27],[10,"idx","","",27],[10,"new","","Creates a new iterator with the specified closure as the \"iterator\nfunction\" and an initial state to eventually pass to the iterator",45],[10,"next","","",45],[10,"size_hint","","",45],[10,"size_hint","","",45],[10,"chain","","",45],[10,"zip","","",45],[10,"map","","",45],[10,"filter","","",45],[10,"filter_map","","",45],[10,"enumerate","","",45],[10,"peekable","","",45],[10,"skip_while","","",45],[10,"take_while","","",45],[10,"skip","","",45],[10,"take","","",45],[10,"scan","","",45],[10,"flat_map","","",45],[10,"fuse","","",45],[10,"inspect","","",45],[10,"by_ref","","",45],[10,"advance","","",45],[10,"collect","","",45],[10,"nth","","",45],[10,"last","","",45],[10,"fold","","",45],[10,"count","","",45],[10,"all","","",45],[10,"any","","",45],[10,"find","","",45],[10,"position","","",45],[10,"max_by","","",45],[10,"min_by","","",45],[10,"clone","","",46],[10,"clone_from","","",46],[10,"next","","",46],[10,"size_hint","","",46],[10,"size_hint","","",46],[10,"chain","","",46],[10,"zip","","",46],[10,"map","","",46],[10,"filter","","",46],[10,"filter_map","","",46],[10,"enumerate","","",46],[10,"peekable","","",46],[10,"skip_while","","",46],[10,"take_while","","",46],[10,"skip","","",46],[10,"take","","",46],[10,"scan","","",46],[10,"flat_map","","",46],[10,"fuse","","",46],[10,"inspect","","",46],[10,"by_ref","","",46],[10,"advance","","",46],[10,"collect","","",46],[10,"nth","","",46],[10,"last","","",46],[10,"fold","","",46],[10,"count","","",46],[10,"all","","",46],[10,"any","","",46],[10,"find","","",46],[10,"position","","",46],[10,"max_by","","",46],[10,"min_by","","",46],[10,"clone","","",47],[10,"clone_from","","",47],[10,"next","","",47],[10,"size_hint","","",47],[10,"size_hint","","",47],[10,"chain","","",47],[10,"zip","","",47],[10,"map","","",47],[10,"filter","","",47],[10,"filter_map","","",47],[10,"enumerate","","",47],[10,"peekable","","",47],[10,"skip_while","","",47],[10,"take_while","","",47],[10,"skip","","",47],[10,"take","","",47],[10,"scan","","",47],[10,"flat_map","","",47],[10,"fuse","","",47],[10,"inspect","","",47],[10,"by_ref","","",47],[10,"advance","","",47],[10,"collect","","",47],[10,"nth","","",47],[10,"last","","",47],[10,"fold","","",47],[10,"count","","",47],[10,"all","","",47],[10,"any","","",47],[10,"find","","",47],[10,"position","","",47],[10,"max_by","","",47],[10,"min_by","","",47],[10,"next_back","","",47],[10,"rev","","",47],[10,"clone","","",48],[10,"clone_from","","",48],[10,"next","","",48],[10,"size_hint","","",48],[10,"size_hint","","",48],[10,"chain","","",48],[10,"zip","","",48],[10,"map","","",48],[10,"filter","","",48],[10,"filter_map","","",48],[10,"enumerate","","",48],[10,"peekable","","",48],[10,"skip_while","","",48],[10,"take_while","","",48],[10,"skip","","",48],[10,"take","","",48],[10,"scan","","",48],[10,"flat_map","","",48],[10,"fuse","","",48],[10,"inspect","","",48],[10,"by_ref","","",48],[10,"advance","","",48],[10,"collect","","",48],[10,"nth","","",48],[10,"last","","",48],[10,"fold","","",48],[10,"count","","",48],[10,"all","","",48],[10,"any","","",48],[10,"find","","",48],[10,"position","","",48],[10,"max_by","","",48],[10,"min_by","","",48],[10,"next_back","","",48],[10,"rev","","",48],[10,"clone","","",49],[10,"clone_from","","",49],[10,"next","","",49],[10,"size_hint","","",49],[10,"chain","","",49],[10,"zip","","",49],[10,"map","","",49],[10,"filter","","",49],[10,"filter_map","","",49],[10,"enumerate","","",49],[10,"peekable","","",49],[10,"skip_while","","",49],[10,"take_while","","",49],[10,"skip","","",49],[10,"take","","",49],[10,"scan","","",49],[10,"flat_map","","",49],[10,"fuse","","",49],[10,"inspect","","",49],[10,"by_ref","","",49],[10,"advance","","",49],[10,"collect","","",49],[10,"nth","","",49],[10,"last","","",49],[10,"fold","","",49],[10,"count","","",49],[10,"all","","",49],[10,"any","","",49],[10,"find","","",49],[10,"position","","",49],[10,"max_by","","",49],[10,"min_by","","",49],[10,"clone","","",50],[10,"clone_from","","",50],[10,"next","","",50],[10,"size_hint","","",50],[10,"chain","","",50],[10,"zip","","",50],[10,"map","","",50],[10,"filter","","",50],[10,"filter_map","","",50],[10,"enumerate","","",50],[10,"peekable","","",50],[10,"skip_while","","",50],[10,"take_while","","",50],[10,"skip","","",50],[10,"take","","",50],[10,"scan","","",50],[10,"flat_map","","",50],[10,"fuse","","",50],[10,"inspect","","",50],[10,"by_ref","","",50],[10,"advance","","",50],[10,"collect","","",50],[10,"nth","","",50],[10,"last","","",50],[10,"fold","","",50],[10,"count","","",50],[10,"all","","",50],[10,"any","","",50],[10,"find","","",50],[10,"position","","",50],[10,"max_by","","",50],[10,"min_by","","",50],[10,"clone","","",51],[10,"clone_from","","",51],[10,"new","","Create a new `Repeat` that endlessly repeats the element `elt`.",51],[10,"next","","",51],[10,"size_hint","","",51],[10,"size_hint","","",51],[10,"chain","","",51],[10,"zip","","",51],[10,"map","","",51],[10,"filter","","",51],[10,"filter_map","","",51],[10,"enumerate","","",51],[10,"peekable","","",51],[10,"skip_while","","",51],[10,"take_while","","",51],[10,"skip","","",51],[10,"take","","",51],[10,"scan","","",51],[10,"flat_map","","",51],[10,"fuse","","",51],[10,"inspect","","",51],[10,"by_ref","","",51],[10,"advance","","",51],[10,"collect","","",51],[10,"nth","","",51],[10,"last","","",51],[10,"fold","","",51],[10,"count","","",51],[10,"all","","",51],[10,"any","","",51],[10,"find","","",51],[10,"position","","",51],[10,"max_by","","",51],[10,"min_by","","",51],[10,"next_back","","",51],[10,"rev","","",51],[10,"indexable","","",51],[10,"idx","","",51],[10,"fmt","core::option","",52],[10,"cmp","","",52],[10,"assert_receiver_is_total_eq","","",52],[10,"partial_cmp","","",52],[10,"lt","","",52],[10,"le","","",52],[10,"gt","","",52],[10,"ge","","",52],[10,"lt","","",52],[10,"le","","",52],[10,"gt","","",52],[10,"ge","","",52],[10,"eq","","",52],[10,"ne","","",52],[10,"ne","","",52],[10,"clone","","",52],[10,"clone_from","","",52],[10,"is_some","","Returns `true` if the option is a `Some` value",52],[10,"is_none","","Returns `true` if the option is a `None` value",52],[10,"as_ref","","Convert from `Option<T>` to `Option<&T>`",52],[10,"as_mut","","Convert from `Option<T>` to `Option<&mut T>`",52],[10,"as_mut_slice","","Convert from `Option<T>` to `&mut [T]` (without copying)",52],[10,"expect","","Unwraps an option, yielding the content of a `Some`",52],[10,"unwrap","","Moves a value out of an option type and returns it, consuming the `Option`.",52],[10,"unwrap_or","","Returns the contained value or a default.",52],[10,"unwrap_or_else","","Returns the contained value or computes it from a closure.",52],[10,"map","","Maps an `Option<T>` to `Option<U>` by applying a function to a contained value",52],[10,"map_or","","Applies a function to the contained value or returns a default.",52],[10,"mutate","","Applies a function to the contained value or does nothing.\nReturns true if the contained value was mutated.",52],[10,"mutate_or_set","","Applies a function to the contained value or sets it to a default.\nReturns true if the contained value was mutated, or false if set to the default.",52],[10,"iter","","Returns an iterator over the possibly contained value.",52],[10,"mut_iter","","Returns a mutable iterator over the possibly contained value.",52],[10,"move_iter","","Returns a consuming iterator over the possibly contained value.",52],[10,"and","","Returns `None` if the option is `None`, otherwise returns `optb`.",52],[10,"and_then","","Returns `None` if the option is `None`, otherwise calls `f` with the\nwrapped value and returns the result.",52],[10,"or","","Returns the option if it contains a value, otherwise returns `optb`.",52],[10,"or_else","","Returns the option if it contains a value, otherwise calls `f` and\nreturns the result.",52],[10,"take","","Takes the value out of the option, leaving a `None` in its place.",52],[10,"filtered","","Filters an optional value using a given function.",52],[10,"while_some","","Applies a function zero or more times until the result is `None`.",52],[10,"take_unwrap","","The option dance. Moves a value out of an option type and returns it,\nreplacing the original with `None`.",52],[10,"get_ref","","Gets an immutable reference to the value inside an option.",52],[10,"get_mut_ref","","Gets a mutable reference to the value inside an option.",52],[10,"unwrap_or_default","","Returns the contained value or a default",52],[10,"as_slice","","Convert from `Option<T>` to `&[T]` (without copying)",52],[10,"default","","",52],[10,"clone","","",53],[10,"clone_from","","",53],[10,"next","","",53],[10,"size_hint","","",53],[10,"size_hint","","",53],[10,"chain","","",53],[10,"zip","","",53],[10,"map","","",53],[10,"filter","","",53],[10,"filter_map","","",53],[10,"enumerate","","",53],[10,"peekable","","",53],[10,"skip_while","","",53],[10,"take_while","","",53],[10,"skip","","",53],[10,"take","","",53],[10,"scan","","",53],[10,"flat_map","","",53],[10,"fuse","","",53],[10,"inspect","","",53],[10,"by_ref","","",53],[10,"advance","","",53],[10,"collect","","",53],[10,"nth","","",53],[10,"last","","",53],[10,"fold","","",53],[10,"count","","",53],[10,"all","","",53],[10,"any","","",53],[10,"find","","",53],[10,"position","","",53],[10,"max_by","","",53],[10,"min_by","","",53],[10,"next_back","","",53],[10,"rev","","",53],[10,"rposition","","",53],[10,"len","","",53],[10,"fmt","core::result","",54],[10,"cmp","","",54],[10,"assert_receiver_is_total_eq","","",54],[10,"partial_cmp","","",54],[10,"lt","","",54],[10,"le","","",54],[10,"gt","","",54],[10,"ge","","",54],[10,"lt","","",54],[10,"le","","",54],[10,"gt","","",54],[10,"ge","","",54],[10,"eq","","",54],[10,"ne","","",54],[10,"ne","","",54],[10,"clone","","",54],[10,"clone_from","","",54],[10,"is_ok","","Returns true if the result is `Ok`",54],[10,"is_err","","Returns true if the result is `Err`",54],[10,"ok","","Convert from `Result<T, E>` to `Option<T>`",54],[10,"err","","Convert from `Result<T, E>` to `Option<E>`",54],[10,"as_ref","","Convert from `Result<T, E>` to `Result<&T, &E>`",54],[10,"as_mut","","Convert from `Result<T, E>` to `Result<&mut T, &mut E>`",54],[10,"map","","Maps a `Result<T, E>` to `Result<U, E>` by applying a function to an\ncontained `Ok` value, leaving an `Err` value untouched.",54],[10,"map_err","","Maps a `Result<T, E>` to `Result<T, F>` by applying a function to an\ncontained `Err` value, leaving an `Ok` value untouched.",54],[10,"and","","Returns `res` if the result is `Ok`, otherwise returns the `Err` value of `self`.",54],[10,"and_then","","Calls `op` if the result is `Ok`, otherwise returns the `Err` value of `self`.",54],[10,"or","","Returns `res` if the result is `Err`, otherwise returns the `Ok` value of `self`.",54],[10,"or_else","","Calls `op` if the result is `Err`, otherwise returns the `Ok` value of `self`.",54],[10,"unwrap_or","","Unwraps a result, yielding the content of an `Ok`.\nElse it returns `optb`.",54],[10,"unwrap_or_else","","Unwraps a result, yielding the content of an `Ok`.\nIf the value is an `Err` then it calls `op` with its value.",54],[10,"unwrap_or_handle","","Deprecated name for `unwrap_or_else()`.",54],[10,"unwrap","","Unwraps a result, yielding the content of an `Ok`.",54],[10,"unwrap_err","","Unwraps a result, yielding the content of an `Err`.",54],[10,"fmt","core::simd","",55],[10,"fmt","","",56],[10,"fmt","","",57],[10,"fmt","","",58],[10,"fmt","","",59],[10,"fmt","","",60],[10,"fmt","","",61],[10,"fmt","","",62],[10,"fmt","","",63],[10,"fmt","","",64],[10,"next","core::slice","",65],[10,"size_hint","","",65],[10,"size_hint","","",65],[10,"chain","","",65],[10,"zip","","",65],[10,"map","","",65],[10,"filter","","",65],[10,"filter_map","","",65],[10,"enumerate","","",65],[10,"peekable","","",65],[10,"skip_while","","",65],[10,"take_while","","",65],[10,"skip","","",65],[10,"take","","",65],[10,"scan","","",65],[10,"flat_map","","",65],[10,"fuse","","",65],[10,"inspect","","",65],[10,"by_ref","","",65],[10,"advance","","",65],[10,"collect","","",65],[10,"nth","","",65],[10,"last","","",65],[10,"fold","","",65],[10,"count","","",65],[10,"all","","",65],[10,"any","","",65],[10,"find","","",65],[10,"position","","",65],[10,"max_by","","",65],[10,"min_by","","",65],[10,"next_back","","",65],[10,"rev","","",65],[10,"rposition","","",65],[10,"len","","",65],[10,"clone","","",65],[10,"clone_from","","",65],[10,"indexable","","",65],[10,"idx","","",65],[10,"next","","",66],[10,"size_hint","","",66],[10,"size_hint","","",66],[10,"chain","","",66],[10,"zip","","",66],[10,"map","","",66],[10,"filter","","",66],[10,"filter_map","","",66],[10,"enumerate","","",66],[10,"peekable","","",66],[10,"skip_while","","",66],[10,"take_while","","",66],[10,"skip","","",66],[10,"take","","",66],[10,"scan","","",66],[10,"flat_map","","",66],[10,"fuse","","",66],[10,"inspect","","",66],[10,"by_ref","","",66],[10,"advance","","",66],[10,"collect","","",66],[10,"nth","","",66],[10,"last","","",66],[10,"fold","","",66],[10,"count","","",66],[10,"all","","",66],[10,"any","","",66],[10,"find","","",66],[10,"position","","",66],[10,"max_by","","",66],[10,"min_by","","",66],[10,"next_back","","",66],[10,"rev","","",66],[10,"rposition","","",66],[10,"len","","",66],[10,"next","","",67],[10,"size_hint","","",67],[10,"size_hint","","",67],[10,"chain","","",67],[10,"zip","","",67],[10,"map","","",67],[10,"filter","","",67],[10,"filter_map","","",67],[10,"enumerate","","",67],[10,"peekable","","",67],[10,"skip_while","","",67],[10,"take_while","","",67],[10,"skip","","",67],[10,"take","","",67],[10,"scan","","",67],[10,"flat_map","","",67],[10,"fuse","","",67],[10,"inspect","","",67],[10,"by_ref","","",67],[10,"advance","","",67],[10,"collect","","",67],[10,"nth","","",67],[10,"last","","",67],[10,"fold","","",67],[10,"count","","",67],[10,"all","","",67],[10,"any","","",67],[10,"find","","",67],[10,"position","","",67],[10,"max_by","","",67],[10,"min_by","","",67],[10,"next_back","","",67],[10,"rev","","",67],[10,"next","","",68],[10,"size_hint","","",68],[10,"size_hint","","",68],[10,"chain","","",68],[10,"zip","","",68],[10,"map","","",68],[10,"filter","","",68],[10,"filter_map","","",68],[10,"enumerate","","",68],[10,"peekable","","",68],[10,"skip_while","","",68],[10,"take_while","","",68],[10,"skip","","",68],[10,"take","","",68],[10,"scan","","",68],[10,"flat_map","","",68],[10,"fuse","","",68],[10,"inspect","","",68],[10,"by_ref","","",68],[10,"advance","","",68],[10,"collect","","",68],[10,"nth","","",68],[10,"last","","",68],[10,"fold","","",68],[10,"count","","",68],[10,"all","","",68],[10,"any","","",68],[10,"find","","",68],[10,"position","","",68],[10,"max_by","","",68],[10,"min_by","","",68],[10,"next_back","","",68],[10,"rev","","",68],[10,"next","","",69],[10,"size_hint","","",69],[10,"size_hint","","",69],[10,"chain","","",69],[10,"zip","","",69],[10,"map","","",69],[10,"filter","","",69],[10,"filter_map","","",69],[10,"enumerate","","",69],[10,"peekable","","",69],[10,"skip_while","","",69],[10,"take_while","","",69],[10,"skip","","",69],[10,"take","","",69],[10,"scan","","",69],[10,"flat_map","","",69],[10,"fuse","","",69],[10,"inspect","","",69],[10,"by_ref","","",69],[10,"advance","","",69],[10,"collect","","",69],[10,"nth","","",69],[10,"last","","",69],[10,"fold","","",69],[10,"count","","",69],[10,"all","","",69],[10,"any","","",69],[10,"find","","",69],[10,"position","","",69],[10,"max_by","","",69],[10,"min_by","","",69],[10,"clone","","",70],[10,"clone_from","","",70],[10,"next","","",70],[10,"size_hint","","",70],[10,"size_hint","","",70],[10,"chain","","",70],[10,"zip","","",70],[10,"map","","",70],[10,"filter","","",70],[10,"filter_map","","",70],[10,"enumerate","","",70],[10,"peekable","","",70],[10,"skip_while","","",70],[10,"take_while","","",70],[10,"skip","","",70],[10,"take","","",70],[10,"scan","","",70],[10,"flat_map","","",70],[10,"fuse","","",70],[10,"inspect","","",70],[10,"by_ref","","",70],[10,"advance","","",70],[10,"collect","","",70],[10,"nth","","",70],[10,"last","","",70],[10,"fold","","",70],[10,"count","","",70],[10,"all","","",70],[10,"any","","",70],[10,"find","","",70],[10,"position","","",70],[10,"max_by","","",70],[10,"min_by","","",70],[10,"clone","","",71],[10,"clone_from","","",71],[10,"next","","",71],[10,"size_hint","","",71],[10,"size_hint","","",71],[10,"chain","","",71],[10,"zip","","",71],[10,"map","","",71],[10,"filter","","",71],[10,"filter_map","","",71],[10,"enumerate","","",71],[10,"peekable","","",71],[10,"skip_while","","",71],[10,"take_while","","",71],[10,"skip","","",71],[10,"take","","",71],[10,"scan","","",71],[10,"flat_map","","",71],[10,"fuse","","",71],[10,"inspect","","",71],[10,"by_ref","","",71],[10,"advance","","",71],[10,"collect","","",71],[10,"nth","","",71],[10,"last","","",71],[10,"fold","","",71],[10,"count","","",71],[10,"all","","",71],[10,"any","","",71],[10,"find","","",71],[10,"position","","",71],[10,"max_by","","",71],[10,"min_by","","",71],[10,"next_back","","",71],[10,"rev","","",71],[10,"indexable","","",71],[10,"idx","","",71],[10,"next","","",72],[10,"size_hint","","",72],[10,"size_hint","","",72],[10,"chain","","",72],[10,"zip","","",72],[10,"map","","",72],[10,"filter","","",72],[10,"filter_map","","",72],[10,"enumerate","","",72],[10,"peekable","","",72],[10,"skip_while","","",72],[10,"take_while","","",72],[10,"skip","","",72],[10,"take","","",72],[10,"scan","","",72],[10,"flat_map","","",72],[10,"fuse","","",72],[10,"inspect","","",72],[10,"by_ref","","",72],[10,"advance","","",72],[10,"collect","","",72],[10,"nth","","",72],[10,"last","","",72],[10,"fold","","",72],[10,"count","","",72],[10,"all","","",72],[10,"any","","",72],[10,"find","","",72],[10,"position","","",72],[10,"max_by","","",72],[10,"min_by","","",72],[10,"next_back","","",72],[10,"rev","","",72],[10,"clone","core::str","",73],[10,"clone_from","","",73],[10,"next","","",73],[10,"size_hint","","",73],[10,"size_hint","","",73],[10,"chain","","",73],[10,"zip","","",73],[10,"map","","",73],[10,"filter","","",73],[10,"filter_map","","",73],[10,"enumerate","","",73],[10,"peekable","","",73],[10,"skip_while","","",73],[10,"take_while","","",73],[10,"skip","","",73],[10,"take","","",73],[10,"scan","","",73],[10,"flat_map","","",73],[10,"fuse","","",73],[10,"inspect","","",73],[10,"by_ref","","",73],[10,"advance","","",73],[10,"collect","","",73],[10,"nth","","",73],[10,"last","","",73],[10,"fold","","",73],[10,"count","","",73],[10,"all","","",73],[10,"any","","",73],[10,"find","","",73],[10,"position","","",73],[10,"max_by","","",73],[10,"min_by","","",73],[10,"next_back","","",73],[10,"rev","","",73],[10,"clone","","",74],[10,"clone_from","","",74],[10,"next","","",74],[10,"size_hint","","",74],[10,"size_hint","","",74],[10,"chain","","",74],[10,"zip","","",74],[10,"map","","",74],[10,"filter","","",74],[10,"filter_map","","",74],[10,"enumerate","","",74],[10,"peekable","","",74],[10,"skip_while","","",74],[10,"take_while","","",74],[10,"skip","","",74],[10,"take","","",74],[10,"scan","","",74],[10,"flat_map","","",74],[10,"fuse","","",74],[10,"inspect","","",74],[10,"by_ref","","",74],[10,"advance","","",74],[10,"collect","","",74],[10,"nth","","",74],[10,"last","","",74],[10,"fold","","",74],[10,"count","","",74],[10,"all","","",74],[10,"any","","",74],[10,"find","","",74],[10,"position","","",74],[10,"max_by","","",74],[10,"min_by","","",74],[10,"next_back","","",74],[10,"rev","","",74],[10,"clone","","",75],[10,"clone_from","","",75],[10,"clone","","",76],[10,"clone_from","","",76],[10,"next","","",75],[10,"size_hint","","",75],[10,"chain","","",75],[10,"zip","","",75],[10,"map","","",75],[10,"filter","","",75],[10,"filter_map","","",75],[10,"enumerate","","",75],[10,"peekable","","",75],[10,"skip_while","","",75],[10,"take_while","","",75],[10,"skip","","",75],[10,"take","","",75],[10,"scan","","",75],[10,"flat_map","","",75],[10,"fuse","","",75],[10,"inspect","","",75],[10,"by_ref","","",75],[10,"advance","","",75],[10,"collect","","",75],[10,"nth","","",75],[10,"last","","",75],[10,"fold","","",75],[10,"count","","",75],[10,"all","","",75],[10,"any","","",75],[10,"find","","",75],[10,"position","","",75],[10,"max_by","","",75],[10,"min_by","","",75],[10,"next_back","","",75],[10,"rev","","",75],[10,"next","","",76],[10,"size_hint","","",76],[10,"chain","","",76],[10,"zip","","",76],[10,"map","","",76],[10,"filter","","",76],[10,"filter_map","","",76],[10,"enumerate","","",76],[10,"peekable","","",76],[10,"skip_while","","",76],[10,"take_while","","",76],[10,"skip","","",76],[10,"take","","",76],[10,"scan","","",76],[10,"flat_map","","",76],[10,"fuse","","",76],[10,"inspect","","",76],[10,"by_ref","","",76],[10,"advance","","",76],[10,"collect","","",76],[10,"nth","","",76],[10,"last","","",76],[10,"fold","","",76],[10,"count","","",76],[10,"all","","",76],[10,"any","","",76],[10,"find","","",76],[10,"position","","",76],[10,"max_by","","",76],[10,"min_by","","",76],[10,"clone","","",77],[10,"clone_from","","",77],[10,"clone","","",78],[10,"clone_from","","",78],[10,"clone","","",79],[10,"clone_from","","",79],[10,"clone","","",80],[10,"clone_from","","",80],[10,"clone","","",81],[10,"clone_from","","",81],[10,"next","","",80],[10,"size_hint","","",80],[10,"chain","","",80],[10,"zip","","",80],[10,"map","","",80],[10,"filter","","",80],[10,"filter_map","","",80],[10,"enumerate","","",80],[10,"peekable","","",80],[10,"skip_while","","",80],[10,"take_while","","",80],[10,"skip","","",80],[10,"take","","",80],[10,"scan","","",80],[10,"flat_map","","",80],[10,"fuse","","",80],[10,"inspect","","",80],[10,"by_ref","","",80],[10,"advance","","",80],[10,"collect","","",80],[10,"nth","","",80],[10,"last","","",80],[10,"fold","","",80],[10,"count","","",80],[10,"all","","",80],[10,"any","","",80],[10,"find","","",80],[10,"position","","",80],[10,"max_by","","",80],[10,"min_by","","",80],[10,"next","","",81],[10,"size_hint","","",81],[10,"chain","","",81],[10,"zip","","",81],[10,"map","","",81],[10,"filter","","",81],[10,"filter_map","","",81],[10,"enumerate","","",81],[10,"peekable","","",81],[10,"skip_while","","",81],[10,"take_while","","",81],[10,"skip","","",81],[10,"take","","",81],[10,"scan","","",81],[10,"flat_map","","",81],[10,"fuse","","",81],[10,"inspect","","",81],[10,"by_ref","","",81],[10,"advance","","",81],[10,"collect","","",81],[10,"nth","","",81],[10,"last","","",81],[10,"fold","","",81],[10,"count","","",81],[10,"all","","",81],[10,"any","","",81],[10,"find","","",81],[10,"position","","",81],[10,"max_by","","",81],[10,"min_by","","",81],[10,"clone","","",82],[10,"clone_from","","",82],[10,"next","","",82],[10,"size_hint","","",82],[10,"size_hint","","",82],[10,"chain","","",82],[10,"zip","","",82],[10,"map","","",82],[10,"filter","","",82],[10,"filter_map","","",82],[10,"enumerate","","",82],[10,"peekable","","",82],[10,"skip_while","","",82],[10,"take_while","","",82],[10,"skip","","",82],[10,"take","","",82],[10,"scan","","",82],[10,"flat_map","","",82],[10,"fuse","","",82],[10,"inspect","","",82],[10,"by_ref","","",82],[10,"advance","","",82],[10,"collect","","",82],[10,"nth","","",82],[10,"last","","",82],[10,"fold","","",82],[10,"count","","",82],[10,"all","","",82],[10,"any","","",82],[10,"find","","",82],[10,"position","","",82],[10,"max_by","","",82],[10,"min_by","","",82],[10,"clone","","",83],[10,"clone_from","","",83],[10,"fmt","","",84],[10,"clone","","",84],[10,"clone_from","","",84],[10,"assert_receiver_is_total_eq","","",84],[10,"eq","","",84],[10,"ne","","",84],[10,"ne","","",84],[10,"to_char_lossy","","Convert `self` to a `char`, taking `LoneSurrogate`s to the\nreplacement character (U+FFFD).",84],[10,"next","","",83],[10,"size_hint","","",83],[10,"size_hint","","",83],[10,"chain","","",83],[10,"zip","","",83],[10,"map","","",83],[10,"filter","","",83],[10,"filter_map","","",83],[10,"enumerate","","",83],[10,"peekable","","",83],[10,"skip_while","","",83],[10,"take_while","","",83],[10,"skip","","",83],[10,"take","","",83],[10,"scan","","",83],[10,"flat_map","","",83],[10,"fuse","","",83],[10,"inspect","","",83],[10,"by_ref","","",83],[10,"advance","","",83],[10,"collect","","",83],[10,"nth","","",83],[10,"last","","",83],[10,"fold","","",83],[10,"count","","",83],[10,"all","","",83],[10,"any","","",83],[10,"find","","",83],[10,"position","","",83],[10,"max_by","","",83],[10,"min_by","","",83],[10,"eq","core::fmt::num","",85],[10,"ne","","",85],[10,"ne","","",85],[10,"clone","","",85],[10,"clone_from","","",85],[10,"eq","","",86],[10,"ne","","",86],[10,"ne","","",86],[10,"clone","","",86],[10,"clone_from","","",86],[10,"eq","","",87],[10,"ne","","",87],[10,"ne","","",87],[10,"clone","","",87],[10,"clone_from","","",87],[10,"eq","","",88],[10,"ne","","",88],[10,"ne","","",88],[10,"clone","","",88],[10,"clone_from","","",88],[10,"eq","","",89],[10,"ne","","",89],[10,"ne","","",89],[10,"clone","","",89],[10,"clone_from","","",89],[10,"eq","","",90],[10,"ne","","",90],[10,"ne","","",90],[10,"clone","","",90],[10,"clone_from","","",90],[10,"fmt","","",91],[10,"fmt","","",91],[10,"fmt","","",91],[10,"fmt","","",91],[10,"fmt","","",91],[10,"fmt","","",91],[10,"fmt","","",91],[10,"fmt","","",91],[10,"fmt","","",91],[10,"fmt","","",91],[10,"eq","core::fmt::rt","",92],[10,"ne","","",92],[10,"ne","","",92],[10,"fmt","core::fmt","",93],[10,"pad_integral","","Performs the correct padding for an integer which has already been\nemitted into a byte-array. The byte-array should *not* contain the sign\nfor the integer, that will be added by this method.",94],[10,"pad","","This function takes a string slice and emits it to the internal buffer\nafter applying the relevant formatting flags specified. The flags\nrecognized for generic strings are:",94],[10,"write","","Writes some data to the underlying buffer contained within this\nformatter.",94],[10,"write_fmt","","Writes some formatted information into this instance",94],[10,"fmt","core::cell","",20],[10,"fmt","","",22],[10,"fmt","","",23],[1,"AtomicBool","sync::atomics","An atomic boolean type."],[1,"AtomicInt","","A signed atomic integer type, supporting basic atomic arithmetic operations"],[1,"AtomicUint","","An unsigned atomic integer type, supporting basic atomic arithmetic operations"],[1,"AtomicPtr","","An unsafe atomic pointer. Only supports basic atomic operations"],[2,"Ordering","","Atomic memory orderings"],[12,"Relaxed","","No ordering constraints, only atomic operations",95],[12,"Release","","When coupled with a store, all previous writes become visible\nto another thread that performs a load with `Acquire` ordering\non the same value",95],[12,"Acquire","","When coupled with a load, all subsequent loads will see data\nwritten before a store with `Release` ordering on the same value\nin another thread",95],[12,"AcqRel","","When coupled with a load, uses `Acquire` ordering, and with a store\n`Release` ordering",95],[12,"SeqCst","","Like `AcqRel` with the additional guarantee that all threads see all\nsequentially consistent operations in the same order.",95],[5,"INIT_ATOMIC_BOOL","",""],[5,"INIT_ATOMIC_INT","",""],[5,"INIT_ATOMIC_UINT","",""],[3,"fence","","An atomic fence."],[0,"spsc_queue","sync","A single-producer single-consumer concurrent queue"],[1,"Queue","sync::spsc_queue","The single-producer single-consumer queue. This structure is not cloneable,\nbut it can be safely shared in an Arc if it is guaranteed that there\nis only one popper and one pusher touching the queue at any one point in\ntime."],[1,"Consumer","","A safe abstraction for the consumer in a single-producer single-consumer\nqueue."],[1,"Producer","","A safe abstraction for the producer in a single-producer single-consumer\nqueue."],[3,"queue","","Creates a new queue with a consumer-producer pair."],[10,"pop","","Attempts to pop the value from the head of the queue, returning `None`\nif the queue is empty.",96],[10,"peek","","Attempts to peek at the head of the queue, returning `None` if the queue\nis empty.",96],[10,"push","","Pushes a new value onto the queue.",97],[10,"new","","Creates a new queue.",98],[10,"push","","Pushes a new value onto this queue. Note that to use this function\nsafely, it must be externally guaranteed that there is only one pusher.",98],[10,"pop","","Attempts to pop a value from this queue. Remember that to use this type\nsafely you must ensure that there is only one popper at a time.",98],[10,"peek","","Attempts to peek at the head of the queue, returning `None` if the queue\nhas no data currently",98],[10,"drop","","",98],[0,"mpsc_queue","sync","A mostly lock-free multi-producer, single consumer queue."],[1,"Queue","sync::mpsc_queue","The multi-producer single-consumer structure. This is not cloneable, but it\nmay be safely shared so long as it is guaranteed that there is only one\npopper at a time (many pushers are allowed)."],[2,"PopResult","","A result of the `pop` function."],[12,"Data","","Some data has been popped",99],[12,"Empty","","The queue is empty",99],[12,"Inconsistent","","The queue is in an inconsistent state. Popping data should succeed, but\nsome pushers have yet to make enough progress in order allow a pop to\nsucceed. It is recommended that a pop() occur \"in the near future\" in\norder to see if the sender has made progress or not",99],[10,"new","","Creates a new queue that is safe to share among multiple producers and\none consumer.",100],[10,"push","","Pushes a new value onto this queue.",100],[10,"pop","","Pops some data from this queue.",100],[10,"casual_pop","","Attempts to pop data from this queue, but doesn't attempt too hard. This\nwill canonicalize inconsistent states to a `None` value.",100],[10,"drop","","",100],[0,"mpmc_bounded_queue","sync",""],[1,"Queue","sync::mpmc_bounded_queue",""],[10,"with_capacity","","",101],[10,"push","","",101],[10,"pop","","",101],[10,"clone","","",101],[0,"deque","sync","A (mostly) lock-free concurrent work-stealing deque"],[1,"Worker","sync::deque","Worker half of the work-stealing deque. This worker has exclusive access to\none side of the deque, and uses `push` and `pop` method to manipulate it."],[1,"Stealer","","The stealing half of the work-stealing deque. Stealers have access to the\nopposite end of the deque from the worker, and they only have access to the\n`steal` method."],[1,"BufferPool","","The allocation pool for buffers used by work-stealing deques. Right now this\nstructure is used for reclamation of memory after it is no longer in use by\ndeques."],[2,"Stolen","","When stealing some data, this is an enumeration of the possible outcomes."],[12,"Empty","","The deque was empty at the time of stealing",102],[12,"Abort","","The stealer lost the race for stealing data, and a retry may return more\ndata.",102],[12,"Data","","The stealer has successfully stolen some data.",102],[10,"fmt","","",102],[10,"eq","","",102],[10,"ne","","",102],[10,"new","","Allocates a new buffer pool which in turn can be used to allocate new\ndeques.",103],[10,"deque","","Allocates a new work-stealing deque which will send/receiving memory to\nand from this buffer pool.",103],[10,"clone","","",103],[10,"push","","Pushes data onto the front of this work queue.",104],[10,"pop","","Pops data off the front of the work queue, returning `None` on an empty\nqueue.",104],[10,"pool","","Gets access to the buffer pool that this worker is attached to. This can\nbe used to create more deques which share the same buffer pool as this\ndeque.",104],[10,"steal","","Steals work off the end of the queue (opposite of the worker's end)",105],[10,"pool","","Gets access to the buffer pool that this stealer is attached to. This\ncan be used to create more deques which share the same buffer pool as\nthis deque.",105],[10,"clone","","",105],[0,"raw","sync","Raw concurrency primitives you know and love."],[1,"Condvar","sync::raw","A mechanism for atomic-unlock-and-deschedule blocking and signalling."],[1,"Semaphore","","A counting, blocking, bounded-waiting semaphore."],[1,"SemaphoreGuard","","An RAII guard used to represent an acquired resource to a semaphore. When\ndropped, this value will release the resource back to the semaphore."],[1,"Mutex","","A blocking, bounded-waiting, mutual exclusion lock with an associated\nFIFO condition variable."],[1,"MutexGuard","","An RAII structure which is used to gain access to a mutex's condition\nvariable. Additionally, when a value of this type is dropped, the\ncorresponding mutex is also unlocked."],[11,"cond","","Inner condition variable which is connected to the outer mutex, and can\nbe used for atomic-unlock-and-deschedule.",106],[1,"RWLock","","A blocking, no-starvation, reader-writer lock with an associated condvar."],[1,"RWLockReadGuard","","An RAII helper which is created by acquiring a read lock on an RWLock. When\ndropped, this will unlock the RWLock."],[1,"RWLockWriteGuard","","An RAII helper which is created by acquiring a write lock on an RWLock. When\ndropped, this will unlock the RWLock."],[11,"cond","","Inner condition variable that is connected to the write-mode of the\nouter rwlock.",107],[10,"wait","","Atomically drop the associated lock, and block until a signal is sent.",108],[10,"wait_on","","As wait(), but can specify which of multiple condition variables to\nwait on. Only a signal_on() or broadcast_on() with the same condvar_id\nwill wake this thread.",108],[10,"signal","","Wake up a blocked task. Returns false if there was no blocked task.",108],[10,"signal_on","","As signal, but with a specified condvar_id. See wait_on.",108],[10,"broadcast","","Wake up all blocked tasks. Returns the number of tasks woken.",108],[10,"broadcast_on","","As broadcast, but with a specified condvar_id. See wait_on.",108],[10,"new","","Create a new semaphore with the specified count.",109],[10,"acquire","","Acquire a resource represented by the semaphore. Blocks if necessary\nuntil resource(s) become available.",109],[10,"release","","Release a held resource represented by the semaphore. Wakes a blocked\ncontending task, if any exist. Won't block the caller.",109],[10,"access","","Acquire a resource of this semaphore, returning an RAII guard which will\nrelease the resource when dropped.",109],[10,"new","","Create a new mutex, with one associated condvar.",110],[10,"new_with_condvars","","Create a new mutex, with a specified number of associated condvars. This\nwill allow calling wait_on/signal_on/broadcast_on with condvar IDs\nbetween 0 and num_condvars-1. (If num_condvars is 0, lock_cond will be\nallowed but any operations on the condvar will fail.)",110],[10,"lock","","Acquires ownership of this mutex, returning an RAII guard which will\nunlock the mutex when dropped. The associated condition variable can\nalso be accessed through the returned guard.",110],[10,"new","","Create a new rwlock, with one associated condvar.",111],[10,"new_with_condvars","","Create a new rwlock, with a specified number of associated condvars.\nSimilar to mutex_with_condvars.",111],[10,"read","","Acquires a read-lock, returning an RAII guard that will unlock the lock\nwhen dropped. Calls to 'read' from other tasks may run concurrently with\nthis one.",111],[10,"write","","Acquire a write-lock, returning an RAII guard that will unlock the lock\nwhen dropped. No calls to 'read' or 'write' from other tasks will run\nconcurrently with this one.",111],[10,"downgrade","","Consumes this write lock and converts it into a read lock.",107],[10,"drop","","",107],[10,"drop","","",112],[0,"mutex","sync","A proper mutex implementation regardless of the \"flavor of task\" which is\nacquiring the lock."],[1,"Mutex","sync::mutex","A mutual exclusion primitive useful for protecting shared data"],[1,"StaticMutex","","The static mutex type is provided to allow for static allocation of mutexes."],[1,"Guard","","An RAII implementation of a \"scoped lock\" of a mutex. When this structure is\ndropped (falls out of scope), the lock will be unlocked."],[5,"LOCKED","",""],[5,"GREEN_BLOCKED","",""],[5,"NATIVE_BLOCKED","",""],[5,"MUTEX_INIT","","Static initialization of a mutex. This constant can be used to initialize\nother mutex constants."],[10,"try_lock","","Attempts to grab this lock, see `Mutex::try_lock`",113],[10,"lock","","Acquires this lock, see `Mutex::lock`",113],[10,"destroy","","Deallocates resources associated with this static mutex.",113],[10,"new","","Creates a new mutex in an unlocked state ready for use.",114],[10,"try_lock","","Attempts to acquire this lock.",114],[10,"lock","","Acquires a mutex, blocking the current task until it is able to do so.",114],[10,"drop","","",115],[10,"drop","","",114],[0,"one","sync","A \"once initialization\" primitive"],[1,"Once","sync::one","A synchronization primitive which can be used to run a one-time global\ninitialization. Useful for one-time initialization for FFI or related\nfunctionality. This type can only be constructed with the `ONCE_INIT`\nvalue."],[5,"ONCE_INIT","","Initialization value for static `Once` values."],[10,"doit","","Perform an initialization routine once and only once. The given closure\nwill be executed if this is the first time `doit` has been called, and\notherwise the routine will *not* be invoked.",116],[0,"comm","sync","Communication primitives for concurrent tasks"],[1,"Select","sync::comm","The \"receiver set\" of the select interface. This structure is used to manage\na set of receivers which are being selected over."],[1,"Handle","","A handle to a receiver which is currently a member of a `Select` set of\nreceivers.  This handle is used to keep the receiver in the set as well as\ninteract with the underlying receiver."],[1,"DuplexStream","","An extension of `pipes::stream` that allows both sending and receiving."],[1,"Receiver","","The receiving-half of Rust's channel type. This half can only be owned by\none task"],[1,"Messages","","An iterator over messages on a receiver, this iterator will block\nwhenever `next` is called, waiting for a new message, and `None` will be\nreturned when the corresponding channel has hung up."],[1,"Sender","","The sending-half of Rust's asynchronous channel type. This half can only be\nowned by one task, but it can be cloned to send to other tasks."],[1,"SyncSender","","The sending-half of Rust's synchronous channel type. This half can only be\nowned by one task, but it can be cloned to send to other tasks."],[2,"TryRecvError","","This enumeration is the list of the possible reasons that try_recv could not\nreturn data when called."],[12,"Empty","","This channel is currently empty, but the sender(s) have not yet\ndisconnected, so data may yet become available.",117],[12,"Disconnected","","This channel's sending half has become disconnected, and there will\nnever be any more data received on this channel",117],[2,"TrySendError","","This enumeration is the list of the possible error outcomes for the\n`SyncSender::try_send` method."],[12,"Full","","The data could not be sent on the channel because it would require that\nthe callee block to send the data.",118],[12,"RecvDisconnected","","This channel's receiving half has disconnected, so the data could not be\nsent. The data is returned back to the callee in this case.",118],[3,"duplex","","Creates a bidirectional stream."],[3,"channel","","Creates a new asynchronous channel, returning the sender/receiver halves."],[3,"sync_channel","","Creates a new synchronous, bounded channel."],[10,"fmt","","",117],[10,"clone","","",117],[10,"eq","","",117],[10,"ne","","",117],[10,"fmt","","",118],[10,"clone","","",118],[10,"eq","","",118],[10,"ne","","",118],[10,"send","","Sends a value along this channel to be received by the corresponding\nreceiver.",119],[10,"send_opt","","Attempts to send a value on this channel, returning it back if it could\nnot be sent.",119],[10,"clone","","",119],[10,"drop","","",119],[10,"send","","Sends a value on this synchronous channel.",120],[10,"send_opt","","Send a value on a channel, returning it back if the receiver\ndisconnected",120],[10,"try_send","","Attempts to send a value on this channel without blocking.",120],[10,"clone","","",120],[10,"drop","","",120],[10,"recv","","Blocks waiting for a value on this receiver",121],[10,"try_recv","","Attempts to return a pending value on this receiver without blocking",121],[10,"recv_opt","","Attempt to wait for a value on this receiver, but does not fail if the\ncorresponding channel has hung up.",121],[10,"iter","","Returns an iterator which will block waiting for messages, but never\n`fail!`. It will return `None` when the channel has hung up.",121],[10,"next","","",122],[10,"drop","","",121],[10,"new","alloc::arc","Create an atomically reference counted wrapper.",123],[10,"downgrade","","Downgrades a strong pointer to a weak pointer",123],[10,"make_unique","","Acquires a mutable pointer to the inner contents by guaranteeing that\nthe reference count is one (no sharing is possible).",123],[10,"default","alloc::boxed","",124],[10,"clone","","Return a copy of the owned box.",124],[10,"clone_from","","Perform copy-assignment from `source` by reusing the existing allocation.",124],[10,"clone_from","","",124],[10,"eq","","",124],[10,"ne","","",124],[10,"ne","","",124],[10,"partial_cmp","","",124],[10,"lt","","",124],[10,"le","","",124],[10,"ge","","",124],[10,"gt","","",124],[10,"lt","","",124],[10,"le","","",124],[10,"gt","","",124],[10,"ge","","",124],[10,"cmp","","",124],[10,"assert_receiver_is_total_eq","","",124],[10,"downcast","","",124],[10,"move","","",124],[10,"fmt","","",124],[10,"fmt","","",124],[10,"clone","alloc::arc","Duplicate an atomically reference counted wrapper.",123],[10,"clone_from","","",123],[10,"deref","","",123],[10,"drop","","",123],[10,"upgrade","","Attempts to upgrade this weak reference to a strong reference.",125],[10,"clone","","",125],[10,"clone_from","","",125],[10,"drop","","",125],[10,"new","alloc::rc","Construct a new reference-counted box",126],[10,"downgrade","","Downgrade the reference-counted pointer to a weak reference",126],[10,"make_unique","","Acquires a mutable pointer to the inner contents by guaranteeing that\nthe reference count is one (no sharing is possible).",126],[10,"deref","","Borrow the value contained in the reference-counted box",126],[10,"drop","","",126],[10,"clone","","",126],[10,"clone_from","","",126],[10,"default","","",126],[10,"eq","","",126],[10,"ne","","",126],[10,"ne","","",126],[10,"assert_receiver_is_total_eq","","",126],[10,"partial_cmp","","",126],[10,"lt","","",126],[10,"le","","",126],[10,"gt","","",126],[10,"ge","","",126],[10,"lt","","",126],[10,"le","","",126],[10,"gt","","",126],[10,"ge","","",126],[10,"cmp","","",126],[10,"fmt","","",126],[10,"upgrade","","Upgrade a weak reference to a strong reference",127],[10,"drop","","",127],[10,"clone","","",127],[10,"clone_from","","",127],[1,"Arc","sync","An atomically reference counted wrapper for shared state."],[1,"Weak","","A weak pointer to an `Arc`."]],"paths":[[1,"MutexGuard"],[1,"RWLockWriteGuard"],[1,"AtomicOption"],[1,"AtomicBool"],[2,"FPCategory"],[1,"TypeId"],[1,"CovariantType"],[1,"ContravariantType"],[1,"InvariantType"],[1,"CovariantLifetime"],[1,"ContravariantLifetime"],[1,"InvariantLifetime"],[1,"NoSend"],[1,"NoCopy"],[1,"NoShare"],[1,"Managed"],[2,"Ordering"],[1,"AtomicInt"],[1,"AtomicUint"],[1,"AtomicPtr"],[1,"Cell"],[1,"RefCell"],[1,"Ref"],[1,"RefMut"],[1,"UnsafeCell"],[1,"Finallyalizer"],[1,"Enumerate"],[1,"Inspect"],[1,"Rev"],[1,"Map"],[1,"Zip"],[1,"ByRef"],[2,"MinMaxResult"],[1,"Cycle"],[1,"Chain"],[1,"Filter"],[1,"FilterMap"],[1,"Peekable"],[1,"SkipWhile"],[1,"TakeWhile"],[1,"Skip"],[1,"Take"],[1,"Scan"],[1,"FlatMap"],[1,"Fuse"],[1,"Unfold"],[1,"Counter"],[1,"Range"],[1,"RangeInclusive"],[1,"RangeStep"],[1,"RangeStepInclusive"],[1,"Repeat"],[2,"Option"],[1,"Item"],[2,"Result"],[1,"i8x16"],[1,"i16x8"],[1,"i32x4"],[1,"i64x2"],[1,"u8x16"],[1,"u16x8"],[1,"u32x4"],[1,"u64x2"],[1,"f32x4"],[1,"f64x2"],[1,"Items"],[1,"MutItems"],[1,"Splits"],[1,"MutSplits"],[1,"SplitsN"],[1,"Windows"],[1,"Chunks"],[1,"MutChunks"],[1,"Chars"],[1,"CharOffsets"],[1,"CharSplits"],[1,"CharSplitsN"],[1,"NaiveSearcher"],[1,"TwoWaySearcher"],[2,"Searcher"],[1,"MatchIndices"],[1,"StrSplits"],[1,"Utf16CodeUnits"],[1,"Utf16Items"],[2,"Utf16Item"],[1,"Binary"],[1,"Octal"],[1,"Decimal"],[1,"LowerHex"],[1,"UpperHex"],[1,"Radix"],[1,"RadixFmt"],[2,"Alignment"],[1,"Arguments"],[1,"Formatter"],[2,"Ordering"],[1,"Consumer"],[1,"Producer"],[1,"Queue"],[2,"PopResult"],[1,"Queue"],[1,"Queue"],[2,"Stolen"],[1,"BufferPool"],[1,"Worker"],[1,"Stealer"],[1,"MutexGuard"],[1,"RWLockWriteGuard"],[1,"Condvar"],[1,"Semaphore"],[1,"Mutex"],[1,"RWLock"],[1,"RWLockReadGuard"],[1,"StaticMutex"],[1,"Mutex"],[1,"Guard"],[1,"Once"],[2,"TryRecvError"],[2,"TrySendError"],[1,"Sender"],[1,"SyncSender"],[1,"Receiver"],[1,"Messages"],[1,"Arc"],[1,"Box"],[1,"Weak"],[1,"Rc"],[1,"Weak"]]};

searchIndex['serialize'] = {"items":[[0,"","serialize","Support code for encoding and decoding types."],[0,"base64","","Base64 binary-to-text encoding"],[1,"Config","serialize::base64","Contains configuration parameters for `to_base64`."],[11,"char_set","","Character set to use",0],[11,"pad","","True to pad output with `=` characters",0],[11,"line_length","","`Some(len)` to wrap lines at `len`, `None` to disable line wrapping",0],[2,"CharacterSet","","Available encoding character sets"],[12,"Standard","","The standard character set (uses `+` and `/`)",1],[12,"UrlSafe","","The URL safe character set (uses `-` and `_`)",1],[2,"FromBase64Error","","Errors that can occur when decoding a base64 encoded string"],[12,"InvalidBase64Byte","","The input contained a character not part of the base64 format",2],[12,"InvalidBase64Length","","The input had an invalid length",2],[5,"STANDARD","","Configuration for RFC 4648 standard base64 encoding"],[5,"URL_SAFE","","Configuration for RFC 4648 base64url encoding"],[5,"MIME","","Configuration for RFC 2045 MIME base64 encoding"],[6,"ToBase64","","A trait for converting a value to base64 encoding."],[9,"to_base64","","Converts the value of `self` to a base64 value following the specified\nformat configuration, returning the owned string.",3],[6,"FromBase64","","A trait for converting from base64 encoded values."],[9,"from_base64","","Converts the value of `self`, interpreted as base64 encoded data, into\nan owned vector of bytes, returning the vector.",4],[10,"fmt","","",2],[0,"hex","serialize","Hex binary-to-text encoding"],[2,"FromHexError","serialize::hex","Errors that can occur when decoding a hex encoded string"],[12,"InvalidHexCharacter","","The input contained a character not part of the hex format",5],[12,"InvalidHexLength","","The input had an invalid length",5],[6,"ToHex","","A trait for converting a value to hexadecimal encoding"],[9,"to_hex","","Converts the value of `self` to a hex value, returning the owned\nstring.",6],[6,"FromHex","","A trait for converting hexadecimal encoded values"],[9,"from_hex","","Converts the value of `self`, interpreted as hexadecimal encoded data,\ninto an owned vector of bytes, returning the vector.",7],[10,"fmt","","",5],[0,"json","serialize","JSON parsing and serialization"],[1,"Encoder","serialize::json","A structure for implementing serialization to JSON."],[1,"PrettyEncoder","","Another encoder for JSON, but prints out human-readable JSON instead of\ncompact data"],[1,"Stack","","A Stack represents the current position of the parser in the logical\nstructure of the JSON stream.\nFor example foo.bar[3].x"],[1,"Parser","","A streaming JSON parser implemented as an iterator of JsonEvent, consuming\nan iterator of char."],[1,"Builder","","A Builder consumes a json::Parser to create a generic Json structure."],[1,"Decoder","","A structure to decode JSON to values in rust."],[2,"Json","","Represents a json value"],[12,"Number","","",8],[12,"String","","",8],[12,"Boolean","","",8],[12,"List","","",8],[12,"Object","","",8],[12,"Null","","",8],[2,"ErrorCode","","The errors that can arise while parsing a JSON stream."],[12,"InvalidSyntax","","",9],[12,"InvalidNumber","","",9],[12,"EOFWhileParsingObject","","",9],[12,"EOFWhileParsingList","","",9],[12,"EOFWhileParsingValue","","",9],[12,"EOFWhileParsingString","","",9],[12,"KeyMustBeAString","","",9],[12,"ExpectedColon","","",9],[12,"TrailingCharacters","","",9],[12,"InvalidEscape","","",9],[12,"InvalidUnicodeCodePoint","","",9],[12,"LoneLeadingSurrogateInHexEscape","","",9],[12,"UnexpectedEndOfHexEscape","","",9],[12,"UnrecognizedHex","","",9],[12,"NotFourDigit","","",9],[12,"NotUtf8","","",9],[2,"ParserError","",""],[12,"SyntaxError","","msg, line, col",10],[12,"IoError","","",10],[2,"DecoderError","",""],[12,"ParseError","","",11],[12,"ExpectedError","","",11],[12,"MissingFieldError","","",11],[12,"UnknownVariantError","","",11],[12,"ApplicationError","","",11],[2,"JsonEvent","","The output of the streaming parser."],[12,"ObjectStart","","",12],[12,"ObjectEnd","","",12],[12,"ListStart","","",12],[12,"ListEnd","","",12],[12,"BooleanValue","","",12],[12,"NumberValue","","",12],[12,"StringValue","","",12],[12,"NullValue","","",12],[12,"Error","","",12],[2,"StackElement","","StackElements compose a Stack.\nFor example, Key(\"foo\"), Key(\"bar\"), Index(3) and Key(\"x\") are the\nStackElements compositing the stack that represents foo.bar[3].x"],[12,"Index","","",13],[12,"Key","","",13],[3,"error_str","","Returns a readable error string for a given error code."],[3,"decode","","Shortcut function to decode a JSON `&str` into an object"],[3,"encode","","Shortcut function to encode a `T` into a JSON `String`"],[3,"escape_bytes","",""],[3,"from_reader","","Decodes a json value from an `&mut io::Reader`"],[3,"from_str","","Decodes a json value from a string"],[4,"List","",""],[4,"Object","",""],[4,"BuilderError","",""],[4,"EncodeResult","",""],[4,"DecodeResult","",""],[6,"ToJson","","A trait for converting values to JSON"],[9,"to_json","","Converts the value of `self` to an instance of JSON",14],[10,"partial_cmp","","",8],[10,"lt","","",8],[10,"le","","",8],[10,"gt","","",8],[10,"ge","","",8],[10,"eq","","",8],[10,"ne","","",8],[10,"clone","","",8],[10,"eq","","",9],[10,"ne","","",9],[10,"clone","","",9],[10,"fmt","","",10],[10,"eq","","",10],[10,"ne","","",10],[10,"clone","","",10],[10,"fmt","","",11],[10,"eq","","",11],[10,"ne","","",11],[10,"clone","","",11],[10,"fmt","","",9],[10,"new","","Creates a new JSON encoder whose output will be written to the writer\nspecified.",15],[10,"buffer_encode","","Encode the specified struct into a json [u8]",15],[10,"str_encode","","Encode the specified struct into a json str",15],[10,"emit_nil","","",15],[10,"emit_uint","","",15],[10,"emit_u64","","",15],[10,"emit_u32","","",15],[10,"emit_u16","","",15],[10,"emit_u8","","",15],[10,"emit_int","","",15],[10,"emit_i64","","",15],[10,"emit_i32","","",15],[10,"emit_i16","","",15],[10,"emit_i8","","",15],[10,"emit_bool","","",15],[10,"emit_f64","","",15],[10,"emit_f32","","",15],[10,"emit_char","","",15],[10,"emit_str","","",15],[10,"emit_enum","","",15],[10,"emit_enum_variant","","",15],[10,"emit_enum_variant_arg","","",15],[10,"emit_enum_struct_variant","","",15],[10,"emit_enum_struct_variant_field","","",15],[10,"emit_struct","","",15],[10,"emit_struct_field","","",15],[10,"emit_tuple","","",15],[10,"emit_tuple_arg","","",15],[10,"emit_tuple_struct","","",15],[10,"emit_tuple_struct_arg","","",15],[10,"emit_option","","",15],[10,"emit_option_none","","",15],[10,"emit_option_some","","",15],[10,"emit_seq","","",15],[10,"emit_seq_elt","","",15],[10,"emit_map","","",15],[10,"emit_map_elt_key","","",15],[10,"emit_map_elt_val","","",15],[10,"new","","Creates a new encoder whose output will be written to the specified writer",16],[10,"emit_nil","","",16],[10,"emit_uint","","",16],[10,"emit_u64","","",16],[10,"emit_u32","","",16],[10,"emit_u16","","",16],[10,"emit_u8","","",16],[10,"emit_int","","",16],[10,"emit_i64","","",16],[10,"emit_i32","","",16],[10,"emit_i16","","",16],[10,"emit_i8","","",16],[10,"emit_bool","","",16],[10,"emit_f64","","",16],[10,"emit_f32","","",16],[10,"emit_char","","",16],[10,"emit_str","","",16],[10,"emit_enum","","",16],[10,"emit_enum_variant","","",16],[10,"emit_enum_variant_arg","","",16],[10,"emit_enum_struct_variant","","",16],[10,"emit_enum_struct_variant_field","","",16],[10,"emit_struct","","",16],[10,"emit_struct_field","","",16],[10,"emit_tuple","","",16],[10,"emit_tuple_arg","","",16],[10,"emit_tuple_struct","","",16],[10,"emit_tuple_struct_arg","","",16],[10,"emit_option","","",16],[10,"emit_option_none","","",16],[10,"emit_option_some","","",16],[10,"emit_seq","","",16],[10,"emit_seq_elt","","",16],[10,"emit_map","","",16],[10,"emit_map_elt_key","","",16],[10,"emit_map_elt_val","","",16],[10,"encode","","",8],[10,"to_writer","","Encodes a json value into an io::writer. Uses a single line.",8],[10,"to_pretty_writer","","Encodes a json value into an io::writer.\nPretty-prints in a more readable format.",8],[10,"to_pretty_str","","Encodes a json value into a string",8],[10,"find","","If the Json value is an Object, returns the value associated with the provided key.\nOtherwise, returns None.",8],[10,"find_path","","Attempts to get a nested Json Object for each key in `keys`.\nIf any key is found not to exist, find_path will return None.\nOtherwise, it will return the Json value associated with the final key.",8],[10,"search","","If the Json value is an Object, performs a depth-first search until\na value associated with the provided key is found. If no value is found\nor the Json value is not an Object, returns None.",8],[10,"is_object","","Returns true if the Json value is an Object. Returns false otherwise.",8],[10,"as_object","","If the Json value is an Object, returns the associated TreeMap.\nReturns None otherwise.",8],[10,"is_list","","Returns true if the Json value is a List. Returns false otherwise.",8],[10,"as_list","","If the Json value is a List, returns the associated vector.\nReturns None otherwise.",8],[10,"is_string","","Returns true if the Json value is a String. Returns false otherwise.",8],[10,"as_string","","If the Json value is a String, returns the associated str.\nReturns None otherwise.",8],[10,"is_number","","Returns true if the Json value is a Number. Returns false otherwise.",8],[10,"as_number","","If the Json value is a Number, returns the associated f64.\nReturns None otherwise.",8],[10,"is_boolean","","Returns true if the Json value is a Boolean. Returns false otherwise.",8],[10,"as_boolean","","If the Json value is a Boolean, returns the associated bool.\nReturns None otherwise.",8],[10,"is_null","","Returns true if the Json value is a Null. Returns false otherwise.",8],[10,"as_null","","If the Json value is a Null, returns ().\nReturns None otherwise.",8],[10,"fmt","","",12],[10,"clone","","",12],[10,"eq","","",12],[10,"ne","","",12],[10,"fmt","","",13],[10,"clone","","",13],[10,"eq","","",13],[10,"ne","","",13],[10,"new","","",17],[10,"len","","Returns The number of elements in the Stack.",17],[10,"is_empty","","Returns true if the stack is empty.",17],[10,"get","","Provides access to the StackElement at a given index.\nlower indices are at the bottom of the stack while higher indices are\nat the top.",17],[10,"is_equal_to","","Compares this stack with an array of StackElements.",17],[10,"starts_with","","Returns true if the bottom-most elements of this stack are the same as\nthe ones passed as parameter.",17],[10,"ends_with","","Returns true if the top-most elements of this stack are the same as\nthe ones passed as parameter.",17],[10,"top","","Returns the top-most element (if any).",17],[10,"next","","",18],[10,"new","","Creates the JSON parser.",18],[10,"stack","","Provides access to the current position in the logical structure of the\nJSON stream.",18],[10,"new","","Create a JSON Builder.",19],[10,"build","","",19],[10,"new","","Creates a new decoder instance for decoding the specified JSON value.",20],[10,"read_nil","","",20],[10,"read_u64","","",20],[10,"read_u32","","",20],[10,"read_u16","","",20],[10,"read_u8","","",20],[10,"read_uint","","",20],[10,"read_i64","","",20],[10,"read_i32","","",20],[10,"read_i16","","",20],[10,"read_i8","","",20],[10,"read_int","","",20],[10,"read_bool","","",20],[10,"read_f64","","",20],[10,"read_f32","","",20],[10,"read_char","","",20],[10,"read_str","","",20],[10,"read_enum","","",20],[10,"read_enum_variant","","",20],[10,"read_enum_variant_arg","","",20],[10,"read_enum_struct_variant","","",20],[10,"read_enum_struct_variant_field","","",20],[10,"read_struct","","",20],[10,"read_struct_field","","",20],[10,"read_tuple","","",20],[10,"read_tuple_arg","","",20],[10,"read_tuple_struct","","",20],[10,"read_tuple_struct_arg","","",20],[10,"read_option","","",20],[10,"read_seq","","",20],[10,"read_seq_elt","","",20],[10,"read_map","","",20],[10,"read_map_elt_key","","",20],[10,"read_map_elt_val","","",20],[10,"error","","",20],[10,"to_json","","",8],[10,"to_json","collections::string","",21],[10,"to_json","collections::vec","",22],[10,"to_json","collections::treemap","",23],[10,"to_json","std::collections::hashmap","",24],[10,"to_json","core::option","",25],[10,"fmt","serialize::json","Encodes a json value into a string",8],[10,"from_str","","",8],[6,"Decoder","serialize",""],[9,"read_nil","","",26],[9,"read_uint","","",26],[9,"read_u64","","",26],[9,"read_u32","","",26],[9,"read_u16","","",26],[9,"read_u8","","",26],[9,"read_int","","",26],[9,"read_i64","","",26],[9,"read_i32","","",26],[9,"read_i16","","",26],[9,"read_i8","","",26],[9,"read_bool","","",26],[9,"read_f64","","",26],[9,"read_f32","","",26],[9,"read_char","","",26],[9,"read_str","","",26],[9,"read_enum","","",26],[9,"read_enum_variant","","",26],[9,"read_enum_variant_arg","","",26],[9,"read_enum_struct_variant","","",26],[9,"read_enum_struct_variant_field","","",26],[9,"read_struct","","",26],[9,"read_struct_field","","",26],[9,"read_tuple","","",26],[9,"read_tuple_arg","","",26],[9,"read_tuple_struct","","",26],[9,"read_tuple_struct_arg","","",26],[9,"read_option","","",26],[9,"read_seq","","",26],[9,"read_seq_elt","","",26],[9,"read_map","","",26],[9,"read_map_elt_key","","",26],[9,"read_map_elt_val","","",26],[9,"error","","",26],[6,"Encoder","",""],[9,"emit_nil","","",27],[9,"emit_uint","","",27],[9,"emit_u64","","",27],[9,"emit_u32","","",27],[9,"emit_u16","","",27],[9,"emit_u8","","",27],[9,"emit_int","","",27],[9,"emit_i64","","",27],[9,"emit_i32","","",27],[9,"emit_i16","","",27],[9,"emit_i8","","",27],[9,"emit_bool","","",27],[9,"emit_f64","","",27],[9,"emit_f32","","",27],[9,"emit_char","","",27],[9,"emit_str","","",27],[9,"emit_enum","","",27],[9,"emit_enum_variant","","",27],[9,"emit_enum_variant_arg","","",27],[9,"emit_enum_struct_variant","","",27],[9,"emit_enum_struct_variant_field","","",27],[9,"emit_struct","","",27],[9,"emit_struct_field","","",27],[9,"emit_tuple","","",27],[9,"emit_tuple_arg","","",27],[9,"emit_tuple_struct","","",27],[9,"emit_tuple_struct_arg","","",27],[9,"emit_option","","",27],[9,"emit_option_none","","",27],[9,"emit_option_some","","",27],[9,"emit_seq","","",27],[9,"emit_seq_elt","","",27],[9,"emit_map","","",27],[9,"emit_map_elt_key","","",27],[9,"emit_map_elt_val","","",27],[6,"Decodable","",""],[9,"decode","","",28],[6,"Encodable","",""],[9,"encode","","",29],[6,"DecoderHelpers","",""],[9,"read_to_vec","","",30],[6,"EncoderHelpers","",""],[9,"emit_from_vec","","",31]],"paths":[[1,"Config"],[2,"CharacterSet"],[2,"FromBase64Error"],[6,"ToBase64"],[6,"FromBase64"],[2,"FromHexError"],[6,"ToHex"],[6,"FromHex"],[2,"Json"],[2,"ErrorCode"],[2,"ParserError"],[2,"DecoderError"],[2,"JsonEvent"],[2,"StackElement"],[6,"ToJson"],[1,"Encoder"],[1,"PrettyEncoder"],[1,"Stack"],[1,"Parser"],[1,"Builder"],[1,"Decoder"],[1,"String"],[1,"Vec"],[1,"TreeMap"],[1,"HashMap"],[2,"Option"],[6,"Decoder"],[6,"Encoder"],[6,"Decodable"],[6,"Encodable"],[6,"DecoderHelpers"],[6,"EncoderHelpers"]]};

searchIndex['uuid'] = {"items":[[0,"","uuid","Generate and parse UUIDs"],[1,"Uuid","","A Universally Unique Identifier (UUID)"],[2,"UuidVersion","","The version of the UUID, denoting the generating algorithm"],[12,"Version1Mac","","Version 1: MAC address",0],[12,"Version2Dce","","Version 2: DCE Security",0],[12,"Version3Md5","","Version 3: MD5 hash",0],[12,"Version4Random","","Version 4: Random",0],[12,"Version5Sha1","","Version 5: SHA-1 hash",0],[2,"UuidVariant","","The reserved variants of UUIDs"],[12,"VariantNCS","","Reserved by the NCS for backward compatibility",1],[12,"VariantRFC4122","","As described in the RFC4122 Specification (default)",1],[12,"VariantMicrosoft","","Reserved by Microsoft for backward compatibility",1],[12,"VariantFuture","","Reserved for future expansion",1],[2,"ParseError","","Error details for string parsing failures"],[12,"ErrorInvalidLength","","",2],[12,"ErrorInvalidCharacter","","",2],[12,"ErrorInvalidGroups","","",2],[12,"ErrorInvalidGroupLength","","",2],[4,"UuidBytes","","A 128-bit (16 byte) buffer containing the ID"],[10,"eq","","",0],[10,"ne","","",0],[10,"eq","","",1],[10,"ne","","",1],[10,"hash","","",3],[10,"fmt","","",2],[10,"nil","","Returns a nil or empty UUID (containing all zeroes)",3],[10,"new","","Create a new UUID of the specified version",3],[10,"new_v4","","Creates a new random UUID",3],[10,"from_fields","","Creates a UUID using the supplied field values",3],[10,"from_bytes","","Creates a UUID using the supplied bytes",3],[10,"get_variant","","Returns the variant of the UUID structure",3],[10,"get_version_num","","Returns the version number of the UUID",3],[10,"get_version","","Returns the version of the UUID",3],[10,"as_bytes","","Return an array of 16 octets containing the UUID data",3],[10,"to_simple_str","","Returns the UUID as a string of 16 hexadecimal digits",3],[10,"to_hyphenated_str","","Returns a string of hexadecimal digits, separated into groups with a hyphen.",3],[10,"to_urn_str","","Returns the UUID formatted as a full URN string",3],[10,"parse_string","","Parses a UUID from a string of hexadecimal digits with optional hyphens",3],[10,"is_nil","","Tests if the UUID is nil",3],[10,"default","","Returns the nil UUID, which is all zeroes",3],[10,"clone","","Returns a copy of the UUID",3],[10,"from_str","","Parse a hex string and interpret as a UUID",3],[10,"fmt","","",3],[10,"eq","","",3],[10,"encode","","Encode a UUID as a hyphenated string",3],[10,"decode","","Decode a UUID from a string",3],[10,"rand","","",3]],"paths":[[2,"UuidVersion"],[2,"UuidVariant"],[2,"ParseError"],[1,"Uuid"]]};

searchIndex['semver'] = {"items":[[0,"","semver","Semantic version parsing and comparison."],[1,"Version","","Represents a version number conforming to the semantic versioning scheme."],[11,"major","","The major version, to be incremented on incompatible changes.",0],[11,"minor","","The minor version, to be incremented when functionality is added in a\nbackwards-compatible manner.",0],[11,"patch","","The patch version, to be incremented when backwards-compatible bug\nfixes are made.",0],[11,"pre","","The pre-release version identifier, if one exists.",0],[11,"build","","The build metadata, ignored when determining version precedence.",0],[2,"Identifier","","An identifier in the pre-release or build metadata. If the identifier can\nbe parsed as a decimal value, it will be represented with `Numeric`."],[12,"Numeric","","",1],[12,"AlphaNumeric","","",1],[3,"parse","","Parse a string into a semver object."],[10,"hash","","",1],[10,"cmp","","",1],[10,"partial_cmp","","",1],[10,"lt","","",1],[10,"le","","",1],[10,"gt","","",1],[10,"ge","","",1],[10,"eq","","",1],[10,"ne","","",1],[10,"clone","","",1],[10,"fmt","","",1],[10,"clone","","",0],[10,"fmt","","",0],[10,"eq","","",0],[10,"partial_cmp","","",0],[10,"cmp","","",0],[10,"hash","","",0]],"paths":[[1,"Version"],[2,"Identifier"]]};

searchIndex['term'] = {"items":[[0,"","term","Terminal formatting library."],[1,"WriterWrapper","","A hack to work around the fact that `Box<Writer + Send>` does not\ncurrently implement `Writer`."],[3,"stdout","","Return a Terminal wrapping stdout, or None if a terminal couldn't be\nopened."],[3,"stderr","","Return a Terminal wrapping stderr, or None if a terminal couldn't be\nopened."],[0,"terminfo","","Terminfo database interface."],[1,"TermInfo","term::terminfo","A parsed terminfo database entry."],[11,"names","","Names for the terminal",0],[11,"bools","","Map of capability name to boolean value",0],[11,"numbers","","Map of capability name to numeric value",0],[11,"strings","","Map of capability name to raw (unexpanded) string",0],[1,"TerminfoTerminal","","A Terminal that knows how many colors it supports, with a reference to its\nparsed Terminfo database record."],[0,"searcher","","ncurses-compatible database discovery"],[3,"get_dbpath_for_term","term::terminfo::searcher","Return path to database entry for `term`"],[3,"open","","Return open file for `term`"],[0,"parser","term::terminfo","TermInfo format parsing.\nncurses-compatible compiled terminfo format parsing (term(5))"],[0,"compiled","term::terminfo::parser","ncurses-compatible compiled terminfo format parsing (term(5))"],[3,"parse","term::terminfo::parser::compiled","Parse a compiled terminfo entry, using long capability names if `longnames` is true"],[3,"msys_terminfo","","Create a dummy TermInfo struct for msys terminals"],[5,"boolfnames","",""],[5,"boolnames","",""],[5,"numfnames","",""],[5,"numnames","",""],[5,"stringfnames","",""],[5,"stringnames","",""],[0,"parm","term::terminfo","Parameterized string expansion"],[1,"Variables","term::terminfo::parm","Container for static and dynamic variable arrays"],[2,"Param","","Types of parameters a capability can use"],[12,"String","","",1],[12,"Number","","",1],[3,"expand","","Expand a parameterized capability"],[10,"clone","","",1],[10,"new","","Return a new zero-initialized Variables",2],[10,"fmt","term::terminfo","",0],[10,"new","","",3],[10,"fg","","",3],[10,"bg","","",3],[10,"attr","","",3],[10,"supports_attr","","",3],[10,"reset","","",3],[10,"unwrap","","",3],[10,"get_ref","","",3],[10,"get_mut","","",3],[10,"write","","",3],[10,"flush","","",3],[0,"color","term","Terminal color definitions"],[4,"Color","term::color","Number for a terminal color"],[5,"BLACK","",""],[5,"RED","",""],[5,"GREEN","",""],[5,"YELLOW","",""],[5,"BLUE","",""],[5,"MAGENTA","",""],[5,"CYAN","",""],[5,"WHITE","",""],[5,"BRIGHT_BLACK","",""],[5,"BRIGHT_RED","",""],[5,"BRIGHT_GREEN","",""],[5,"BRIGHT_YELLOW","",""],[5,"BRIGHT_BLUE","",""],[5,"BRIGHT_MAGENTA","",""],[5,"BRIGHT_CYAN","",""],[5,"BRIGHT_WHITE","",""],[0,"attr","term","Terminal attributes"],[2,"Attr","term::attr","Terminal attributes for use with term.attr()."],[12,"Bold","","Bold (or possibly bright) mode",4],[12,"Dim","","Dim mode, also called faint or half-bright. Often not supported",4],[12,"Italic","","Italics mode. Often not supported",4],[12,"Underline","","Underline mode",4],[12,"Blink","","Blink mode",4],[12,"Standout","","Standout mode. Often implemented as Reverse, sometimes coupled with Bold",4],[12,"Reverse","","Reverse mode, inverts the foreground and background colors",4],[12,"Secure","","Secure mode, also called invis mode. Hides the printed text",4],[12,"ForegroundColor","","Convenience attribute to set the foreground color",4],[12,"BackgroundColor","","Convenience attribute to set the background color",4],[6,"Terminal","term","A terminal with similar capabilities to an ANSI Terminal\n(foreground/background colors etc)."],[9,"new","","Returns `None` whenever the terminal cannot be created for some\nreason.",5],[9,"fg","","Sets the foreground color to the given color.",5],[9,"bg","","Sets the background color to the given color.",5],[9,"attr","","Sets the given terminal attribute, if supported.  Returns `Ok(true)`\nif the attribute was supported, `Ok(false)` otherwise, and `Err(e)` if\nthere was an I/O error.",5],[9,"supports_attr","","Returns whether the given terminal attribute is supported.",5],[9,"reset","","Resets all terminal attributes and color to the default.\nReturns `Ok()`.",5],[9,"unwrap","","Returns the contained stream, destroying the `Terminal`",5],[9,"get_ref","","Gets an immutable reference to the stream inside",5],[9,"get_mut","","Gets a mutable reference to the stream inside",5],[10,"write","","",6],[10,"flush","","",6]],"paths":[[1,"TermInfo"],[2,"Param"],[1,"Variables"],[1,"TerminfoTerminal"],[2,"Attr"],[6,"Terminal"],[1,"WriterWrapper"]]};

searchIndex['glob'] = {"items":[[0,"","glob","Support for matching file paths against Unix shell style patterns."],[1,"Paths","","An iterator that yields Paths from the filesystem that match a particular\npattern - see the `glob` function for more details."],[1,"Pattern","","A compiled Unix shell style pattern."],[1,"MatchOptions","","Configuration options to modify the behaviour of `Pattern::matches_with(..)`"],[11,"case_sensitive","","Whether or not patterns should be matched in a case-sensitive manner. This\ncurrently only considers upper/lower case relationships between ASCII characters,\nbut in future this might be extended to work with Unicode.",0],[11,"require_literal_separator","","If this is true then path-component separator characters (e.g. `/` on Posix)\nmust be matched by a literal `/`, rather than by `*` or `?` or `[...]`",0],[11,"require_literal_leading_dot","","If this is true then paths that contain components that start with a `.` will\nnot match unless the `.` appears literally in the pattern: `*`, `?` or `[...]`\nwill not match. This is useful because such files are conventionally considered\nhidden on Unix systems and it might be desirable to skip them when listing files.",0],[3,"glob","","\nReturn an iterator that produces all the Paths that match the given pattern,\nwhich may be absolute or relative to the current working directory."],[3,"glob_with","","Return an iterator that produces all the Paths that match the given pattern,\nwhich may be absolute or relative to the current working directory."],[10,"next","","",1],[10,"default","","",2],[10,"hash","","",2],[10,"cmp","","",2],[10,"partial_cmp","","",2],[10,"lt","","",2],[10,"le","","",2],[10,"gt","","",2],[10,"ge","","",2],[10,"eq","","",2],[10,"ne","","",2],[10,"clone","","",2],[10,"new","","This function compiles Unix shell style patterns: `?` matches any single\ncharacter, `*` matches any (possibly empty) sequence of characters and\n`[...]` matches any character inside the brackets, unless the first\ncharacter is `!` in which case it matches any character except those\nbetween the `!` and the `]`. Character sequences can also specify ranges\nof characters, as ordered by Unicode, so e.g. `[0-9]` specifies any\ncharacter between 0 and 9 inclusive.",2],[10,"escape","","Escape metacharacters within the given string by surrounding them in\nbrackets. The resulting string will, when compiled into a `Pattern`,\nmatch the input string and nothing else.",2],[10,"matches","","Return if the given `str` matches this `Pattern` using the default\nmatch options (i.e. `MatchOptions::new()`).",2],[10,"matches_path","","Return if the given `Path`, when converted to a `str`, matches this `Pattern`\nusing the default match options (i.e. `MatchOptions::new()`).",2],[10,"matches_with","","Return if the given `str` matches this `Pattern` using the specified match options.",2],[10,"matches_path_with","","Return if the given `Path`, when converted to a `str`, matches this `Pattern`\nusing the specified match options.",2],[10,"default","","",0],[10,"hash","","",0],[10,"cmp","","",0],[10,"partial_cmp","","",0],[10,"lt","","",0],[10,"le","","",0],[10,"gt","","",0],[10,"ge","","",0],[10,"eq","","",0],[10,"ne","","",0],[10,"clone","","",0],[10,"new","","Constructs a new `MatchOptions` with default field values. This is used\nwhen calling functions that do not take an explicit `MatchOptions` parameter.",0]],"paths":[[1,"MatchOptions"],[1,"Paths"],[1,"Pattern"]]};

searchIndex['arena'] = {"items":[[0,"","arena","The arena, a fast but limited type of allocator."],[1,"Arena","","A slower reflection-based arena that can allocate objects of any type."],[1,"TypedArena","","A faster arena that can hold objects of only one type."],[10,"new","","Allocate a new Arena with 32 bytes preallocated.",0],[10,"new_with_size","","Allocate a new Arena with `initial_size` bytes preallocated.",0],[10,"drop","","",0],[10,"alloc","","Allocate a new item in the arena, using `op` to initialize the value\nand returning a reference to it.",0],[10,"new","","Creates a new TypedArena with preallocated space for 8 objects.",1],[10,"with_capacity","","Creates a new TypedArena with preallocated space for the given number of\nobjects.",1],[10,"alloc","","Allocates an object in the TypedArena, returning a reference to it.",1],[10,"drop","","",1]],"paths":[[1,"Arena"],[1,"TypedArena"]]};

searchIndex['flate'] = {"items":[[0,"","flate","Simple [DEFLATE][def]-based compression. This is a wrapper around the\n[`miniz`][mz] library, which is a one-file pure-C implementation of zlib."],[3,"deflate_bytes","","Compress a buffer, without writing any sort of header on the output."],[3,"deflate_bytes_zlib","","Compress a buffer, using a header that zlib can understand."],[3,"inflate_bytes","","Decompress a buffer, without parsing any sort of header on the input."],[3,"inflate_bytes_zlib","","Decompress a buffer that starts with a zlib header."]],"paths":[]};

searchIndex['native'] = {"items":[[0,"","native","The native I/O and threading crate"],[3,"lang_start","",""],[3,"start","","Executes the given procedure after initializing the runtime with the given\nargc/argv."],[3,"run","","Executes a procedure on the current thread in a Rust task context."],[0,"io","","Native thread-blocking I/O implementation"],[1,"IoFactory","native::io","Implementation of rt::rtio's IoFactory trait to generate handles to the\nnative I/O functionality."],[0,"addrinfo","",""],[1,"GetAddrInfoRequest","native::io::addrinfo",""],[10,"run","","",0],[0,"net","native::io",""],[1,"TcpStream","native::io::net",""],[1,"Guard","",""],[11,"fd","","",1],[11,"guard","","",1],[1,"TcpListener","",""],[1,"TcpAcceptor","",""],[1,"UdpSocket","",""],[3,"htons","",""],[3,"ntohs","",""],[3,"getsockopt","",""],[3,"sockaddr_to_addr","",""],[3,"init","",""],[3,"read","",""],[3,"write","",""],[4,"sock_t","",""],[10,"connect","","",2],[10,"fd","","",2],[10,"read","","",2],[10,"write","","",2],[10,"peer_name","","",2],[10,"control_congestion","","",2],[10,"nodelay","","",2],[10,"keepalive","","",2],[10,"letdie","","",2],[10,"clone","","",2],[10,"close_write","","",2],[10,"close_read","","",2],[10,"set_timeout","","",2],[10,"set_read_timeout","","",2],[10,"set_write_timeout","","",2],[10,"socket_name","","",2],[10,"drop","","",1],[10,"bind","","",3],[10,"fd","","",3],[10,"native_listen","","",3],[10,"listen","","",3],[10,"socket_name","","",3],[10,"fd","","",4],[10,"native_accept","","",4],[10,"socket_name","","",4],[10,"accept","","",4],[10,"accept_simultaneously","","",4],[10,"dont_accept_simultaneously","","",4],[10,"set_timeout","","",4],[10,"bind","","",5],[10,"fd","","",5],[10,"set_broadcast","","",5],[10,"set_multicast_loop","","",5],[10,"set_membership","","",5],[10,"socket_name","","",5],[10,"recv_from","","",5],[10,"send_to","","",5],[10,"join_multicast","","",5],[10,"leave_multicast","","",5],[10,"loop_multicast_locally","","",5],[10,"dont_loop_multicast_locally","","",5],[10,"multicast_time_to_live","","",5],[10,"time_to_live","","",5],[10,"hear_broadcasts","","",5],[10,"ignore_broadcasts","","",5],[10,"clone","","",5],[10,"set_timeout","","",5],[10,"set_read_timeout","","",5],[10,"set_write_timeout","","",5],[0,"process","native::io",""],[1,"Process","native::io::process","A value representing a child process."],[10,"spawn","","Creates a new process using native process-spawning abilities provided\nby the OS. Operations on this process will be blocking instead of using\nthe runtime for sleeping just this current task.",6],[10,"kill","","",6],[10,"id","","",6],[10,"set_timeout","","",6],[10,"wait","","",6],[10,"kill","","",6],[10,"drop","","",6],[0,"file","native::io","Blocking posix-based file I/O"],[1,"FileDesc","native::io::file",""],[1,"CFile","",""],[3,"open","",""],[3,"mkdir","",""],[3,"readdir","",""],[3,"unlink","",""],[3,"rename","",""],[3,"chmod","",""],[3,"rmdir","",""],[3,"chown","",""],[3,"readlink","",""],[3,"symlink","",""],[3,"link","",""],[3,"stat","",""],[3,"lstat","",""],[3,"utime","",""],[4,"fd_t","",""],[10,"new","","Create a `FileDesc` from an open C file descriptor.",7],[10,"inner_read","","",7],[10,"inner_write","","",7],[10,"fd","","",7],[10,"read","","",7],[10,"write","","",7],[10,"pread","","",7],[10,"pwrite","","",7],[10,"seek","","",7],[10,"tell","","",7],[10,"fsync","","",7],[10,"datasync","","",7],[10,"truncate","","",7],[10,"fstat","","",7],[10,"read","","",7],[10,"write","","",7],[10,"clone","","",7],[10,"close_read","","",7],[10,"close_write","","",7],[10,"set_timeout","","",7],[10,"set_read_timeout","","",7],[10,"set_write_timeout","","",7],[10,"read","","",7],[10,"write","","",7],[10,"set_raw","","",7],[10,"get_winsize","","",7],[10,"isatty","","",7],[10,"new","","Create a `CFile` from an open `FILE` pointer.",8],[10,"flush","","",8],[10,"read","","",8],[10,"write","","",8],[10,"pread","","",8],[10,"pwrite","","",8],[10,"seek","","",8],[10,"tell","","",8],[10,"fsync","","",8],[10,"datasync","","",8],[10,"truncate","","",8],[10,"fstat","","",8],[10,"drop","","",8],[0,"timer","native::io","Timers for non-linux/non-windows OSes"],[1,"Timer","native::io::timer",""],[2,"Req","",""],[12,"NewTimer","","",9],[12,"RemoveTimer","","",9],[3,"now","",""],[10,"new","","",10],[10,"sleep","","",10],[10,"sleep","","",10],[10,"oneshot","","",10],[10,"period","","",10],[10,"drop","","",10],[0,"pipe","native::io",""],[1,"UnixStream","native::io::pipe",""],[1,"UnixListener","",""],[1,"UnixAcceptor","",""],[10,"connect","","",11],[10,"read","","",11],[10,"write","","",11],[10,"clone","","",11],[10,"close_write","","",11],[10,"close_read","","",11],[10,"set_timeout","","",11],[10,"set_read_timeout","","",11],[10,"set_write_timeout","","",11],[10,"bind","","",12],[10,"native_listen","","",12],[10,"listen","","",12],[10,"native_accept","","",13],[10,"accept","","",13],[10,"set_timeout","","",13],[10,"drop","","",12],[10,"new","native::io","",14],[10,"tcp_connect","","",14],[10,"tcp_bind","","",14],[10,"udp_bind","","",14],[10,"unix_bind","","",14],[10,"unix_connect","","",14],[10,"get_host_addresses","","",14],[10,"fs_from_raw_fd","","",14],[10,"fs_open","","",14],[10,"fs_unlink","","",14],[10,"fs_stat","","",14],[10,"fs_mkdir","","",14],[10,"fs_chmod","","",14],[10,"fs_rmdir","","",14],[10,"fs_rename","","",14],[10,"fs_readdir","","",14],[10,"fs_lstat","","",14],[10,"fs_chown","","",14],[10,"fs_readlink","","",14],[10,"fs_symlink","","",14],[10,"fs_link","","",14],[10,"fs_utime","","",14],[10,"timer_init","","",14],[10,"spawn","","",14],[10,"kill","","",14],[10,"pipe_open","","",14],[10,"tty_open","","",14],[10,"signal","","",14],[0,"task","native","Tasks implemented on top of OS threads"],[1,"NativeSpawner","native::task","A spawner for native tasks"],[3,"new","","Creates a new Task which is ready to execute as a 1:1 task."],[3,"spawn","","Spawns a function with the default configuration"],[3,"spawn_opts","","Spawns a new task given the configuration options and a procedure to run\ninside the task."],[6,"NativeTaskBuilder","","An extension trait adding a `native` configuration method to `TaskBuilder`."],[9,"native","","",15],[10,"spawn","","",16],[10,"native","std::task","",17]],"paths":[[1,"GetAddrInfoRequest"],[1,"Guard"],[1,"TcpStream"],[1,"TcpListener"],[1,"TcpAcceptor"],[1,"UdpSocket"],[1,"Process"],[1,"FileDesc"],[1,"CFile"],[2,"Req"],[1,"Timer"],[1,"UnixStream"],[1,"UnixListener"],[1,"UnixAcceptor"],[1,"IoFactory"],[6,"NativeTaskBuilder"],[1,"NativeSpawner"],[1,"TaskBuilder"]]};

searchIndex['rustuv'] = {"items":[[0,"","rustuv","Bindings to libuv, along with the default implementation of `std::rt::rtio`."],[1,"ForbidSwitch","",""],[1,"ForbidUnwind","",""],[1,"Request","",""],[11,"handle","","",0],[1,"Loop","","FIXME: Loop(*handle) is buggy with destructors. Normal structs\nwith dtors may not be destructured, but tuple structs can,\nbut the results are not correct."],[1,"UvError","",""],[3,"event_loop","","Creates a new event loop which is powered by libuv"],[3,"uv_error_to_io_error","",""],[3,"status_to_maybe_uv_error","","Given a uv error code, convert a callback status to a UvError"],[3,"status_to_io_result","",""],[3,"empty_buf","",""],[3,"slice_to_uv_buf","","Borrow a slice to a Buf"],[0,"uvio","","The implementation of `rtio` for libuv"],[1,"UvEventLoop","rustuv::uvio",""],[1,"UvIoFactory","",""],[11,"loop_","","",1],[10,"new","","",2],[10,"drop","","",2],[10,"run","","",2],[10,"callback","","",2],[10,"pausable_idle_callback","","",2],[10,"remote_callback","","",2],[10,"io","","",2],[10,"has_active_io","","",2],[10,"uv_loop","","",1],[10,"make_handle","","",1],[10,"tcp_connect","","",1],[10,"tcp_bind","","",1],[10,"udp_bind","","",1],[10,"timer_init","","",1],[10,"get_host_addresses","","",1],[10,"fs_from_raw_fd","","",1],[10,"fs_open","","",1],[10,"fs_unlink","","",1],[10,"fs_lstat","","",1],[10,"fs_stat","","",1],[10,"fs_mkdir","","",1],[10,"fs_rmdir","","",1],[10,"fs_rename","","",1],[10,"fs_chmod","","",1],[10,"fs_readdir","","",1],[10,"fs_link","","",1],[10,"fs_symlink","","",1],[10,"fs_chown","","",1],[10,"fs_readlink","","",1],[10,"fs_utime","","",1],[10,"spawn","","",1],[10,"kill","","",1],[10,"unix_bind","","",1],[10,"unix_connect","","",1],[10,"tty_open","","",1],[10,"pipe_open","","",1],[10,"signal","","",1],[0,"uvll","rustuv","Low-level bindings to the libuv library."],[1,"uv_buf_t","rustuv::uvll",""],[11,"base","","",3],[11,"len","","",3],[1,"uv_process_options_t","",""],[11,"exit_cb","","",4],[11,"file","","",4],[11,"args","","",4],[11,"env","","",4],[11,"cwd","","",4],[11,"flags","","",4],[11,"stdio_count","","",4],[11,"stdio","","",4],[11,"uid","","",4],[11,"gid","","",4],[1,"uv_stdio_container_t","",""],[1,"uv_timespec_t","",""],[11,"tv_sec","","",5],[11,"tv_nsec","","",5],[1,"uv_stat_t","",""],[11,"st_dev","","",6],[11,"st_mode","","",6],[11,"st_nlink","","",6],[11,"st_uid","","",6],[11,"st_gid","","",6],[11,"st_rdev","","",6],[11,"st_ino","","",6],[11,"st_size","","",6],[11,"st_blksize","","",6],[11,"st_blocks","","",6],[11,"st_flags","","",6],[11,"st_gen","","",6],[11,"st_atim","","",6],[11,"st_mtim","","",6],[11,"st_ctim","","",6],[11,"st_birthtim","","",6],[2,"uv_run_mode","",""],[12,"RUN_DEFAULT","","",7],[12,"RUN_ONCE","","",7],[12,"RUN_NOWAIT","","",7],[2,"uv_poll_event","",""],[12,"UV_READABLE","","",8],[12,"UV_WRITABLE","","",8],[2,"uv_handle_type","",""],[12,"UV_UNKNOWN_HANDLE","","",9],[12,"UV_ASYNC","","",9],[12,"UV_CHECK","","",9],[12,"UV_FS_EVENT","","",9],[12,"UV_FS_POLL","","",9],[12,"UV_HANDLE","","",9],[12,"UV_IDLE","","",9],[12,"UV_NAMED_PIPE","","",9],[12,"UV_POLL","","",9],[12,"UV_PREPARE","","",9],[12,"UV_PROCESS","","",9],[12,"UV_STREAM","","",9],[12,"UV_TCP","","",9],[12,"UV_TIMER","","",9],[12,"UV_TTY","","",9],[12,"UV_UDP","","",9],[12,"UV_SIGNAL","","",9],[12,"UV_FILE","","",9],[12,"UV_HANDLE_TYPE_MAX","","",9],[2,"uv_req_type","",""],[12,"UV_UNKNOWN_REQ","","",10],[12,"UV_REQ","","",10],[12,"UV_CONNECT","","",10],[12,"UV_WRITE","","",10],[12,"UV_SHUTDOWN","","",10],[12,"UV_UDP_SEND","","",10],[12,"UV_FS","","",10],[12,"UV_WORK","","",10],[12,"UV_GETADDRINFO","","",10],[12,"UV_REQ_TYPE_MAX","","",10],[2,"uv_membership","",""],[12,"UV_LEAVE_GROUP","","",11],[12,"UV_JOIN_GROUP","","",11],[3,"malloc_handle","",""],[3,"free_handle","",""],[3,"malloc_req","",""],[3,"free_req","",""],[3,"loop_new","",""],[3,"uv_write","",""],[3,"uv_udp_send","",""],[3,"get_udp_handle_from_send_req","",""],[3,"process_pid","",""],[3,"set_stdio_container_flags","",""],[3,"set_stdio_container_fd","",""],[3,"set_stdio_container_stream","",""],[3,"get_result_from_fs_req","",""],[3,"get_ptr_from_fs_req","",""],[3,"get_path_from_fs_req","",""],[3,"get_loop_from_fs_req","",""],[3,"get_loop_from_getaddrinfo_req","",""],[3,"get_loop_for_uv_handle","",""],[3,"get_stream_handle_from_connect_req","",""],[3,"get_stream_handle_from_write_req","",""],[3,"get_data_for_uv_loop","",""],[3,"set_data_for_uv_loop","",""],[3,"get_data_for_uv_handle","",""],[3,"set_data_for_uv_handle","",""],[3,"get_data_for_req","",""],[3,"set_data_for_req","",""],[3,"populate_stat","",""],[3,"guess_handle","",""],[13,"uv_loop_delete","",""],[13,"uv_ref","",""],[13,"uv_unref","",""],[13,"uv_handle_size","",""],[13,"uv_req_size","",""],[13,"uv_run","",""],[13,"uv_close","",""],[13,"uv_walk","",""],[13,"uv_buf_init","",""],[13,"uv_strerror","",""],[13,"uv_err_name","",""],[13,"uv_listen","",""],[13,"uv_accept","",""],[13,"uv_read_start","",""],[13,"uv_read_stop","",""],[13,"uv_shutdown","",""],[13,"uv_idle_init","",""],[13,"uv_idle_start","",""],[13,"uv_idle_stop","",""],[13,"uv_async_init","",""],[13,"uv_async_send","",""],[13,"uv_tcp_init","",""],[13,"uv_tcp_connect","",""],[13,"uv_tcp_bind","",""],[13,"uv_tcp_nodelay","",""],[13,"uv_tcp_keepalive","",""],[13,"uv_tcp_simultaneous_accepts","",""],[13,"uv_tcp_getsockname","",""],[13,"uv_tcp_getpeername","",""],[13,"uv_udp_init","",""],[13,"uv_udp_bind","",""],[13,"uv_udp_recv_start","",""],[13,"uv_udp_set_membership","",""],[13,"uv_udp_recv_stop","",""],[13,"uv_udp_set_multicast_loop","",""],[13,"uv_udp_set_multicast_ttl","",""],[13,"uv_udp_set_ttl","",""],[13,"uv_udp_set_broadcast","",""],[13,"uv_udp_getsockname","",""],[13,"uv_timer_init","",""],[13,"uv_timer_start","",""],[13,"uv_timer_stop","",""],[13,"uv_fs_open","",""],[13,"uv_fs_unlink","",""],[13,"uv_fs_write","",""],[13,"uv_fs_read","",""],[13,"uv_fs_close","",""],[13,"uv_fs_stat","",""],[13,"uv_fs_fstat","",""],[13,"uv_fs_mkdir","",""],[13,"uv_fs_rmdir","",""],[13,"uv_fs_readdir","",""],[13,"uv_fs_req_cleanup","",""],[13,"uv_fs_fsync","",""],[13,"uv_fs_fdatasync","",""],[13,"uv_fs_ftruncate","",""],[13,"uv_fs_readlink","",""],[13,"uv_fs_symlink","",""],[13,"uv_fs_rename","",""],[13,"uv_fs_utime","",""],[13,"uv_fs_link","",""],[13,"uv_fs_chown","",""],[13,"uv_fs_chmod","",""],[13,"uv_fs_lstat","",""],[13,"uv_poll_init_socket","",""],[13,"uv_poll_start","",""],[13,"uv_poll_stop","",""],[13,"uv_getaddrinfo","",""],[13,"uv_freeaddrinfo","",""],[13,"uv_spawn","",""],[13,"uv_process_kill","",""],[13,"uv_kill","",""],[13,"uv_pipe_init","",""],[13,"uv_pipe_open","",""],[13,"uv_pipe_bind","",""],[13,"uv_pipe_connect","",""],[13,"uv_tty_init","",""],[13,"uv_tty_set_mode","",""],[13,"uv_tty_get_winsize","",""],[13,"uv_signal_init","",""],[13,"uv_signal_start","",""],[13,"uv_signal_stop","",""],[0,"errors","",""],[5,"EACCES","rustuv::uvll::errors",""],[5,"ECONNREFUSED","",""],[5,"ECONNRESET","",""],[5,"ENOENT","",""],[5,"ENOTCONN","",""],[5,"EPIPE","",""],[5,"ECONNABORTED","",""],[5,"ECANCELED","",""],[5,"EBADF","",""],[5,"EADDRNOTAVAIL","",""],[5,"EADDRINUSE","",""],[5,"EPERM","",""],[4,"uv_buf_len_t","rustuv::uvll",""],[4,"uv_os_socket_t","",""],[4,"uv_handle_t","",""],[4,"uv_req_t","",""],[4,"uv_loop_t","",""],[4,"uv_idle_t","",""],[4,"uv_tcp_t","",""],[4,"uv_udp_t","",""],[4,"uv_poll_t","",""],[4,"uv_connect_t","",""],[4,"uv_connection_t","",""],[4,"uv_write_t","",""],[4,"uv_async_t","",""],[4,"uv_timer_t","",""],[4,"uv_stream_t","",""],[4,"uv_fs_t","",""],[4,"uv_udp_send_t","",""],[4,"uv_getaddrinfo_t","",""],[4,"uv_process_t","",""],[4,"uv_pipe_t","",""],[4,"uv_tty_t","",""],[4,"uv_signal_t","",""],[4,"uv_shutdown_t","",""],[4,"uv_idle_cb","",""],[4,"uv_alloc_cb","",""],[4,"uv_read_cb","",""],[4,"uv_udp_send_cb","",""],[4,"uv_udp_recv_cb","",""],[4,"uv_close_cb","",""],[4,"uv_poll_cb","",""],[4,"uv_walk_cb","",""],[4,"uv_async_cb","",""],[4,"uv_connect_cb","",""],[4,"uv_connection_cb","",""],[4,"uv_timer_cb","",""],[4,"uv_write_cb","",""],[4,"uv_getaddrinfo_cb","",""],[4,"uv_exit_cb","",""],[4,"uv_signal_cb","",""],[4,"uv_fs_cb","",""],[4,"uv_shutdown_cb","",""],[4,"uv_uid_t","",""],[4,"uv_gid_t","",""],[5,"OK","",""],[5,"EOF","",""],[5,"UNKNOWN","",""],[5,"PROCESS_SETUID","",""],[5,"PROCESS_SETGID","",""],[5,"PROCESS_WINDOWS_VERBATIM_ARGUMENTS","",""],[5,"PROCESS_DETACHED","",""],[5,"PROCESS_WINDOWS_HIDE","",""],[5,"STDIO_IGNORE","",""],[5,"STDIO_CREATE_PIPE","",""],[5,"STDIO_INHERIT_FD","",""],[5,"STDIO_INHERIT_STREAM","",""],[5,"STDIO_READABLE_PIPE","",""],[5,"STDIO_WRITABLE_PIPE","",""],[10,"new","","",6],[10,"is_file","","",6],[10,"is_dir","","",6],[10,"eq","","",9],[10,"ne","","",9],[10,"eq","","",10],[10,"ne","","",10],[10,"eq","","",11],[10,"ne","","",11],[0,"file","rustuv",""],[1,"FsRequest","rustuv::file",""],[1,"FileWatcher","",""],[10,"open","","",12],[10,"unlink","","",12],[10,"lstat","","",12],[10,"stat","","",12],[10,"fstat","","",12],[10,"write","","",12],[10,"read","","",12],[10,"mkdir","","",12],[10,"rmdir","","",12],[10,"rename","","",12],[10,"chmod","","",12],[10,"readdir","","",12],[10,"readlink","","",12],[10,"chown","","",12],[10,"truncate","","",12],[10,"link","","",12],[10,"symlink","","",12],[10,"fsync","","",12],[10,"datasync","","",12],[10,"utime","","",12],[10,"get_result","","",12],[10,"get_stat","","",12],[10,"get_ptr","","",12],[10,"mkstat","","",12],[10,"drop","","",12],[10,"new","","",13],[10,"drop","","",13],[10,"read","","",13],[10,"write","","",13],[10,"pread","","",13],[10,"pwrite","","",13],[10,"seek","","",13],[10,"tell","","",13],[10,"fsync","","",13],[10,"datasync","","",13],[10,"truncate","","",13],[10,"fstat","","",13],[0,"net","rustuv",""],[1,"TcpWatcher","rustuv::net","TCP implementation"],[1,"TcpListener","",""],[1,"TcpAcceptor","",""],[1,"UdpWatcher","","UDP implementation"],[3,"htons","","Generic functions related to dealing with sockaddr things"],[3,"ntohs","",""],[3,"sockaddr_to_addr","",""],[3,"shutdown","",""],[10,"new","","",14],[10,"connect","","",14],[10,"socket_name","","",14],[10,"read","","",14],[10,"write","","",14],[10,"peer_name","","",14],[10,"control_congestion","","",14],[10,"nodelay","","",14],[10,"keepalive","","",14],[10,"letdie","","",14],[10,"clone","","",14],[10,"close_read","","",14],[10,"close_write","","",14],[10,"set_timeout","","",14],[10,"set_read_timeout","","",14],[10,"set_write_timeout","","",14],[10,"uv_handle","","",14],[10,"drop","","",14],[10,"bind","","",15],[10,"uv_handle","","",15],[10,"socket_name","","",15],[10,"listen","","",15],[10,"drop","","",15],[10,"socket_name","","",16],[10,"accept","","",16],[10,"accept_simultaneously","","",16],[10,"dont_accept_simultaneously","","",16],[10,"set_timeout","","",16],[10,"bind","","",17],[10,"uv_handle","","",17],[10,"socket_name","","",17],[10,"recv_from","","",17],[10,"send_to","","",17],[10,"join_multicast","","",17],[10,"leave_multicast","","",17],[10,"loop_multicast_locally","","",17],[10,"dont_loop_multicast_locally","","",17],[10,"multicast_time_to_live","","",17],[10,"time_to_live","","",17],[10,"hear_broadcasts","","",17],[10,"ignore_broadcasts","","",17],[10,"clone","","",17],[10,"set_timeout","","",17],[10,"set_read_timeout","","",17],[10,"set_write_timeout","","",17],[10,"drop","","",17],[0,"idle","rustuv",""],[1,"IdleWatcher","rustuv::idle",""],[10,"new","","",18],[10,"onetime","","",18],[10,"pause","","",18],[10,"resume","","",18],[10,"uv_handle","","",18],[10,"drop","","",18],[0,"timer","rustuv",""],[1,"TimerWatcher","rustuv::timer",""],[11,"handle","","",19],[2,"NextAction","",""],[12,"WakeTask","","",20],[12,"CallOnce","","",20],[12,"CallMany","","",20],[10,"new","","",19],[10,"new_home","","",19],[10,"start","","",19],[10,"stop","","",19],[10,"set_data","","",19],[10,"uv_handle","","",19],[10,"sleep","","",19],[10,"oneshot","","",19],[10,"period","","",19],[10,"drop","","",19],[0,"async","rustuv",""],[1,"AsyncWatcher","rustuv::async",""],[10,"new","","",21],[10,"uv_handle","","",21],[10,"from_uv_handle","","",21],[10,"fire","","",21],[10,"drop","","",21],[0,"addrinfo","rustuv",""],[1,"GetAddrInfoRequest","rustuv::addrinfo",""],[3,"accum_addrinfo","",""],[10,"run","","",22],[0,"process","rustuv",""],[1,"Process","rustuv::process",""],[10,"spawn","","Spawn a new process inside the specified event loop.",23],[10,"kill","","",23],[10,"uv_handle","","",23],[10,"id","","",23],[10,"kill","","",23],[10,"wait","","",23],[10,"set_timeout","","",23],[10,"drop","","",23],[0,"pipe","rustuv",""],[1,"PipeWatcher","rustuv::pipe",""],[1,"PipeListener","",""],[1,"PipeAcceptor","",""],[10,"new","","",24],[10,"new_home","","",24],[10,"open","","",24],[10,"connect","","",24],[10,"handle","","",24],[10,"read","","",24],[10,"write","","",24],[10,"clone","","",24],[10,"close_read","","",24],[10,"close_write","","",24],[10,"set_timeout","","",24],[10,"set_read_timeout","","",24],[10,"set_write_timeout","","",24],[10,"uv_handle","","",24],[10,"drop","","",24],[10,"bind","","",25],[10,"listen","","",25],[10,"uv_handle","","",25],[10,"drop","","",25],[10,"accept","","",26],[10,"set_timeout","","",26],[0,"tty","rustuv",""],[1,"TtyWatcher","rustuv::tty",""],[10,"new","","",27],[10,"read","","",27],[10,"write","","",27],[10,"set_raw","","",27],[10,"get_winsize","","",27],[10,"isatty","","",27],[10,"uv_handle","","",27],[10,"drop","","",27],[0,"signal","rustuv",""],[1,"SignalWatcher","rustuv::signal",""],[10,"new","","",28],[10,"uv_handle","","",28],[10,"drop","","",28],[0,"stream","rustuv",""],[1,"StreamWatcher","rustuv::stream",""],[11,"handle","","",29],[10,"new","","",29],[10,"read","","",29],[10,"cancel_read","","",29],[10,"write","","",29],[10,"cancel_write","","",29],[4,"Buf","rustuv","The uv buffer type"],[6,"UvHandle","","A type that wraps a uv handle"],[9,"uv_handle","","",30],[10,"uv_loop","","",30],[10,"alloc","","",30],[10,"from_uv_handle","","",30],[10,"install","","",30],[10,"close_async_","","",30],[10,"close","","",30],[10,"drop","","",31],[10,"drop","","",32],[10,"new","","",0],[10,"wrap","","",0],[10,"set_data","","",0],[10,"get_data","","",0],[10,"defuse","","",0],[10,"drop","","",0],[10,"new","","",33],[10,"wrap","","",33],[10,"run","","",33],[10,"close","","",33],[10,"name","","",34],[10,"desc","","",34],[10,"is_eof","","",34],[10,"fmt","","",34]],"paths":[[1,"Request"],[1,"UvIoFactory"],[1,"UvEventLoop"],[1,"uv_buf_t"],[1,"uv_process_options_t"],[1,"uv_timespec_t"],[1,"uv_stat_t"],[2,"uv_run_mode"],[2,"uv_poll_event"],[2,"uv_handle_type"],[2,"uv_req_type"],[2,"uv_membership"],[1,"FsRequest"],[1,"FileWatcher"],[1,"TcpWatcher"],[1,"TcpListener"],[1,"TcpAcceptor"],[1,"UdpWatcher"],[1,"IdleWatcher"],[1,"TimerWatcher"],[2,"NextAction"],[1,"AsyncWatcher"],[1,"GetAddrInfoRequest"],[1,"Process"],[1,"PipeWatcher"],[1,"PipeListener"],[1,"PipeAcceptor"],[1,"TtyWatcher"],[1,"SignalWatcher"],[1,"StreamWatcher"],[6,"UvHandle"],[1,"ForbidSwitch"],[1,"ForbidUnwind"],[1,"Loop"],[1,"UvError"]]};

searchIndex['green'] = {"items":[[0,"","green","The \"green scheduling\" library"],[1,"PoolConfig","","Configuration of how an M:N pool of schedulers is spawned."],[11,"threads","","The number of schedulers (OS threads) to spawn into this M:N pool.",0],[11,"event_loop_factory","","A factory function used to create new event loops. If this is not\nspecified then the default event loop factory is used.",0],[1,"SchedPool","","A structure representing a handle to a pool of schedulers. This handle is\nused to keep the pool alive and also reap the status from the pool."],[1,"GreenSpawner","","A spawner for green tasks"],[3,"start","","Set up a default runtime configuration, given compiler-supplied arguments."],[3,"run","","Execute the main function in a pool of M:N schedulers."],[0,"basic","","This is a basic event loop implementation not meant for any \"real purposes\"\nother than testing the scheduler and proving that it's possible to have a\npluggable event loop."],[3,"event_loop","green::basic","This is the only exported function from this module."],[0,"context","green",""],[1,"Context","green::context",""],[3,"mut_offset","",""],[4,"InitFn","",""],[10,"empty","","",1],[10,"new","","Create a new context that will resume execution by running proc()",1],[10,"swap","","",1],[0,"coroutine","green",""],[1,"Coroutine","green::coroutine","A coroutine is nothing more than a (register context, stack) pair."],[11,"current_stack_segment","","The segment of stack on which the task is currently running or\nif the task is blocked, on which the task will resume\nexecution.",2],[11,"saved_context","","Always valid if the task is alive and not running.",2],[10,"empty","","",2],[10,"recycle","","Destroy coroutine and try to reuse std::stack segment.",2],[0,"sched","green",""],[1,"Scheduler","green::sched","A scheduler is responsible for coordinating the execution of Tasks\non a single thread. The scheduler runs inside a slightly modified\nRust Task. When not running this task is stored in the scheduler\nstruct. The scheduler struct acts like a baton, all scheduling\nactions are transfers of the baton."],[11,"pool_id","","ID number of the pool that this scheduler is a member of. When\nreawakening green tasks, this is used to ensure that tasks aren't\nreawoken on the wrong pool of schedulers.",3],[11,"stack_pool","","The pool of stacks that this scheduler has cached",3],[11,"task_state","","Bookkeeping for the number of tasks which are currently running around\ninside this pool of schedulers",3],[11,"event_loop","","The event loop used to drive the scheduler and perform I/O",3],[1,"SchedHandle","",""],[11,"sched_id","","",4],[2,"SchedMessage","",""],[12,"Wake","","",5],[12,"Shutdown","","",5],[12,"NewNeighbor","","",5],[12,"PinnedTask","","",5],[12,"TaskFromFriend","","",5],[12,"RunOnce","","",5],[6,"ClosureConverter","",""],[9,"from_fn","","",6],[9,"to_fn","","",6],[10,"new","","",3],[10,"new_special","","",3],[10,"bootstrap","","",3],[10,"run","","",3],[10,"enqueue_task","","Schedule a task to be executed later.",3],[10,"change_task_context","","",3],[10,"get_contexts","","",3],[10,"resume_task_immediately","","",3],[10,"deschedule_running_task_and_then","","Block a running task, context switch to the scheduler, then pass the\nblocked task to a closure.",3],[10,"switch_running_tasks_and_then","","",3],[10,"terminate_current_task","","Called by a running task to end execution, after which it will\nbe recycled by the scheduler for reuse in a new task.",3],[10,"run_task","","",3],[10,"run_task_later","","",3],[10,"yield_now","","Yield control to the scheduler, executing another task. This is guaranteed\nto introduce some amount of randomness to the scheduler. Currently the\nrandomness is a result of performing a round of work stealing (which\nmay end up stealing from the current scheduler).",3],[10,"maybe_yield","","",3],[10,"sched_id","","",3],[10,"run_cleanup_job","","",3],[10,"make_handle","","",3],[10,"send","","",4],[0,"sleeper_list","green","Maintains a shared list of sleeping schedulers. Schedulers\nuse this to wake each other up."],[1,"SleeperList","green::sleeper_list",""],[10,"new","","",7],[10,"push","","",7],[10,"pop","","",7],[10,"casual_pop","","",7],[10,"clone","","",7],[0,"stack","green",""],[1,"Stack","green::stack","A task's stack. The name \"Stack\" is a vestige of segmented stacks."],[1,"StackPool","",""],[10,"new","","Allocate a new stack of `size`. If size = 0, this will fail. Use\n`dummy_stack` if you want a zero-sized stack.",8],[10,"dummy_stack","","Create a 0-length stack which starts (and ends) at 0.",8],[10,"start","","Point to the low end of the allocated stack",8],[10,"end","","Point one uint beyond the high end of the allocated stack",8],[10,"drop","","",8],[10,"new","","",9],[10,"take_stack","","",9],[10,"give_stack","","",9],[0,"task","green","The Green Task implementation"],[1,"GreenTask","green::task","The necessary fields needed to keep track of a green task (as opposed to a\n1:1 task)."],[11,"coroutine","","Coroutine that this task is running on, otherwise known as the register\ncontext and the stack that this task owns. This field is optional to\nrelinquish ownership back to a scheduler to recycle stacks at a later\ndate.",10],[11,"handle","","Optional handle back into the home sched pool of this task. This field\nis lazily initialized.",10],[11,"sched","","Slot for maintaining ownership of a scheduler. If a task is running,\nthis value will be Some(sched) where the task is running on \"sched\".",10],[11,"task","","Temporary ownership slot of a std::rt::task::Task object. This is used\nto squirrel that libstd task away while we're performing green task\noperations.",10],[11,"task_type","","Dictates whether this is a sched task or a normal green task",10],[11,"pool_id","","Home pool that this task was spawned into. This field is lazily\ninitialized until when the task is initially scheduled, and is used to\nmake sure that tasks are always woken up in the correct pool of\nschedulers.",10],[11,"nasty_deschedule_lock","","",10],[2,"TaskType","",""],[12,"TypeGreen","","",11],[12,"TypeSched","","",11],[2,"Home","",""],[12,"AnySched","","",12],[12,"HomeSched","","",12],[10,"new","","Creates a new green task which is not homed to any particular scheduler\nand will not have any contained Task structure.",10],[10,"new_homed","","Creates a new task (like `new`), but specifies the home for new task.",10],[10,"new_typed","","Creates a new green task with the specified coroutine and type, this is\nuseful when creating scheduler tasks.",10],[10,"configure","","Creates a new green task with the given configuration options for the\ncontained Task object. The given stack pool is also used to allocate a\nnew stack for this task.",10],[10,"convert","","Just like the `maybe_take_runtime` function, this function should *not*\nexist. Usage of this function is _strongly_ discouraged. This is an\nabsolute last resort necessary for converting a libstd task to a green\ntask.",10],[10,"give_home","","",10],[10,"take_unwrap_home","","",10],[10,"is_home_no_tls","","",10],[10,"homed","","",10],[10,"is_sched","","",10],[10,"as_uint","","",10],[10,"from_uint","","",10],[10,"put_with_sched","","",10],[10,"put_task","","",10],[10,"swap","","",10],[10,"put","","",10],[10,"yield_now","","",10],[10,"maybe_yield","","",10],[10,"deschedule","","",10],[10,"reawaken","","",10],[10,"spawn_sibling","","",10],[10,"local_io","","",10],[10,"stack_bounds","","",10],[10,"can_block","","",10],[10,"wrap","","",10],[6,"GreenTaskBuilder","green","An extension trait adding `green` configuration methods to `TaskBuilder`."],[9,"green","","",13],[9,"green_pinned","","",13],[10,"new","","Returns the default configuration, as determined the environment\nvariables of this process.",0],[10,"new","","Execute the main function in a pool of M:N schedulers.",14],[10,"task","","Creates a new task configured to run inside of this pool of schedulers.\nThis is useful to create a task which can then be sent to a specific\nscheduler created by `spawn_sched` (and possibly pin it to that\nscheduler).",14],[10,"spawn","","Spawns a new task into this pool of schedulers, using the specified\noptions to configure the new task which is spawned.",14],[10,"spawn_sched","","Spawns a new scheduler into this M:N pool. A handle is returned to the\nscheduler for use. The scheduler will not exit as long as this handle is\nactive.",14],[10,"shutdown","","Consumes the pool of schedulers, waiting for all tasks to exit and all\nschedulers to shut down.",14],[10,"drop","","",14],[10,"spawn","","",15],[10,"green","std::task","",16],[10,"green_pinned","","",16],[15,"green_start!","green","A helper macro for booting a program with libgreen"]],"paths":[[1,"PoolConfig"],[1,"Context"],[1,"Coroutine"],[1,"Scheduler"],[1,"SchedHandle"],[2,"SchedMessage"],[6,"ClosureConverter"],[1,"SleeperList"],[1,"Stack"],[1,"StackPool"],[1,"GreenTask"],[2,"TaskType"],[2,"Home"],[6,"GreenTaskBuilder"],[1,"SchedPool"],[1,"GreenSpawner"],[1,"TaskBuilder"]]};

searchIndex['std'] = {"items":[[0,"","std","# The Rust Standard Library"],[0,"macros","","Standard library macros"],[0,"builtin","std::macros","Built-in macros to the compiler itself."],[0,"bitflags","std","The `bitflags!` macro generates a `struct` that holds a set of C-style\nbitmask flags. It is useful for creating typesafe wrappers for C APIs."],[0,"prelude","","The Rust prelude"],[0,"int","","Operations and constants for architecture-sized signed integers (`int` type)"],[3,"parse_bytes","std::int","Parse a byte slice as a number in the given base"],[3,"to_str_bytes","","Convert to a string as a byte slice in a given base."],[5,"BITS","",""],[5,"BYTES","",""],[5,"MIN","",""],[5,"MAX","",""],[16,"int","","Operations and constants for architecture-sized signed integers (`int` type)"],[0,"i8","std","Operations and constants for signed 8-bits integers (`i8` type)"],[3,"parse_bytes","std::i8","Parse a byte slice as a number in the given base"],[3,"to_str_bytes","","Convert to a string as a byte slice in a given base."],[5,"BITS","",""],[5,"BYTES","",""],[5,"MIN","",""],[5,"MAX","",""],[16,"i8","","Operations and constants for signed 8-bits integers (`i8` type)"],[0,"i16","std","Operations and constants for signed 16-bits integers (`i16` type)"],[3,"parse_bytes","std::i16","Parse a byte slice as a number in the given base"],[3,"to_str_bytes","","Convert to a string as a byte slice in a given base."],[5,"BITS","",""],[5,"BYTES","",""],[5,"MIN","",""],[5,"MAX","",""],[16,"i16","","Operations and constants for signed 16-bits integers (`i16` type)"],[0,"i32","std","Operations and constants for signed 32-bits integers (`i32` type)"],[3,"parse_bytes","std::i32","Parse a byte slice as a number in the given base"],[3,"to_str_bytes","","Convert to a string as a byte slice in a given base."],[5,"BITS","",""],[5,"BYTES","",""],[5,"MIN","",""],[5,"MAX","",""],[16,"i32","","Operations and constants for signed 32-bits integers (`i32` type)"],[0,"i64","std","Operations and constants for signed 64-bits integers (`i64` type)"],[3,"parse_bytes","std::i64","Parse a byte slice as a number in the given base"],[3,"to_str_bytes","","Convert to a string as a byte slice in a given base."],[5,"BITS","",""],[5,"BYTES","",""],[5,"MIN","",""],[5,"MAX","",""],[16,"i64","","Operations and constants for signed 64-bits integers (`i64` type)"],[0,"uint","std","Operations and constants for architecture-sized unsigned integers (`uint` type)"],[3,"parse_bytes","std::uint","Parse a byte slice as a number in the given base"],[3,"to_str_bytes","","Convert to a string as a byte slice in a given base."],[5,"BITS","",""],[5,"BYTES","",""],[5,"MIN","",""],[5,"MAX","",""],[16,"uint","","Operations and constants for architecture-sized unsigned integers (`uint` type)"],[0,"u8","std","Operations and constants for unsigned 8-bits integers (`u8` type)"],[3,"parse_bytes","std::u8","Parse a byte slice as a number in the given base"],[3,"to_str_bytes","","Convert to a string as a byte slice in a given base."],[5,"BITS","",""],[5,"BYTES","",""],[5,"MIN","",""],[5,"MAX","",""],[16,"u8","","Operations and constants for unsigned 8-bits integers (`u8` type)"],[0,"u16","std","Operations and constants for unsigned 16-bits integers (`u16` type)"],[3,"parse_bytes","std::u16","Parse a byte slice as a number in the given base"],[3,"to_str_bytes","","Convert to a string as a byte slice in a given base."],[5,"BITS","",""],[5,"BYTES","",""],[5,"MIN","",""],[5,"MAX","",""],[16,"u16","","Operations and constants for unsigned 16-bits integers (`u16` type)"],[0,"u32","std","Operations and constants for unsigned 32-bits integers (`u32` type)"],[3,"parse_bytes","std::u32","Parse a byte slice as a number in the given base"],[3,"to_str_bytes","","Convert to a string as a byte slice in a given base."],[5,"BITS","",""],[5,"BYTES","",""],[5,"MIN","",""],[5,"MAX","",""],[16,"u32","","Operations and constants for unsigned 32-bits integers (`u32` type)"],[0,"u64","std","Operations and constants for unsigned 64-bits integer (`u64` type)"],[3,"parse_bytes","std::u64","Parse a byte slice as a number in the given base"],[3,"to_str_bytes","","Convert to a string as a byte slice in a given base."],[5,"BITS","",""],[5,"BYTES","",""],[5,"MIN","",""],[5,"MAX","",""],[16,"u64","","Operations and constants for unsigned 64-bits integer (`u64` type)"],[0,"f32","std","Operations and constants for 32-bits floats (`f32` type)"],[3,"to_string","std::f32","Converts a float to a string"],[3,"to_str_hex","","Converts a float to a string in hexadecimal format"],[3,"to_str_radix_special","","Converts a float to a string in a given radix, and a flag indicating\nwhether it's a special value"],[3,"to_str_exact","","Converts a float to a string with exactly the number of\nprovided significant digits"],[3,"to_str_digits","","Converts a float to a string with a maximum number of\nsignificant digits"],[3,"to_str_exp_exact","","Converts a float to a string using the exponential notation with exactly the number of\nprovided digits after the decimal point in the significand"],[3,"to_str_exp_digits","","Converts a float to a string using the exponential notation with the maximum number of\ndigits after the decimal point in the significand"],[3,"from_str_hex","","Convert a string in base 16 to a float.\nAccepts an optional binary exponent."],[5,"RADIX","",""],[5,"MANTISSA_DIGITS","",""],[5,"DIGITS","",""],[5,"EPSILON","",""],[5,"MIN_VALUE","",""],[5,"MIN_POS_VALUE","",""],[5,"MAX_VALUE","",""],[5,"MIN_EXP","",""],[5,"MAX_EXP","",""],[5,"MIN_10_EXP","",""],[5,"MAX_10_EXP","",""],[5,"NAN","",""],[5,"INFINITY","",""],[5,"NEG_INFINITY","",""],[0,"consts","","Various useful constants."],[5,"PI","std::f32::consts",""],[5,"PI_2","",""],[5,"FRAC_PI_2","",""],[5,"FRAC_PI_3","",""],[5,"FRAC_PI_4","",""],[5,"FRAC_PI_6","",""],[5,"FRAC_PI_8","",""],[5,"FRAC_1_PI","",""],[5,"FRAC_2_PI","",""],[5,"FRAC_2_SQRTPI","",""],[5,"SQRT2","",""],[5,"FRAC_1_SQRT2","",""],[5,"E","",""],[5,"LOG2_E","",""],[5,"LOG10_E","",""],[5,"LN_2","",""],[5,"LN_10","",""],[16,"f32","std::f32","Operations and constants for 32-bits floats (`f32` type)"],[0,"f64","std","Operations and constants for 64-bits floats (`f64` type)"],[3,"to_string","std::f64","Converts a float to a string"],[3,"to_str_hex","","Converts a float to a string in hexadecimal format"],[3,"to_str_radix_special","","Converts a float to a string in a given radix, and a flag indicating\nwhether it's a special value"],[3,"to_str_exact","","Converts a float to a string with exactly the number of\nprovided significant digits"],[3,"to_str_digits","","Converts a float to a string with a maximum number of\nsignificant digits"],[3,"to_str_exp_exact","","Converts a float to a string using the exponential notation with exactly the number of\nprovided digits after the decimal point in the significand"],[3,"to_str_exp_digits","","Converts a float to a string using the exponential notation with the maximum number of\ndigits after the decimal point in the significand"],[3,"from_str_hex","","Convert a string in base 16 to a float.\nAccepts an optional binary exponent."],[5,"RADIX","",""],[5,"MANTISSA_DIGITS","",""],[5,"DIGITS","",""],[5,"EPSILON","",""],[5,"MIN_VALUE","",""],[5,"MIN_POS_VALUE","",""],[5,"MAX_VALUE","",""],[5,"MIN_EXP","",""],[5,"MAX_EXP","",""],[5,"MIN_10_EXP","",""],[5,"MAX_10_EXP","",""],[5,"NAN","",""],[5,"INFINITY","",""],[5,"NEG_INFINITY","",""],[0,"consts","","Various useful constants."],[5,"PI","std::f64::consts",""],[5,"PI_2","",""],[5,"FRAC_PI_2","",""],[5,"FRAC_PI_3","",""],[5,"FRAC_PI_4","",""],[5,"FRAC_PI_6","",""],[5,"FRAC_PI_8","",""],[5,"FRAC_1_PI","",""],[5,"FRAC_2_PI","",""],[5,"FRAC_2_SQRTPI","",""],[5,"SQRT2","",""],[5,"FRAC_1_SQRT2","",""],[5,"E","",""],[5,"LOG2_E","",""],[5,"LOG10_E","",""],[5,"LN_2","",""],[5,"LN_10","",""],[16,"f64","std::f64","Operations and constants for 64-bits floats (`f64` type)"],[0,"rand","std","Utilities for random number generation"],[1,"OsRng","std::rand","A random number generator that retrieves randomness straight from\nthe operating system. Platform sources:"],[1,"StdRng","","The standard RNG. This is designed to be efficient on the current\nplatform."],[1,"TaskRng","","The task-local RNG."],[3,"weak_rng","","Create a weak random number generator with a default algorithm and seed."],[3,"task_rng","","Retrieve the lazily-initialized task-local random number\ngenerator, seeded by the system. Intended to be used in method\nchaining style, e.g. `task_rng().gen::<int>()`."],[3,"random","","Generates a random value using the task-local random number generator."],[3,"sample","","Randomly sample up to `amount` elements from an iterator."],[0,"os","","Interfaces to the operating system provided random number\ngenerators."],[1,"OsRng","std::rand::os","A random number generator that retrieves randomness straight from\nthe operating system. Platform sources:"],[0,"reader","std::rand","A wrapper around any Reader to treat it as an RNG."],[1,"ReaderRng","std::rand::reader","An RNG that reads random bytes straight from a `Reader`. This will\nwork best with an infinite reader, but this is not required."],[10,"new","","Create a new `ReaderRng` from a `Reader`.",0],[10,"next_u32","","",0],[10,"next_u64","","",0],[10,"fill_bytes","","",0],[10,"new","std::rand","Create a randomly seeded instance of `StdRng`.",1],[10,"next_u32","","",1],[10,"next_u64","","",1],[10,"reseed","","",1],[10,"from_seed","","",1],[10,"next_u32","","",2],[10,"next_u64","","",2],[10,"fill_bytes","","",2],[6,"Rand","","A type that can be randomly generated using an `Rng`."],[9,"rand","","Generates a random instance of this type using the specified source of\nrandomness.",3],[6,"Rng","","A random number generator."],[9,"next_u32","","Return the next random u32.",4],[9,"next_u64","","Return the next random u64.",4],[9,"fill_bytes","","Fill `dest` with random data.",4],[9,"gen","","Return a random value of a `Rand` type.",4],[9,"gen_iter","","Return an iterator which will yield an infinite number of randomly\ngenerated items.",4],[9,"gen_range","","Generate a random value in the range [`low`, `high`). Fails if\n`low >= high`.",4],[9,"gen_weighted_bool","","Return a bool with a 1 in n chance of true",4],[9,"gen_ascii_chars","","Return an iterator of random characters from the set A-Z,a-z,0-9.",4],[9,"choose","","Return a random element from `values`.",4],[9,"choose_option","","Deprecated name for `choose()`.",4],[9,"shuffle","","Shuffle a mutable slice in place.",4],[6,"SeedableRng","","A random number generator that can be explicitly seeded to produce\nthe same stream of randomness multiple times."],[9,"reseed","","Reseed an RNG with the given seed.",5],[9,"from_seed","","Create a new RNG with the given seed.",5],[10,"new","rand::distributions::range","Create a new `Range` instance that samples uniformly from\n`[low, high)`. Fails if `low >= high`.",6],[10,"sample","","",6],[10,"ind_sample","","",6],[10,"new","rand::distributions::gamma","Construct an object representing the `Gamma(shape, scale)`\ndistribution.",7],[10,"sample","","",7],[10,"sample","","",8],[10,"sample","","",9],[10,"ind_sample","","",7],[10,"ind_sample","","",8],[10,"ind_sample","","",9],[10,"new","","Create a new chi-squared distribution with degrees-of-freedom\n`k`. Fails if `k < 0`.",10],[10,"sample","","",10],[10,"ind_sample","","",10],[10,"new","","Create a new `FisherF` distribution, with the given\nparameter. Fails if either `m` or `n` are not positive.",11],[10,"sample","","",11],[10,"ind_sample","","",11],[10,"new","","Create a new Student t distribution with `n` degrees of\nfreedom. Fails if `n <= 0`.",12],[10,"sample","","",12],[10,"ind_sample","","",12],[10,"rand","rand::distributions::normal","",13],[10,"new","","Construct a new `Normal` distribution with the given mean and\nstandard deviation. Fails if `std_dev < 0`.",14],[10,"sample","","",14],[10,"ind_sample","","",14],[10,"new","","Construct a new `LogNormal` distribution with the given mean\nand standard deviation. Fails if `std_dev < 0`.",15],[10,"sample","","",15],[10,"ind_sample","","",15],[10,"rand","rand::distributions::exponential","",16],[10,"new","","Construct a new `Exp` with the given shape parameter\n`lambda`. Fails if `lambda <= 0`.",17],[10,"sample","","",17],[10,"ind_sample","","",17],[10,"sample","rand::distributions","",18],[10,"ind_sample","","",18],[10,"new","","Create a new `WeightedChoice`.",19],[10,"sample","","",19],[10,"ind_sample","","",19],[10,"new_unseeded","rand::isaac","Create an ISAAC random number generator using the default\nfixed seed.",20],[10,"next_u32","","",20],[10,"next_u64","","",20],[10,"fill_bytes","","",20],[10,"gen","","",20],[10,"gen_iter","","",20],[10,"gen_range","","",20],[10,"gen_weighted_bool","","",20],[10,"gen_ascii_chars","","",20],[10,"choose","","",20],[10,"choose_option","","",20],[10,"shuffle","","",20],[10,"reseed","","",20],[10,"from_seed","","Create an ISAAC random number generator with a seed. This can\nbe any length, although the maximum number of elements used is\n256 and any more will be silently ignored. A generator\nconstructed with a given seed will generate the same sequence\nof values as all other generators constructed with that seed.",20],[10,"rand","","",20],[10,"new_unseeded","","Create a 64-bit ISAAC random number generator using the\ndefault fixed seed.",21],[10,"next_u32","","",21],[10,"next_u64","","",21],[10,"next_u64","","",21],[10,"fill_bytes","","",21],[10,"gen","","",21],[10,"gen_iter","","",21],[10,"gen_range","","",21],[10,"gen_weighted_bool","","",21],[10,"gen_ascii_chars","","",21],[10,"choose","","",21],[10,"choose_option","","",21],[10,"shuffle","","",21],[10,"reseed","","",21],[10,"from_seed","","Create an ISAAC random number generator with a seed. This can\nbe any length, although the maximum number of elements used is\n256 and any more will be silently ignored. A generator\nconstructed with a given seed will generate the same sequence\nof values as all other generators constructed with that seed.",21],[10,"rand","","",21],[10,"new","rand::reseeding","Create a new `ReseedingRng` with the given parameters.",22],[10,"reseed_if_necessary","","Reseed the internal RNG if the number of bytes that have been\ngenerated exceed the threshold.",22],[10,"next_u32","","",22],[10,"next_u64","","",22],[10,"fill_bytes","","",22],[10,"next_u64","","",22],[10,"fill_bytes","","",22],[10,"gen","","",22],[10,"gen_iter","","",22],[10,"gen_range","","",22],[10,"gen_weighted_bool","","",22],[10,"gen_ascii_chars","","",22],[10,"choose","","",22],[10,"choose_option","","",22],[10,"shuffle","","",22],[10,"reseed","","",22],[10,"from_seed","","Create a new `ReseedingRng` from the given reseeder and\nseed. This uses a default value for `generation_threshold`.",22],[10,"reseed","","",23],[10,"default","","",23],[10,"rand","rand","",24],[10,"rand","","",25],[10,"rand","","",24],[10,"rand","","",25],[10,"rand","core::option","",26],[10,"next","rand","",27],[10,"size_hint","","",27],[10,"chain","","",27],[10,"zip","","",27],[10,"map","","",27],[10,"filter","","",27],[10,"filter_map","","",27],[10,"enumerate","","",27],[10,"peekable","","",27],[10,"skip_while","","",27],[10,"take_while","","",27],[10,"skip","","",27],[10,"take","","",27],[10,"scan","","",27],[10,"flat_map","","",27],[10,"fuse","","",27],[10,"inspect","","",27],[10,"by_ref","","",27],[10,"advance","","",27],[10,"collect","","",27],[10,"nth","","",27],[10,"last","","",27],[10,"fold","","",27],[10,"count","","",27],[10,"all","","",27],[10,"any","","",27],[10,"find","","",27],[10,"position","","",27],[10,"max_by","","",27],[10,"min_by","","",27],[10,"next","","",28],[10,"size_hint","","",28],[10,"chain","","",28],[10,"zip","","",28],[10,"map","","",28],[10,"filter","","",28],[10,"filter_map","","",28],[10,"enumerate","","",28],[10,"peekable","","",28],[10,"skip_while","","",28],[10,"take_while","","",28],[10,"skip","","",28],[10,"take","","",28],[10,"scan","","",28],[10,"flat_map","","",28],[10,"fuse","","",28],[10,"inspect","","",28],[10,"by_ref","","",28],[10,"advance","","",28],[10,"collect","","",28],[10,"nth","","",28],[10,"last","","",28],[10,"fold","","",28],[10,"count","","",28],[10,"all","","",28],[10,"any","","",28],[10,"find","","",28],[10,"position","","",28],[10,"max_by","","",28],[10,"min_by","","",28],[10,"new_unseeded","","Creates a new XorShiftRng instance which is not seeded.",29],[10,"next_u32","","",29],[10,"next_u64","","",29],[10,"fill_bytes","","",29],[10,"gen","","",29],[10,"gen_iter","","",29],[10,"gen_range","","",29],[10,"gen_weighted_bool","","",29],[10,"gen_ascii_chars","","",29],[10,"choose","","",29],[10,"choose_option","","",29],[10,"shuffle","","",29],[10,"reseed","","Reseed an XorShiftRng. This will fail if `seed` is entirely 0.",29],[10,"from_seed","","Create a new XorShiftRng. This will fail if `seed` is entirely 0.",29],[10,"rand","","",29],[1,"Open01","std::rand","A wrapper for generating floating point numbers uniformly in the\nopen interval `(0,1)` (not including either endpoint)."],[1,"Closed01","","A wrapper for generating floating point numbers uniformly in the\nclosed interval `[0,1]` (including both endpoints)."],[1,"XorShiftRng","","An Xorshift[1] random number\ngenerator."],[1,"IsaacRng","","A random number generator that uses the ISAAC algorithm[1]."],[1,"Isaac64Rng","","A random number generator that uses ISAAC-64[1], the 64-bit\nvariant of the ISAAC algorithm."],[0,"distributions","","Sampling from random distributions."],[0,"range","std::rand::distributions","Generating numbers between two others."],[1,"Range","std::rand::distributions::range","Sample values uniformly between two bounds."],[6,"SampleRange","","The helper trait for types that have a sensible way to sample\nuniformly between two values. This should not be used directly,\nand is only to facilitate `Range`."],[9,"construct_range","","Construct the `Range` object that `sample_range`\nrequires. This should not ever be called directly, only via\n`Range::new`, which will check that `low < high`, so this\nfunction doesn't have to repeat the check.",30],[9,"sample_range","","Sample a value from the given `Range` with the given `Rng` as\na source of randomness.",30],[0,"gamma","std::rand::distributions","The Gamma and derived distributions."],[1,"Gamma","std::rand::distributions::gamma","The Gamma distribution `Gamma(shape, scale)` distribution."],[1,"ChiSquared","","The chi-squared distribution `(k)`, where `k` is the degrees of\nfreedom."],[1,"FisherF","","The Fisher F distribution `F(m, n)`."],[1,"StudentT","","The Student t distribution, `t(nu)`, where `nu` is the degrees of\nfreedom."],[0,"normal","std::rand::distributions","The normal and derived distributions."],[1,"StandardNormal","std::rand::distributions::normal","A wrapper around an `f64` to generate N(0, 1) random numbers\n(a.k.a.  a standard normal, or Gaussian)."],[1,"Normal","","The normal distribution `N(mean, std_dev**2)`."],[1,"LogNormal","","The log-normal distribution `ln N(mean, std_dev**2)`."],[0,"exponential","std::rand::distributions","The exponential distribution."],[1,"Exp1","std::rand::distributions::exponential","A wrapper around an `f64` to generate Exp(1) random numbers."],[1,"Exp","","The exponential distribution `Exp(lambda)`."],[6,"Sample","std::rand::distributions","Types that can be used to create a random instance of `Support`."],[9,"sample","","Generate a random value of `Support`, using `rng` as the\nsource of randomness.",31],[6,"IndependentSample","","`Sample`s that do not require keeping track of state."],[9,"ind_sample","","Generate a random value.",32],[1,"RandSample","","A wrapper for generating types that implement `Rand` via the\n`Sample` & `IndependentSample` traits."],[1,"Weighted","","A value with a particular weight for use with `WeightedChoice`."],[11,"weight","","The numerical weight of this item",33],[11,"item","","The actual item which is being weighted",33],[1,"WeightedChoice","","A distribution that selects from a finite collection of weighted items."],[1,"Normal","","The normal distribution `N(mean, std_dev**2)`."],[1,"Exp","","The exponential distribution `Exp(lambda)`."],[1,"Range","","Sample values uniformly between two bounds."],[1,"LogNormal","","The log-normal distribution `ln N(mean, std_dev**2)`."],[1,"Gamma","","The Gamma distribution `Gamma(shape, scale)` distribution."],[1,"ChiSquared","","The chi-squared distribution `(k)`, where `k` is the degrees of\nfreedom."],[1,"StudentT","","The Student t distribution, `t(nu)`, where `nu` is the degrees of\nfreedom."],[1,"FisherF","","The Fisher F distribution `F(m, n)`."],[0,"reseeding","std::rand","A wrapper around another RNG that reseeds it after it\ngenerates a certain number of random bytes."],[1,"ReseedingRng","std::rand::reseeding","A wrapper around any RNG which reseeds the underlying RNG after it\nhas generated a certain number of random bytes."],[11,"reseeder","","Controls the behaviour when reseeding the RNG.",22],[6,"Reseeder","","Something that can be used to reseed an RNG via `ReseedingRng`."],[9,"reseed","","Reseed the given RNG.",34],[1,"ReseedWithDefault","","Reseed an RNG using a `Default` instance. This reseeds by\nreplacing the RNG with the result of a `Default::default` call."],[0,"ascii","std","Operations on ASCII strings and characters"],[1,"Ascii","std::ascii","Datatype to hold one ascii character. It wraps a `u8`, with the highest bit always zero."],[5,"ASCII_LOWER_MAP","",""],[5,"ASCII_UPPER_MAP","",""],[6,"AsciiCast","","Trait for converting into an ascii type."],[10,"to_ascii","","Convert to an ascii type, fail on non-ASCII input.",35],[10,"to_ascii_opt","","Convert to an ascii type, return None on non-ASCII input.",35],[9,"to_ascii_nocheck","","Convert to an ascii type, not doing any range asserts",35],[9,"is_ascii","","Check if convertible to ascii",35],[6,"OwnedAsciiCast","","Trait for copyless casting to an ascii vector."],[9,"is_ascii","","Check if convertible to ascii",36],[10,"into_ascii","","Take ownership and cast to an ascii vector. Fail on non-ASCII input.",36],[10,"into_ascii_opt","","Take ownership and cast to an ascii vector. Return None on non-ASCII input.",36],[9,"into_ascii_nocheck","","Take ownership and cast to an ascii vector.\nDoes not perform validation checks.",36],[6,"AsciiStr","","Trait for converting an ascii type to a string. Needed to convert\n`&[Ascii]` to `&str`."],[9,"as_str_ascii","","Convert to a string.",37],[9,"to_lower","","Convert to vector representing a lower cased ascii string.",37],[9,"to_upper","","Convert to vector representing a upper cased ascii string.",37],[9,"eq_ignore_case","","Compares two Ascii strings ignoring case.",37],[6,"IntoBytes","","Trait to convert to an owned byte vector by consuming self"],[9,"into_bytes","","Converts to an owned byte vector by consuming self",38],[6,"OwnedAsciiExt","","Extension methods for ASCII-subset only operations on owned strings"],[9,"into_ascii_upper","","Convert the string to ASCII upper case:\nASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\nbut non-ASCII letters are unchanged.",39],[9,"into_ascii_lower","","Convert the string to ASCII lower case:\nASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\nbut non-ASCII letters are unchanged.",39],[6,"AsciiExt","","Extension methods for ASCII-subset only operations on string slices"],[9,"to_ascii_upper","","Makes a copy of the string in ASCII upper case:\nASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\nbut non-ASCII letters are unchanged.",40],[9,"to_ascii_lower","","Makes a copy of the string in ASCII lower case:\nASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\nbut non-ASCII letters are unchanged.",40],[9,"eq_ignore_ascii_case","","Check that two strings are an ASCII case-insensitive match.\nSame as `to_ascii_lower(a) == to_ascii_lower(b)`,\nbut without allocating and copying temporary strings.",40],[10,"hash","","",41],[10,"cmp","","",41],[10,"partial_cmp","","",41],[10,"lt","","",41],[10,"le","","",41],[10,"gt","","",41],[10,"ge","","",41],[10,"eq","","",41],[10,"ne","","",41],[10,"clone","","",41],[10,"to_byte","","Converts an ascii character into a `u8`.",41],[10,"to_char","","Converts an ascii character into a `char`.",41],[10,"to_lower","","",41],[10,"to_lowercase","","Convert to lowercase.",41],[10,"to_upper","","",41],[10,"to_uppercase","","Convert to uppercase.",41],[10,"eq_ignore_case","","Compares two ascii characters of equality, ignoring case.",41],[10,"is_alpha","","",41],[10,"is_alphabetic","","Check if the character is a letter (a-z, A-Z)",41],[10,"is_digit","","Check if the character is a number (0-9)",41],[10,"is_alnum","","",41],[10,"is_alphanumeric","","Check if the character is a letter or number",41],[10,"is_blank","","Check if the character is a space or horizontal tab",41],[10,"is_control","","Check if the character is a control character",41],[10,"is_graph","","Checks if the character is printable (except space)",41],[10,"is_print","","Checks if the character is printable (including space)",41],[10,"is_lower","","",41],[10,"is_lowercase","","Checks if the character is lowercase",41],[10,"is_upper","","",41],[10,"is_uppercase","","Checks if the character is uppercase",41],[10,"is_punctuation","","Checks if the character is punctuation",41],[10,"is_hex","","Checks if the character is a valid hex digit",41],[10,"fmt","","",41],[10,"is_ascii","collections::string","",42],[10,"into_ascii_nocheck","","",42],[10,"is_ascii","collections::vec","",43],[10,"into_ascii_nocheck","","",43],[10,"into_string","","",43],[10,"into_bytes","","",43],[10,"into_ascii_upper","collections::string","",42],[10,"into_ascii_lower","","",42],[10,"into_ascii_upper","collections::vec","",43],[10,"into_ascii_lower","","",43],[0,"gc","std","Task-local garbage-collected boxes"],[1,"Gc","std::gc","Immutable garbage-collected pointer type"],[5,"GC","","An value that represents the task-local managed heap."],[10,"clone","","Clone the pointer only",44],[10,"eq","","",44],[10,"ne","","",44],[10,"partial_cmp","","",44],[10,"lt","","",44],[10,"le","","",44],[10,"ge","","",44],[10,"gt","","",44],[10,"cmp","","",44],[10,"deref","","",44],[10,"default","","",44],[10,"hash","","",44],[10,"fmt","","",44],[0,"from_str","std","The `FromStr` trait for types that can be created from strings"],[3,"from_str","std::from_str","A utility function that just calls FromStr::from_str"],[6,"FromStr","","A trait to abstract the idea of creating a new instance of a type from a\nstring."],[9,"from_str","","Parses a string `s` to return an optional value of this type. If the\nstring is ill-formatted, the None is returned.",45],[10,"from_str","collections::string","",42],[0,"num","std","Numeric traits and functions for generic mathematics"],[3,"from_str_radix","std::num","A utility function that just calls FromStrRadix::from_str_radix."],[0,"strconv","",""],[2,"ExponentFormat","std::num::strconv","A flag that specifies whether to use exponential (scientific) notation."],[12,"ExpNone","","Do not use exponential notation.",46],[12,"ExpDec","","Use exponential notation with the exponent having a base of 10 and the\nexponent sign being `e` or `E`. For example, 1000 would be printed\n1e3.",46],[12,"ExpBin","","Use exponential notation with the exponent having a base of 2 and the\nexponent sign being `p` or `P`. For example, 8 would be printed 1p3.",46],[2,"SignificantDigits","","The number of digits used for emitting the fractional part of a number, if\nany."],[12,"DigAll","","All calculable digits will be printed.",47],[12,"DigMax","","At most the given number of digits will be printed, truncating any\ntrailing zeroes.",47],[12,"DigExact","","Precisely the given number of digits will be printed.",47],[2,"SignFormat","","How to emit the sign of a number."],[12,"SignNone","","No sign will be printed. The exponent sign will also be emitted.",48],[12,"SignNeg","","`-` will be printed for negative values, but no sign will be emitted\nfor positive numbers.",48],[12,"SignAll","","`+` will be printed for positive values, and `-` will be printed for\nnegative values.",48],[3,"int_to_str_bytes_common","","Converts an integral number to its string representation as a byte vector.\nThis is meant to be a common base implementation for all integral string\nconversion functions like `to_string()` or `to_str_radix()`."],[3,"float_to_str_bytes_common","","Converts a number to its string representation as a byte vector.\nThis is meant to be a common base implementation for all numeric string\nconversion functions like `to_string()` or `to_str_radix()`."],[3,"float_to_str_common","","Converts a number to its string representation. This is a wrapper for\n`to_str_bytes_common()`, for details see there."],[3,"from_str_bytes_common","","Parses a byte slice as a number. This is meant to\nbe a common base implementation for all numeric string conversion\nfunctions like `from_str()` or `from_str_radix()`."],[3,"from_str_common","","Parses a string as a number. This is a wrapper for\n`from_str_bytes_common()`, for details see there."],[6,"NumStrConv","","Encompasses functions used by the string converter."],[9,"nan","","Returns the NaN value.",49],[9,"inf","","Returns the infinite value.",49],[9,"neg_inf","","Returns the negative infinite value.",49],[9,"neg_zero","","Returns -0.0.",49],[9,"round_to_zero","","Rounds the number toward zero.",49],[9,"fractional_part","","Returns the fractional part of the number.",49],[6,"FloatMath","std::num","Mathematical operations on primitive floating point numbers."],[9,"ldexp","","Constructs a floating point number created by multiplying `x` by 2\nraised to the power of `exp`.",50],[9,"frexp","","Breaks the number into a normalized fraction and a base-2 exponent,\nsatisfying:",50],[9,"next_after","","Returns the next representable floating-point value in the direction of\n`other`.",50],[9,"max","","Returns the maximum of the two numbers.",50],[9,"min","","Returns the minimum of the two numbers.",50],[9,"cbrt","","Take the cubic root of a number.",50],[9,"hypot","","Calculate the length of the hypotenuse of a right-angle triangle given\nlegs of length `x` and `y`.",50],[9,"sin","","Computes the sine of a number (in radians).",50],[9,"cos","","Computes the cosine of a number (in radians).",50],[9,"tan","","Computes the tangent of a number (in radians).",50],[9,"asin","","Computes the arcsine of a number. Return value is in radians in\nthe range [-pi/2, pi/2] or NaN if the number is outside the range\n[-1, 1].",50],[9,"acos","","Computes the arccosine of a number. Return value is in radians in\nthe range [0, pi] or NaN if the number is outside the range\n[-1, 1].",50],[9,"atan","","Computes the arctangent of a number. Return value is in radians in the\nrange [-pi/2, pi/2];",50],[9,"atan2","","Computes the four quadrant arctangent of a number, `y`, and another\nnumber `x`. Return value is in radians in the range [-pi, pi].",50],[9,"sin_cos","","Simultaneously computes the sine and cosine of the number, `x`. Returns\n`(sin(x), cos(x))`.",50],[9,"exp_m1","","Returns the exponential of the number, minus 1, in a way that is\naccurate even if the number is close to zero.",50],[9,"ln_1p","","Returns the natural logarithm of the number plus 1 (`ln(1+n)`) more\naccurately than if the operations were performed separately.",50],[9,"sinh","","Hyperbolic sine function.",50],[9,"cosh","","Hyperbolic cosine function.",50],[9,"tanh","","Hyperbolic tangent function.",50],[9,"asinh","","Inverse hyperbolic sine function.",50],[9,"acosh","","Inverse hyperbolic cosine function.",50],[9,"atanh","","Inverse hyperbolic tangent function.",50],[6,"ToStrRadix","","A generic trait for converting a value to a string with a radix (base)"],[9,"to_str_radix","","",51],[6,"FromStrRadix","","A generic trait for converting a string with a radix (base) to a value"],[9,"from_str_radix","","",52],[6,"Num","","The base trait for numeric types"],[3,"div_rem","","Simultaneous division and remainder"],[6,"Zero","","Defines an additive identity element for `Self`."],[9,"zero","","Returns the additive identity element of `Self`, `0`.",53],[9,"is_zero","","Returns `true` if `self` is equal to the additive identity.",53],[3,"zero","","Returns the additive identity, `0`."],[6,"One","","Defines a multiplicative identity element for `Self`."],[9,"one","","Returns the multiplicative identity element of `Self`, `1`.",54],[3,"one","","Returns the multiplicative identity, `1`."],[6,"Signed","","Useful functions for signed numbers (i.e. numbers that can be negative)."],[9,"abs","","Computes the absolute value.",55],[9,"abs_sub","","The positive difference of two numbers.",55],[9,"signum","","Returns the sign of the number.",55],[9,"is_positive","","Returns true if the number is positive and false if the number is zero or negative.",55],[9,"is_negative","","Returns true if the number is negative and false if the number is zero or positive.",55],[3,"abs","","Computes the absolute value."],[3,"abs_sub","","The positive difference of two numbers."],[3,"signum","","Returns the sign of the number."],[6,"Unsigned","","A trait for values which cannot be negative"],[3,"pow","","Raises a value to the power of exp, using exponentiation by squaring."],[6,"Bounded","","Numbers which have upper and lower bounds"],[9,"min_value","","returns the smallest finite number this type can represent",56],[9,"max_value","","returns the largest finite number this type can represent",56],[6,"Primitive","","Specifies the available operations common to all of Rust's core numeric primitives.\nThese may not always make sense from a purely mathematical point of view, but\nmay be useful for systems programming."],[6,"Int","","A primitive signed or unsigned integer equipped with various bitwise\noperators, bit counting methods, and endian conversion functions."],[9,"count_ones","","Returns the number of ones in the binary representation of the integer.",57],[9,"count_zeros","","Returns the number of zeros in the binary representation of the integer.",57],[9,"leading_zeros","","Returns the number of leading zeros in the binary representation\nof the integer.",57],[9,"trailing_zeros","","Returns the number of trailing zeros in the binary representation\nof the integer.",57],[9,"rotate_left","","Shifts the bits to the left by a specified amount amount, `n`, wrapping\nthe truncated bits to the end of the resulting integer.",57],[9,"rotate_right","","Shifts the bits to the right by a specified amount amount, `n`, wrapping\nthe truncated bits to the beginning of the resulting integer.",57],[9,"swap_bytes","","Reverses the byte order of the integer.",57],[9,"from_be","","Convert a integer from big endian to the target's endianness.",57],[9,"from_le","","Convert a integer from little endian to the target's endianness.",57],[9,"to_be","","Convert the integer to big endian from the target's endianness.",57],[9,"to_le","","Convert the integer to little endian from the target's endianness.",57],[6,"Saturating","","Saturating math operations"],[9,"saturating_add","","Saturating addition operator.\nReturns a+b, saturating at the numeric bounds instead of overflowing.",58],[9,"saturating_sub","","Saturating subtraction operator.\nReturns a-b, saturating at the numeric bounds instead of overflowing.",58],[6,"CheckedAdd","","Performs addition that returns `None` instead of wrapping around on overflow."],[9,"checked_add","","Adds two numbers, checking for overflow. If overflow happens, `None` is returned.",59],[6,"CheckedSub","","Performs subtraction that returns `None` instead of wrapping around on underflow."],[9,"checked_sub","","Subtracts two numbers, checking for underflow. If underflow happens, `None` is returned.",60],[6,"CheckedMul","","Performs multiplication that returns `None` instead of wrapping around on underflow or\noverflow."],[9,"checked_mul","","Multiplies two numbers, checking for underflow or overflow. If underflow or overflow\nhappens, `None` is returned.",61],[6,"CheckedDiv","","Performs division that returns `None` instead of wrapping around on underflow or overflow."],[9,"checked_div","","Divides two numbers, checking for underflow or overflow. If underflow or overflow happens,\n`None` is returned.",62],[3,"cast","","Cast from one machine scalar to another."],[6,"FromPrimitive","","A generic trait for converting a number to a value."],[9,"from_int","","Convert an `int` to return an optional value of this type. If the\nvalue cannot be represented by this value, the `None` is returned.",63],[9,"from_i8","","Convert an `i8` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",63],[9,"from_i16","","Convert an `i16` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",63],[9,"from_i32","","Convert an `i32` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",63],[9,"from_i64","","Convert an `i64` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",63],[9,"from_uint","","Convert an `uint` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",63],[9,"from_u8","","Convert an `u8` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",63],[9,"from_u16","","Convert an `u16` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",63],[9,"from_u32","","Convert an `u32` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",63],[9,"from_u64","","Convert an `u64` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",63],[9,"from_f32","","Convert a `f32` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",63],[9,"from_f64","","Convert a `f64` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",63],[6,"NumCast","","An interface for casting between machine scalars."],[9,"from","","Creates a number from another value that can be converted into a primitive via the\n`ToPrimitive` trait.",64],[6,"ToPrimitive","","A generic trait for converting a value to a number."],[9,"to_int","","Converts the value of `self` to an `int`.",65],[9,"to_i8","","Converts the value of `self` to an `i8`.",65],[9,"to_i16","","Converts the value of `self` to an `i16`.",65],[9,"to_i32","","Converts the value of `self` to an `i32`.",65],[9,"to_i64","","Converts the value of `self` to an `i64`.",65],[9,"to_uint","","Converts the value of `self` to an `uint`.",65],[9,"to_u8","","Converts the value of `self` to an `u8`.",65],[9,"to_u16","","Converts the value of `self` to an `u16`.",65],[9,"to_u32","","Converts the value of `self` to an `u32`.",65],[9,"to_u64","","Converts the value of `self` to an `u64`.",65],[9,"to_f32","","Converts the value of `self` to an `f32`.",65],[9,"to_f64","","Converts the value of `self` to an `f64`.",65],[3,"next_power_of_two","","Returns the smallest power of 2 greater than or equal to `n`."],[3,"is_power_of_two","",""],[3,"checked_next_power_of_two","","Returns the smallest power of 2 greater than or equal to `n`. If the next\npower of two is greater than the type's maximum value, `None` is returned,\notherwise the power of 2 is wrapped in `Some`."],[3,"from_int","","A utility function that just calls `FromPrimitive::from_int`."],[3,"from_i8","","A utility function that just calls `FromPrimitive::from_i8`."],[3,"from_i16","","A utility function that just calls `FromPrimitive::from_i16`."],[3,"from_i32","","A utility function that just calls `FromPrimitive::from_i32`."],[3,"from_i64","","A utility function that just calls `FromPrimitive::from_i64`."],[3,"from_uint","","A utility function that just calls `FromPrimitive::from_uint`."],[3,"from_u8","","A utility function that just calls `FromPrimitive::from_u8`."],[3,"from_u16","","A utility function that just calls `FromPrimitive::from_u16`."],[3,"from_u32","","A utility function that just calls `FromPrimitive::from_u32`."],[3,"from_u64","","A utility function that just calls `FromPrimitive::from_u64`."],[3,"from_f32","","A utility function that just calls `FromPrimitive::from_f32`."],[3,"from_f64","","A utility function that just calls `FromPrimitive::from_f64`."],[10,"fmt","core::num","",66],[10,"eq","","",66],[10,"ne","","",66],[10,"ne","","",66],[10,"fmt","core::intrinsics","",67],[10,"assert_receiver_is_total_eq","","",67],[10,"eq","","",67],[10,"ne","","",67],[10,"ne","","",67],[10,"of","","Returns the `TypeId` of the type this generic function has been instantiated with",67],[10,"hash","","",67],[10,"clone","core::kinds::marker","",68],[10,"clone_from","","",68],[10,"eq","","",68],[10,"ne","","",68],[10,"ne","","",68],[10,"clone","","",69],[10,"clone_from","","",69],[10,"eq","","",69],[10,"ne","","",69],[10,"ne","","",69],[10,"clone","","",70],[10,"clone_from","","",70],[10,"eq","","",70],[10,"ne","","",70],[10,"ne","","",70],[10,"clone","","",71],[10,"clone_from","","",71],[10,"eq","","",71],[10,"ne","","",71],[10,"ne","","",71],[10,"clone","","",72],[10,"clone_from","","",72],[10,"eq","","",72],[10,"ne","","",72],[10,"ne","","",72],[10,"clone","","",73],[10,"clone_from","","",73],[10,"eq","","",73],[10,"ne","","",73],[10,"ne","","",73],[10,"clone","","",74],[10,"clone_from","","",74],[10,"eq","","",74],[10,"ne","","",74],[10,"ne","","",74],[10,"clone","","",75],[10,"clone_from","","",75],[10,"eq","","",75],[10,"ne","","",75],[10,"ne","","",75],[10,"clone","","",76],[10,"clone_from","","",76],[10,"eq","","",76],[10,"ne","","",76],[10,"ne","","",76],[10,"clone","","",77],[10,"clone_from","","",77],[10,"eq","","",77],[10,"ne","","",77],[10,"ne","","",77],[10,"fmt","core::cmp","",78],[10,"eq","","",78],[10,"ne","","",78],[10,"ne","","",78],[10,"clone","","",78],[10,"clone_from","","",78],[10,"assert_receiver_is_total_eq","","",78],[10,"cmp","","",78],[10,"partial_cmp","","",78],[10,"lt","","",78],[10,"le","","",78],[10,"gt","","",78],[10,"ge","","",78],[10,"new","core::atomics","Create a new `AtomicBool`",79],[10,"load","","Load the value",79],[10,"store","","Store the value",79],[10,"swap","","Store a value, returning the old value",79],[10,"compare_and_swap","","If the current value is the same as expected, store a new value",79],[10,"fetch_and","","A logical \"and\" operation",79],[10,"fetch_nand","","A logical \"nand\" operation",79],[10,"fetch_or","","A logical \"or\" operation",79],[10,"fetch_xor","","A logical \"xor\" operation",79],[10,"new","","Create a new `AtomicInt`",80],[10,"load","","Load the value",80],[10,"store","","Store the value",80],[10,"swap","","Store a value, returning the old value",80],[10,"compare_and_swap","","If the current value is the same as expected, store a new value",80],[10,"fetch_add","","Add to the current value, returning the previous",80],[10,"fetch_sub","","Subtract from the current value, returning the previous",80],[10,"fetch_and","","Bitwise and with the current value, returning the previous",80],[10,"fetch_or","","Bitwise or with the current value, returning the previous",80],[10,"fetch_xor","","Bitwise xor with the current value, returning the previous",80],[10,"new","","Create a new `AtomicUint`",81],[10,"load","","Load the value",81],[10,"store","","Store the value",81],[10,"swap","","Store a value, returning the old value",81],[10,"compare_and_swap","","If the current value is the same as expected, store a new value",81],[10,"fetch_add","","Add to the current value, returning the previous",81],[10,"fetch_sub","","Subtract from the current value, returning the previous",81],[10,"fetch_and","","Bitwise and with the current value, returning the previous",81],[10,"fetch_or","","Bitwise or with the current value, returning the previous",81],[10,"fetch_xor","","Bitwise xor with the current value, returning the previous",81],[10,"new","","Create a new `AtomicPtr`",82],[10,"load","","Load the value",82],[10,"store","","Store the value",82],[10,"swap","","Store a value, returning the old value",82],[10,"compare_and_swap","","If the current value is the same as expected, store a new value",82],[10,"new","core::cell","Creates a new `Cell` containing the given value.",83],[10,"get","","Returns a copy of the contained value.",83],[10,"set","","Sets the contained value.",83],[10,"clone","","",83],[10,"clone_from","","",83],[10,"eq","","",83],[10,"ne","","",83],[10,"new","","Create a new `RefCell` containing `value`",84],[10,"unwrap","","Consumes the `RefCell`, returning the wrapped value.",84],[10,"try_borrow","","Attempts to immutably borrow the wrapped value.",84],[10,"borrow","","Immutably borrows the wrapped value.",84],[10,"try_borrow_mut","","Mutably borrows the wrapped value.",84],[10,"borrow_mut","","Mutably borrows the wrapped value.",84],[10,"clone","","",84],[10,"clone_from","","",84],[10,"eq","","",84],[10,"ne","","",84],[10,"drop","","",85],[10,"deref","","",85],[10,"drop","","",86],[10,"deref","","",86],[10,"deref_mut","","",86],[10,"new","","Construct a new instance of `UnsafeCell` which will wrapp the specified\nvalue.",87],[10,"get","","Gets a mutable pointer to the wrapped value.",87],[10,"unwrap","","Unwraps the value",87],[10,"drop","core::finally","",88],[10,"rposition","core::iter","",89],[10,"len","","",89],[10,"rposition","","",90],[10,"len","","",90],[10,"rposition","","",91],[10,"len","","",91],[10,"rposition","","",92],[10,"len","","",92],[10,"rposition","","",93],[10,"len","","",93],[10,"clone","","",91],[10,"clone_from","","",91],[10,"next","","",91],[10,"size_hint","","",91],[10,"size_hint","","",91],[10,"chain","","",91],[10,"zip","","",91],[10,"map","","",91],[10,"filter","","",91],[10,"filter_map","","",91],[10,"enumerate","","",91],[10,"peekable","","",91],[10,"skip_while","","",91],[10,"take_while","","",91],[10,"skip","","",91],[10,"take","","",91],[10,"scan","","",91],[10,"flat_map","","",91],[10,"fuse","","",91],[10,"inspect","","",91],[10,"by_ref","","",91],[10,"advance","","",91],[10,"collect","","",91],[10,"nth","","",91],[10,"last","","",91],[10,"fold","","",91],[10,"count","","",91],[10,"all","","",91],[10,"any","","",91],[10,"find","","",91],[10,"position","","",91],[10,"max_by","","",91],[10,"min_by","","",91],[10,"next_back","","",91],[10,"rev","","",91],[10,"indexable","","",91],[10,"idx","","",91],[10,"next","","",94],[10,"size_hint","","",94],[10,"size_hint","","",94],[10,"chain","","",94],[10,"zip","","",94],[10,"map","","",94],[10,"filter","","",94],[10,"filter_map","","",94],[10,"enumerate","","",94],[10,"peekable","","",94],[10,"skip_while","","",94],[10,"take_while","","",94],[10,"skip","","",94],[10,"take","","",94],[10,"scan","","",94],[10,"flat_map","","",94],[10,"fuse","","",94],[10,"inspect","","",94],[10,"by_ref","","",94],[10,"advance","","",94],[10,"collect","","",94],[10,"nth","","",94],[10,"last","","",94],[10,"fold","","",94],[10,"count","","",94],[10,"all","","",94],[10,"any","","",94],[10,"find","","",94],[10,"position","","",94],[10,"max_by","","",94],[10,"min_by","","",94],[10,"next_back","","",94],[10,"rev","","",94],[10,"fmt","","",95],[10,"eq","","",95],[10,"ne","","",95],[10,"ne","","",95],[10,"clone","","",95],[10,"clone_from","","",95],[10,"into_option","","`into_option` creates an `Option` of type `(T,T)`. The returned `Option` has variant\n`None` if and only if the `MinMaxResult` has variant `NoElements`. Otherwise variant\n`Some(x,y)` is returned where `x <= y`. If `MinMaxResult` has variant `OneElement(x)`,\nperforming this operation will make one clone of `x`.",95],[10,"clone","","",96],[10,"clone_from","","",96],[10,"next","","",96],[10,"size_hint","","",96],[10,"size_hint","","",96],[10,"chain","","",96],[10,"zip","","",96],[10,"map","","",96],[10,"filter","","",96],[10,"filter_map","","",96],[10,"enumerate","","",96],[10,"peekable","","",96],[10,"skip_while","","",96],[10,"take_while","","",96],[10,"skip","","",96],[10,"take","","",96],[10,"scan","","",96],[10,"flat_map","","",96],[10,"fuse","","",96],[10,"inspect","","",96],[10,"by_ref","","",96],[10,"advance","","",96],[10,"collect","","",96],[10,"nth","","",96],[10,"last","","",96],[10,"fold","","",96],[10,"count","","",96],[10,"all","","",96],[10,"any","","",96],[10,"find","","",96],[10,"position","","",96],[10,"max_by","","",96],[10,"min_by","","",96],[10,"indexable","","",96],[10,"idx","","",96],[10,"clone","","",97],[10,"clone_from","","",97],[10,"next","","",97],[10,"size_hint","","",97],[10,"size_hint","","",97],[10,"chain","","",97],[10,"zip","","",97],[10,"map","","",97],[10,"filter","","",97],[10,"filter_map","","",97],[10,"enumerate","","",97],[10,"peekable","","",97],[10,"skip_while","","",97],[10,"take_while","","",97],[10,"skip","","",97],[10,"take","","",97],[10,"scan","","",97],[10,"flat_map","","",97],[10,"fuse","","",97],[10,"inspect","","",97],[10,"by_ref","","",97],[10,"advance","","",97],[10,"collect","","",97],[10,"nth","","",97],[10,"last","","",97],[10,"fold","","",97],[10,"count","","",97],[10,"all","","",97],[10,"any","","",97],[10,"find","","",97],[10,"position","","",97],[10,"max_by","","",97],[10,"min_by","","",97],[10,"next_back","","",97],[10,"rev","","",97],[10,"indexable","","",97],[10,"idx","","",97],[10,"clone","","",93],[10,"clone_from","","",93],[10,"next","","",93],[10,"size_hint","","",93],[10,"size_hint","","",93],[10,"chain","","",93],[10,"zip","","",93],[10,"map","","",93],[10,"filter","","",93],[10,"filter_map","","",93],[10,"enumerate","","",93],[10,"peekable","","",93],[10,"skip_while","","",93],[10,"take_while","","",93],[10,"skip","","",93],[10,"take","","",93],[10,"scan","","",93],[10,"flat_map","","",93],[10,"fuse","","",93],[10,"inspect","","",93],[10,"by_ref","","",93],[10,"advance","","",93],[10,"collect","","",93],[10,"nth","","",93],[10,"last","","",93],[10,"fold","","",93],[10,"count","","",93],[10,"all","","",93],[10,"any","","",93],[10,"find","","",93],[10,"position","","",93],[10,"max_by","","",93],[10,"min_by","","",93],[10,"next_back","","",93],[10,"rev","","",93],[10,"indexable","","",93],[10,"idx","","",93],[10,"next","","",92],[10,"size_hint","","",92],[10,"size_hint","","",92],[10,"chain","","",92],[10,"zip","","",92],[10,"map","","",92],[10,"filter","","",92],[10,"filter_map","","",92],[10,"enumerate","","",92],[10,"peekable","","",92],[10,"skip_while","","",92],[10,"take_while","","",92],[10,"skip","","",92],[10,"take","","",92],[10,"scan","","",92],[10,"flat_map","","",92],[10,"fuse","","",92],[10,"inspect","","",92],[10,"by_ref","","",92],[10,"advance","","",92],[10,"collect","","",92],[10,"nth","","",92],[10,"last","","",92],[10,"fold","","",92],[10,"count","","",92],[10,"all","","",92],[10,"any","","",92],[10,"find","","",92],[10,"position","","",92],[10,"max_by","","",92],[10,"min_by","","",92],[10,"next_back","","",92],[10,"rev","","",92],[10,"indexable","","",92],[10,"idx","","",92],[10,"next","","",98],[10,"size_hint","","",98],[10,"size_hint","","",98],[10,"chain","","",98],[10,"zip","","",98],[10,"map","","",98],[10,"filter","","",98],[10,"filter_map","","",98],[10,"enumerate","","",98],[10,"peekable","","",98],[10,"skip_while","","",98],[10,"take_while","","",98],[10,"skip","","",98],[10,"take","","",98],[10,"scan","","",98],[10,"flat_map","","",98],[10,"fuse","","",98],[10,"inspect","","",98],[10,"by_ref","","",98],[10,"advance","","",98],[10,"collect","","",98],[10,"nth","","",98],[10,"last","","",98],[10,"fold","","",98],[10,"count","","",98],[10,"all","","",98],[10,"any","","",98],[10,"find","","",98],[10,"position","","",98],[10,"max_by","","",98],[10,"min_by","","",98],[10,"next_back","","",98],[10,"rev","","",98],[10,"next","","",99],[10,"size_hint","","",99],[10,"size_hint","","",99],[10,"chain","","",99],[10,"zip","","",99],[10,"map","","",99],[10,"filter","","",99],[10,"filter_map","","",99],[10,"enumerate","","",99],[10,"peekable","","",99],[10,"skip_while","","",99],[10,"take_while","","",99],[10,"skip","","",99],[10,"take","","",99],[10,"scan","","",99],[10,"flat_map","","",99],[10,"fuse","","",99],[10,"inspect","","",99],[10,"by_ref","","",99],[10,"advance","","",99],[10,"collect","","",99],[10,"nth","","",99],[10,"last","","",99],[10,"fold","","",99],[10,"count","","",99],[10,"all","","",99],[10,"any","","",99],[10,"find","","",99],[10,"position","","",99],[10,"max_by","","",99],[10,"min_by","","",99],[10,"next_back","","",99],[10,"rev","","",99],[10,"clone","","",89],[10,"clone_from","","",89],[10,"next","","",89],[10,"size_hint","","",89],[10,"size_hint","","",89],[10,"chain","","",89],[10,"zip","","",89],[10,"map","","",89],[10,"filter","","",89],[10,"filter_map","","",89],[10,"enumerate","","",89],[10,"peekable","","",89],[10,"skip_while","","",89],[10,"take_while","","",89],[10,"skip","","",89],[10,"take","","",89],[10,"scan","","",89],[10,"flat_map","","",89],[10,"fuse","","",89],[10,"inspect","","",89],[10,"by_ref","","",89],[10,"advance","","",89],[10,"collect","","",89],[10,"nth","","",89],[10,"last","","",89],[10,"fold","","",89],[10,"count","","",89],[10,"all","","",89],[10,"any","","",89],[10,"find","","",89],[10,"position","","",89],[10,"max_by","","",89],[10,"min_by","","",89],[10,"next_back","","",89],[10,"rev","","",89],[10,"indexable","","",89],[10,"idx","","",89],[10,"next","","",100],[10,"size_hint","","",100],[10,"size_hint","","",100],[10,"chain","","",100],[10,"zip","","",100],[10,"map","","",100],[10,"filter","","",100],[10,"filter_map","","",100],[10,"enumerate","","",100],[10,"peekable","","",100],[10,"skip_while","","",100],[10,"take_while","","",100],[10,"skip","","",100],[10,"take","","",100],[10,"scan","","",100],[10,"flat_map","","",100],[10,"fuse","","",100],[10,"inspect","","",100],[10,"by_ref","","",100],[10,"advance","","",100],[10,"collect","","",100],[10,"nth","","",100],[10,"last","","",100],[10,"fold","","",100],[10,"count","","",100],[10,"all","","",100],[10,"any","","",100],[10,"find","","",100],[10,"position","","",100],[10,"max_by","","",100],[10,"min_by","","",100],[10,"peek","","Return a reference to the next element of the iterator with out advancing it,\nor None if the iterator is exhausted.",100],[10,"is_empty","","Check whether peekable iterator is empty or not.",100],[10,"next","","",101],[10,"size_hint","","",101],[10,"size_hint","","",101],[10,"chain","","",101],[10,"zip","","",101],[10,"map","","",101],[10,"filter","","",101],[10,"filter_map","","",101],[10,"enumerate","","",101],[10,"peekable","","",101],[10,"skip_while","","",101],[10,"take_while","","",101],[10,"skip","","",101],[10,"take","","",101],[10,"scan","","",101],[10,"flat_map","","",101],[10,"fuse","","",101],[10,"inspect","","",101],[10,"by_ref","","",101],[10,"advance","","",101],[10,"collect","","",101],[10,"nth","","",101],[10,"last","","",101],[10,"fold","","",101],[10,"count","","",101],[10,"all","","",101],[10,"any","","",101],[10,"find","","",101],[10,"position","","",101],[10,"max_by","","",101],[10,"min_by","","",101],[10,"next","","",102],[10,"size_hint","","",102],[10,"size_hint","","",102],[10,"chain","","",102],[10,"zip","","",102],[10,"map","","",102],[10,"filter","","",102],[10,"filter_map","","",102],[10,"enumerate","","",102],[10,"peekable","","",102],[10,"skip_while","","",102],[10,"take_while","","",102],[10,"skip","","",102],[10,"take","","",102],[10,"scan","","",102],[10,"flat_map","","",102],[10,"fuse","","",102],[10,"inspect","","",102],[10,"by_ref","","",102],[10,"advance","","",102],[10,"collect","","",102],[10,"nth","","",102],[10,"last","","",102],[10,"fold","","",102],[10,"count","","",102],[10,"all","","",102],[10,"any","","",102],[10,"find","","",102],[10,"position","","",102],[10,"max_by","","",102],[10,"min_by","","",102],[10,"clone","","",103],[10,"clone_from","","",103],[10,"next","","",103],[10,"size_hint","","",103],[10,"size_hint","","",103],[10,"chain","","",103],[10,"zip","","",103],[10,"map","","",103],[10,"filter","","",103],[10,"filter_map","","",103],[10,"enumerate","","",103],[10,"peekable","","",103],[10,"skip_while","","",103],[10,"take_while","","",103],[10,"skip","","",103],[10,"take","","",103],[10,"scan","","",103],[10,"flat_map","","",103],[10,"fuse","","",103],[10,"inspect","","",103],[10,"by_ref","","",103],[10,"advance","","",103],[10,"collect","","",103],[10,"nth","","",103],[10,"last","","",103],[10,"fold","","",103],[10,"count","","",103],[10,"all","","",103],[10,"any","","",103],[10,"find","","",103],[10,"position","","",103],[10,"max_by","","",103],[10,"min_by","","",103],[10,"indexable","","",103],[10,"idx","","",103],[10,"clone","","",104],[10,"clone_from","","",104],[10,"next","","",104],[10,"size_hint","","",104],[10,"size_hint","","",104],[10,"chain","","",104],[10,"zip","","",104],[10,"map","","",104],[10,"filter","","",104],[10,"filter_map","","",104],[10,"enumerate","","",104],[10,"peekable","","",104],[10,"skip_while","","",104],[10,"take_while","","",104],[10,"skip","","",104],[10,"take","","",104],[10,"scan","","",104],[10,"flat_map","","",104],[10,"fuse","","",104],[10,"inspect","","",104],[10,"by_ref","","",104],[10,"advance","","",104],[10,"collect","","",104],[10,"nth","","",104],[10,"last","","",104],[10,"fold","","",104],[10,"count","","",104],[10,"all","","",104],[10,"any","","",104],[10,"find","","",104],[10,"position","","",104],[10,"max_by","","",104],[10,"min_by","","",104],[10,"indexable","","",104],[10,"idx","","",104],[10,"next","","",105],[10,"size_hint","","",105],[10,"size_hint","","",105],[10,"chain","","",105],[10,"zip","","",105],[10,"map","","",105],[10,"filter","","",105],[10,"filter_map","","",105],[10,"enumerate","","",105],[10,"peekable","","",105],[10,"skip_while","","",105],[10,"take_while","","",105],[10,"skip","","",105],[10,"take","","",105],[10,"scan","","",105],[10,"flat_map","","",105],[10,"fuse","","",105],[10,"inspect","","",105],[10,"by_ref","","",105],[10,"advance","","",105],[10,"collect","","",105],[10,"nth","","",105],[10,"last","","",105],[10,"fold","","",105],[10,"count","","",105],[10,"all","","",105],[10,"any","","",105],[10,"find","","",105],[10,"position","","",105],[10,"max_by","","",105],[10,"min_by","","",105],[10,"next","","",106],[10,"size_hint","","",106],[10,"size_hint","","",106],[10,"chain","","",106],[10,"zip","","",106],[10,"map","","",106],[10,"filter","","",106],[10,"filter_map","","",106],[10,"enumerate","","",106],[10,"peekable","","",106],[10,"skip_while","","",106],[10,"take_while","","",106],[10,"skip","","",106],[10,"take","","",106],[10,"scan","","",106],[10,"flat_map","","",106],[10,"fuse","","",106],[10,"inspect","","",106],[10,"by_ref","","",106],[10,"advance","","",106],[10,"collect","","",106],[10,"nth","","",106],[10,"last","","",106],[10,"fold","","",106],[10,"count","","",106],[10,"all","","",106],[10,"any","","",106],[10,"find","","",106],[10,"position","","",106],[10,"max_by","","",106],[10,"min_by","","",106],[10,"next_back","","",106],[10,"rev","","",106],[10,"clone","","",107],[10,"clone_from","","",107],[10,"next","","",107],[10,"size_hint","","",107],[10,"size_hint","","",107],[10,"chain","","",107],[10,"zip","","",107],[10,"map","","",107],[10,"filter","","",107],[10,"filter_map","","",107],[10,"enumerate","","",107],[10,"peekable","","",107],[10,"skip_while","","",107],[10,"take_while","","",107],[10,"skip","","",107],[10,"take","","",107],[10,"scan","","",107],[10,"flat_map","","",107],[10,"fuse","","",107],[10,"inspect","","",107],[10,"by_ref","","",107],[10,"advance","","",107],[10,"collect","","",107],[10,"nth","","",107],[10,"last","","",107],[10,"fold","","",107],[10,"count","","",107],[10,"all","","",107],[10,"any","","",107],[10,"find","","",107],[10,"position","","",107],[10,"max_by","","",107],[10,"min_by","","",107],[10,"next_back","","",107],[10,"rev","","",107],[10,"indexable","","",107],[10,"idx","","",107],[10,"reset_fuse","","Resets the fuse such that the next call to .next() or .next_back() will\ncall the underlying iterator again even if it previously returned None.",107],[10,"next","","",90],[10,"size_hint","","",90],[10,"size_hint","","",90],[10,"chain","","",90],[10,"zip","","",90],[10,"map","","",90],[10,"filter","","",90],[10,"filter_map","","",90],[10,"enumerate","","",90],[10,"peekable","","",90],[10,"skip_while","","",90],[10,"take_while","","",90],[10,"skip","","",90],[10,"take","","",90],[10,"scan","","",90],[10,"flat_map","","",90],[10,"fuse","","",90],[10,"inspect","","",90],[10,"by_ref","","",90],[10,"advance","","",90],[10,"collect","","",90],[10,"nth","","",90],[10,"last","","",90],[10,"fold","","",90],[10,"count","","",90],[10,"all","","",90],[10,"any","","",90],[10,"find","","",90],[10,"position","","",90],[10,"max_by","","",90],[10,"min_by","","",90],[10,"next_back","","",90],[10,"rev","","",90],[10,"indexable","","",90],[10,"idx","","",90],[10,"new","","Creates a new iterator with the specified closure as the \"iterator\nfunction\" and an initial state to eventually pass to the iterator",108],[10,"next","","",108],[10,"size_hint","","",108],[10,"size_hint","","",108],[10,"chain","","",108],[10,"zip","","",108],[10,"map","","",108],[10,"filter","","",108],[10,"filter_map","","",108],[10,"enumerate","","",108],[10,"peekable","","",108],[10,"skip_while","","",108],[10,"take_while","","",108],[10,"skip","","",108],[10,"take","","",108],[10,"scan","","",108],[10,"flat_map","","",108],[10,"fuse","","",108],[10,"inspect","","",108],[10,"by_ref","","",108],[10,"advance","","",108],[10,"collect","","",108],[10,"nth","","",108],[10,"last","","",108],[10,"fold","","",108],[10,"count","","",108],[10,"all","","",108],[10,"any","","",108],[10,"find","","",108],[10,"position","","",108],[10,"max_by","","",108],[10,"min_by","","",108],[10,"clone","","",109],[10,"clone_from","","",109],[10,"next","","",109],[10,"size_hint","","",109],[10,"size_hint","","",109],[10,"chain","","",109],[10,"zip","","",109],[10,"map","","",109],[10,"filter","","",109],[10,"filter_map","","",109],[10,"enumerate","","",109],[10,"peekable","","",109],[10,"skip_while","","",109],[10,"take_while","","",109],[10,"skip","","",109],[10,"take","","",109],[10,"scan","","",109],[10,"flat_map","","",109],[10,"fuse","","",109],[10,"inspect","","",109],[10,"by_ref","","",109],[10,"advance","","",109],[10,"collect","","",109],[10,"nth","","",109],[10,"last","","",109],[10,"fold","","",109],[10,"count","","",109],[10,"all","","",109],[10,"any","","",109],[10,"find","","",109],[10,"position","","",109],[10,"max_by","","",109],[10,"min_by","","",109],[10,"clone","","",110],[10,"clone_from","","",110],[10,"next","","",110],[10,"size_hint","","",110],[10,"size_hint","","",110],[10,"chain","","",110],[10,"zip","","",110],[10,"map","","",110],[10,"filter","","",110],[10,"filter_map","","",110],[10,"enumerate","","",110],[10,"peekable","","",110],[10,"skip_while","","",110],[10,"take_while","","",110],[10,"skip","","",110],[10,"take","","",110],[10,"scan","","",110],[10,"flat_map","","",110],[10,"fuse","","",110],[10,"inspect","","",110],[10,"by_ref","","",110],[10,"advance","","",110],[10,"collect","","",110],[10,"nth","","",110],[10,"last","","",110],[10,"fold","","",110],[10,"count","","",110],[10,"all","","",110],[10,"any","","",110],[10,"find","","",110],[10,"position","","",110],[10,"max_by","","",110],[10,"min_by","","",110],[10,"next_back","","",110],[10,"rev","","",110],[10,"clone","","",111],[10,"clone_from","","",111],[10,"next","","",111],[10,"size_hint","","",111],[10,"size_hint","","",111],[10,"chain","","",111],[10,"zip","","",111],[10,"map","","",111],[10,"filter","","",111],[10,"filter_map","","",111],[10,"enumerate","","",111],[10,"peekable","","",111],[10,"skip_while","","",111],[10,"take_while","","",111],[10,"skip","","",111],[10,"take","","",111],[10,"scan","","",111],[10,"flat_map","","",111],[10,"fuse","","",111],[10,"inspect","","",111],[10,"by_ref","","",111],[10,"advance","","",111],[10,"collect","","",111],[10,"nth","","",111],[10,"last","","",111],[10,"fold","","",111],[10,"count","","",111],[10,"all","","",111],[10,"any","","",111],[10,"find","","",111],[10,"position","","",111],[10,"max_by","","",111],[10,"min_by","","",111],[10,"next_back","","",111],[10,"rev","","",111],[10,"clone","","",112],[10,"clone_from","","",112],[10,"next","","",112],[10,"size_hint","","",112],[10,"chain","","",112],[10,"zip","","",112],[10,"map","","",112],[10,"filter","","",112],[10,"filter_map","","",112],[10,"enumerate","","",112],[10,"peekable","","",112],[10,"skip_while","","",112],[10,"take_while","","",112],[10,"skip","","",112],[10,"take","","",112],[10,"scan","","",112],[10,"flat_map","","",112],[10,"fuse","","",112],[10,"inspect","","",112],[10,"by_ref","","",112],[10,"advance","","",112],[10,"collect","","",112],[10,"nth","","",112],[10,"last","","",112],[10,"fold","","",112],[10,"count","","",112],[10,"all","","",112],[10,"any","","",112],[10,"find","","",112],[10,"position","","",112],[10,"max_by","","",112],[10,"min_by","","",112],[10,"clone","","",113],[10,"clone_from","","",113],[10,"next","","",113],[10,"size_hint","","",113],[10,"chain","","",113],[10,"zip","","",113],[10,"map","","",113],[10,"filter","","",113],[10,"filter_map","","",113],[10,"enumerate","","",113],[10,"peekable","","",113],[10,"skip_while","","",113],[10,"take_while","","",113],[10,"skip","","",113],[10,"take","","",113],[10,"scan","","",113],[10,"flat_map","","",113],[10,"fuse","","",113],[10,"inspect","","",113],[10,"by_ref","","",113],[10,"advance","","",113],[10,"collect","","",113],[10,"nth","","",113],[10,"last","","",113],[10,"fold","","",113],[10,"count","","",113],[10,"all","","",113],[10,"any","","",113],[10,"find","","",113],[10,"position","","",113],[10,"max_by","","",113],[10,"min_by","","",113],[10,"clone","","",114],[10,"clone_from","","",114],[10,"new","","Create a new `Repeat` that endlessly repeats the element `elt`.",114],[10,"next","","",114],[10,"size_hint","","",114],[10,"size_hint","","",114],[10,"chain","","",114],[10,"zip","","",114],[10,"map","","",114],[10,"filter","","",114],[10,"filter_map","","",114],[10,"enumerate","","",114],[10,"peekable","","",114],[10,"skip_while","","",114],[10,"take_while","","",114],[10,"skip","","",114],[10,"take","","",114],[10,"scan","","",114],[10,"flat_map","","",114],[10,"fuse","","",114],[10,"inspect","","",114],[10,"by_ref","","",114],[10,"advance","","",114],[10,"collect","","",114],[10,"nth","","",114],[10,"last","","",114],[10,"fold","","",114],[10,"count","","",114],[10,"all","","",114],[10,"any","","",114],[10,"find","","",114],[10,"position","","",114],[10,"max_by","","",114],[10,"min_by","","",114],[10,"next_back","","",114],[10,"rev","","",114],[10,"indexable","","",114],[10,"idx","","",114],[10,"fmt","core::option","",26],[10,"cmp","","",26],[10,"assert_receiver_is_total_eq","","",26],[10,"partial_cmp","","",26],[10,"lt","","",26],[10,"le","","",26],[10,"gt","","",26],[10,"ge","","",26],[10,"lt","","",26],[10,"le","","",26],[10,"gt","","",26],[10,"ge","","",26],[10,"eq","","",26],[10,"ne","","",26],[10,"ne","","",26],[10,"clone","","",26],[10,"clone_from","","",26],[10,"is_some","","Returns `true` if the option is a `Some` value",26],[10,"is_none","","Returns `true` if the option is a `None` value",26],[10,"as_ref","","Convert from `Option<T>` to `Option<&T>`",26],[10,"as_mut","","Convert from `Option<T>` to `Option<&mut T>`",26],[10,"as_mut_slice","","Convert from `Option<T>` to `&mut [T]` (without copying)",26],[10,"expect","","Unwraps an option, yielding the content of a `Some`",26],[10,"unwrap","","Moves a value out of an option type and returns it, consuming the `Option`.",26],[10,"unwrap_or","","Returns the contained value or a default.",26],[10,"unwrap_or_else","","Returns the contained value or computes it from a closure.",26],[10,"map","","Maps an `Option<T>` to `Option<U>` by applying a function to a contained value",26],[10,"map_or","","Applies a function to the contained value or returns a default.",26],[10,"mutate","","Applies a function to the contained value or does nothing.\nReturns true if the contained value was mutated.",26],[10,"mutate_or_set","","Applies a function to the contained value or sets it to a default.\nReturns true if the contained value was mutated, or false if set to the default.",26],[10,"iter","","Returns an iterator over the possibly contained value.",26],[10,"mut_iter","","Returns a mutable iterator over the possibly contained value.",26],[10,"move_iter","","Returns a consuming iterator over the possibly contained value.",26],[10,"and","","Returns `None` if the option is `None`, otherwise returns `optb`.",26],[10,"and_then","","Returns `None` if the option is `None`, otherwise calls `f` with the\nwrapped value and returns the result.",26],[10,"or","","Returns the option if it contains a value, otherwise returns `optb`.",26],[10,"or_else","","Returns the option if it contains a value, otherwise calls `f` and\nreturns the result.",26],[10,"take","","Takes the value out of the option, leaving a `None` in its place.",26],[10,"filtered","","Filters an optional value using a given function.",26],[10,"while_some","","Applies a function zero or more times until the result is `None`.",26],[10,"take_unwrap","","The option dance. Moves a value out of an option type and returns it,\nreplacing the original with `None`.",26],[10,"get_ref","","Gets an immutable reference to the value inside an option.",26],[10,"get_mut_ref","","Gets a mutable reference to the value inside an option.",26],[10,"unwrap_or_default","","Returns the contained value or a default",26],[10,"as_slice","","Convert from `Option<T>` to `&[T]` (without copying)",26],[10,"default","","",26],[10,"clone","","",115],[10,"clone_from","","",115],[10,"next","","",115],[10,"size_hint","","",115],[10,"size_hint","","",115],[10,"chain","","",115],[10,"zip","","",115],[10,"map","","",115],[10,"filter","","",115],[10,"filter_map","","",115],[10,"enumerate","","",115],[10,"peekable","","",115],[10,"skip_while","","",115],[10,"take_while","","",115],[10,"skip","","",115],[10,"take","","",115],[10,"scan","","",115],[10,"flat_map","","",115],[10,"fuse","","",115],[10,"inspect","","",115],[10,"by_ref","","",115],[10,"advance","","",115],[10,"collect","","",115],[10,"nth","","",115],[10,"last","","",115],[10,"fold","","",115],[10,"count","","",115],[10,"all","","",115],[10,"any","","",115],[10,"find","","",115],[10,"position","","",115],[10,"max_by","","",115],[10,"min_by","","",115],[10,"next_back","","",115],[10,"rev","","",115],[10,"rposition","","",115],[10,"len","","",115],[10,"fmt","core::result","",116],[10,"cmp","","",116],[10,"assert_receiver_is_total_eq","","",116],[10,"partial_cmp","","",116],[10,"lt","","",116],[10,"le","","",116],[10,"gt","","",116],[10,"ge","","",116],[10,"lt","","",116],[10,"le","","",116],[10,"gt","","",116],[10,"ge","","",116],[10,"eq","","",116],[10,"ne","","",116],[10,"ne","","",116],[10,"clone","","",116],[10,"clone_from","","",116],[10,"is_ok","","Returns true if the result is `Ok`",116],[10,"is_err","","Returns true if the result is `Err`",116],[10,"ok","","Convert from `Result<T, E>` to `Option<T>`",116],[10,"err","","Convert from `Result<T, E>` to `Option<E>`",116],[10,"as_ref","","Convert from `Result<T, E>` to `Result<&T, &E>`",116],[10,"as_mut","","Convert from `Result<T, E>` to `Result<&mut T, &mut E>`",116],[10,"map","","Maps a `Result<T, E>` to `Result<U, E>` by applying a function to an\ncontained `Ok` value, leaving an `Err` value untouched.",116],[10,"map_err","","Maps a `Result<T, E>` to `Result<T, F>` by applying a function to an\ncontained `Err` value, leaving an `Ok` value untouched.",116],[10,"and","","Returns `res` if the result is `Ok`, otherwise returns the `Err` value of `self`.",116],[10,"and_then","","Calls `op` if the result is `Ok`, otherwise returns the `Err` value of `self`.",116],[10,"or","","Returns `res` if the result is `Err`, otherwise returns the `Ok` value of `self`.",116],[10,"or_else","","Calls `op` if the result is `Err`, otherwise returns the `Ok` value of `self`.",116],[10,"unwrap_or","","Unwraps a result, yielding the content of an `Ok`.\nElse it returns `optb`.",116],[10,"unwrap_or_else","","Unwraps a result, yielding the content of an `Ok`.\nIf the value is an `Err` then it calls `op` with its value.",116],[10,"unwrap_or_handle","","Deprecated name for `unwrap_or_else()`.",116],[10,"unwrap","","Unwraps a result, yielding the content of an `Ok`.",116],[10,"unwrap_err","","Unwraps a result, yielding the content of an `Err`.",116],[10,"fmt","core::simd","",117],[10,"fmt","","",118],[10,"fmt","","",119],[10,"fmt","","",120],[10,"fmt","","",121],[10,"fmt","","",122],[10,"fmt","","",123],[10,"fmt","","",124],[10,"fmt","","",125],[10,"fmt","","",126],[10,"next","core::slice","",127],[10,"size_hint","","",127],[10,"size_hint","","",127],[10,"chain","","",127],[10,"zip","","",127],[10,"map","","",127],[10,"filter","","",127],[10,"filter_map","","",127],[10,"enumerate","","",127],[10,"peekable","","",127],[10,"skip_while","","",127],[10,"take_while","","",127],[10,"skip","","",127],[10,"take","","",127],[10,"scan","","",127],[10,"flat_map","","",127],[10,"fuse","","",127],[10,"inspect","","",127],[10,"by_ref","","",127],[10,"advance","","",127],[10,"collect","","",127],[10,"nth","","",127],[10,"last","","",127],[10,"fold","","",127],[10,"count","","",127],[10,"all","","",127],[10,"any","","",127],[10,"find","","",127],[10,"position","","",127],[10,"max_by","","",127],[10,"min_by","","",127],[10,"next_back","","",127],[10,"rev","","",127],[10,"rposition","","",127],[10,"len","","",127],[10,"clone","","",127],[10,"clone_from","","",127],[10,"indexable","","",127],[10,"idx","","",127],[10,"next","","",128],[10,"size_hint","","",128],[10,"size_hint","","",128],[10,"chain","","",128],[10,"zip","","",128],[10,"map","","",128],[10,"filter","","",128],[10,"filter_map","","",128],[10,"enumerate","","",128],[10,"peekable","","",128],[10,"skip_while","","",128],[10,"take_while","","",128],[10,"skip","","",128],[10,"take","","",128],[10,"scan","","",128],[10,"flat_map","","",128],[10,"fuse","","",128],[10,"inspect","","",128],[10,"by_ref","","",128],[10,"advance","","",128],[10,"collect","","",128],[10,"nth","","",128],[10,"last","","",128],[10,"fold","","",128],[10,"count","","",128],[10,"all","","",128],[10,"any","","",128],[10,"find","","",128],[10,"position","","",128],[10,"max_by","","",128],[10,"min_by","","",128],[10,"next_back","","",128],[10,"rev","","",128],[10,"rposition","","",128],[10,"len","","",128],[10,"next","","",129],[10,"size_hint","","",129],[10,"size_hint","","",129],[10,"chain","","",129],[10,"zip","","",129],[10,"map","","",129],[10,"filter","","",129],[10,"filter_map","","",129],[10,"enumerate","","",129],[10,"peekable","","",129],[10,"skip_while","","",129],[10,"take_while","","",129],[10,"skip","","",129],[10,"take","","",129],[10,"scan","","",129],[10,"flat_map","","",129],[10,"fuse","","",129],[10,"inspect","","",129],[10,"by_ref","","",129],[10,"advance","","",129],[10,"collect","","",129],[10,"nth","","",129],[10,"last","","",129],[10,"fold","","",129],[10,"count","","",129],[10,"all","","",129],[10,"any","","",129],[10,"find","","",129],[10,"position","","",129],[10,"max_by","","",129],[10,"min_by","","",129],[10,"next_back","","",129],[10,"rev","","",129],[10,"next","","",130],[10,"size_hint","","",130],[10,"size_hint","","",130],[10,"chain","","",130],[10,"zip","","",130],[10,"map","","",130],[10,"filter","","",130],[10,"filter_map","","",130],[10,"enumerate","","",130],[10,"peekable","","",130],[10,"skip_while","","",130],[10,"take_while","","",130],[10,"skip","","",130],[10,"take","","",130],[10,"scan","","",130],[10,"flat_map","","",130],[10,"fuse","","",130],[10,"inspect","","",130],[10,"by_ref","","",130],[10,"advance","","",130],[10,"collect","","",130],[10,"nth","","",130],[10,"last","","",130],[10,"fold","","",130],[10,"count","","",130],[10,"all","","",130],[10,"any","","",130],[10,"find","","",130],[10,"position","","",130],[10,"max_by","","",130],[10,"min_by","","",130],[10,"next_back","","",130],[10,"rev","","",130],[10,"next","","",131],[10,"size_hint","","",131],[10,"size_hint","","",131],[10,"chain","","",131],[10,"zip","","",131],[10,"map","","",131],[10,"filter","","",131],[10,"filter_map","","",131],[10,"enumerate","","",131],[10,"peekable","","",131],[10,"skip_while","","",131],[10,"take_while","","",131],[10,"skip","","",131],[10,"take","","",131],[10,"scan","","",131],[10,"flat_map","","",131],[10,"fuse","","",131],[10,"inspect","","",131],[10,"by_ref","","",131],[10,"advance","","",131],[10,"collect","","",131],[10,"nth","","",131],[10,"last","","",131],[10,"fold","","",131],[10,"count","","",131],[10,"all","","",131],[10,"any","","",131],[10,"find","","",131],[10,"position","","",131],[10,"max_by","","",131],[10,"min_by","","",131],[10,"clone","","",132],[10,"clone_from","","",132],[10,"next","","",132],[10,"size_hint","","",132],[10,"size_hint","","",132],[10,"chain","","",132],[10,"zip","","",132],[10,"map","","",132],[10,"filter","","",132],[10,"filter_map","","",132],[10,"enumerate","","",132],[10,"peekable","","",132],[10,"skip_while","","",132],[10,"take_while","","",132],[10,"skip","","",132],[10,"take","","",132],[10,"scan","","",132],[10,"flat_map","","",132],[10,"fuse","","",132],[10,"inspect","","",132],[10,"by_ref","","",132],[10,"advance","","",132],[10,"collect","","",132],[10,"nth","","",132],[10,"last","","",132],[10,"fold","","",132],[10,"count","","",132],[10,"all","","",132],[10,"any","","",132],[10,"find","","",132],[10,"position","","",132],[10,"max_by","","",132],[10,"min_by","","",132],[10,"clone","","",133],[10,"clone_from","","",133],[10,"next","","",133],[10,"size_hint","","",133],[10,"size_hint","","",133],[10,"chain","","",133],[10,"zip","","",133],[10,"map","","",133],[10,"filter","","",133],[10,"filter_map","","",133],[10,"enumerate","","",133],[10,"peekable","","",133],[10,"skip_while","","",133],[10,"take_while","","",133],[10,"skip","","",133],[10,"take","","",133],[10,"scan","","",133],[10,"flat_map","","",133],[10,"fuse","","",133],[10,"inspect","","",133],[10,"by_ref","","",133],[10,"advance","","",133],[10,"collect","","",133],[10,"nth","","",133],[10,"last","","",133],[10,"fold","","",133],[10,"count","","",133],[10,"all","","",133],[10,"any","","",133],[10,"find","","",133],[10,"position","","",133],[10,"max_by","","",133],[10,"min_by","","",133],[10,"next_back","","",133],[10,"rev","","",133],[10,"indexable","","",133],[10,"idx","","",133],[10,"next","","",134],[10,"size_hint","","",134],[10,"size_hint","","",134],[10,"chain","","",134],[10,"zip","","",134],[10,"map","","",134],[10,"filter","","",134],[10,"filter_map","","",134],[10,"enumerate","","",134],[10,"peekable","","",134],[10,"skip_while","","",134],[10,"take_while","","",134],[10,"skip","","",134],[10,"take","","",134],[10,"scan","","",134],[10,"flat_map","","",134],[10,"fuse","","",134],[10,"inspect","","",134],[10,"by_ref","","",134],[10,"advance","","",134],[10,"collect","","",134],[10,"nth","","",134],[10,"last","","",134],[10,"fold","","",134],[10,"count","","",134],[10,"all","","",134],[10,"any","","",134],[10,"find","","",134],[10,"position","","",134],[10,"max_by","","",134],[10,"min_by","","",134],[10,"next_back","","",134],[10,"rev","","",134],[10,"clone","core::str","",135],[10,"clone_from","","",135],[10,"next","","",135],[10,"size_hint","","",135],[10,"size_hint","","",135],[10,"chain","","",135],[10,"zip","","",135],[10,"map","","",135],[10,"filter","","",135],[10,"filter_map","","",135],[10,"enumerate","","",135],[10,"peekable","","",135],[10,"skip_while","","",135],[10,"take_while","","",135],[10,"skip","","",135],[10,"take","","",135],[10,"scan","","",135],[10,"flat_map","","",135],[10,"fuse","","",135],[10,"inspect","","",135],[10,"by_ref","","",135],[10,"advance","","",135],[10,"collect","","",135],[10,"nth","","",135],[10,"last","","",135],[10,"fold","","",135],[10,"count","","",135],[10,"all","","",135],[10,"any","","",135],[10,"find","","",135],[10,"position","","",135],[10,"max_by","","",135],[10,"min_by","","",135],[10,"next_back","","",135],[10,"rev","","",135],[10,"clone","","",136],[10,"clone_from","","",136],[10,"next","","",136],[10,"size_hint","","",136],[10,"size_hint","","",136],[10,"chain","","",136],[10,"zip","","",136],[10,"map","","",136],[10,"filter","","",136],[10,"filter_map","","",136],[10,"enumerate","","",136],[10,"peekable","","",136],[10,"skip_while","","",136],[10,"take_while","","",136],[10,"skip","","",136],[10,"take","","",136],[10,"scan","","",136],[10,"flat_map","","",136],[10,"fuse","","",136],[10,"inspect","","",136],[10,"by_ref","","",136],[10,"advance","","",136],[10,"collect","","",136],[10,"nth","","",136],[10,"last","","",136],[10,"fold","","",136],[10,"count","","",136],[10,"all","","",136],[10,"any","","",136],[10,"find","","",136],[10,"position","","",136],[10,"max_by","","",136],[10,"min_by","","",136],[10,"next_back","","",136],[10,"rev","","",136],[10,"clone","","",137],[10,"clone_from","","",137],[10,"clone","","",138],[10,"clone_from","","",138],[10,"next","","",137],[10,"size_hint","","",137],[10,"chain","","",137],[10,"zip","","",137],[10,"map","","",137],[10,"filter","","",137],[10,"filter_map","","",137],[10,"enumerate","","",137],[10,"peekable","","",137],[10,"skip_while","","",137],[10,"take_while","","",137],[10,"skip","","",137],[10,"take","","",137],[10,"scan","","",137],[10,"flat_map","","",137],[10,"fuse","","",137],[10,"inspect","","",137],[10,"by_ref","","",137],[10,"advance","","",137],[10,"collect","","",137],[10,"nth","","",137],[10,"last","","",137],[10,"fold","","",137],[10,"count","","",137],[10,"all","","",137],[10,"any","","",137],[10,"find","","",137],[10,"position","","",137],[10,"max_by","","",137],[10,"min_by","","",137],[10,"next_back","","",137],[10,"rev","","",137],[10,"next","","",138],[10,"size_hint","","",138],[10,"chain","","",138],[10,"zip","","",138],[10,"map","","",138],[10,"filter","","",138],[10,"filter_map","","",138],[10,"enumerate","","",138],[10,"peekable","","",138],[10,"skip_while","","",138],[10,"take_while","","",138],[10,"skip","","",138],[10,"take","","",138],[10,"scan","","",138],[10,"flat_map","","",138],[10,"fuse","","",138],[10,"inspect","","",138],[10,"by_ref","","",138],[10,"advance","","",138],[10,"collect","","",138],[10,"nth","","",138],[10,"last","","",138],[10,"fold","","",138],[10,"count","","",138],[10,"all","","",138],[10,"any","","",138],[10,"find","","",138],[10,"position","","",138],[10,"max_by","","",138],[10,"min_by","","",138],[10,"clone","","",139],[10,"clone_from","","",139],[10,"clone","","",140],[10,"clone_from","","",140],[10,"clone","","",141],[10,"clone_from","","",141],[10,"clone","","",142],[10,"clone_from","","",142],[10,"clone","","",143],[10,"clone_from","","",143],[10,"next","","",142],[10,"size_hint","","",142],[10,"chain","","",142],[10,"zip","","",142],[10,"map","","",142],[10,"filter","","",142],[10,"filter_map","","",142],[10,"enumerate","","",142],[10,"peekable","","",142],[10,"skip_while","","",142],[10,"take_while","","",142],[10,"skip","","",142],[10,"take","","",142],[10,"scan","","",142],[10,"flat_map","","",142],[10,"fuse","","",142],[10,"inspect","","",142],[10,"by_ref","","",142],[10,"advance","","",142],[10,"collect","","",142],[10,"nth","","",142],[10,"last","","",142],[10,"fold","","",142],[10,"count","","",142],[10,"all","","",142],[10,"any","","",142],[10,"find","","",142],[10,"position","","",142],[10,"max_by","","",142],[10,"min_by","","",142],[10,"next","","",143],[10,"size_hint","","",143],[10,"chain","","",143],[10,"zip","","",143],[10,"map","","",143],[10,"filter","","",143],[10,"filter_map","","",143],[10,"enumerate","","",143],[10,"peekable","","",143],[10,"skip_while","","",143],[10,"take_while","","",143],[10,"skip","","",143],[10,"take","","",143],[10,"scan","","",143],[10,"flat_map","","",143],[10,"fuse","","",143],[10,"inspect","","",143],[10,"by_ref","","",143],[10,"advance","","",143],[10,"collect","","",143],[10,"nth","","",143],[10,"last","","",143],[10,"fold","","",143],[10,"count","","",143],[10,"all","","",143],[10,"any","","",143],[10,"find","","",143],[10,"position","","",143],[10,"max_by","","",143],[10,"min_by","","",143],[10,"clone","","",144],[10,"clone_from","","",144],[10,"next","","",144],[10,"size_hint","","",144],[10,"size_hint","","",144],[10,"chain","","",144],[10,"zip","","",144],[10,"map","","",144],[10,"filter","","",144],[10,"filter_map","","",144],[10,"enumerate","","",144],[10,"peekable","","",144],[10,"skip_while","","",144],[10,"take_while","","",144],[10,"skip","","",144],[10,"take","","",144],[10,"scan","","",144],[10,"flat_map","","",144],[10,"fuse","","",144],[10,"inspect","","",144],[10,"by_ref","","",144],[10,"advance","","",144],[10,"collect","","",144],[10,"nth","","",144],[10,"last","","",144],[10,"fold","","",144],[10,"count","","",144],[10,"all","","",144],[10,"any","","",144],[10,"find","","",144],[10,"position","","",144],[10,"max_by","","",144],[10,"min_by","","",144],[10,"clone","","",145],[10,"clone_from","","",145],[10,"fmt","","",146],[10,"clone","","",146],[10,"clone_from","","",146],[10,"assert_receiver_is_total_eq","","",146],[10,"eq","","",146],[10,"ne","","",146],[10,"ne","","",146],[10,"to_char_lossy","","Convert `self` to a `char`, taking `LoneSurrogate`s to the\nreplacement character (U+FFFD).",146],[10,"next","","",145],[10,"size_hint","","",145],[10,"size_hint","","",145],[10,"chain","","",145],[10,"zip","","",145],[10,"map","","",145],[10,"filter","","",145],[10,"filter_map","","",145],[10,"enumerate","","",145],[10,"peekable","","",145],[10,"skip_while","","",145],[10,"take_while","","",145],[10,"skip","","",145],[10,"take","","",145],[10,"scan","","",145],[10,"flat_map","","",145],[10,"fuse","","",145],[10,"inspect","","",145],[10,"by_ref","","",145],[10,"advance","","",145],[10,"collect","","",145],[10,"nth","","",145],[10,"last","","",145],[10,"fold","","",145],[10,"count","","",145],[10,"all","","",145],[10,"any","","",145],[10,"find","","",145],[10,"position","","",145],[10,"max_by","","",145],[10,"min_by","","",145],[10,"eq","core::fmt::num","",147],[10,"ne","","",147],[10,"ne","","",147],[10,"clone","","",147],[10,"clone_from","","",147],[10,"eq","","",148],[10,"ne","","",148],[10,"ne","","",148],[10,"clone","","",148],[10,"clone_from","","",148],[10,"eq","","",149],[10,"ne","","",149],[10,"ne","","",149],[10,"clone","","",149],[10,"clone_from","","",149],[10,"eq","","",150],[10,"ne","","",150],[10,"ne","","",150],[10,"clone","","",150],[10,"clone_from","","",150],[10,"eq","","",151],[10,"ne","","",151],[10,"ne","","",151],[10,"clone","","",151],[10,"clone_from","","",151],[10,"eq","","",152],[10,"ne","","",152],[10,"ne","","",152],[10,"clone","","",152],[10,"clone_from","","",152],[10,"fmt","","",153],[10,"fmt","","",153],[10,"fmt","","",153],[10,"fmt","","",153],[10,"fmt","","",153],[10,"fmt","","",153],[10,"fmt","","",153],[10,"fmt","","",153],[10,"fmt","","",153],[10,"fmt","","",153],[10,"eq","core::fmt::rt","",154],[10,"ne","","",154],[10,"ne","","",154],[10,"fmt","core::fmt","",155],[10,"pad_integral","","Performs the correct padding for an integer which has already been\nemitted into a byte-array. The byte-array should *not* contain the sign\nfor the integer, that will be added by this method.",156],[10,"pad","","This function takes a string slice and emits it to the internal buffer\nafter applying the relevant formatting flags specified. The flags\nrecognized for generic strings are:",156],[10,"write","","Writes some data to the underlying buffer contained within this\nformatter.",156],[10,"write_fmt","","Writes some formatted information into this instance",156],[10,"fmt","core::cell","",83],[10,"fmt","","",85],[10,"fmt","","",86],[2,"FPCategory","std::num","Used for representing the classification of floating point numbers"],[12,"FPNaN","","\"Not a Number\", often obtained by dividing by zero",66],[12,"FPInfinite","","Positive or negative infinity",66],[12,"FPZero","","Positive or negative zero",66],[12,"FPSubnormal","","De-normalized floating point representation (less precise than `FPNormal`)",66],[12,"FPNormal","","A regular floating point number",66],[6,"Float","","Operations on primitive floating point numbers."],[9,"nan","","Returns the NaN value.",157],[9,"infinity","","Returns the infinite value.",157],[9,"neg_infinity","","Returns the negative infinite value.",157],[9,"neg_zero","","Returns -0.0.",157],[9,"is_nan","","Returns true if this value is NaN and false otherwise.",157],[9,"is_infinite","","Returns true if this value is positive infinity or negative infinity and\nfalse otherwise.",157],[9,"is_finite","","Returns true if this number is neither infinite nor NaN.",157],[9,"is_normal","","Returns true if this number is neither zero, infinite, denormal, or NaN.",157],[9,"classify","","Returns the category that this number falls into.",157],[9,"mantissa_digits","","Returns the number of binary digits of mantissa that this type supports.",157],[9,"digits","","Returns the number of base-10 digits of precision that this type supports.",157],[9,"epsilon","","Returns the difference between 1.0 and the smallest representable number larger than 1.0.",157],[9,"min_exp","","Returns the minimum binary exponent that this type can represent.",157],[9,"max_exp","","Returns the maximum binary exponent that this type can represent.",157],[9,"min_10_exp","","Returns the minimum base-10 exponent that this type can represent.",157],[9,"max_10_exp","","Returns the maximum base-10 exponent that this type can represent.",157],[9,"min_pos_value","","Returns the smallest normalized positive number that this type can represent.",157],[9,"integer_decode","","Returns the mantissa, exponent and sign as integers, respectively.",157],[9,"floor","","Return the largest integer less than or equal to a number.",157],[9,"ceil","","Return the smallest integer greater than or equal to a number.",157],[9,"round","","Return the nearest integer to a number. Round half-way cases away from\n`0.0`.",157],[9,"trunc","","Return the integer part of a number.",157],[9,"fract","","Return the fractional part of a number.",157],[9,"mul_add","","Fused multiply-add. Computes `(self * a) + b` with only one rounding\nerror. This produces a more accurate result with better performance than\na separate multiplication operation followed by an add.",157],[9,"recip","","Take the reciprocal (inverse) of a number, `1/x`.",157],[9,"powi","","Raise a number to an integer power.",157],[9,"powf","","Raise a number to a floating point power.",157],[9,"sqrt2","","sqrt(2.0).",157],[9,"frac_1_sqrt2","","1.0 / sqrt(2.0).",157],[9,"sqrt","","Take the square root of a number.",157],[9,"rsqrt","","Take the reciprocal (inverse) square root of a number, `1/sqrt(x)`.",157],[9,"pi","","Archimedes' constant.",157],[9,"two_pi","","2.0 * pi.",157],[9,"frac_pi_2","","pi / 2.0.",157],[9,"frac_pi_3","","pi / 3.0.",157],[9,"frac_pi_4","","pi / 4.0.",157],[9,"frac_pi_6","","pi / 6.0.",157],[9,"frac_pi_8","","pi / 8.0.",157],[9,"frac_1_pi","","1.0 / pi.",157],[9,"frac_2_pi","","2.0 / pi.",157],[9,"frac_2_sqrtpi","","2.0 / sqrt(pi).",157],[9,"e","","Euler's number.",157],[9,"log2_e","","log2(e).",157],[9,"log10_e","","log10(e).",157],[9,"ln_2","","ln(2.0).",157],[9,"ln_10","","ln(10.0).",157],[9,"exp","","Returns `e^(self)`, (the exponential function).",157],[9,"exp2","","Returns 2 raised to the power of the number, `2^(self)`.",157],[9,"ln","","Returns the natural logarithm of the number.",157],[9,"log","","Returns the logarithm of the number with respect to an arbitrary base.",157],[9,"log2","","Returns the base 2 logarithm of the number.",157],[9,"log10","","Returns the base 10 logarithm of the number.",157],[9,"to_degrees","","Convert radians to degrees.",157],[9,"to_radians","","Convert degrees to radians.",157],[0,"to_string","std","The `ToString` trait for converting to strings"],[6,"ToString","std::to_string","A generic trait for converting a value to a string"],[9,"to_string","","Converts the value of `self` to an owned string",158],[6,"IntoStr","","Trait for converting a type to a string, consuming it in the process."],[9,"into_string","","Consume and convert to a string.",159],[0,"collections","std","Collection types."],[0,"hashmap","std::collections","Unordered containers, implemented as hash-tables (`HashSet` and `HashMap` types)"],[1,"HashMap","std::collections::hashmap","A hash map implementation which uses linear probing with Robin\nHood bucket stealing."],[1,"HashSet","","An implementation of a hash set using the underlying representation of a\nHashMap where the value is (). As with the `HashMap` type, a `HashSet`\nrequires that the elements implement the `Eq` and `Hash` traits."],[4,"Entries","","HashMap iterator"],[4,"MutEntries","","HashMap mutable values iterator"],[4,"MoveEntries","","HashMap move iterator"],[4,"Keys","","HashMap keys iterator"],[4,"Values","","HashMap values iterator"],[4,"SetItems","","HashSet iterator"],[4,"SetMoveItems","","HashSet move iterator"],[4,"SetAlgebraItems","","Set operations iterator"],[10,"clone","","",160],[10,"len","","Return the number of elements in the map.",160],[10,"clear","","Clear the map, removing all key-value pairs. Keeps the allocated memory\nfor reuse.",160],[10,"find","","",160],[10,"contains_key","","",160],[10,"find_mut","","",160],[10,"swap","","",160],[10,"pop","","",160],[10,"new","","Create an empty HashMap.",160],[10,"with_capacity","","Creates an empty hash map with the given initial capacity.",160],[10,"with_hasher","","Creates an empty hashmap which will use the given hasher to hash keys.",160],[10,"with_capacity_and_hasher","","Create an empty HashMap with space for at least `capacity`\nelements, using `hasher` to hash the keys.",160],[10,"reserve","","The hashtable will never try to shrink below this size. You can use\nthis function to reduce reallocations if your hashtable frequently\ngrows and shrinks by large amounts.",160],[10,"find_or_insert","","Return the value corresponding to the key in the map, or insert\nand return the value if it doesn't exist.",160],[10,"find_or_insert_with","","Return the value corresponding to the key in the map, or create,\ninsert, and return a new value if it doesn't exist.",160],[10,"insert_or_update_with","","Insert a key-value pair into the map if the key is not already present.\nOtherwise, modify the existing value for the key.\nReturns the new or modified value for the key.",160],[10,"find_with_or_insert_with","","Modify and return the value corresponding to the key in the map, or\ninsert and return a new value if it doesn't exist.",160],[10,"get","","Retrieves a value for the given key.\nSee [`find`](../trait.Map.html#tymethod.find) for a non-failing alternative.",160],[10,"get_mut","","Retrieves a mutable value for the given key.\nSee [`find_mut`](../trait.MutableMap.html#tymethod.find_mut) for a non-failing alternative.",160],[10,"contains_key_equiv","","Return true if the map contains a value for the specified key,\nusing equivalence.",160],[10,"find_equiv","","Return the value corresponding to the key in the map, using\nequivalence.",160],[10,"pop_equiv","","Remove an equivalent key from the map, returning the value at the\nkey if the key was previously in the map.",160],[10,"keys","","An iterator visiting all keys in arbitrary order.\nIterator element type is `&'a K`.",160],[10,"values","","An iterator visiting all values in arbitrary order.\nIterator element type is `&'a V`.",160],[10,"iter","","An iterator visiting all key-value pairs in arbitrary order.\nIterator element type is `(&'a K, &'a V)`.",160],[10,"mut_iter","","An iterator visiting all key-value pairs in arbitrary order,\nwith mutable references to the values.\nIterator element type is `(&'a K, &'a mut V)`.",160],[10,"move_iter","","Creates a consuming iterator, that is, one that moves each key-value\npair out of the map in arbitrary order. The map cannot be used after\ncalling this.",160],[10,"find_copy","","Return a copy of the value corresponding to the key.",160],[10,"get_copy","","Return a copy of the value corresponding to the key.",160],[10,"eq","","",160],[10,"fmt","","",160],[10,"default","","",160],[10,"from_iter","","",160],[10,"extend","","",160],[10,"clone","","",161],[10,"new","","Create an empty HashSet.",161],[10,"with_capacity","","Create an empty HashSet with space for at least `n` elements in\nthe hash table.",161],[10,"with_hasher","","Creates a new empty hash set which will use the given hasher to hash\nkeys.",161],[10,"with_capacity_and_hasher","","Create an empty HashSet with space for at least `capacity`\nelements in the hash table, using `hasher` to hash the keys.",161],[10,"reserve","","Reserve space for at least `n` elements in the hash table.",161],[10,"contains_equiv","","Returns true if the hash set contains a value equivalent to the\ngiven query value.",161],[10,"iter","","An iterator visiting all elements in arbitrary order.\nIterator element type is &'a T.",161],[10,"move_iter","","Creates a consuming iterator, that is, one that moves each value out\nof the set in arbitrary order. The set cannot be used after calling\nthis.",161],[10,"difference","","Visit the values representing the difference.",161],[10,"symmetric_difference","","Visit the values representing the symmetric difference.",161],[10,"intersection","","Visit the values representing the intersection.",161],[10,"union","","Visit the values representing the union.",161],[10,"eq","","",161],[10,"len","","",161],[10,"clear","","",161],[10,"contains","","",161],[10,"is_disjoint","","",161],[10,"is_subset","","",161],[10,"insert","","",161],[10,"remove","","",161],[10,"fmt","","",161],[10,"from_iter","","",161],[10,"extend","","",161],[10,"default","","",161],[0,"lru_cache","std::collections","A cache that holds a limited number of key-value pairs. When the\ncapacity of the cache is exceeded, the least-recently-used\n(where \"used\" means a look-up or putting the pair into the cache)\npair is automatically removed."],[1,"LruCache","std::collections::lru_cache","An LRU Cache."],[10,"new","","Create an LRU Cache that holds at most `capacity` items.",162],[10,"put","","Put a key-value pair into cache.",162],[10,"get","","Return a value corresponding to the key in the cache.",162],[10,"pop","","Remove and return a value corresponding to the key from the cache.",162],[10,"capacity","","Return the maximum number of key-value pairs the cache can hold.",162],[10,"change_capacity","","Change the number of key-value pairs the cache can hold. Remove\nleast-recently-used key-value pairs if necessary.",162],[10,"fmt","","Return a string that lists the key-value pairs from most-recently\nused to least-recently used.",162],[10,"len","","Return the number of key-value pairs in the cache.",162],[10,"clear","","Clear the cache of all key-value pairs.",162],[10,"drop","","",162],[6,"Collection","std::collections","A trait to represent the abstract idea of a container. The only concrete\nknowledge known is the number of elements contained within."],[9,"len","","Return the number of elements in the container",163],[9,"is_empty","","Return true if the container contains no elements",163],[6,"Mutable","","A trait to represent mutable containers"],[9,"clear","","Clear the container, removing all values.",164],[6,"Map","","A map is a key-value store where values may be looked up by their keys. This\ntrait provides basic operations to operate on these stores."],[9,"find","","Return a reference to the value corresponding to the key.",165],[9,"contains_key","","Return true if the map contains a value for the specified key.",165],[6,"MutableMap","","This trait provides basic operations to modify the contents of a map."],[9,"insert","","Insert a key-value pair into the map. An existing value for a\nkey is replaced by the new value. Return true if the key did\nnot already exist in the map.",166],[9,"remove","","Remove a key-value pair from the map. Return true if the key\nwas present in the map, otherwise false.",166],[9,"swap","","Insert a key-value pair from the map. If the key already had a value\npresent in the map, that value is returned. Otherwise None is returned.",166],[9,"pop","","Removes a key from the map, returning the value at the key if the key\nwas previously in the map.",166],[9,"find_mut","","Return a mutable reference to the value corresponding to the key.",166],[6,"Set","","A set is a group of objects which are each distinct from one another. This\ntrait represents actions which can be performed on sets to iterate over\nthem."],[9,"contains","","Return true if the set contains a value.",167],[9,"is_disjoint","","Return true if the set has no elements in common with `other`.\nThis is equivalent to checking for an empty intersection.",167],[9,"is_subset","","Return true if the set is a subset of another.",167],[9,"is_superset","","Return true if the set is a superset of another.",167],[6,"MutableSet","","This trait represents actions which can be performed on sets to mutate\nthem."],[9,"insert","","Add a value to the set. Return true if the value was not already\npresent in the set.",168],[9,"remove","","Remove a value from the set. Return true if the value was\npresent in the set.",168],[6,"Deque","","A double-ended sequence that allows querying, insertion and deletion at both\nends."],[9,"front","","Provide a reference to the front element, or `None` if the sequence is\nempty.",169],[9,"front_mut","","Provide a mutable reference to the front element, or `None` if the\nsequence is empty.",169],[9,"back","","Provide a reference to the back element, or `None` if the sequence is\nempty.",169],[9,"back_mut","","Provide a mutable reference to the back element, or `None` if the sequence\nis empty.",169],[9,"push_front","","Insert an element first in the sequence.",169],[9,"push_back","","Insert an element last in the sequence.",169],[9,"pop_back","","Remove the last element and return it, or `None` if the sequence is empty.",169],[9,"pop_front","","Remove the first element and return it, or `None` if the sequence is empty.",169],[6,"MutableSeq","",""],[9,"push","","Append an element to the back of a collection.",170],[9,"pop","","Remove the last element from a collection and return it, or `None` if it is\nempty.",170],[10,"new","collections::bitv","Create an empty Bitv.",171],[10,"with_capacity","","Create a Bitv that holds `nbits` elements, setting each element\nto `init`.",171],[10,"get","","Retrieve the value at index `i`.",171],[10,"set","","Set the value of a bit at a index `i`.",171],[10,"set_all","","Set all bits to 1.",171],[10,"negate","","Flip all bits.",171],[10,"union","","Calculate the union of two bitvectors, acts like bitwise or.",171],[10,"intersect","","Calculate the intersection of two bitvectors, acts like bitwise and.",171],[10,"difference","","Calculate the difference between two bitvectors.",171],[10,"all","","Returns `true` if all bits are 1.",171],[10,"iter","","Return an iterator over the elements of the vector in order.",171],[10,"none","","Return `true` if all bits are 0.",171],[10,"any","","Return `true` if any bit is 1.",171],[10,"to_bytes","","Organise the bits into bytes, such that the first bit in the\n`Bitv` becomes the high-order bit of the first byte. If the\nsize of the `Bitv` is not a multiple of 8 then trailing bits\nwill be filled-in with `false`.",171],[10,"to_bools","","Transform `self` into a `Vec<bool>` by turning each bit into a `bool`.",171],[10,"eq_vec","","Compare a bitvector to a vector of `bool`.\nBoth the bitvector and vector must have the same length.\n# Failure",171],[10,"truncate","","Shorten a Bitv, dropping excess elements.",171],[10,"reserve","","Grow the vector to be able to store `size` bits without resizing.",171],[10,"capacity","","Return the capacity in bits for this bit vector. Inserting any\nelement less than this amount will not trigger a resizing.",171],[10,"grow","","Grow the `Bitv` in-place. Add `n` copies of `value` to the `Bitv`.",171],[10,"pop","","Shorten by one and return the removed element.",171],[10,"push","","Push a `bool` onto the end.",171],[10,"clone","","",172],[10,"clone_from","","",172],[10,"clone","","",173],[10,"clone_from","","",173],[10,"clone","","",174],[10,"clone_from","","",174],[10,"index","","",171],[10,"next","","Returns (offset, word)",175],[10,"size_hint","","",175],[10,"chain","","",175],[10,"zip","","",175],[10,"map","","",175],[10,"filter","","",175],[10,"filter_map","","",175],[10,"enumerate","","",175],[10,"peekable","","",175],[10,"skip_while","","",175],[10,"take_while","","",175],[10,"skip","","",175],[10,"take","","",175],[10,"scan","","",175],[10,"flat_map","","",175],[10,"fuse","","",175],[10,"inspect","","",175],[10,"by_ref","","",175],[10,"advance","","",175],[10,"collect","","",175],[10,"nth","","",175],[10,"last","","",175],[10,"fold","","",175],[10,"count","","",175],[10,"all","","",175],[10,"any","","",175],[10,"find","","",175],[10,"position","","",175],[10,"max_by","","",175],[10,"min_by","","",175],[10,"default","","",171],[10,"len","","",171],[10,"is_empty","","",171],[10,"clear","","",171],[10,"from_iter","","",171],[10,"extend","","",171],[10,"clone","","",171],[10,"clone_from","","",171],[10,"clone_from","","",171],[10,"partial_cmp","","",171],[10,"lt","","",171],[10,"le","","",171],[10,"gt","","",171],[10,"ge","","",171],[10,"cmp","","",171],[10,"fmt","","",171],[10,"hash","","",171],[10,"eq","","",171],[10,"ne","","",171],[10,"assert_receiver_is_total_eq","","",171],[10,"next","","",176],[10,"size_hint","","",176],[10,"size_hint","","",176],[10,"chain","","",176],[10,"zip","","",176],[10,"map","","",176],[10,"filter","","",176],[10,"filter_map","","",176],[10,"enumerate","","",176],[10,"peekable","","",176],[10,"skip_while","","",176],[10,"take_while","","",176],[10,"skip","","",176],[10,"take","","",176],[10,"scan","","",176],[10,"flat_map","","",176],[10,"fuse","","",176],[10,"inspect","","",176],[10,"by_ref","","",176],[10,"advance","","",176],[10,"collect","","",176],[10,"nth","","",176],[10,"last","","",176],[10,"fold","","",176],[10,"count","","",176],[10,"all","","",176],[10,"any","","",176],[10,"find","","",176],[10,"position","","",176],[10,"max_by","","",176],[10,"min_by","","",176],[10,"next_back","","",176],[10,"rev","","",176],[10,"rposition","","",176],[10,"len","","",176],[10,"indexable","","",176],[10,"idx","","",176],[10,"cmp","","",177],[10,"partial_cmp","","",177],[10,"lt","","",177],[10,"le","","",177],[10,"gt","","",177],[10,"ge","","",177],[10,"lt","","",177],[10,"le","","",177],[10,"gt","","",177],[10,"ge","","",177],[10,"assert_receiver_is_total_eq","","",177],[10,"eq","","",177],[10,"ne","","",177],[10,"ne","","",177],[10,"clone","","",177],[10,"clone_from","","",177],[10,"default","","",177],[10,"new","","Create a new bit vector set with initially no contents.",177],[10,"with_capacity","","Create a new bit vector set with initially no contents, able to\nhold `nbits` elements without resizing.",177],[10,"from_bitv","","Create a new bit vector set from the given bit vector.",177],[10,"capacity","","Returns the capacity in bits for this bit vector. Inserting any\nelement less than this amount will not trigger a resizing.",177],[10,"reserve","","Grows the underlying vector to be able to store `size` bits.",177],[10,"unwrap","","Consume this set to return the underlying bit vector.",177],[10,"get_ref","","Return a reference to the underlying bit vector.",177],[10,"get_mut_ref","","Return a mutable reference to the underlying bit vector.",177],[10,"shrink_to_fit","","Truncate the underlying vector to the least length required.",177],[10,"iter","","Iterator over each uint stored in the BitvSet.",177],[10,"union","","Iterator over each uint stored in `self` union `other`.\nSee [union_with](#method.union_with) for an efficient in-place version.",177],[10,"intersection","","Iterator over each uint stored in `self` intersect `other`.\nSee [intersect_with](#method.intersect_with) for an efficient in-place version.",177],[10,"difference","","Iterator over each uint stored in the `self` setminus `other`.\nSee [difference_with](#method.difference_with) for an efficient in-place version.",177],[10,"symmetric_difference","","Iterator over each uint stored in the symmetric difference of `self` and `other`.\nSee [symmetric_difference_with](#method.symmetric_difference_with) for\nan efficient in-place version.",177],[10,"union_with","","Union in-place with the specified other bit vector.",177],[10,"intersect_with","","Intersect in-place with the specified other bit vector.",177],[10,"difference_with","","Difference in-place with the specified other bit vector.",177],[10,"symmetric_difference_with","","Symmetric difference in-place with the specified other bit vector.",177],[10,"fmt","","",177],[10,"hash","","",177],[10,"len","","",177],[10,"is_empty","","",177],[10,"clear","","",177],[10,"contains","","",177],[10,"is_disjoint","","",177],[10,"is_subset","","",177],[10,"is_superset","","",177],[10,"is_superset","","",177],[10,"insert","","",177],[10,"remove","","",177],[10,"next","","",178],[10,"size_hint","","",178],[10,"size_hint","","",178],[10,"chain","","",178],[10,"zip","","",178],[10,"map","","",178],[10,"filter","","",178],[10,"filter_map","","",178],[10,"enumerate","","",178],[10,"peekable","","",178],[10,"skip_while","","",178],[10,"take_while","","",178],[10,"skip","","",178],[10,"take","","",178],[10,"scan","","",178],[10,"flat_map","","",178],[10,"fuse","","",178],[10,"inspect","","",178],[10,"by_ref","","",178],[10,"advance","","",178],[10,"collect","","",178],[10,"nth","","",178],[10,"last","","",178],[10,"fold","","",178],[10,"count","","",178],[10,"all","","",178],[10,"any","","",178],[10,"find","","",178],[10,"position","","",178],[10,"max_by","","",178],[10,"min_by","","",178],[10,"next","","",179],[10,"size_hint","","",179],[10,"size_hint","","",179],[10,"chain","","",179],[10,"zip","","",179],[10,"map","","",179],[10,"filter","","",179],[10,"filter_map","","",179],[10,"enumerate","","",179],[10,"peekable","","",179],[10,"skip_while","","",179],[10,"take_while","","",179],[10,"skip","","",179],[10,"take","","",179],[10,"scan","","",179],[10,"flat_map","","",179],[10,"fuse","","",179],[10,"inspect","","",179],[10,"by_ref","","",179],[10,"advance","","",179],[10,"collect","","",179],[10,"nth","","",179],[10,"last","","",179],[10,"fold","","",179],[10,"count","","",179],[10,"all","","",179],[10,"any","","",179],[10,"find","","",179],[10,"position","","",179],[10,"max_by","","",179],[10,"min_by","","",179],[10,"new","collections::btree","Returns new BTree with root node (leaf) and user-supplied lower bound\nThe lower bound applies to every node except the root node.",180],[10,"get","","Returns the value of a given key, which may not exist in the tree.\nCalls the root node's get method.",180],[10,"insert","","An insert method that uses the clone() feature for support.",180],[10,"clone","","Implements the Clone trait for the BTree.\nUses a helper function/constructor to produce a new BTree.",180],[10,"clone_from","","",180],[10,"eq","","",180],[10,"ne","","",180],[10,"assert_receiver_is_total_eq","","",180],[10,"partial_cmp","","",180],[10,"lt","","",180],[10,"le","","",180],[10,"gt","","",180],[10,"ge","","",180],[10,"cmp","","Returns an ordering based on the root nodes of each BTree.",180],[10,"fmt","","Returns a string representation of the BTree",180],[10,"clone","","Returns a new node based on whether or not it is a branch or a leaf.",181],[10,"clone_from","","",181],[10,"eq","","",181],[10,"ne","","",181],[10,"assert_receiver_is_total_eq","","",181],[10,"partial_cmp","","",181],[10,"lt","","",181],[10,"le","","",181],[10,"gt","","",181],[10,"ge","","",181],[10,"cmp","","Implementation of Ord for Nodes.",181],[10,"fmt","","Returns a string representation of a Node.\nWill iterate over the Node and show \"Key: x, value: y, child: () // \"\nfor all elements in the Node. \"Child\" only exists if the Node contains\na branch.",181],[10,"clone","","Returns a new Leaf with the same elts.",182],[10,"clone_from","","",182],[10,"eq","","",182],[10,"ne","","",182],[10,"assert_receiver_is_total_eq","","",182],[10,"partial_cmp","","",182],[10,"lt","","",182],[10,"le","","",182],[10,"gt","","",182],[10,"ge","","",182],[10,"cmp","","Returns an ordering based on the first element of each Leaf.",182],[10,"fmt","","Returns a string representation of a Leaf.",182],[10,"clone","","Returns a new branch using the clone methods of the Branch's internal variables.",183],[10,"clone_from","","",183],[10,"eq","","",183],[10,"ne","","",183],[10,"assert_receiver_is_total_eq","","",183],[10,"partial_cmp","","",183],[10,"lt","","",183],[10,"le","","",183],[10,"gt","","",183],[10,"ge","","",183],[10,"cmp","","Compares the first elements of two branches to determine an ordering",183],[10,"fmt","","Returns a string representation of a Branch.",183],[10,"clone","","Returns a new LeafElt by cloning the key and value.",184],[10,"clone_from","","",184],[10,"eq","","",184],[10,"ne","","",184],[10,"assert_receiver_is_total_eq","","",184],[10,"partial_cmp","","",184],[10,"lt","","",184],[10,"le","","",184],[10,"gt","","",184],[10,"ge","","",184],[10,"cmp","","Returns an ordering based on the keys of the LeafElts.",184],[10,"fmt","","Returns a string representation of a LeafElt.",184],[10,"clone","","Returns a new BranchElt by cloning the key, value, and left child.",185],[10,"clone_from","","",185],[10,"eq","","",185],[10,"ne","","",185],[10,"assert_receiver_is_total_eq","","",185],[10,"partial_cmp","","",185],[10,"lt","","",185],[10,"le","","",185],[10,"gt","","",185],[10,"ge","","",185],[10,"cmp","","Fulfills Ord for BranchElts",185],[10,"fmt","","Returns string containing key, value, and child (which should recur to a\nleaf) Consider changing in future to be more readable.",185],[10,"clone","collections::dlist","",186],[10,"clone_from","","",186],[10,"clone","","",187],[10,"clone_from","","",187],[10,"clone","","",188],[10,"clone_from","","",188],[10,"is_empty","","O(1)",189],[10,"len","","O(1)",189],[10,"is_empty","","",189],[10,"clear","","Remove all elements from the DList",189],[10,"front","","Provide a reference to the front element, or None if the list is empty",189],[10,"front_mut","","Provide a mutable reference to the front element, or None if the list is empty",189],[10,"back","","Provide a reference to the back element, or None if the list is empty",189],[10,"back_mut","","Provide a mutable reference to the back element, or None if the list is empty",189],[10,"push_front","","Add an element first in the list",189],[10,"pop_front","","Remove the first element and return it, or None if the list is empty",189],[10,"push_back","","",189],[10,"pop_back","","",189],[10,"push","","",189],[10,"pop","","",189],[10,"default","","",189],[10,"new","","Create an empty DList",189],[10,"rotate_forward","","Move the last element to the front of the list.",189],[10,"rotate_backward","","Move the first element to the back of the list.",189],[10,"append","","Add all elements from `other` to the end of the list",189],[10,"prepend","","Add all elements from `other` to the beginning of the list",189],[10,"insert_when","","Insert `elt` before the first `x` in the list where `f(x, elt)` is true,\nor at the end.",189],[10,"merge","","Merge DList `other` into this DList, using the function `f`.\nIterate the both DList with `a` from self and `b` from `other`, and\nput `a` in the result if `f(a, b)` is true, else `b`.",189],[10,"iter","","Provide a forward iterator",189],[10,"mut_iter","","Provide a forward iterator with mutable references",189],[10,"move_iter","","Consume the list into an iterator yielding elements by value",189],[10,"insert_ordered","","Insert `elt` sorted in ascending order",189],[10,"drop","","",189],[10,"next","","",186],[10,"size_hint","","",186],[10,"size_hint","","",186],[10,"chain","","",186],[10,"zip","","",186],[10,"map","","",186],[10,"filter","","",186],[10,"filter_map","","",186],[10,"enumerate","","",186],[10,"peekable","","",186],[10,"skip_while","","",186],[10,"take_while","","",186],[10,"skip","","",186],[10,"take","","",186],[10,"scan","","",186],[10,"flat_map","","",186],[10,"fuse","","",186],[10,"inspect","","",186],[10,"by_ref","","",186],[10,"advance","","",186],[10,"collect","","",186],[10,"nth","","",186],[10,"last","","",186],[10,"fold","","",186],[10,"count","","",186],[10,"all","","",186],[10,"any","","",186],[10,"find","","",186],[10,"position","","",186],[10,"max_by","","",186],[10,"min_by","","",186],[10,"next_back","","",186],[10,"rev","","",186],[10,"rposition","","",186],[10,"len","","",186],[10,"next","","",190],[10,"size_hint","","",190],[10,"size_hint","","",190],[10,"chain","","",190],[10,"zip","","",190],[10,"map","","",190],[10,"filter","","",190],[10,"filter_map","","",190],[10,"enumerate","","",190],[10,"peekable","","",190],[10,"skip_while","","",190],[10,"take_while","","",190],[10,"skip","","",190],[10,"take","","",190],[10,"scan","","",190],[10,"flat_map","","",190],[10,"fuse","","",190],[10,"inspect","","",190],[10,"by_ref","","",190],[10,"advance","","",190],[10,"collect","","",190],[10,"nth","","",190],[10,"last","","",190],[10,"fold","","",190],[10,"count","","",190],[10,"all","","",190],[10,"any","","",190],[10,"find","","",190],[10,"position","","",190],[10,"max_by","","",190],[10,"min_by","","",190],[10,"next_back","","",190],[10,"rev","","",190],[10,"rposition","","",190],[10,"len","","",190],[10,"insert_next","","",190],[10,"peek_next","","",190],[10,"next","","",187],[10,"size_hint","","",187],[10,"size_hint","","",187],[10,"chain","","",187],[10,"zip","","",187],[10,"map","","",187],[10,"filter","","",187],[10,"filter_map","","",187],[10,"enumerate","","",187],[10,"peekable","","",187],[10,"skip_while","","",187],[10,"take_while","","",187],[10,"skip","","",187],[10,"take","","",187],[10,"scan","","",187],[10,"flat_map","","",187],[10,"fuse","","",187],[10,"inspect","","",187],[10,"by_ref","","",187],[10,"advance","","",187],[10,"collect","","",187],[10,"nth","","",187],[10,"last","","",187],[10,"fold","","",187],[10,"count","","",187],[10,"all","","",187],[10,"any","","",187],[10,"find","","",187],[10,"position","","",187],[10,"max_by","","",187],[10,"min_by","","",187],[10,"next_back","","",187],[10,"rev","","",187],[10,"from_iter","","",189],[10,"extend","","",189],[10,"eq","","",189],[10,"ne","","",189],[10,"ne","","",189],[10,"partial_cmp","","",189],[10,"lt","","",189],[10,"le","","",189],[10,"gt","","",189],[10,"ge","","",189],[10,"clone","","",189],[10,"clone_from","","",189],[10,"fmt","","",189],[10,"hash","","",189],[10,"fmt","collections::enum_set","",191],[10,"hash","","",191],[10,"assert_receiver_is_total_eq","","",191],[10,"eq","","",191],[10,"ne","","",191],[10,"ne","","",191],[10,"clone","","",191],[10,"clone_from","","",191],[10,"empty","","Returns an empty EnumSet.",191],[10,"is_empty","","Returns true if an EnumSet is empty.",191],[10,"intersects","","Returns true if an EnumSet contains any enum of a given EnumSet",191],[10,"intersection","","Returns an intersection of both EnumSets.",191],[10,"contains","","Returns true if a given EnumSet is included in an EnumSet.",191],[10,"union","","Returns a union of both EnumSets.",191],[10,"add","","Add an enum to an EnumSet",191],[10,"contains_elem","","Returns true if an EnumSet contains a given enum",191],[10,"iter","","Returns an iterator over an EnumSet",191],[10,"sub","","",191],[10,"bitor","","",191],[10,"bitand","","",191],[10,"next","","",192],[10,"size_hint","","",192],[10,"size_hint","","",192],[10,"chain","","",192],[10,"zip","","",192],[10,"map","","",192],[10,"filter","","",192],[10,"filter_map","","",192],[10,"enumerate","","",192],[10,"peekable","","",192],[10,"skip_while","","",192],[10,"take_while","","",192],[10,"skip","","",192],[10,"take","","",192],[10,"scan","","",192],[10,"flat_map","","",192],[10,"fuse","","",192],[10,"inspect","","",192],[10,"by_ref","","",192],[10,"advance","","",192],[10,"collect","","",192],[10,"nth","","",192],[10,"last","","",192],[10,"fold","","",192],[10,"count","","",192],[10,"all","","",192],[10,"any","","",192],[10,"find","","",192],[10,"position","","",192],[10,"max_by","","",192],[10,"min_by","","",192],[10,"clone","collections::priority_queue","",193],[10,"clone_from","","",193],[10,"len","","Returns the length of the queue",193],[10,"is_empty","","",193],[10,"clear","","Drop all items from the queue",193],[10,"default","","",193],[10,"new","","Create an empty PriorityQueue as a max-heap.",193],[10,"with_capacity","","Create an empty PriorityQueue with a specific capacity.\nThis preallocates enough memory for `capacity` elements,\nso that the PriorityQueue does not have to be reallocated\nuntil it contains at least that many values.",193],[10,"from_vec","","Create a PriorityQueue from a vector. This is sometimes called\n`heapifying` the vector.",193],[10,"iter","","An iterator visiting all values in underlying vector, in\narbitrary order.",193],[10,"top","","Returns the greatest item in a queue or `None` if it is empty.",193],[10,"maybe_top","","",193],[10,"capacity","","Returns the number of elements the queue can hold without reallocating.",193],[10,"reserve_exact","","Reserve capacity for exactly `n` elements in the PriorityQueue.\nDo nothing if the capacity is already sufficient.",193],[10,"reserve","","Reserve capacity for at least `n` elements in the PriorityQueue.\nDo nothing if the capacity is already sufficient.",193],[10,"pop","","Remove the greatest item from a queue and return it, or `None` if it is\nempty.",193],[10,"maybe_pop","","",193],[10,"push","","Push an item onto the queue.",193],[10,"push_pop","","Optimized version of a push followed by a pop.",193],[10,"replace","","Optimized version of a pop followed by a push. The push is done\nregardless of whether the queue is empty.",193],[10,"into_vec","","Consume the PriorityQueue and return the underlying vector\nin arbitrary order.",193],[10,"into_sorted_vec","","Consume the PriorityQueue and return a vector in sorted\n(ascending) order.",193],[10,"next","","",194],[10,"size_hint","","",194],[10,"size_hint","","",194],[10,"chain","","",194],[10,"zip","","",194],[10,"map","","",194],[10,"filter","","",194],[10,"filter_map","","",194],[10,"enumerate","","",194],[10,"peekable","","",194],[10,"skip_while","","",194],[10,"take_while","","",194],[10,"skip","","",194],[10,"take","","",194],[10,"scan","","",194],[10,"flat_map","","",194],[10,"fuse","","",194],[10,"inspect","","",194],[10,"by_ref","","",194],[10,"advance","","",194],[10,"collect","","",194],[10,"nth","","",194],[10,"last","","",194],[10,"fold","","",194],[10,"count","","",194],[10,"all","","",194],[10,"any","","",194],[10,"find","","",194],[10,"position","","",194],[10,"max_by","","",194],[10,"min_by","","",194],[10,"from_iter","","",193],[10,"extend","","",193],[10,"clone","collections::ringbuf","",195],[10,"clone_from","","",195],[10,"len","","Return the number of elements in the RingBuf",195],[10,"is_empty","","",195],[10,"clear","","Clear the RingBuf, removing all values.",195],[10,"front","","Return a reference to the first element in the RingBuf",195],[10,"front_mut","","Return a mutable reference to the first element in the RingBuf",195],[10,"back","","Return a reference to the last element in the RingBuf",195],[10,"back_mut","","Return a mutable reference to the last element in the RingBuf",195],[10,"pop_front","","Remove and return the first element in the RingBuf, or None if it is empty",195],[10,"push_front","","Prepend an element to the RingBuf",195],[10,"push_back","","",195],[10,"pop_back","","",195],[10,"push","","",195],[10,"pop","","",195],[10,"default","","",195],[10,"new","","Create an empty RingBuf",195],[10,"with_capacity","","Create an empty RingBuf with space for at least `n` elements.",195],[10,"get","","Retrieve an element in the RingBuf by index",195],[10,"get_mut","","Retrieve an element in the RingBuf by index",195],[10,"swap","","Swap elements at indices `i` and `j`",195],[10,"reserve_exact","","Reserve capacity for exactly `n` elements in the given RingBuf,\ndoing nothing if `self`'s capacity is already equal to or greater\nthan the requested capacity",195],[10,"reserve","","Reserve capacity for at least `n` elements in the given RingBuf,\nover-allocating in case the caller needs to reserve additional\nspace.",195],[10,"iter","","Front-to-back iterator.",195],[10,"mut_iter","","Front-to-back iterator which returns mutable values.",195],[10,"next","","",196],[10,"size_hint","","",196],[10,"size_hint","","",196],[10,"chain","","",196],[10,"zip","","",196],[10,"map","","",196],[10,"filter","","",196],[10,"filter_map","","",196],[10,"enumerate","","",196],[10,"peekable","","",196],[10,"skip_while","","",196],[10,"take_while","","",196],[10,"skip","","",196],[10,"take","","",196],[10,"scan","","",196],[10,"flat_map","","",196],[10,"fuse","","",196],[10,"inspect","","",196],[10,"by_ref","","",196],[10,"advance","","",196],[10,"collect","","",196],[10,"nth","","",196],[10,"last","","",196],[10,"fold","","",196],[10,"count","","",196],[10,"all","","",196],[10,"any","","",196],[10,"find","","",196],[10,"position","","",196],[10,"max_by","","",196],[10,"min_by","","",196],[10,"next_back","","",196],[10,"rev","","",196],[10,"rposition","","",196],[10,"len","","",196],[10,"indexable","","",196],[10,"idx","","",196],[10,"next","","",197],[10,"size_hint","","",197],[10,"size_hint","","",197],[10,"chain","","",197],[10,"zip","","",197],[10,"map","","",197],[10,"filter","","",197],[10,"filter_map","","",197],[10,"enumerate","","",197],[10,"peekable","","",197],[10,"skip_while","","",197],[10,"take_while","","",197],[10,"skip","","",197],[10,"take","","",197],[10,"scan","","",197],[10,"flat_map","","",197],[10,"fuse","","",197],[10,"inspect","","",197],[10,"by_ref","","",197],[10,"advance","","",197],[10,"collect","","",197],[10,"nth","","",197],[10,"last","","",197],[10,"fold","","",197],[10,"count","","",197],[10,"all","","",197],[10,"any","","",197],[10,"find","","",197],[10,"position","","",197],[10,"max_by","","",197],[10,"min_by","","",197],[10,"next_back","","",197],[10,"rev","","",197],[10,"rposition","","",197],[10,"len","","",197],[10,"eq","","",195],[10,"ne","","",195],[10,"ne","","",195],[10,"partial_cmp","","",195],[10,"lt","","",195],[10,"le","","",195],[10,"gt","","",195],[10,"ge","","",195],[10,"hash","","",195],[10,"from_iter","","",195],[10,"extend","","",195],[10,"fmt","","",195],[10,"assert_receiver_is_total_eq","collections::smallintmap","",198],[10,"eq","","",198],[10,"ne","","",198],[10,"ne","","",198],[10,"len","","Return the number of elements in the map.",198],[10,"is_empty","","Return `true` if there are no elements in the map.",198],[10,"is_empty","","",198],[10,"clear","","Clear the map, removing all key-value pairs.",198],[10,"find","","Return a reference to the value corresponding to the key.",198],[10,"contains_key","","",198],[10,"find_mut","","Return a mutable reference to the value corresponding to the key.",198],[10,"insert","","Insert a key-value pair into the map. An existing value for a\nkey is replaced by the new value. Return `true` if the key did\nnot already exist in the map.",198],[10,"remove","","Remove a key-value pair from the map. Return `true` if the key\nwas present in the map, otherwise `false`.",198],[10,"swap","","Insert a key-value pair from the map. If the key already had a value\npresent in the map, that value is returned. Otherwise `None` is returned.",198],[10,"pop","","Removes a key from the map, returning the value at the key if the key\nwas previously in the map.",198],[10,"insert","","",198],[10,"remove","","",198],[10,"default","","",198],[10,"clone","","",198],[10,"clone_from","","",198],[10,"clone_from","","",198],[10,"hash","","",198],[10,"new","","Create an empty SmallIntMap.",198],[10,"with_capacity","","Create an empty SmallIntMap with space for at least `capacity` elements\nbefore resizing.",198],[10,"get","","Retrieves a value for the given key.\nSee [`find`](../trait.Map.html#tymethod.find) for a non-failing alternative.",198],[10,"keys","","An iterator visiting all keys in ascending order by the keys.\nIterator element type is `uint`.",198],[10,"values","","An iterator visiting all values in ascending order by the keys.\nIterator element type is `&'r V`.",198],[10,"iter","","An iterator visiting all key-value pairs in ascending order by the keys.\nIterator element type is `(uint, &'r V)`.",198],[10,"mut_iter","","An iterator visiting all key-value pairs in ascending order by the keys,\nwith mutable references to the values\nIterator element type is `(uint, &'r mut V)`.",198],[10,"move_iter","","Empties the map, moving all values into the specified closure.",198],[10,"update","","Update a value in the map. If the key already exists in the map,\nmodify the value with `ff` taking `oldval, newval`.\nOtherwise set the value to `newval`.\nReturn `true` if the key did not already exist in the map.",198],[10,"update_with_key","","Update a value in the map. If the key already exists in the map,\nmodify the value with `ff` taking `key, oldval, newval`.\nOtherwise set the value to `newval`.\nReturn `true` if the key did not already exist in the map.",198],[10,"partial_cmp","","",198],[10,"lt","","",198],[10,"le","","",198],[10,"gt","","",198],[10,"ge","","",198],[10,"cmp","","",198],[10,"fmt","","",198],[10,"from_iter","","",198],[10,"extend","","",198],[10,"next","","",199],[10,"size_hint","","",199],[10,"size_hint","","",199],[10,"chain","","",199],[10,"zip","","",199],[10,"map","","",199],[10,"filter","","",199],[10,"filter_map","","",199],[10,"enumerate","","",199],[10,"peekable","","",199],[10,"skip_while","","",199],[10,"take_while","","",199],[10,"skip","","",199],[10,"take","","",199],[10,"scan","","",199],[10,"flat_map","","",199],[10,"fuse","","",199],[10,"inspect","","",199],[10,"by_ref","","",199],[10,"advance","","",199],[10,"collect","","",199],[10,"nth","","",199],[10,"last","","",199],[10,"fold","","",199],[10,"count","","",199],[10,"all","","",199],[10,"any","","",199],[10,"find","","",199],[10,"position","","",199],[10,"max_by","","",199],[10,"min_by","","",199],[10,"next_back","","",199],[10,"rev","","",199],[10,"next","","",200],[10,"size_hint","","",200],[10,"size_hint","","",200],[10,"chain","","",200],[10,"zip","","",200],[10,"map","","",200],[10,"filter","","",200],[10,"filter_map","","",200],[10,"enumerate","","",200],[10,"peekable","","",200],[10,"skip_while","","",200],[10,"take_while","","",200],[10,"skip","","",200],[10,"take","","",200],[10,"scan","","",200],[10,"flat_map","","",200],[10,"fuse","","",200],[10,"inspect","","",200],[10,"by_ref","","",200],[10,"advance","","",200],[10,"collect","","",200],[10,"nth","","",200],[10,"last","","",200],[10,"fold","","",200],[10,"count","","",200],[10,"all","","",200],[10,"any","","",200],[10,"find","","",200],[10,"position","","",200],[10,"max_by","","",200],[10,"min_by","","",200],[10,"next_back","","",200],[10,"rev","","",200],[10,"clone","collections::treemap","",201],[10,"clone_from","","",201],[10,"eq","","",201],[10,"ne","","",201],[10,"partial_cmp","","",201],[10,"lt","","",201],[10,"le","","",201],[10,"gt","","",201],[10,"ge","","",201],[10,"fmt","","",201],[10,"len","","",201],[10,"is_empty","","",201],[10,"clear","","",201],[10,"find","","",201],[10,"contains_key","","",201],[10,"find_mut","","",201],[10,"swap","","",201],[10,"pop","","",201],[10,"insert","","",201],[10,"remove","","",201],[10,"default","","",201],[10,"new","","Create an empty `TreeMap`.",201],[10,"keys","","Get a lazy iterator over the keys in the map, in ascending order.",201],[10,"values","","Get a lazy iterator over the values in the map, in ascending order\nwith respect to the corresponding keys.",201],[10,"iter","","Get a lazy iterator over the key-value pairs in the map, in ascending order.",201],[10,"rev_iter","","Get a lazy reverse iterator over the key-value pairs in the map, in descending order.",201],[10,"mut_iter","","Get a lazy forward iterator over the key-value pairs in the\nmap, with the values being mutable.",201],[10,"mut_rev_iter","","Get a lazy reverse iterator over the key-value pairs in the\nmap, with the values being mutable.",201],[10,"move_iter","","Get a lazy iterator that consumes the treemap, it is not usable\nafter calling this.",201],[10,"find_with","","Return the value for which `f(key)` returns `Equal`. `f` is invoked\nwith current key and guides tree navigation. That means `f` should\nbe aware of natural ordering of the tree.",201],[10,"find_mut_with","","Return the value for which `f(key)` returns `Equal`. `f` is invoked\nwith current key and guides tree navigation. That means `f` should\nbe aware of natural ordering of the tree.",201],[10,"lower_bound","","Return a lazy iterator to the first key-value pair whose key is not less than `k`\nIf all keys in map are less than `k` an empty iterator is returned.",201],[10,"upper_bound","","Return a lazy iterator to the first key-value pair whose key is greater than `k`\nIf all keys in map are less than or equal to `k` an empty iterator is returned.",201],[10,"mut_lower_bound","","Return a lazy value iterator to the first key-value pair (with\nthe value being mutable) whose key is not less than `k`.",201],[10,"mut_upper_bound","","Return a lazy iterator to the first key-value pair (with the\nvalue being mutable) whose key is greater than `k`.",201],[10,"next","","Advance the iterator to the next node (in order) and return a\ntuple with a reference to the key and value. If there are no\nmore nodes, return `None`.",202],[10,"size_hint","","",202],[10,"size_hint","","",202],[10,"chain","","",202],[10,"zip","","",202],[10,"map","","",202],[10,"filter","","",202],[10,"filter_map","","",202],[10,"enumerate","","",202],[10,"peekable","","",202],[10,"skip_while","","",202],[10,"take_while","","",202],[10,"skip","","",202],[10,"take","","",202],[10,"scan","","",202],[10,"flat_map","","",202],[10,"fuse","","",202],[10,"inspect","","",202],[10,"by_ref","","",202],[10,"advance","","",202],[10,"collect","","",202],[10,"nth","","",202],[10,"last","","",202],[10,"fold","","",202],[10,"count","","",202],[10,"all","","",202],[10,"any","","",202],[10,"find","","",202],[10,"position","","",202],[10,"max_by","","",202],[10,"min_by","","",202],[10,"next","","",203],[10,"size_hint","","",203],[10,"size_hint","","",203],[10,"chain","","",203],[10,"zip","","",203],[10,"map","","",203],[10,"filter","","",203],[10,"filter_map","","",203],[10,"enumerate","","",203],[10,"peekable","","",203],[10,"skip_while","","",203],[10,"take_while","","",203],[10,"skip","","",203],[10,"take","","",203],[10,"scan","","",203],[10,"flat_map","","",203],[10,"fuse","","",203],[10,"inspect","","",203],[10,"by_ref","","",203],[10,"advance","","",203],[10,"collect","","",203],[10,"nth","","",203],[10,"last","","",203],[10,"fold","","",203],[10,"count","","",203],[10,"all","","",203],[10,"any","","",203],[10,"find","","",203],[10,"position","","",203],[10,"max_by","","",203],[10,"min_by","","",203],[10,"next","","Advance the iterator to the next node (in order) and return a\ntuple with a reference to the key and value. If there are no\nmore nodes, return `None`.",204],[10,"size_hint","","",204],[10,"size_hint","","",204],[10,"chain","","",204],[10,"zip","","",204],[10,"map","","",204],[10,"filter","","",204],[10,"filter_map","","",204],[10,"enumerate","","",204],[10,"peekable","","",204],[10,"skip_while","","",204],[10,"take_while","","",204],[10,"skip","","",204],[10,"take","","",204],[10,"scan","","",204],[10,"flat_map","","",204],[10,"fuse","","",204],[10,"inspect","","",204],[10,"by_ref","","",204],[10,"advance","","",204],[10,"collect","","",204],[10,"nth","","",204],[10,"last","","",204],[10,"fold","","",204],[10,"count","","",204],[10,"all","","",204],[10,"any","","",204],[10,"find","","",204],[10,"position","","",204],[10,"max_by","","",204],[10,"min_by","","",204],[10,"next","","",205],[10,"size_hint","","",205],[10,"size_hint","","",205],[10,"chain","","",205],[10,"zip","","",205],[10,"map","","",205],[10,"filter","","",205],[10,"filter_map","","",205],[10,"enumerate","","",205],[10,"peekable","","",205],[10,"skip_while","","",205],[10,"take_while","","",205],[10,"skip","","",205],[10,"take","","",205],[10,"scan","","",205],[10,"flat_map","","",205],[10,"fuse","","",205],[10,"inspect","","",205],[10,"by_ref","","",205],[10,"advance","","",205],[10,"collect","","",205],[10,"nth","","",205],[10,"last","","",205],[10,"fold","","",205],[10,"count","","",205],[10,"all","","",205],[10,"any","","",205],[10,"find","","",205],[10,"position","","",205],[10,"max_by","","",205],[10,"min_by","","",205],[10,"next","","",206],[10,"size_hint","","",206],[10,"size_hint","","",206],[10,"chain","","",206],[10,"zip","","",206],[10,"map","","",206],[10,"filter","","",206],[10,"filter_map","","",206],[10,"enumerate","","",206],[10,"peekable","","",206],[10,"skip_while","","",206],[10,"take_while","","",206],[10,"skip","","",206],[10,"take","","",206],[10,"scan","","",206],[10,"flat_map","","",206],[10,"fuse","","",206],[10,"inspect","","",206],[10,"by_ref","","",206],[10,"advance","","",206],[10,"collect","","",206],[10,"nth","","",206],[10,"last","","",206],[10,"fold","","",206],[10,"count","","",206],[10,"all","","",206],[10,"any","","",206],[10,"find","","",206],[10,"position","","",206],[10,"max_by","","",206],[10,"min_by","","",206],[10,"next","","",207],[10,"size_hint","","",207],[10,"chain","","",207],[10,"zip","","",207],[10,"map","","",207],[10,"filter","","",207],[10,"filter_map","","",207],[10,"enumerate","","",207],[10,"peekable","","",207],[10,"skip_while","","",207],[10,"take_while","","",207],[10,"skip","","",207],[10,"take","","",207],[10,"scan","","",207],[10,"flat_map","","",207],[10,"fuse","","",207],[10,"inspect","","",207],[10,"by_ref","","",207],[10,"advance","","",207],[10,"collect","","",207],[10,"nth","","",207],[10,"last","","",207],[10,"fold","","",207],[10,"count","","",207],[10,"all","","",207],[10,"any","","",207],[10,"find","","",207],[10,"position","","",207],[10,"max_by","","",207],[10,"min_by","","",207],[10,"next","","",208],[10,"size_hint","","",208],[10,"chain","","",208],[10,"zip","","",208],[10,"map","","",208],[10,"filter","","",208],[10,"filter_map","","",208],[10,"enumerate","","",208],[10,"peekable","","",208],[10,"skip_while","","",208],[10,"take_while","","",208],[10,"skip","","",208],[10,"take","","",208],[10,"scan","","",208],[10,"flat_map","","",208],[10,"fuse","","",208],[10,"inspect","","",208],[10,"by_ref","","",208],[10,"advance","","",208],[10,"collect","","",208],[10,"nth","","",208],[10,"last","","",208],[10,"fold","","",208],[10,"count","","",208],[10,"all","","",208],[10,"any","","",208],[10,"find","","",208],[10,"position","","",208],[10,"max_by","","",208],[10,"min_by","","",208],[10,"clone","","",209],[10,"clone_from","","",209],[10,"eq","","",209],[10,"ne","","",209],[10,"partial_cmp","","",209],[10,"lt","","",209],[10,"le","","",209],[10,"gt","","",209],[10,"ge","","",209],[10,"fmt","","",209],[10,"len","","",209],[10,"is_empty","","",209],[10,"clear","","",209],[10,"contains","","",209],[10,"is_disjoint","","",209],[10,"is_subset","","",209],[10,"is_superset","","",209],[10,"insert","","",209],[10,"remove","","",209],[10,"default","","",209],[10,"new","","Create an empty `TreeSet`.",209],[10,"iter","","Get a lazy iterator over the values in the set, in ascending order.",209],[10,"rev_iter","","Get a lazy iterator over the values in the set, in descending order.",209],[10,"move_iter","","Creates a consuming iterator, that is, one that moves each value out of the\nset in ascending order. The set cannot be used after calling this.",209],[10,"lower_bound","","Get a lazy iterator pointing to the first value not less than `v` (greater or equal).\nIf all elements in the set are less than `v` empty iterator is returned.",209],[10,"upper_bound","","Get a lazy iterator pointing to the first value greater than `v`.\nIf all elements in the set are less than or equal to `v` an\nempty iterator is returned.",209],[10,"difference","","Visit the values representing the difference, in ascending order.",209],[10,"symmetric_difference","","Visit the values representing the symmetric difference, in ascending order.",209],[10,"intersection","","Visit the values representing the intersection, in ascending order.",209],[10,"union","","Visit the values representing the union, in ascending order.",209],[10,"next","","",210],[10,"size_hint","","",210],[10,"chain","","",210],[10,"zip","","",210],[10,"map","","",210],[10,"filter","","",210],[10,"filter_map","","",210],[10,"enumerate","","",210],[10,"peekable","","",210],[10,"skip_while","","",210],[10,"take_while","","",210],[10,"skip","","",210],[10,"take","","",210],[10,"scan","","",210],[10,"flat_map","","",210],[10,"fuse","","",210],[10,"inspect","","",210],[10,"by_ref","","",210],[10,"advance","","",210],[10,"collect","","",210],[10,"nth","","",210],[10,"last","","",210],[10,"fold","","",210],[10,"count","","",210],[10,"all","","",210],[10,"any","","",210],[10,"find","","",210],[10,"position","","",210],[10,"max_by","","",210],[10,"min_by","","",210],[10,"next","","",211],[10,"size_hint","","",211],[10,"chain","","",211],[10,"zip","","",211],[10,"map","","",211],[10,"filter","","",211],[10,"filter_map","","",211],[10,"enumerate","","",211],[10,"peekable","","",211],[10,"skip_while","","",211],[10,"take_while","","",211],[10,"skip","","",211],[10,"take","","",211],[10,"scan","","",211],[10,"flat_map","","",211],[10,"fuse","","",211],[10,"inspect","","",211],[10,"by_ref","","",211],[10,"advance","","",211],[10,"collect","","",211],[10,"nth","","",211],[10,"last","","",211],[10,"fold","","",211],[10,"count","","",211],[10,"all","","",211],[10,"any","","",211],[10,"find","","",211],[10,"position","","",211],[10,"max_by","","",211],[10,"min_by","","",211],[10,"next","","",212],[10,"size_hint","","",212],[10,"chain","","",212],[10,"zip","","",212],[10,"map","","",212],[10,"filter","","",212],[10,"filter_map","","",212],[10,"enumerate","","",212],[10,"peekable","","",212],[10,"skip_while","","",212],[10,"take_while","","",212],[10,"skip","","",212],[10,"take","","",212],[10,"scan","","",212],[10,"flat_map","","",212],[10,"fuse","","",212],[10,"inspect","","",212],[10,"by_ref","","",212],[10,"advance","","",212],[10,"collect","","",212],[10,"nth","","",212],[10,"last","","",212],[10,"fold","","",212],[10,"count","","",212],[10,"all","","",212],[10,"any","","",212],[10,"find","","",212],[10,"position","","",212],[10,"max_by","","",212],[10,"min_by","","",212],[10,"next","","",213],[10,"size_hint","","",213],[10,"chain","","",213],[10,"zip","","",213],[10,"map","","",213],[10,"filter","","",213],[10,"filter_map","","",213],[10,"enumerate","","",213],[10,"peekable","","",213],[10,"skip_while","","",213],[10,"take_while","","",213],[10,"skip","","",213],[10,"take","","",213],[10,"scan","","",213],[10,"flat_map","","",213],[10,"fuse","","",213],[10,"inspect","","",213],[10,"by_ref","","",213],[10,"advance","","",213],[10,"collect","","",213],[10,"nth","","",213],[10,"last","","",213],[10,"fold","","",213],[10,"count","","",213],[10,"all","","",213],[10,"any","","",213],[10,"find","","",213],[10,"position","","",213],[10,"max_by","","",213],[10,"min_by","","",213],[10,"clone","","",214],[10,"clone_from","","",214],[10,"new","","Creates a new tree node.",214],[10,"from_iter","","",201],[10,"extend","","",201],[10,"hash","","",201],[10,"from_iter","","",209],[10,"extend","","",209],[10,"hash","","",209],[10,"clone","collections::trie","",215],[10,"clone_from","","",215],[10,"clone","","",216],[10,"clone_from","","",216],[10,"eq","","",216],[10,"ne","","",216],[10,"assert_receiver_is_total_eq","","",216],[10,"partial_cmp","","",216],[10,"lt","","",216],[10,"le","","",216],[10,"gt","","",216],[10,"ge","","",216],[10,"cmp","","",216],[10,"fmt","","",216],[10,"len","","Return the number of elements in the map.",216],[10,"is_empty","","",216],[10,"clear","","Clear the map, removing all values.",216],[10,"find","","Return a reference to the value corresponding to the key.",216],[10,"contains_key","","",216],[10,"find_mut","","Return a mutable reference to the value corresponding to the key.",216],[10,"swap","","Insert a key-value pair from the map. If the key already had a value\npresent in the map, that value is returned. Otherwise None is returned.",216],[10,"pop","","Removes a key from the map, returning the value at the key if the key\nwas previously in the map.",216],[10,"insert","","",216],[10,"remove","","",216],[10,"default","","",216],[10,"new","","Create an empty TrieMap.",216],[10,"each_reverse","","Visit all key-value pairs in reverse order. Abort traversal when f returns false.\nReturn true if f returns true for all elements.",216],[10,"keys","","Get an iterator visiting all keys in ascending order by the keys.\nIterator element type is `uint`.",216],[10,"values","","Get an iterator visiting all values in ascending order by the keys.\nIterator element type is `&'r T`.",216],[10,"iter","","Get an iterator over the key-value pairs in the map, ordered by keys.",216],[10,"mut_iter","","Get an iterator over the key-value pairs in the map, with the\nability to mutate the values.",216],[10,"lower_bound","","Get an iterator pointing to the first key-value pair whose key is not less than `key`.\nIf all keys in the map are less than `key` an empty iterator is returned.",216],[10,"upper_bound","","Get an iterator pointing to the first key-value pair whose key is greater than `key`.\nIf all keys in the map are not greater than `key` an empty iterator is returned.",216],[10,"mut_lower_bound","","Get an iterator pointing to the first key-value pair whose key is not less than `key`.\nIf all keys in the map are less than `key` an empty iterator is returned.",216],[10,"mut_upper_bound","","Get an iterator pointing to the first key-value pair whose key is greater than `key`.\nIf all keys in the map are not greater than `key` an empty iterator is returned.",216],[10,"from_iter","","",216],[10,"extend","","",216],[10,"hash","","",216],[10,"cmp","","",217],[10,"partial_cmp","","",217],[10,"lt","","",217],[10,"le","","",217],[10,"gt","","",217],[10,"ge","","",217],[10,"lt","","",217],[10,"le","","",217],[10,"gt","","",217],[10,"ge","","",217],[10,"assert_receiver_is_total_eq","","",217],[10,"eq","","",217],[10,"ne","","",217],[10,"ne","","",217],[10,"hash","","",217],[10,"clone","","",217],[10,"clone_from","","",217],[10,"fmt","","",217],[10,"len","","Return the number of elements in the set.",217],[10,"is_empty","","",217],[10,"clear","","Clear the set, removing all values.",217],[10,"contains","","",217],[10,"is_disjoint","","",217],[10,"is_subset","","",217],[10,"is_superset","","",217],[10,"is_superset","","",217],[10,"insert","","",217],[10,"remove","","",217],[10,"default","","",217],[10,"new","","Create an empty TrieSet.",217],[10,"each_reverse","","Visit all values in reverse order. Abort traversal when `f` returns false.\nReturn `true` if `f` returns `true` for all elements.",217],[10,"iter","","Get an iterator over the values in the set, in sorted order.",217],[10,"lower_bound","","Get an iterator pointing to the first value that is not less than `val`.\nIf all values in the set are less than `val` an empty iterator is returned.",217],[10,"upper_bound","","Get an iterator pointing to the first value that key is greater than `val`.\nIf all values in the set are less than or equal to `val` an empty iterator is returned.",217],[10,"from_iter","","",217],[10,"extend","","",217],[10,"clone","","",218],[10,"clone_from","","",218],[10,"next","","",219],[10,"size_hint","","",219],[10,"size_hint","","",219],[10,"chain","","",219],[10,"zip","","",219],[10,"map","","",219],[10,"filter","","",219],[10,"filter_map","","",219],[10,"enumerate","","",219],[10,"peekable","","",219],[10,"skip_while","","",219],[10,"take_while","","",219],[10,"skip","","",219],[10,"take","","",219],[10,"scan","","",219],[10,"flat_map","","",219],[10,"fuse","","",219],[10,"inspect","","",219],[10,"by_ref","","",219],[10,"advance","","",219],[10,"collect","","",219],[10,"nth","","",219],[10,"last","","",219],[10,"fold","","",219],[10,"count","","",219],[10,"all","","",219],[10,"any","","",219],[10,"find","","",219],[10,"position","","",219],[10,"max_by","","",219],[10,"min_by","","",219],[10,"next","","",220],[10,"size_hint","","",220],[10,"size_hint","","",220],[10,"chain","","",220],[10,"zip","","",220],[10,"map","","",220],[10,"filter","","",220],[10,"filter_map","","",220],[10,"enumerate","","",220],[10,"peekable","","",220],[10,"skip_while","","",220],[10,"take_while","","",220],[10,"skip","","",220],[10,"take","","",220],[10,"scan","","",220],[10,"flat_map","","",220],[10,"fuse","","",220],[10,"inspect","","",220],[10,"by_ref","","",220],[10,"advance","","",220],[10,"collect","","",220],[10,"nth","","",220],[10,"last","","",220],[10,"fold","","",220],[10,"count","","",220],[10,"all","","",220],[10,"any","","",220],[10,"find","","",220],[10,"position","","",220],[10,"max_by","","",220],[10,"min_by","","",220],[10,"next","","",221],[10,"size_hint","","",221],[10,"size_hint","","",221],[10,"chain","","",221],[10,"zip","","",221],[10,"map","","",221],[10,"filter","","",221],[10,"filter_map","","",221],[10,"enumerate","","",221],[10,"peekable","","",221],[10,"skip_while","","",221],[10,"take_while","","",221],[10,"skip","","",221],[10,"take","","",221],[10,"scan","","",221],[10,"flat_map","","",221],[10,"fuse","","",221],[10,"inspect","","",221],[10,"by_ref","","",221],[10,"advance","","",221],[10,"collect","","",221],[10,"nth","","",221],[10,"last","","",221],[10,"fold","","",221],[10,"count","","",221],[10,"all","","",221],[10,"any","","",221],[10,"find","","",221],[10,"position","","",221],[10,"max_by","","",221],[10,"min_by","","",221],[10,"new","collections::slice","Create an `ElementSwaps` iterator for a sequence of `length` elements",222],[10,"next","","",222],[10,"size_hint","","",222],[10,"size_hint","","",222],[10,"chain","","",222],[10,"zip","","",222],[10,"map","","",222],[10,"filter","","",222],[10,"filter_map","","",222],[10,"enumerate","","",222],[10,"peekable","","",222],[10,"skip_while","","",222],[10,"take_while","","",222],[10,"skip","","",222],[10,"take","","",222],[10,"scan","","",222],[10,"flat_map","","",222],[10,"fuse","","",222],[10,"inspect","","",222],[10,"by_ref","","",222],[10,"advance","","",222],[10,"collect","","",222],[10,"nth","","",222],[10,"last","","",222],[10,"fold","","",222],[10,"count","","",222],[10,"all","","",222],[10,"any","","",222],[10,"find","","",222],[10,"position","","",222],[10,"max_by","","",222],[10,"min_by","","",222],[10,"next","","",223],[10,"size_hint","","",223],[10,"size_hint","","",223],[10,"chain","","",223],[10,"zip","","",223],[10,"map","","",223],[10,"filter","","",223],[10,"filter_map","","",223],[10,"enumerate","","",223],[10,"peekable","","",223],[10,"skip_while","","",223],[10,"take_while","","",223],[10,"skip","","",223],[10,"take","","",223],[10,"scan","","",223],[10,"flat_map","","",223],[10,"fuse","","",223],[10,"inspect","","",223],[10,"by_ref","","",223],[10,"advance","","",223],[10,"collect","","",223],[10,"nth","","",223],[10,"last","","",223],[10,"fold","","",223],[10,"count","","",223],[10,"all","","",223],[10,"any","","",223],[10,"find","","",223],[10,"position","","",223],[10,"max_by","","",223],[10,"min_by","","",223],[10,"concat","collections::vec","",43],[10,"connect","","",43],[10,"clone","collections::str","",224],[10,"clone_from","","",224],[10,"clone","","",225],[10,"clone_from","","",225],[10,"next","","",225],[10,"size_hint","","",225],[10,"size_hint","","",225],[10,"chain","","",225],[10,"zip","","",225],[10,"map","","",225],[10,"filter","","",225],[10,"filter_map","","",225],[10,"enumerate","","",225],[10,"peekable","","",225],[10,"skip_while","","",225],[10,"take_while","","",225],[10,"skip","","",225],[10,"take","","",225],[10,"scan","","",225],[10,"flat_map","","",225],[10,"fuse","","",225],[10,"inspect","","",225],[10,"by_ref","","",225],[10,"advance","","",225],[10,"collect","","",225],[10,"nth","","",225],[10,"last","","",225],[10,"fold","","",225],[10,"count","","",225],[10,"all","","",225],[10,"any","","",225],[10,"find","","",225],[10,"position","","",225],[10,"max_by","","",225],[10,"min_by","","",225],[10,"is_owned","","Returns `true` if this `MaybeOwned` wraps an owned string",226],[10,"is_slice","","Returns `true` if this `MaybeOwned` wraps a borrowed string",226],[10,"into_maybe_owned","collections::string","",42],[10,"into_maybe_owned","collections::str","",226],[10,"eq","","",226],[10,"ne","","",226],[10,"assert_receiver_is_total_eq","","",226],[10,"partial_cmp","","",226],[10,"lt","","",226],[10,"le","","",226],[10,"gt","","",226],[10,"ge","","",226],[10,"cmp","","",226],[10,"equiv","","",226],[10,"as_slice","","",226],[10,"into_string","","",226],[10,"into_owned","","",226],[10,"escape_default","","",226],[10,"escape_unicode","","",226],[10,"replace","","",226],[10,"to_owned","","",226],[10,"to_utf16","","",226],[10,"repeat","","",226],[10,"lev_distance","","",226],[10,"nfd_chars","","",226],[10,"nfkd_chars","","",226],[10,"len","","",226],[10,"is_empty","","",226],[10,"clone","","",226],[10,"clone_from","","",226],[10,"default","","",226],[10,"hash","","",226],[10,"fmt","","",226],[10,"cmp","collections::string","",42],[10,"assert_receiver_is_total_eq","","",42],[10,"partial_cmp","","",42],[10,"lt","","",42],[10,"le","","",42],[10,"gt","","",42],[10,"ge","","",42],[10,"lt","","",42],[10,"le","","",42],[10,"gt","","",42],[10,"ge","","",42],[10,"eq","","",42],[10,"ne","","",42],[10,"ne","","",42],[10,"clone","","",42],[10,"clone_from","","",42],[10,"new","","Creates a new string buffer initialized with the empty string.",42],[10,"with_capacity","","Creates a new string buffer with the given capacity.\nThe string will be able to hold exactly `capacity` bytes without\nreallocating. If `capacity` is 0, the string will not allocate.",42],[10,"from_str","","Creates a new string buffer from the given string.",42],[10,"from_raw_parts","","Deprecated. Replaced by `string::raw::from_parts`",42],[10,"from_owned_str","","Deprecated.",42],[10,"from_utf8","","Returns the vector as a string buffer, if possible, taking care not to\ncopy it.",42],[10,"from_utf8_lossy","","Converts a vector of bytes to a new utf-8 string.\nAny invalid utf-8 sequences are replaced with U+FFFD REPLACEMENT CHARACTER.",42],[10,"from_utf16","","Decode a UTF-16 encoded vector `v` into a `String`, returning `None`\nif `v` contains any invalid data.",42],[10,"from_utf16_lossy","","Decode a UTF-16 encoded vector `v` into a string, replacing\ninvalid data with the replacement character (U+FFFD).",42],[10,"from_chars","","Convert a vector of chars to a string.",42],[10,"into_bytes","","Return the underlying byte buffer, encoded as UTF-8.",42],[10,"append","","Pushes the given string onto this buffer; then, returns `self` so that it can be used\nagain.",42],[10,"from_char","","Creates a string buffer by repeating a character `length` times.",42],[10,"from_byte","","Convert a byte to a UTF-8 string.",42],[10,"push_str","","Pushes the given string onto this string buffer.",42],[10,"grow","","Push `ch` onto the given string `count` times.",42],[10,"byte_capacity","","Returns the number of bytes that this string buffer can hold without reallocating.",42],[10,"reserve_additional","","Reserves capacity for at least `extra` additional bytes in this string buffer.",42],[10,"reserve","","Reserves capacity for at least `capacity` bytes in this string buffer.",42],[10,"reserve_exact","","Reserves capacity for exactly `capacity` bytes in this string buffer.",42],[10,"shrink_to_fit","","Shrinks the capacity of this string buffer to match its length.",42],[10,"push_char","","Adds the given character to the end of the string.",42],[10,"push_bytes","","Pushes the given bytes onto this string buffer.\nThis is unsafe because it does not check\nto ensure that the resulting string will be valid UTF-8.",42],[10,"as_bytes","","Works with the underlying buffer as a byte slice.",42],[10,"as_mut_bytes","","Works with the underlying buffer as a mutable byte slice.",42],[10,"truncate","","Shorten a string to the specified length.",42],[10,"push_byte","","Appends a byte to this string buffer.",42],[10,"pop_byte","","Removes the last byte from the string buffer and returns it.\nReturns `None` if this string buffer is empty.",42],[10,"pop_char","","Removes the last character from the string buffer and returns it.\nReturns `None` if this string buffer is empty.",42],[10,"shift_byte","","Removes the first byte from the string buffer and returns it.\nReturns `None` if this string buffer is empty.",42],[10,"shift_char","","Removes the first character from the string buffer and returns it.\nReturns `None` if this string buffer is empty.",42],[10,"as_mut_vec","","Views the string buffer as a mutable sequence of bytes.",42],[10,"len","","",42],[10,"is_empty","","",42],[10,"clear","","",42],[10,"from_iter","","",42],[10,"extend","","",42],[10,"as_slice","","",42],[10,"into_string","","",42],[10,"into_owned","","",42],[10,"escape_default","","",42],[10,"escape_unicode","","",42],[10,"replace","","",42],[10,"to_owned","","",42],[10,"to_utf16","","",42],[10,"repeat","","",42],[10,"lev_distance","","",42],[10,"nfd_chars","","",42],[10,"nfkd_chars","","",42],[10,"default","","",42],[10,"fmt","","",42],[10,"hash","","",42],[10,"equiv","","",42],[10,"add","","",42],[10,"new","collections::vec","Constructs a new, empty `Vec`.",43],[10,"with_capacity","","Constructs a new, empty `Vec` with the specified capacity.",43],[10,"from_fn","","Creates and initializes a `Vec`.",43],[10,"from_raw_parts","","Create a `Vec<T>` directly from the raw constituents.",43],[10,"partition","","Consumes the `Vec`, partitioning it based on a predicate.",43],[10,"append","","Iterates over the `second` vector, copying each element and appending it to\nthe `first`. Afterwards, the `first` is then returned for use again.",43],[10,"from_slice","","Constructs a `Vec` by cloning elements of a slice.",43],[10,"from_elem","","Constructs a `Vec` with copies of a value.",43],[10,"push_all","","Appends all elements in a slice to the `Vec`.",43],[10,"grow","","Grows the `Vec` in-place.",43],[10,"grow_set","","Sets the value of a vector element at a given index, growing the vector\nas needed.",43],[10,"partitioned","","Partitions a vector based on a predicate.",43],[10,"clone","","",43],[10,"clone_from","","",43],[10,"clone_from","","",43],[10,"index","","",43],[10,"from_iter","","",43],[10,"extend","","",43],[10,"eq","","",43],[10,"ne","","",43],[10,"partial_cmp","","",43],[10,"lt","","",43],[10,"le","","",43],[10,"gt","","",43],[10,"ge","","",43],[10,"assert_receiver_is_total_eq","","",43],[10,"equiv","","",43],[10,"cmp","","",43],[10,"len","","",43],[10,"is_empty","","",43],[10,"to_vec","","",43],[10,"into_vec","","",43],[10,"to_owned","","",43],[10,"into_owned","","",43],[10,"capacity","","Returns the number of elements the vector can hold without\nreallocating.",43],[10,"reserve_additional","","Reserves capacity for at least `n` additional elements in the given\nvector.",43],[10,"reserve","","Reserves capacity for at least `n` elements in the given vector.",43],[10,"reserve_exact","","Reserves capacity for exactly `capacity` elements in the given vector.",43],[10,"shrink_to_fit","","Shrink the capacity of the vector as much as possible",43],[10,"append_one","","Appends one element to the vector provided. The vector itself is then\nreturned for use again.",43],[10,"truncate","","Shorten a vector, dropping excess elements.",43],[10,"as_mut_slice","","Work with `self` as a mutable slice.",43],[10,"move_iter","","Creates a consuming iterator, that is, one that moves each\nvalue out of the vector (from start to end). The vector cannot\nbe used after calling this.",43],[10,"set_len","","Sets the length of a vector.",43],[10,"get","","Returns a reference to the value at index `index`.",43],[10,"get_mut","","Returns a mutable reference to the value at index `index`.",43],[10,"iter","","Returns an iterator over references to the elements of the vector in\norder.",43],[10,"mut_iter","","Returns an iterator over mutable references to the elements of the\nvector in order.",43],[10,"sort_by","","Sort the vector, in place, using `compare` to compare elements.",43],[10,"slice","","Returns a slice of self spanning the interval [`start`, `end`).",43],[10,"tail","","Returns a slice containing all but the first element of the vector.",43],[10,"tailn","","Returns all but the first `n' elements of a vector.",43],[10,"last","","Returns a reference to the last element of a vector, or `None` if it is\nempty.",43],[10,"mut_last","","Returns a mutable reference to the last element of a vector, or `None`\nif it is empty.",43],[10,"swap_remove","","Remove an element from anywhere in the vector and return it, replacing\nit with the last element. This does not preserve ordering, but is O(1).",43],[10,"unshift","","Prepend an element to the vector.",43],[10,"shift","","Removes the first element from a vector and returns it, or `None` if\nthe vector is empty.",43],[10,"insert","","Insert an element at position `index` within the vector, shifting all\nelements after position i one position to the right.",43],[10,"remove","","Remove and return the element at position `index` within the vector,\nshifting all elements after position `index` one position to the left.\nReturns `None` if `i` is out of bounds.",43],[10,"push_all_move","","Takes ownership of the vector `other`, moving all elements into\nthe current vector. This does not copy any elements, and it is\nillegal to use the `other` vector after calling this method\n(because it is moved here).",43],[10,"mut_slice","","Returns a mutable slice of `self` between `start` and `end`.",43],[10,"mut_slice_from","","Returns a mutable slice of self from `start` to the end of the vec.",43],[10,"mut_slice_to","","Returns a mutable slice of self from the start of the vec to `end`.",43],[10,"mut_split_at","","Returns a pair of mutable slices that divides the vec at an index.",43],[10,"reverse","","Reverse the order of elements in a vector, in place.",43],[10,"slice_from","","Returns a slice of `self` from `start` to the end of the vec.",43],[10,"slice_to","","Returns a slice of self from the start of the vec to `end`.",43],[10,"init","","Returns a slice containing all but the last element of the vector.",43],[10,"as_ptr","","Returns an unsafe pointer to the vector's buffer.",43],[10,"as_mut_ptr","","Returns a mutable unsafe pointer to the vector's buffer.",43],[10,"retain","","Retains only the elements specified by the predicate.",43],[10,"grow_fn","","Expands a vector in place, initializing the new elements to the result of a function.",43],[10,"sort","","Sorts the vector in place.",43],[10,"clear","","",43],[10,"contains","","Return true if a vector contains an element with the given value",43],[10,"dedup","","Remove consecutive repeated elements in the vector.",43],[10,"as_slice","","Work with `self` as a slice.",43],[10,"add","","",43],[10,"drop","","",43],[10,"default","","",43],[10,"fmt","","",43],[10,"push","","Append an element to the back of a collection.",43],[10,"pop","","",43],[10,"next","","",227],[10,"size_hint","","",227],[10,"size_hint","","",227],[10,"chain","","",227],[10,"zip","","",227],[10,"map","","",227],[10,"filter","","",227],[10,"filter_map","","",227],[10,"enumerate","","",227],[10,"peekable","","",227],[10,"skip_while","","",227],[10,"take_while","","",227],[10,"skip","","",227],[10,"take","","",227],[10,"scan","","",227],[10,"flat_map","","",227],[10,"fuse","","",227],[10,"inspect","","",227],[10,"by_ref","","",227],[10,"advance","","",227],[10,"collect","","",227],[10,"nth","","",227],[10,"last","","",227],[10,"fold","","",227],[10,"count","","",227],[10,"all","","",227],[10,"any","","",227],[10,"find","","",227],[10,"position","","",227],[10,"max_by","","",227],[10,"min_by","","",227],[10,"next_back","","",227],[10,"rev","","",227],[10,"drop","","",227],[10,"new","collections::hash::sip","Create a `SipState` that is keyed off the provided keys.",228],[10,"new_with_keys","","Create a `SipState` that is keyed off the provided keys.",228],[10,"reset","","Reset the state back to it's initial state.",228],[10,"result","","Return the computed hash.",228],[10,"write","","",228],[10,"clone","","",228],[10,"clone_from","","",228],[10,"default","","",228],[10,"clone","","",229],[10,"clone_from","","",229],[10,"new","","Create a `Sip`.",229],[10,"new_with_keys","","Create a `Sip` that is keyed off the provided keys.",229],[10,"hash","","",229],[10,"default","","",229],[10,"hash","collections::vec","",43],[10,"hash","alloc::boxed","",230],[10,"hash","alloc::rc","",231],[10,"hash","core::option","",26],[10,"hash","core::intrinsics","",67],[10,"hash","core::result","",116],[1,"Bitv","std::collections","The bitvector type"],[1,"BitvSet","","An implementation of a set using a bit vector as an underlying\nrepresentation for holding unsigned numerical elements."],[1,"BTree","",""],[1,"DList","","A doubly-linked list."],[1,"EnumSet","","A specialized Set implementation to use enum types."],[1,"PriorityQueue","","A priority queue implemented with a binary heap."],[1,"RingBuf","","RingBuf is a circular buffer that implements Deque."],[1,"SmallIntMap","","A map optimized for small integer keys."],[1,"TreeMap","","This is implemented as an AA tree, which is a simplified variation of\na red-black tree where red (horizontal) nodes can only be added\nas a right child. The time complexity is the same, and re-balancing\noperations are more frequent but also cheaper."],[1,"TreeSet","","A implementation of the `Set` trait on top of the `TreeMap` container. The\nonly requirement is that the type of the elements contained ascribes to the\n`Ord` trait."],[1,"TrieMap","","A map implemented as a radix trie."],[1,"TrieSet","","A set implemented as a radix trie."],[0,"bitv","","Collections implemented with bit vectors."],[1,"Bitv","std::collections::bitv","The bitvector type"],[3,"from_bytes","","Transform a byte-vector into a `Bitv`. Each byte becomes 8 bits,\nwith the most significant bits of each byte coming first. Each\nbit becomes `true` if equal to 1 or `false` if equal to 0."],[3,"from_fn","","Create a `Bitv` of the specified length where the value at each\nindex is `f(index)`."],[1,"Bits","","An iterator for `Bitv`."],[1,"BitvSet","","An implementation of a set using a bit vector as an underlying\nrepresentation for holding unsigned numerical elements."],[1,"BitPositions","","An iterator for `BitvSet`."],[1,"TwoBitPositions","","An iterator combining wo `BitvSet` iterators."],[0,"btree","std::collections","Starting implementation of a btree for rust.\nStructure inspired by github user davidhalperin's gist."],[1,"BTree","std::collections::btree",""],[0,"dlist","std::collections","A doubly-linked list with owned nodes."],[1,"DList","std::collections::dlist","A doubly-linked list."],[1,"Items","","Double-ended DList iterator"],[1,"MutItems","","Double-ended mutable DList iterator"],[1,"MoveItems","","DList consuming iterator"],[6,"ListInsertion","","Allow mutating the DList while iterating"],[9,"insert_next","","Insert `elt` just after to the element most recently returned by `.next()`",232],[9,"peek_next","","Provide a reference to the next element, without changing the iterator",232],[0,"enum_set","std::collections","A structure for holding a set of enum variants"],[1,"EnumSet","std::collections::enum_set","A specialized Set implementation to use enum types."],[6,"CLike","","An interface for casting C-like enum to uint and back."],[9,"to_uint","","Converts C-like enum to uint.",233],[9,"from_uint","","Converts uint to C-like enum.",233],[1,"Items","","An iterator over an EnumSet"],[0,"priority_queue","std::collections","A priority queue implemented with a binary heap."],[1,"PriorityQueue","std::collections::priority_queue","A priority queue implemented with a binary heap."],[1,"Items","","PriorityQueue iterator."],[0,"ringbuf","std::collections","A double-ended queue implemented as a circular buffer"],[1,"RingBuf","std::collections::ringbuf","RingBuf is a circular buffer that implements Deque."],[1,"Items","","RingBuf iterator"],[1,"MutItems","","RingBuf mutable iterator"],[0,"smallintmap","std::collections","A simple map based on a vector for small integer keys. Space requirements\nare O(highest integer key)."],[1,"SmallIntMap","std::collections::smallintmap","A map optimized for small integer keys."],[1,"Entries","","Forward iterator over a map."],[1,"MutEntries","","Forward iterator over the key-value pairs of a map, with the\nvalues being mutable."],[4,"Keys","",""],[4,"Values","",""],[0,"treemap","std::collections","An ordered map and set implemented as self-balancing binary search\ntrees. The only requirement for the types is that the key implements\n`Ord`."],[1,"TreeMap","std::collections::treemap","This is implemented as an AA tree, which is a simplified variation of\na red-black tree where red (horizontal) nodes can only be added\nas a right child. The time complexity is the same, and re-balancing\noperations are more frequent but also cheaper."],[1,"Entries","","Lazy forward iterator over a map"],[1,"RevEntries","","Lazy backward iterator over a map"],[1,"MutEntries","","Lazy forward iterator over a map that allows for the mutation of\nthe values."],[1,"RevMutEntries","","Lazy backward iterator over a map"],[4,"Keys","",""],[4,"Values","",""],[1,"MoveEntries","","Lazy forward iterator over a map that consumes the map while iterating"],[1,"TreeSet","","A implementation of the `Set` trait on top of the `TreeMap` container. The\nonly requirement is that the type of the elements contained ascribes to the\n`Ord` trait."],[1,"SetItems","","Lazy forward iterator over a set"],[1,"RevSetItems","","Lazy backward iterator over a set"],[4,"MoveSetItems","",""],[1,"DifferenceItems","","Lazy iterator producing elements in the set difference (in-order)"],[1,"SymDifferenceItems","","Lazy iterator producing elements in the set symmetric difference (in-order)"],[1,"IntersectionItems","","Lazy iterator producing elements in the set intersection (in-order)"],[1,"UnionItems","","Lazy iterator producing elements in the set union (in-order)"],[0,"trie","std::collections","Ordered containers with unsigned integer keys,\nimplemented as radix tries (`TrieSet` and `TrieMap` types)."],[1,"TrieMap","std::collections::trie","A map implemented as a radix trie."],[1,"TrieSet","","A set implemented as a radix trie."],[1,"Entries","","Forward iterator over a map."],[1,"MutEntries","","Forward iterator over the key-value pairs of a map, with the\nvalues being mutable."],[4,"Keys","",""],[4,"Values","",""],[1,"SetItems","","Forward iterator over a set."],[0,"hash","std","Generic hashing support."],[1,"RandomSipHasher","std::hash","`RandomSipHasher` computes the SipHash algorithm from a stream of bytes\ninitialized with random keys."],[10,"clone","","",234],[10,"new","","Construct a new `RandomSipHasher` that is initialized with random keys.",234],[10,"hash","","",234],[10,"default","","",234],[6,"Hash","","A trait that represents a hashable type. The `S` type parameter is an\nabstract hash state that is used by the `Hash` to compute the hash.\nIt defaults to `std::hash::sip::SipState`."],[9,"hash","","Compute a hash of the value.",235],[6,"Hasher","","A trait that computes a hash for a value. The main users of this trait are\ncontainers like `HashMap`, which need a generic way hash multiple types."],[9,"hash","","Compute a hash of the value.",236],[6,"Writer","",""],[9,"write","","",237],[3,"hash","","Hash a value using the SipHash algorithm."],[0,"sip","","Implementation of SipHash 2-4"],[1,"SipState","std::hash::sip","`SipState` computes a SipHash 2-4 hash over a stream of bytes."],[1,"SipHasher","","`SipHasher` computes the SipHash algorithm from a stream of bytes."],[3,"hash","","Hash a value using the SipHash algorithm."],[3,"hash_with_keys","","Hash a value with the SipHash algorithm with the provided keys."],[0,"task","std","Task creation"],[1,"SiblingSpawner","std::task","The default task spawner, which spawns siblings to the current task."],[1,"TaskBuilder","","The task builder type."],[3,"spawn","","Creates and executes a new child task"],[3,"try","","Execute a function in a newly-spawned task and return either the return\nvalue of the function or an error if the task failed."],[3,"try_future","","Execute a function in another task and return a future representing the\ntask's result."],[3,"with_task_name","","Read the name of the current task."],[3,"name","","Read the name of the current task."],[3,"deschedule","","Yield control to the task scheduler."],[3,"failing","","True if the running task is currently failing (e.g. will return `true` inside a\ndestructor that is run while unwinding the stack after a call to `fail!()`)."],[6,"Spawner","","A means of spawning a task"],[9,"spawn","","Spawn a task, given low-level task options.",238],[10,"spawn","","",239],[10,"new","","Generate the base configuration for spawning a task, off of which more\nconfiguration methods can be chained.",240],[10,"named","","Name the task-to-be. Currently the name is used for identification\nonly in failure messages.",240],[10,"stack_size","","Set the size of the stack for the new task.",240],[10,"stdout","","Redirect task-local stdout.",240],[10,"stderr","","Redirect task-local stderr.",240],[10,"spawner","","Set the spawning mechanism for the task.",240],[10,"with_wrapper","","Add a wrapper to the body of the spawned task.",240],[10,"spawn","","Creates and executes a new child task.",240],[10,"try_future","","Execute a proc in a newly-spawned task and return a future representing\nthe task's result. The task has the properties and behavior\nspecified by the `TaskBuilder`.",240],[10,"try","","Execute a function in a newly-spawnedtask and block until the task\ncompletes or fails. Equivalent to `.try_future(f).unwrap()`.",240],[0,"sync","std","Useful synchronization primitives"],[1,"Future","std::sync","A type encapsulating the result of a computation which may not be complete"],[1,"TaskPool","","A task pool used to execute functions in parallel."],[0,"atomics","","Atomic types"],[10,"new","sync::atomics","Create a new `AtomicOption`",241],[10,"empty","","Create a new `AtomicOption` that doesn't contain a value",241],[10,"swap","","Store a value, returning the old value",241],[10,"take","","Remove the value, leaving the `AtomicOption` empty.",241],[10,"fill","","Replace an empty value with a non-empty value.",241],[10,"is_empty","","Returns `true` if the `AtomicOption` is empty.",241],[10,"drop","","",241],[10,"new","sync::mpsc_intrusive","",242],[10,"push","","",242],[10,"pop","","You'll note that the other MPSC queue in std::sync is non-intrusive and\nreturns a `PopResult` here to indicate when the queue is inconsistent.\nAn \"inconsistent state\" in the other queue means that a pusher has\npushed, but it hasn't finished linking the rest of the chain.",242],[10,"new","","",243],[10,"next","","",243],[10,"pop","sync::spsc_queue","Attempts to pop the value from the head of the queue, returning `None`\nif the queue is empty.",244],[10,"peek","","Attempts to peek at the head of the queue, returning `None` if the queue\nis empty.",244],[10,"push","","Pushes a new value onto the queue.",245],[10,"new","","Creates a new queue.",246],[10,"push","","Pushes a new value onto this queue. Note that to use this function\nsafely, it must be externally guaranteed that there is only one pusher.",246],[10,"pop","","Attempts to pop a value from this queue. Remember that to use this type\nsafely you must ensure that there is only one popper at a time.",246],[10,"peek","","Attempts to peek at the head of the queue, returning `None` if the queue\nhas no data currently",246],[10,"drop","","",246],[10,"new","sync::mpsc_queue","Creates a new queue that is safe to share among multiple producers and\none consumer.",247],[10,"push","","Pushes a new value onto this queue.",247],[10,"pop","","Pops some data from this queue.",247],[10,"casual_pop","","Attempts to pop data from this queue, but doesn't attempt too hard. This\nwill canonicalize inconsistent states to a `None` value.",247],[10,"drop","","",247],[10,"with_capacity","sync::mpmc_bounded_queue","",248],[10,"push","","",248],[10,"pop","","",248],[10,"clone","","",248],[10,"clone_from","","",248],[10,"fmt","sync::deque","",249],[10,"eq","","",249],[10,"ne","","",249],[10,"ne","","",249],[10,"new","","Allocates a new buffer pool which in turn can be used to allocate new\ndeques.",250],[10,"deque","","Allocates a new work-stealing deque which will send/receiving memory to\nand from this buffer pool.",250],[10,"clone","","",250],[10,"clone_from","","",250],[10,"push","","Pushes data onto the front of this work queue.",251],[10,"pop","","Pops data off the front of the work queue, returning `None` on an empty\nqueue.",251],[10,"pool","","Gets access to the buffer pool that this worker is attached to. This can\nbe used to create more deques which share the same buffer pool as this\ndeque.",251],[10,"steal","","Steals work off the end of the queue (opposite of the worker's end)",252],[10,"pool","","Gets access to the buffer pool that this stealer is attached to. This\ncan be used to create more deques which share the same buffer pool as\nthis deque.",252],[10,"clone","","",252],[10,"clone_from","","",252],[10,"drop","","",253],[10,"drop","","",254],[10,"acquire","sync::raw","",255],[10,"release","","",255],[10,"access","","",255],[10,"drop","","",256],[10,"access_cond","","",255],[10,"wait","","Atomically drop the associated lock, and block until a signal is sent.",257],[10,"wait_on","","As wait(), but can specify which of multiple condition variables to\nwait on. Only a signal_on() or broadcast_on() with the same condvar_id\nwill wake this thread.",257],[10,"signal","","Wake up a blocked task. Returns false if there was no blocked task.",257],[10,"signal_on","","As signal, but with a specified condvar_id. See wait_on.",257],[10,"broadcast","","Wake up all blocked tasks. Returns the number of tasks woken.",257],[10,"broadcast_on","","As broadcast, but with a specified condvar_id. See wait_on.",257],[10,"new","","Create a new semaphore with the specified count.",258],[10,"acquire","","Acquire a resource represented by the semaphore. Blocks if necessary\nuntil resource(s) become available.",258],[10,"release","","Release a held resource represented by the semaphore. Wakes a blocked\ncontending task, if any exist. Won't block the caller.",258],[10,"access","","Acquire a resource of this semaphore, returning an RAII guard which will\nrelease the resource when dropped.",258],[10,"new","","Create a new mutex, with one associated condvar.",259],[10,"new_with_condvars","","Create a new mutex, with a specified number of associated condvars. This\nwill allow calling wait_on/signal_on/broadcast_on with condvar IDs\nbetween 0 and num_condvars-1. (If num_condvars is 0, lock_cond will be\nallowed but any operations on the condvar will fail.)",259],[10,"lock","","Acquires ownership of this mutex, returning an RAII guard which will\nunlock the mutex when dropped. The associated condition variable can\nalso be accessed through the returned guard.",259],[10,"new","","Create a new rwlock, with one associated condvar.",260],[10,"new_with_condvars","","Create a new rwlock, with a specified number of associated condvars.\nSimilar to mutex_with_condvars.",260],[10,"read","","Acquires a read-lock, returning an RAII guard that will unlock the lock\nwhen dropped. Calls to 'read' from other tasks may run concurrently with\nthis one.",260],[10,"write","","Acquire a write-lock, returning an RAII guard that will unlock the lock\nwhen dropped. No calls to 'read' or 'write' from other tasks will run\nconcurrently with this one.",260],[10,"downgrade","","Consumes this write lock and converts it into a read lock.",261],[10,"drop","","",261],[10,"drop","","",262],[10,"fmt","sync::mutex","",263],[10,"eq","","",263],[10,"ne","","",263],[10,"ne","","",263],[10,"try_lock","","Attempts to grab this lock, see `Mutex::try_lock`",264],[10,"lock","","Acquires this lock, see `Mutex::lock`",264],[10,"destroy","","Deallocates resources associated with this static mutex.",264],[10,"new","","Creates a new mutex in an unlocked state ready for use.",265],[10,"try_lock","","Attempts to acquire this lock.",265],[10,"lock","","Acquires a mutex, blocking the current task until it is able to do so.",265],[10,"drop","","",266],[10,"drop","","",265],[10,"doit","sync::one","Perform an initialization routine once and only once. The given closure\nwill be executed if this is the first time `doit` has been called, and\notherwise the routine will *not* be invoked.",267],[10,"send","sync::comm::duplex","",268],[10,"send_opt","","",268],[10,"recv","","",268],[10,"try_recv","","",268],[10,"recv_opt","","",268],[10,"new","sync::comm::oneshot","",269],[10,"send","","",269],[10,"sent","","",269],[10,"recv","","",269],[10,"try_recv","","",269],[10,"upgrade","","",269],[10,"drop_chan","","",269],[10,"drop_port","","",269],[10,"can_recv","","",269],[10,"start_selection","","",269],[10,"abort_selection","","",269],[10,"drop","","",269],[10,"new","sync::comm::select","Creates a new selection structure. This set is initially empty and\n`wait` will fail!() if called.",270],[10,"handle","","Creates a new handle into this receiver set for a new receiver. Note\nthat this does *not* add the receiver to the receiver set, for that you\nmust call the `add` method on the handle itself.",270],[10,"wait","","Waits for an event on this receiver set. The returned value is *not* an\nindex, but rather an id. This id can be queried against any active\n`Handle` structures (each one has an `id` method). The handle with\nthe matching `id` will have some sort of event available on it. The\nevent could either be that data is available or the corresponding\nchannel has been closed.",270],[10,"id","","Retrieve the id of this handle.",271],[10,"recv","","Receive a value on the underlying receiver. Has the same semantics as\n`Receiver.recv`",271],[10,"recv_opt","","Block to receive a value on the underlying receiver, returning `Some` on\nsuccess or `None` if the channel disconnects. This function has the same\nsemantics as `Receiver.recv_opt`",271],[10,"add","","Adds this handle to the receiver set that the handle was created from. This\nmethod can be called multiple times, but it has no effect if `add` was\ncalled previously.",271],[10,"remove","","Removes this handle from the `Select` set. This method is unsafe because\nit has no guarantee that the `Handle` was not moved since `add` was\ncalled.",271],[10,"drop","","",270],[10,"drop","","",271],[10,"next","","",272],[10,"size_hint","","",272],[10,"chain","","",272],[10,"zip","","",272],[10,"map","","",272],[10,"filter","","",272],[10,"filter_map","","",272],[10,"enumerate","","",272],[10,"peekable","","",272],[10,"skip_while","","",272],[10,"take_while","","",272],[10,"skip","","",272],[10,"take","","",272],[10,"scan","","",272],[10,"flat_map","","",272],[10,"fuse","","",272],[10,"inspect","","",272],[10,"by_ref","","",272],[10,"advance","","",272],[10,"collect","","",272],[10,"nth","","",272],[10,"last","","",272],[10,"fold","","",272],[10,"count","","",272],[10,"all","","",272],[10,"any","","",272],[10,"find","","",272],[10,"position","","",272],[10,"max_by","","",272],[10,"min_by","","",272],[10,"new","sync::comm::shared","",273],[10,"postinit_lock","","",273],[10,"inherit_blocker","","",273],[10,"send","","",273],[10,"recv","","",273],[10,"try_recv","","",273],[10,"clone_chan","","",273],[10,"drop_chan","","",273],[10,"drop_port","","",273],[10,"can_recv","","",273],[10,"start_selection","","",273],[10,"abort_selection","","",273],[10,"drop","","",273],[10,"new","sync::comm::stream","",274],[10,"send","","",274],[10,"upgrade","","",274],[10,"recv","","",274],[10,"try_recv","","",274],[10,"drop_chan","","",274],[10,"drop_port","","",274],[10,"can_recv","","",274],[10,"start_selection","","",274],[10,"abort_selection","","",274],[10,"drop","","",274],[10,"fmt","sync::comm::sync","",275],[10,"new","","",276],[10,"send","","",276],[10,"try_send","","",276],[10,"recv","","",276],[10,"try_recv","","",276],[10,"clone_chan","","",276],[10,"drop_chan","","",276],[10,"drop_port","","",276],[10,"can_recv","","",276],[10,"start_selection","","",276],[10,"abort_selection","","",276],[10,"drop","","",276],[10,"fmt","sync::comm","",277],[10,"clone","","",277],[10,"clone_from","","",277],[10,"eq","","",277],[10,"ne","","",277],[10,"ne","","",277],[10,"fmt","","",278],[10,"clone","","",278],[10,"clone_from","","",278],[10,"eq","","",278],[10,"ne","","",278],[10,"ne","","",278],[10,"send","","Sends a value along this channel to be received by the corresponding\nreceiver.",279],[10,"send_opt","","Attempts to send a value on this channel, returning it back if it could\nnot be sent.",279],[10,"clone","","",279],[10,"clone_from","","",279],[10,"drop","","",279],[10,"send","","Sends a value on this synchronous channel.",280],[10,"send_opt","","Send a value on a channel, returning it back if the receiver\ndisconnected",280],[10,"try_send","","Attempts to send a value on this channel without blocking.",280],[10,"clone","","",280],[10,"clone_from","","",280],[10,"drop","","",280],[10,"recv","","Blocks waiting for a value on this receiver",281],[10,"try_recv","","Attempts to return a pending value on this receiver without blocking",281],[10,"recv_opt","","Attempt to wait for a value on this receiver, but does not fail if the\ncorresponding channel has hung up.",281],[10,"iter","","Returns an iterator which will block waiting for messages, but never\n`fail!`. It will return `None` when the channel has hung up.",281],[10,"next","","",282],[10,"size_hint","","",282],[10,"chain","","",282],[10,"zip","","",282],[10,"map","","",282],[10,"filter","","",282],[10,"filter_map","","",282],[10,"enumerate","","",282],[10,"peekable","","",282],[10,"skip_while","","",282],[10,"take_while","","",282],[10,"skip","","",282],[10,"take","","",282],[10,"scan","","",282],[10,"flat_map","","",282],[10,"fuse","","",282],[10,"inspect","","",282],[10,"by_ref","","",282],[10,"advance","","",282],[10,"collect","","",282],[10,"nth","","",282],[10,"last","","",282],[10,"fold","","",282],[10,"count","","",282],[10,"all","","",282],[10,"any","","",282],[10,"find","","",282],[10,"position","","",282],[10,"max_by","","",282],[10,"min_by","","",282],[10,"drop","","",281],[10,"drop","sync::lock","",283],[10,"wait","","Atomically exit the associated lock and block until a signal is sent.",284],[10,"wait_on","","Atomically exit the associated lock and block on a specified condvar\nuntil a signal is sent on that same condvar.",284],[10,"signal","","Wake up a blocked task. Returns false if there was no blocked task.",284],[10,"signal_on","","Wake up a blocked task on a specified condvar (as\nsync::cond.signal_on). Returns false if there was no blocked task.",284],[10,"broadcast","","Wake up all blocked tasks. Returns the number of tasks woken.",284],[10,"broadcast_on","","Wake up all blocked tasks on a specified condvar (as\nsync::cond.broadcast_on). Returns the number of tasks woken.",284],[10,"new","","Creates a new mutex to protect the user-supplied data.",285],[10,"new_with_condvars","","Create a new mutex, with a specified number of associated condvars.",285],[10,"lock","","Access the underlying mutable data with mutual exclusion from other\ntasks. The returned value is an RAII guard which will unlock the mutex\nwhen dropped. All concurrent tasks attempting to lock the mutex will\nblock while the returned value is still alive.",285],[10,"deref","","",286],[10,"deref_mut","","",286],[10,"new","","Create a reader/writer lock with the supplied data.",287],[10,"new_with_condvars","","Create a reader/writer lock with the supplied data and a specified number\nof condvars (as sync::RWLock::new_with_condvars).",287],[10,"write","","Access the underlying data mutably. Locks the rwlock in write mode;\nother readers and writers will block.",287],[10,"read","","Access the underlying data immutably. May run concurrently with other\nreading tasks.",287],[10,"downgrade","","Consumes this write lock token, returning a new read lock token.",288],[10,"deref","","",289],[10,"deref","","",288],[10,"deref_mut","","",288],[10,"new","","Create a new barrier that can block a given number of tasks.",290],[10,"wait","","Block the current task until a certain number of tasks is waiting.",290],[1,"AtomicOption","std::sync::atomics","An atomic, nullable unique pointer"],[5,"INIT_ATOMIC_INT","",""],[1,"AtomicUint","","An unsigned atomic integer type, supporting basic atomic arithmetic operations"],[1,"AtomicInt","","A signed atomic integer type, supporting basic atomic arithmetic operations"],[2,"Ordering","","Atomic memory orderings"],[12,"Relaxed","","No ordering constraints, only atomic operations",291],[12,"Release","","When coupled with a store, all previous writes become visible\nto another thread that performs a load with `Acquire` ordering\non the same value",291],[12,"Acquire","","When coupled with a load, all subsequent loads will see data\nwritten before a store with `Release` ordering on the same value\nin another thread",291],[12,"AcqRel","","When coupled with a load, uses `Acquire` ordering, and with a store\n`Release` ordering",291],[12,"SeqCst","","Like `AcqRel` with the additional guarantee that all threads see all\nsequentially consistent operations in the same order.",291],[5,"INIT_ATOMIC_BOOL","",""],[1,"AtomicBool","","An atomic boolean type."],[3,"fence","","An atomic fence."],[1,"AtomicPtr","","An unsafe atomic pointer. Only supports basic atomic operations"],[5,"INIT_ATOMIC_UINT","",""],[0,"deque","std::sync","A (mostly) lock-free concurrent work-stealing deque"],[1,"Worker","std::sync::deque","Worker half of the work-stealing deque. This worker has exclusive access to\none side of the deque, and uses `push` and `pop` method to manipulate it."],[1,"Stealer","","The stealing half of the work-stealing deque. Stealers have access to the\nopposite end of the deque from the worker, and they only have access to the\n`steal` method."],[2,"Stolen","","When stealing some data, this is an enumeration of the possible outcomes."],[12,"Empty","","The deque was empty at the time of stealing",249],[12,"Abort","","The stealer lost the race for stealing data, and a retry may return more\ndata.",249],[12,"Data","","The stealer has successfully stolen some data.",249],[1,"BufferPool","","The allocation pool for buffers used by work-stealing deques. Right now this\nstructure is used for reclamation of memory after it is no longer in use by\ndeques."],[0,"mpmc_bounded_queue","std::sync",""],[1,"Queue","std::sync::mpmc_bounded_queue",""],[0,"mpsc_queue","std::sync","A mostly lock-free multi-producer, single consumer queue."],[2,"PopResult","std::sync::mpsc_queue","A result of the `pop` function."],[12,"Data","","Some data has been popped",292],[12,"Empty","","The queue is empty",292],[12,"Inconsistent","","The queue is in an inconsistent state. Popping data should succeed, but\nsome pushers have yet to make enough progress in order allow a pop to\nsucceed. It is recommended that a pop() occur \"in the near future\" in\norder to see if the sender has made progress or not",292],[1,"Queue","","The multi-producer single-consumer structure. This is not cloneable, but it\nmay be safely shared so long as it is guaranteed that there is only one\npopper at a time (many pushers are allowed)."],[0,"spsc_queue","std::sync","A single-producer single-consumer concurrent queue"],[1,"Queue","std::sync::spsc_queue","The single-producer single-consumer queue. This structure is not cloneable,\nbut it can be safely shared in an Arc if it is guaranteed that there\nis only one popper and one pusher touching the queue at any one point in\ntime."],[1,"Consumer","","A safe abstraction for the consumer in a single-producer single-consumer\nqueue."],[1,"Producer","","A safe abstraction for the producer in a single-producer single-consumer\nqueue."],[3,"queue","","Creates a new queue with a consumer-producer pair."],[10,"new","alloc::arc","Create an atomically reference counted wrapper.",293],[10,"downgrade","","Downgrades a strong pointer to a weak pointer",293],[10,"make_unique","","Acquires a mutable pointer to the inner contents by guaranteeing that\nthe reference count is one (no sharing is possible).",293],[10,"default","alloc::boxed","",230],[10,"clone","","Return a copy of the owned box.",230],[10,"clone_from","","Perform copy-assignment from `source` by reusing the existing allocation.",230],[10,"clone_from","","",230],[10,"eq","","",230],[10,"ne","","",230],[10,"ne","","",230],[10,"partial_cmp","","",230],[10,"lt","","",230],[10,"le","","",230],[10,"ge","","",230],[10,"gt","","",230],[10,"lt","","",230],[10,"le","","",230],[10,"gt","","",230],[10,"ge","","",230],[10,"cmp","","",230],[10,"assert_receiver_is_total_eq","","",230],[10,"downcast","","",230],[10,"move","","",230],[10,"fmt","","",230],[10,"fmt","","",230],[10,"clone","alloc::arc","Duplicate an atomically reference counted wrapper.",293],[10,"clone_from","","",293],[10,"deref","","",293],[10,"drop","","",293],[10,"upgrade","","Attempts to upgrade this weak reference to a strong reference.",294],[10,"clone","","",294],[10,"clone_from","","",294],[10,"drop","","",294],[10,"new","alloc::rc","Construct a new reference-counted box",231],[10,"downgrade","","Downgrade the reference-counted pointer to a weak reference",231],[10,"make_unique","","Acquires a mutable pointer to the inner contents by guaranteeing that\nthe reference count is one (no sharing is possible).",231],[10,"deref","","Borrow the value contained in the reference-counted box",231],[10,"drop","","",231],[10,"clone","","",231],[10,"clone_from","","",231],[10,"default","","",231],[10,"eq","","",231],[10,"ne","","",231],[10,"ne","","",231],[10,"assert_receiver_is_total_eq","","",231],[10,"partial_cmp","","",231],[10,"lt","","",231],[10,"le","","",231],[10,"gt","","",231],[10,"ge","","",231],[10,"lt","","",231],[10,"le","","",231],[10,"gt","","",231],[10,"ge","","",231],[10,"cmp","","",231],[10,"fmt","","",231],[10,"upgrade","","Upgrade a weak reference to a strong reference",295],[10,"drop","","",295],[10,"clone","","",295],[10,"clone_from","","",295],[1,"Arc","std::sync","An atomically reference counted wrapper for shared state."],[1,"Weak","","A weak pointer to an `Arc`."],[1,"Mutex","","A wrapper type which provides synchronized access to the underlying data, of\ntype `T`. A mutex always provides exclusive access, and concurrent requests\nwill block while the mutex is already locked."],[1,"MutexGuard","","An guard which is created by locking a mutex. Through this guard the\nunderlying data can be accessed."],[11,"cond","","Inner condition variable connected to the locked mutex that this guard\nwas created from. This can be used for atomic-unlock-and-deschedule.",286],[1,"Condvar","","A condition variable, a mechanism for unlock-and-descheduling and\nsignaling, for use with the lock types."],[1,"Barrier","","A barrier enables multiple tasks to synchronize the beginning\nof some computation."],[1,"RWLock","","A dual-mode reader-writer lock. The data can be accessed mutably or\nimmutably, and immutably-accessing tasks may run concurrently."],[1,"RWLockReadGuard","","A guard which is created by locking an rwlock in read mode. Through this\nguard the underlying data can be accessed."],[1,"RWLockWriteGuard","","A guard which is created by locking an rwlock in write mode. Through this\nguard the underlying data can be accessed."],[11,"cond","","Inner condition variable that can be used to sleep on the write mode of\nthis rwlock.",288],[1,"Semaphore","","A counting, blocking, bounded-waiting semaphore."],[1,"SemaphoreGuard","","An RAII guard used to represent an acquired resource to a semaphore. When\ndropped, this value will release the resource back to the semaphore."],[1,"Once","","A synchronization primitive which can be used to run a one-time global\ninitialization. Useful for one-time initialization for FFI or related\nfunctionality. This type can only be constructed with the `ONCE_INIT`\nvalue."],[5,"ONCE_INIT","",""],[0,"c_vec","std","Library to interface with chunks of memory allocated in C."],[1,"CVec","std::c_vec","The type representing a foreign chunk of memory"],[10,"drop","","",296],[10,"new","","Create a `CVec` from a raw pointer to a buffer with a given length.",296],[10,"new_with_dtor","","Create a `CVec` from a foreign buffer, with a given length,\nand a function to run upon destruction.",296],[10,"as_mut_slice","","View the stored data as a mutable slice.",296],[10,"get","","Retrieves an element at a given index, returning `None` if the requested\nindex is greater than the length of the vector.",296],[10,"get_mut","","Retrieves a mutable element at a given index, returning `None` if the\nrequested index is greater than the length of the vector.",296],[10,"unwrap","","Unwrap the pointer without running the destructor",296],[10,"as_slice","","View the stored data as a slice.",296],[10,"len","","",296],[0,"dynamic_lib","std","Dynamic library facilities."],[1,"DynamicLibrary","std::dynamic_lib",""],[0,"dl","",""],[2,"RTLD","std::dynamic_lib::dl",""],[12,"Lazy","","",297],[12,"Now","","",297],[12,"Global","","",297],[12,"Local","","",297],[3,"open_external","",""],[3,"open_internal","",""],[3,"check_for_errors_in","",""],[3,"symbol","",""],[3,"close","",""],[10,"drop","std::dynamic_lib","",298],[10,"open","","Lazily open a dynamic library. When passed None it gives a\nhandle to the calling process",298],[10,"prepend_search_path","","Prepends a path to this process's search path for dynamic libraries",298],[10,"create_path","","From a slice of paths, create a new vector which is suitable to be an\nenvironment variable for this platforms dylib search path.",298],[10,"envvar","","Returns the environment variable for this process's dynamic library\nsearch path",298],[10,"search_path","","Returns the current search path for dynamic libraries being used by this\nprocess",298],[10,"symbol","","Access the value at the symbol of the dynamic library",298],[0,"os","std","Higher-level interfaces to libc::* functions and operating system services."],[1,"Pipe","std::os","A low-level OS in-memory pipe."],[11,"reader","","A file descriptor representing the reading end of the pipe. Data written\non the `out` file descriptor can be read from this file descriptor.",299],[11,"writer","","A file descriptor representing the write end of the pipe. Data written\nto this file descriptor can be read from the `input` file descriptor.",299],[1,"MemoryMap","","A memory mapped file or chunk of memory. This is a very system-specific\ninterface to the OS's memory mapping facilities (`mmap` on POSIX,\n`VirtualAlloc`/`CreateFileMapping` on win32). It makes no attempt at\nabstracting platform differences, besides in error values returned. Consider\nyourself warned."],[2,"MemoryMapKind","","Type of memory map"],[12,"MapFile","","Virtual memory map. Usually used to change the permissions of a given\nchunk of memory.  Corresponds to `VirtualAlloc` on Windows.",300],[12,"MapVirtual","","Virtual memory map. Usually used to change the permissions of a given\nchunk of memory, or for allocation. Corresponds to `VirtualAlloc` on\nWindows.",300],[2,"MapOption","","Options the memory map is created with"],[12,"MapReadable","","The memory should be readable",301],[12,"MapWritable","","The memory should be writable",301],[12,"MapExecutable","","The memory should be executable",301],[12,"MapAddr","","Create a map for a specific address range. Corresponds to `MAP_FIXED` on\nPOSIX.",301],[12,"MapFd","","Create a memory mapping for a file with a given fd.",301],[12,"MapOffset","","When using `MapFd`, the start of the map is `uint` bytes from the start\nof the file.",301],[12,"MapNonStandardFlags","","On POSIX, this can be used to specify the default flags passed to\n`mmap`. By default it uses `MAP_PRIVATE` and, if not using `MapFd`,\n`MAP_ANON`. This will override both of those. This is platform-specific\n(the exact values used) and ignored on Windows.",301],[2,"MapError","","Possible errors when creating a map."],[12,"ErrFdNotAvail","","## The following are POSIX-specific",302],[12,"ErrInvalidFd","","fd was not valid",302],[12,"ErrUnaligned","","Either the address given by `MapAddr` or offset given by `MapOffset` was\nnot a multiple of `MemoryMap::granularity` (unaligned to page size).",302],[12,"ErrNoMapSupport","","With `MapFd`, the fd does not support mapping.",302],[12,"ErrNoMem","","If using `MapAddr`, the address + `min_len` was outside of the process's\naddress space. If using `MapFd`, the target of the fd didn't have enough\nresources to fulfill the request.",302],[12,"ErrZeroLength","","A zero-length map was requested. This is invalid according to\n[POSIX](http://pubs.opengroup.org/onlinepubs/9699919799/functions/mmap.html).\nNot all platforms obey this, but this wrapper does.",302],[12,"ErrUnknown","","Unrecognized error. The inner value is the unrecognized errno.",302],[12,"ErrUnsupProt","","## The following are win32-specific",302],[12,"ErrUnsupOffset","","When using `MapFd`, `MapOffset` was given (Windows does not support this\nat all)",302],[12,"ErrAlreadyExists","","When using `MapFd`, there was already a mapping to the file.",302],[12,"ErrVirtualAlloc","","Unrecognized error from `VirtualAlloc`. The inner value is the return\nvalue of GetLastError.",302],[12,"ErrCreateFileMappingW","","Unrecognized error from `CreateFileMapping`. The inner value is the\nreturn value of `GetLastError`.",302],[12,"ErrMapViewOfFile","","Unrecognized error from `MapViewOfFile`. The inner value is the return\nvalue of `GetLastError`.",302],[3,"num_cpus","","Get the number of cores available"],[3,"getcwd","","Returns the current working directory as a Path."],[3,"env","","Returns a vector of (variable, value) pairs, for all the environment\nvariables of the current process."],[3,"env_as_bytes","","Returns a vector of (variable, value) byte-vector pairs for all the\nenvironment variables of the current process."],[3,"getenv","","Fetches the environment variable `n` from the current process, returning\nNone if the variable isn't set."],[3,"getenv_as_bytes","","Fetches the environment variable `n` byte vector from the current process,\nreturning None if the variable isn't set."],[3,"setenv","","Sets the environment variable `n` to the value `v` for the currently running\nprocess."],[3,"unsetenv","","Remove a variable from the environment entirely."],[3,"split_paths","","Parses input according to platform conventions for the `PATH`\nenvironment variable."],[3,"join_paths","","Joins a collection of `Path`s appropriately for the `PATH`\nenvironment variable."],[3,"pipe","","Creates a new low-level OS in-memory pipe."],[3,"dll_filename","","Returns the proper dll filename for the given basename of a file\nas a String."],[3,"self_exe_name","","Optionally returns the filesystem path to the current executable which is\nrunning but with the executable name."],[3,"self_exe_path","","Optionally returns the filesystem path to the current executable which is\nrunning."],[3,"homedir","","Optionally returns the path to the current user's home directory if known."],[3,"tmpdir","","Returns the path to a temporary directory."],[3,"make_absolute","","\nConvert a relative path to an absolute path"],[3,"change_dir","","Changes the current working directory to the specified path, returning\nwhether the change was completed successfully or not."],[3,"errno","","Returns the platform-specific value of errno"],[3,"error_string","","Return the string corresponding to an `errno()` value of `errnum`.\n# Example\n```rust\nuse std::os;"],[3,"last_os_error","","Get a string representing the platform-dependent last error"],[3,"set_exit_status","","Sets the process exit code"],[3,"get_exit_status","","Fetches the process's current exit code. This defaults to 0 and can change\nby calling `set_exit_status`."],[3,"args","","Returns the arguments which this program was started with (normally passed\nvia the command line)."],[3,"args_as_bytes","","Returns the arguments which this program was started with (normally passed\nvia the command line) as byte vectors."],[3,"page_size","","Returns the page size of the current architecture in bytes."],[0,"consts","",""],[5,"ARCH","std::os::consts",""],[5,"FAMILY","",""],[5,"SYSNAME","","A string describing the specific operating system in use: in this\ncase, `linux`."],[5,"DLL_PREFIX","","Specifies the filename prefix used for shared libraries on this\nplatform: in this case, `lib`."],[5,"DLL_SUFFIX","","Specifies the filename suffix used for shared libraries on this\nplatform: in this case, `.so`."],[5,"DLL_EXTENSION","","Specifies the file extension used for shared libraries on this\nplatform that goes after the dot: in this case, `so`."],[5,"EXE_SUFFIX","","Specifies the filename suffix used for executable binaries on this\nplatform: in this case, the empty string."],[5,"EXE_EXTENSION","","Specifies the file extension, if any, used for executable binaries\non this platform: in this case, the empty string."],[5,"TMPBUF_SZ","std::os",""],[10,"fmt","","",302],[10,"new","","Create a new mapping with the given `options`, at least `min_len` bytes\nlong. `min_len` must be greater than zero; see the note on\n`ErrZeroLength`.",303],[10,"granularity","","Granularity that the offset or address must be for `MapOffset` and\n`MapAddr` respectively.",303],[10,"drop","","Unmap the mapping. Fails the task if `munmap` fails.",303],[10,"data","","Returns the pointer to the memory created or modified by this map.",303],[10,"len","","Returns the number of bytes this map applies to.",303],[10,"kind","","Returns the type of mapping this represents.",303],[0,"io","std","I/O, including files, networking, timers, and processes"],[1,"TempDir","std::io","A wrapper for a path to temporary directory implementing automatic\nscope-based deletion."],[1,"MemReader","","Reads from an owned byte vector"],[1,"BufReader","","Reads from a fixed-size byte slice"],[1,"MemWriter","","Writes to an owned, growable byte vector"],[1,"BufWriter","","Writes to a fixed-size byte slice"],[1,"BufferedReader","","Wraps a Reader and buffers input from it"],[1,"BufferedWriter","","Wraps a Writer and buffers output to it"],[1,"BufferedStream","","Wraps a Stream and buffers input and output to and from it."],[1,"LineBufferedWriter","","Wraps a Writer and buffers output to it, flushing whenever a newline (`0x0a`,\n`'\\n'`) is detected."],[1,"ChanReader","","Allows reading from a rx."],[1,"ChanWriter","","Allows writing to a tx."],[1,"IoError","","The type passed to I/O condition handlers to indicate error"],[11,"kind","","An enumeration which can be matched against for determining the flavor\nof error.",304],[11,"desc","","A human-readable description about the error",304],[11,"detail","","Detailed information about this error, not always available",304],[1,"RefReader","","A `RefReader` is a struct implementing `Reader` which contains a reference\nto another reader. This is often useful when composing streams."],[1,"RefWriter","","A `RefWriter` is a struct implementing `Writer` which contains a reference\nto another writer. This is often useful when composing streams."],[1,"Lines","","An iterator that reads a line on each iteration,\nuntil `.read_line()` encounters `EndOfFile`."],[1,"Chars","","An iterator that reads a utf8-encoded character on each iteration,\nuntil `.read_char()` encounters `EndOfFile`."],[1,"IncomingConnections","","An infinite iterator over incoming connection attempts.\nCalling `next` will block the task until a connection is attempted."],[1,"FileStat","","A structure used to describe metadata information about a file. This\nstructure is created through the `stat` method on a `Path`."],[11,"size","","The size of the file, in bytes",305],[11,"kind","","The kind of file this path points to (directory, file, pipe, etc.)",305],[11,"perm","","The file permissions currently on the file",305],[11,"created","","The time that the file was created at, in platform-dependent\nmilliseconds",305],[11,"modified","","The time that this file was last modified, in platform-dependent\nmilliseconds",305],[11,"accessed","","The time that this file was last accessed, in platform-dependent\nmilliseconds",305],[11,"unstable","","Information returned by stat() which is not guaranteed to be\nplatform-independent. This information may be useful on some platforms,\nbut it may have different meanings or no meaning at all on other\nplatforms.",305],[1,"UnstableFileStat","","This structure represents all of the possible information which can be\nreturned from a `stat` syscall which is not contained in the `FileStat`\nstructure. This information is not necessarily platform independent, and may\nhave different meanings or no meaning at all on some platforms."],[11,"device","","The ID of the device containing the file.",306],[11,"inode","","The file serial number.",306],[11,"rdev","","The device ID.",306],[11,"nlink","","The number of hard links to this file.",306],[11,"uid","","The user ID of the file.",306],[11,"gid","","The group ID of the file.",306],[11,"blksize","","The optimal block size for I/O.",306],[11,"blocks","","The blocks allocated for this file.",306],[11,"flags","","User-defined flags for the file.",306],[11,"gen","","The file generation number.",306],[1,"FilePermission","","A set of permissions for a file or directory is represented\nby a set of flags which are or'd together."],[2,"IoErrorKind","","A list specifying general categories of I/O error."],[12,"OtherIoError","","Any I/O error not part of this list.",307],[12,"EndOfFile","","The operation could not complete because end of file was reached.",307],[12,"FileNotFound","","The file was not found.",307],[12,"PermissionDenied","","The file permissions disallowed access to this file.",307],[12,"ConnectionFailed","","A network connection failed for some reason not specified in this list.",307],[12,"Closed","","The network operation failed because the network connection was closed.",307],[12,"ConnectionRefused","","The connection was refused by the remote server.",307],[12,"ConnectionReset","","The connection was reset by the remote server.",307],[12,"ConnectionAborted","","The connection was aborted (terminated) by the remote server.",307],[12,"NotConnected","","The network operation failed because it was not connected yet.",307],[12,"BrokenPipe","","The operation failed because a pipe was closed.",307],[12,"PathAlreadyExists","","A file already existed with that name.",307],[12,"PathDoesntExist","","No file exists at that location.",307],[12,"MismatchedFileTypeForOperation","","The path did not specify the type of file that this operation required. For example,\nattempting to copy a directory with the `fs::copy()` operation will fail with this error.",307],[12,"ResourceUnavailable","","The operation temporarily failed (for example, because a signal was received), and retrying\nmay succeed.",307],[12,"IoUnavailable","","No I/O functionality is available for this task.",307],[12,"InvalidInput","","A parameter was incorrect in a way that caused an I/O error not part of this list.",307],[12,"TimedOut","","The I/O operation's timeout expired, causing it to be canceled.",307],[12,"ShortWrite","","This write operation failed to write all of its data.",307],[12,"NoProgress","","The Reader returned 0 bytes from `read()` too many times.",307],[2,"SeekStyle","","When seeking, the resulting cursor is offset from a base by the offset given\nto the `seek` function. The base used is specified by this enumeration."],[12,"SeekSet","","Seek from the beginning of the stream",308],[12,"SeekEnd","","Seek from the end of the stream",308],[12,"SeekCur","","Seek from the current position",308],[2,"FileMode","","A mode specifies how a file should be opened or created. These modes are\npassed to `File::open_mode` and are used to control where the file is\npositioned when it is initially opened."],[12,"Open","","Opens a file positioned at the beginning.",309],[12,"Append","","Opens a file positioned at EOF.",309],[12,"Truncate","","Opens a file, truncating it if it already exists.",309],[2,"FileAccess","","Access permissions with which the file should be opened. `File`s\nopened with `Read` will return an error if written to."],[12,"Read","","Read-only access, requests to write will result in an error",310],[12,"Write","","Write-only access, requests to read will result in an error",310],[12,"ReadWrite","","Read-write access, no requests are denied by default",310],[2,"FileType","","Different kinds of files which can be identified by a call to stat"],[12,"TypeFile","","This is a normal file, corresponding to `S_IFREG`",311],[12,"TypeDirectory","","This file is a directory, corresponding to `S_IFDIR`",311],[12,"TypeNamedPipe","","This file is a named pipe, corresponding to `S_IFIFO`",311],[12,"TypeBlockSpecial","","This file is a block device, corresponding to `S_IFBLK`",311],[12,"TypeSymlink","","This file is a symbolic link to another file, corresponding to `S_IFLNK`",311],[12,"TypeUnknown","","The type of this file is not recognized as one of the other categories",311],[3,"standard_error","","Creates a standard error for a commonly used flavor of error. The `detail`\nfield of the returned error will always be `None`."],[0,"test","","Various utility functions useful for writing I/O tests"],[3,"next_test_port","std::io::test","Get a port number, starting at 9600, for use in tests"],[3,"next_test_unix","","Get a temporary path which could be the location of a unix socket"],[3,"next_test_ip4","","Get a unique IPv4 localhost:port pair starting at 9600"],[3,"next_test_ip6","","Get a unique IPv6 localhost:port pair starting at 9600"],[3,"raise_fd_limit","","Raises the file descriptor limit when running tests if necessary"],[0,"extensions","std::io","Utility mixins that apply to all Readers and Writers"],[1,"Bytes","std::io::extensions","An iterator that reads a single byte on each iteration,\nuntil `.read_byte()` returns `EndOfFile`."],[3,"u64_to_le_bytes","","Converts an 8-bit to 64-bit unsigned value to a little-endian byte\nrepresentation of the given size. If the size is not big enough to\nrepresent the value, then the high-order bytes are truncated."],[3,"u64_to_be_bytes","","Converts an 8-bit to 64-bit unsigned value to a big-endian byte\nrepresentation of the given size. If the size is not big enough to\nrepresent the value, then the high-order bytes are truncated."],[3,"u64_from_be_bytes","","Extracts an 8-bit to 64-bit unsigned big-endian value from the given byte\nbuffer and returns it as a 64-bit value."],[10,"new","","Constructs a new byte iterator from the given Reader instance.",312],[10,"next","","",312],[0,"fs","std::io","Synchronous File I/O"],[1,"File","std::io::fs","Unconstrained file access type that exposes read and write operations"],[1,"Directories","","An iterator which walks over a directory"],[3,"unlink","","Unlink a file from the underlying filesystem."],[3,"stat","","Given a path, query the file system to get information about a file,\ndirectory, etc. This function will traverse symlinks to query\ninformation about the destination file."],[3,"lstat","","Perform the same operation as the `stat` function, except that this\nfunction does not traverse through symlinks. This will return\ninformation about the symlink file instead of the file that it points\nto."],[3,"rename","","Rename a file or directory to a new name."],[3,"copy","","Copies the contents of one file to another. This function will also\ncopy the permission bits of the original file to the destination file."],[3,"chmod","","Changes the permission mode bits found on a file or a directory. This\nfunction takes a mask from the `io` module"],[3,"chown","","Change the user and group owners of a file at the specified path."],[3,"link","","Creates a new hard link on the filesystem. The `dst` path will be a\nlink pointing to the `src` path. Note that systems often require these\ntwo paths to both be located on the same filesystem."],[3,"symlink","","Creates a new symbolic link on the filesystem. The `dst` path will be a\nsymlink pointing to the `src` path."],[3,"readlink","","Reads a symlink, returning the file that the symlink points to."],[3,"mkdir","","Create a new, empty directory at the provided path"],[3,"rmdir","","Remove an existing, empty directory"],[3,"readdir","","Retrieve a vector containing all entries within a provided directory"],[3,"walk_dir","","Returns an iterator which will recursively walk the directory structure\nrooted at `path`. The path given will not be iterated over, and this will\nperform iteration in some top-down order.  The contents of unreadable\nsubdirectories are ignored."],[3,"mkdir_recursive","","Recursively create a directory and all of its parent components if they\nare missing."],[3,"rmdir_recursive","","Removes a directory at this path, after removing all its contents. Use\ncarefully!"],[3,"change_file_times","","Changes the timestamps for a file's last modification and access time.\nThe file at the path specified will have its last access time set to\n`atime` and its modification time set to `mtime`. The times specified should\nbe in milliseconds."],[10,"open_mode","","Open a file at `path` in the mode specified by the `mode` and `access`\narguments",313],[10,"open","","Attempts to open a file in read-only mode. This function is equivalent to\n`File::open_mode(path, Open, Read)`, and will raise all of the same\nerrors that `File::open_mode` does.",313],[10,"create","","Attempts to create a file in write-only mode. This function is\nequivalent to `File::open_mode(path, Truncate, Write)`, and will\nraise all of the same errors that `File::open_mode` does.",313],[10,"path","","Returns the original path which was used to open this file.",313],[10,"fsync","","Synchronizes all modifications to this file to its permanent storage\ndevice. This will flush any internal buffers necessary to perform this\noperation.",313],[10,"datasync","","This function is similar to `fsync`, except that it may not synchronize\nfile metadata to the filesystem. This is intended for use case which\nmust synchronize content, but don't need the metadata on disk. The goal\nof this method is to reduce disk operations.",313],[10,"truncate","","Either truncates or extends the underlying file, updating the size of\nthis file to become `size`. This is equivalent to unix's `truncate`\nfunction.",313],[10,"eof","","Tests whether this stream has reached EOF.",313],[10,"stat","","Queries information about the underlying file.",313],[10,"next","","",314],[10,"read","","",313],[10,"write","","",313],[10,"tell","","",313],[10,"seek","","",313],[0,"net","std::io","Networking I/O"],[0,"addrinfo","std::io::net","Synchronous DNS Resolution"],[1,"Hint","std::io::net::addrinfo","This structure is used to provide hints when fetching addresses for a\nremote host to control how the lookup is performed."],[11,"family","","",315],[11,"socktype","","",315],[11,"protocol","","",315],[11,"flags","","",315],[1,"Info","",""],[11,"address","","",316],[11,"family","","",316],[11,"socktype","","",316],[11,"protocol","","",316],[11,"flags","","",316],[2,"SocketType","","Hints to the types of sockets that are desired when looking up hosts"],[12,"Stream","","",317],[12,"Datagram","","",317],[12,"Raw","","",317],[2,"Flag","","Flags which can be or'd into the `flags` field of a `Hint`. These are used\nto manipulate how a query is performed."],[12,"AddrConfig","","",318],[12,"All","","",318],[12,"CanonName","","",318],[12,"NumericHost","","",318],[12,"NumericServ","","",318],[12,"Passive","","",318],[12,"V4Mapped","","",318],[2,"Protocol","","A transport protocol associated with either a hint or a return value of\n`lookup`"],[12,"TCP","","",319],[12,"UDP","","",319],[3,"get_host_addresses","","Easy name resolution. Given a hostname, returns the list of IP addresses for\nthat hostname."],[0,"tcp","std::io::net","TCP network connections"],[1,"TcpStream","std::io::net::tcp","A structure which represents a TCP stream between a local socket and a\nremote socket."],[1,"TcpListener","","A structure representing a socket server. This listener is used to create a\n`TcpAcceptor` which can be used to accept sockets on a local port."],[1,"TcpAcceptor","","The accepting half of a TCP socket server. This structure is created through\na `TcpListener`'s `listen` method, and this object can be used to accept new\n`TcpStream` instances."],[10,"connect","","Open a TCP connection to a remote host by hostname or IP address.",320],[10,"connect_timeout","","Creates a TCP connection to a remote socket address, timing out after\nthe specified number of milliseconds.",320],[10,"peer_name","","Returns the socket address of the remote peer of this TCP connection.",320],[10,"socket_name","","Returns the socket address of the local half of this TCP connection.",320],[10,"set_nodelay","","Sets the nodelay flag on this connection to the boolean specified",320],[10,"set_keepalive","","Sets the keepalive timeout to the timeout specified.",320],[10,"close_read","","Closes the reading half of this connection.",320],[10,"close_write","","Closes the writing half of this connection.",320],[10,"set_timeout","","Sets a timeout, in milliseconds, for blocking operations on this stream.",320],[10,"set_read_timeout","","Sets the timeout for read operations on this stream.",320],[10,"set_write_timeout","","Sets the timeout for write operations on this stream.",320],[10,"clone","","Creates a new handle to this TCP stream, allowing for simultaneous reads\nand writes of this connection.",320],[10,"read","","",320],[10,"write","","",320],[10,"bind","","Creates a new `TcpListener` which will be bound to the specified IP\nand port. This listener is not ready for accepting connections,\n`listen` must be called on it before that's possible.",321],[10,"socket_name","","Returns the local socket address of this listener.",321],[10,"listen","","",321],[10,"set_timeout","","Prevents blocking on all future accepts after `ms` milliseconds have\nelapsed.",322],[10,"accept","","",322],[0,"udp","std::io::net","UDP (User Datagram Protocol) network connections."],[1,"UdpSocket","std::io::net::udp","A User Datagram Protocol socket."],[1,"UdpStream","","A type that allows convenient usage of a UDP stream connected to one\naddress via the `Reader` and `Writer` traits."],[10,"bind","","Creates a UDP socket from the given socket address.",323],[10,"recv_from","","Receives data from the socket. On success, returns the number of bytes\nread and the address from whence the data came.",323],[10,"recvfrom","","",323],[10,"send_to","","Sends data on the socket to the given address. Returns nothing on\nsuccess.",323],[10,"sendto","","",323],[10,"connect","","Creates a `UdpStream`, which allows use of the `Reader` and `Writer`\ntraits to receive and send data from the same address. This transfers\nownership of the socket to the stream.",323],[10,"socket_name","","Returns the socket address that this socket was created from.",323],[10,"join_multicast","","Joins a multicast IP address (becomes a member of it)",323],[10,"leave_multicast","","Leaves a multicast IP address (drops membership from it)",323],[10,"set_multicast_loop","","Set the multicast loop flag to the specified value",323],[10,"set_multicast_ttl","","Sets the multicast TTL",323],[10,"set_ttl","","Sets this socket's TTL",323],[10,"set_broadcast","","Sets the broadcast flag on or off",323],[10,"set_broadast","","Sets the broadcast flag on or off",323],[10,"set_timeout","","Sets the read/write timeout for this socket.",323],[10,"set_read_timeout","","Sets the read timeout for this socket.",323],[10,"set_write_timeout","","Sets the write timeout for this socket.",323],[10,"clone","","Creates a new handle to this UDP socket, allowing for simultaneous\nreads and writes of the socket.",323],[10,"as_socket","","Allows access to the underlying UDP socket owned by this stream. This\nis useful to, for example, use the socket to send data to hosts other\nthan the one that this stream is connected to.",324],[10,"disconnect","","Consumes this UDP stream and returns out the underlying socket.",324],[10,"read","","",324],[10,"write","","",324],[0,"ip","std::io::net","Internet Protocol (IP) addresses."],[1,"SocketAddr","std::io::net::ip",""],[11,"ip","","",325],[11,"port","","",325],[2,"IpAddr","",""],[12,"Ipv4Addr","","",326],[12,"Ipv6Addr","","",326],[4,"Port","",""],[10,"hash","","",326],[10,"clone","","",326],[10,"eq","","",326],[10,"ne","","",326],[10,"fmt","","",326],[10,"hash","","",325],[10,"clone","","",325],[10,"eq","","",325],[10,"ne","","",325],[10,"fmt","","",325],[10,"from_str","","",326],[10,"from_str","","",325],[0,"unix","std::io::net","Named pipes"],[1,"UnixStream","std::io::net::unix","A stream which communicates over a named pipe."],[1,"UnixListener","","A value that can listen for incoming named pipe connection requests."],[1,"UnixAcceptor","","A value that can accept named pipe connections, returned from `listen()`."],[10,"connect","","Connect to a pipe named by `path`. This will attempt to open a\nconnection to the underlying socket.",327],[10,"connect_timeout","","Connect to a pipe named by `path`, timing out if the specified number of\nmilliseconds.",327],[10,"close_read","","Closes the reading half of this connection.",327],[10,"close_write","","Closes the writing half of this connection.",327],[10,"set_timeout","","Sets the read/write timeout for this socket.",327],[10,"set_read_timeout","","Sets the read timeout for this socket.",327],[10,"set_write_timeout","","Sets the write timeout for this socket.",327],[10,"clone","","",327],[10,"read","","",327],[10,"write","","",327],[10,"bind","","Creates a new listener, ready to receive incoming connections on the\nspecified socket. The server will be named by `path`.",328],[10,"listen","","",328],[10,"set_timeout","","Sets a timeout for this acceptor, after which accept() will no longer\nblock indefinitely.",329],[10,"accept","","",329],[0,"pipe","std::io","Synchronous, in-memory pipes."],[1,"PipeStream","std::io::pipe","A synchronous, in-memory pipe."],[1,"PipePair","",""],[11,"reader","","",330],[11,"writer","","",330],[10,"open","","Consumes a file descriptor to return a pipe stream that will have\nsynchronous, but non-blocking reads/writes. This is useful if the file\ndescriptor is acquired via means other than the standard methods.",331],[10,"pair","","Creates a pair of in-memory OS pipes for a unidirectional communication\nstream.",331],[10,"clone","","",331],[10,"read","","",331],[10,"write","","",331],[0,"process","std::io","Bindings for executing child processes"],[1,"Process","std::io::process","Representation of a running or exited child process."],[11,"stdin","","Handle to the child's stdin, if the `stdin` field of this process's\n`ProcessConfig` was `CreatePipe`. By default, this handle is `Some`.",332],[11,"stdout","","Handle to the child's stdout, if the `stdout` field of this process's\n`ProcessConfig` was `CreatePipe`. By default, this handle is `Some`.",332],[11,"stderr","","Handle to the child's stderr, if the `stderr` field of this process's\n`ProcessConfig` was `CreatePipe`. By default, this handle is `Some`.",332],[11,"extra_io","","Extra I/O handles as configured by the original `ProcessConfig` when\nthis process was created. This is by default empty.",332],[1,"Command","","The `Command` type acts as a process builder, providing fine-grained control\nover how a new process should be spawned. A default configuration can be\ngenerated using `Command::new(program)`, where `program` gives a path to the\nprogram to be executed. Additional builder methods allow the configuration\nto be changed (for example, by adding arguments) prior to spawning:"],[1,"ProcessOutput","","The output of a finished process."],[11,"status","","The status (exit code) of the process.",333],[11,"output","","The data that the process wrote to stdout.",333],[11,"error","","The data that the process wrote to stderr.",333],[2,"StdioContainer","","Describes what to do with a standard io stream for a child process."],[12,"Ignored","","This stream will be ignored. This is the equivalent of attaching the\nstream to `/dev/null`",334],[12,"InheritFd","","The specified file descriptor is inherited for the stream which it is\nspecified for.",334],[12,"CreatePipe","","Creates a pipe for the specified file descriptor which will be created\nwhen the process is spawned.",334],[2,"ProcessExit","","Describes the result of a process after it has terminated.\nNote that Windows have no signals, so the result is usually ExitStatus."],[12,"ExitStatus","","Normal termination with an exit status.",335],[12,"ExitSignal","","Termination by signal, with the signal number.",335],[4,"EnvMap","","A HashMap representation of environment variables."],[5,"PleaseExitSignal","","Signal a process to exit, without forcibly killing it. Corresponds to\nSIGTERM on unix platforms."],[5,"MustDieSignal","","Signal a process to exit immediately, forcibly killing it. Corresponds to\nSIGKILL on unix platforms."],[10,"clone","","",336],[10,"new","","Constructs a new `Command` for launching the program at\npath `program`, with the following default configuration:",336],[10,"arg","","Add an argument to pass to the program.",336],[10,"args","","Add multiple arguments to pass to the program.",336],[10,"env","","Inserts or updates an environment variable mapping.",336],[10,"env_remove","","Removes an environment variable mapping.",336],[10,"env_set_all","","Sets the entire environment map for the child process.",336],[10,"cwd","","Set the working directory for the child process.",336],[10,"stdin","","Configuration for the child process's stdin handle (file descriptor 0).\nDefaults to `CreatePipe(true, false)` so the input can be written to.",336],[10,"stdout","","Configuration for the child process's stdout handle (file descriptor 1).\nDefaults to `CreatePipe(false, true)` so the output can be collected.",336],[10,"stderr","","Configuration for the child process's stderr handle (file descriptor 2).\nDefaults to `CreatePipe(false, true)` so the output can be collected.",336],[10,"extra_io","","Attaches a stream/file descriptor/pipe to the child process. Inherited\nfile descriptors are numbered consecutively, starting at 3; the first\nthree file descriptors (stdin/stdout/stderr) are configured with the\n`stdin`, `stdout`, and `stderr` methods.",336],[10,"uid","","Sets the child process's user id. This translates to a `setuid` call in\nthe child process. Setting this value on windows will cause the spawn to\nfail. Failure in the `setuid` call on unix will also cause the spawn to\nfail.",336],[10,"gid","","Similar to `uid`, but sets the group id of the child process. This has\nthe same semantics as the `uid` field.",336],[10,"detached","","Sets the child process to be spawned in a detached state. On unix, this\nmeans that the child is the leader of a new process group.",336],[10,"spawn","","Executes the command as a child process, which is returned.",336],[10,"output","","Executes the command as a child process, waiting for it to finish and\ncollecting all of its output.",336],[10,"status","","Executes a command as a child process, waiting for it to finish and\ncollecting its exit status.",336],[10,"fmt","","Format the program and arguments of a Command for display. Any\nnon-utf8 data is lossily converted using the utf8 replacement\ncharacter.",336],[10,"clone","","",333],[10,"eq","","",333],[10,"ne","","",333],[10,"clone","","",334],[10,"clone","","",335],[10,"eq","","",335],[10,"ne","","",335],[10,"fmt","","Format a ProcessExit enum, to nicely present the information.",335],[10,"success","","Was termination successful? Signal termination not considered a success,\nand success is defined as a zero exit status.",335],[10,"matches_exit_status","","Checks whether this ProcessExit matches the given exit status.\nTermination by signal will never match an exit code.",335],[10,"kill","","Sends `signal` to another process in the system identified by `id`.",332],[10,"id","","Returns the process id of this child process",332],[10,"signal","","Sends the specified signal to the child process, returning whether the\nsignal could be delivered or not.",332],[10,"signal_exit","","Sends a signal to this child requesting that it exits. This is\nequivalent to sending a SIGTERM on unix platforms.",332],[10,"signal_kill","","Sends a signal to this child forcing it to exit. This is equivalent to\nsending a SIGKILL on unix platforms.",332],[10,"wait","","Wait for the child to exit completely, returning the status that it\nexited with. This function will continue to have the same return value\nafter it has been called at least once.",332],[10,"set_timeout","","Sets a timeout, in milliseconds, for future calls to wait().",332],[10,"wait_with_output","","Simultaneously wait for the child to exit and collect all remaining\noutput on the stdout/stderr handles, returning a `ProcessOutput`\ninstance.",332],[10,"forget","","Forgets this process, allowing it to outlive the parent",332],[10,"drop","","",332],[0,"signal","std::io","Signal handling"],[1,"Listener","std::io::signal","Listener provides a receiver to listen for registered signals."],[11,"rx","","Clients of Listener can `recv()` on this receiver. This is exposed to\nallow selection over it as well as manipulation of the receiver\ndirectly.",337],[2,"Signum","","Signals that can be sent and received"],[12,"Break","","Equivalent to SIGBREAK, delivered when the user presses Ctrl-Break.",338],[12,"HangUp","","Equivalent to SIGHUP, delivered when the user closes the terminal\nwindow. On delivery of HangUp, the program is given approximately\n10 seconds to perform any cleanup. After that, Windows will\nunconditionally terminate it.",338],[12,"Interrupt","","Equivalent to SIGINT, delivered when the user presses Ctrl-c.",338],[12,"Quit","","Equivalent to SIGQUIT, delivered when the user presses Ctrl-\\.",338],[12,"StopTemporarily","","Equivalent to SIGTSTP, delivered when the user presses Ctrl-z.",338],[12,"User1","","Equivalent to SIGUSR1.",338],[12,"User2","","Equivalent to SIGUSR2.",338],[12,"WindowSizeChange","","Equivalent to SIGWINCH, delivered when the console has been resized.\nWindowSizeChange may not be delivered in a timely manner; size change\nwill only be detected when the cursor is being moved.",338],[10,"fmt","","",338],[10,"hash","","",338],[10,"eq","","",338],[10,"ne","","",338],[10,"new","","Creates a new listener for signals. Once created, signals are bound via\nthe `register` method (otherwise nothing will ever be received)",337],[10,"register","","Listen for a signal, returning true when successfully registered for\nsignum. Signals can be received using `recv()`.",337],[10,"unregister","","Unregisters a signal. If this listener currently had a handler\nregistered for the signal, then it will stop receiving any more\nnotification about the signal. If the signal has already been received,\nit may still be returned by `recv`.",337],[0,"stdio","std::io","Non-blocking access to stdin, stdout, and stderr."],[1,"StdReader","std::io::stdio","Representation of a reader of a standard input stream"],[1,"StdWriter","","Representation of a writer to a standard output stream"],[3,"stdin","","Creates a new non-blocking handle to the stdin of the current process."],[3,"stdin_raw","","Creates a new non-blocking handle to the stdin of the current process."],[3,"stdout","","Creates a line-buffered handle to the stdout of the current process."],[3,"stdout_raw","","Creates an unbuffered handle to the stdout of the current process"],[3,"stderr","","Creates a line-buffered handle to the stderr of the current process."],[3,"stderr_raw","","Creates an unbuffered handle to the stderr of the current process"],[3,"set_stdout","","Resets the task-local stdout handle to the specified writer"],[3,"set_stderr","","Resets the task-local stderr handle to the specified writer"],[3,"flush","","Flushes the local task's stdout handle."],[3,"print","","Prints a string to the stdout of the current process. No newline is emitted\nafter the string is printed."],[3,"println","","Prints a string as a line. to the stdout of the current process. A literal\n`\\n` character is printed to the console after the string."],[3,"print_args","","Similar to `print`, but takes a `fmt::Arguments` structure to be compatible\nwith the `format_args!` macro."],[3,"println_args","","Similar to `println`, but takes a `fmt::Arguments` structure to be\ncompatible with the `format_args!` macro."],[10,"isatty","","Returns whether this stream is attached to a TTY instance or not.",339],[10,"read","","",339],[10,"winsize","","Gets the size of this output window, if possible. This is typically used\nwhen the writer is attached to something like a terminal, this is used\nto fetch the dimensions of the terminal.",340],[10,"set_raw","","Controls whether this output stream is a \"raw stream\" or simply a normal\nstream.",340],[10,"isatty","","Returns whether this stream is attached to a TTY instance or not.",340],[10,"write","","",340],[0,"timer","std::io","Synchronous Timers"],[1,"Timer","std::io::timer","A synchronous timer object"],[3,"sleep","","Sleep the current task for `msecs` milliseconds."],[10,"new","","Creates a new timer which can be used to put the current task to sleep\nfor a number of milliseconds, or to possibly create channels which will\nget notified after an amount of time has passed.",341],[10,"sleep","","Blocks the current task for `msecs` milliseconds.",341],[10,"oneshot","","Creates a oneshot receiver which will have a notification sent when\n`msecs` milliseconds has elapsed.",341],[10,"periodic","","Creates a receiver which will have a continuous stream of notifications\nbeing sent every `msecs` milliseconds.",341],[0,"util","std::io","Utility implementations of Reader and Writer"],[1,"LimitReader","std::io::util","Wraps a `Reader`, limiting the number of bytes that can be read from it."],[1,"NullWriter","","A `Writer` which ignores bytes written to it, like /dev/null."],[1,"ZeroReader","","A `Reader` which returns an infinite stream of 0 bytes, like /dev/zero."],[1,"NullReader","","A `Reader` which is always at EOF, like /dev/null."],[1,"MultiWriter","","A `Writer` which multiplexes writes to a set of `Writers`."],[1,"ChainedReader","","A `Reader` which chains input from multiple `Readers`, reading each to\ncompletion before moving onto the next."],[1,"TeeReader","","A `Reader` which forwards input from another `Reader`, passing it along to\na `Writer` as well. Similar to the `tee(1)` command."],[1,"IterReader","","A `Reader` which converts an `Iterator<u8>` into a `Reader`."],[3,"copy","","Copies all data from a `Reader` to a `Writer`."],[10,"new","","Creates a new `LimitReader`",342],[10,"unwrap","","Consumes the `LimitReader`, returning the underlying `Reader`.",342],[10,"limit","","Returns the number of bytes that can be read before the `LimitReader`\nwill return EOF.",342],[10,"read","","",342],[10,"fill_buf","","",342],[10,"consume","","",342],[10,"write","","",343],[10,"read","","",344],[10,"fill_buf","","",344],[10,"consume","","",344],[10,"read","","",345],[10,"fill_buf","","",345],[10,"consume","","",345],[10,"new","","Creates a new `MultiWriter`",346],[10,"write","","",346],[10,"flush","","",346],[10,"new","","Creates a new `ChainedReader`",347],[10,"read","","",347],[10,"new","","Creates a new `TeeReader`",348],[10,"unwrap","","Consumes the `TeeReader`, returning the underlying `Reader` and\n`Writer`.",348],[10,"read","","",348],[10,"new","","Create a new `IterReader` which will read from the specified `Iterator`.",349],[10,"read","","",349],[4,"IoResult","std::io","A convenient typedef of the return value of any I/O action."],[5,"UserRead","",""],[5,"UserWrite","",""],[5,"UserExecute","",""],[5,"GroupRead","",""],[5,"GroupWrite","",""],[5,"GroupExecute","",""],[5,"OtherRead","",""],[5,"OtherWrite","",""],[5,"OtherExecute","",""],[5,"UserRWX","",""],[5,"GroupRWX","",""],[5,"OtherRWX","",""],[5,"UserFile","","Permissions for user owned files, equivalent to 0644 on\nunix-like systems."],[5,"UserDir","","Permissions for user owned directories, equivalent to 0755 on\nunix-like systems."],[5,"UserExec","","Permissions for user owned executables, equivalent to 0755\non unix-like systems."],[5,"AllPermissions","","All possible permissions enabled."],[6,"UpdateIoError","","A trait that lets you add a `detail` to an IoError easily"],[9,"update_err","","Returns an IoError with updated description and detail",350],[9,"update_detail","","Returns an IoError with updated detail",350],[9,"update_desc","","Returns an IoError with update description",350],[6,"Reader","","A trait for objects which are byte-oriented streams. Readers are defined by\none method, `read`. This function will block until data is available,\nfilling in the provided buffer with any data read."],[9,"read","","Read bytes, up to the length of `buf` and place them in `buf`.\nReturns the number of bytes read. The number of bytes read may\nbe less than the number requested, even 0. Returns `Err` on EOF.",351],[10,"read_at_least","","Reads at least `min` bytes and places them in `buf`.\nReturns the number of bytes read.",351],[10,"read_byte","","Reads a single byte. Returns `Err` on EOF.",351],[10,"push","","Reads up to `len` bytes and appends them to a vector.\nReturns the number of bytes read. The number of bytes read may be\nless than the number requested, even 0. Returns Err on EOF.",351],[10,"push_at_least","","Reads at least `min` bytes, but no more than `len`, and appends them to\na vector.\nReturns the number of bytes read.",351],[10,"read_exact","","Reads exactly `len` bytes and gives you back a new vector of length\n`len`",351],[10,"read_to_end","","Reads all remaining bytes from the stream.",351],[10,"read_to_string","","Reads all of the remaining bytes of this stream, interpreting them as a\nUTF-8 encoded stream. The corresponding string is returned.",351],[10,"bytes","","Create an iterator that reads a single byte on\neach iteration, until EOF.",351],[10,"read_le_uint_n","","Reads `n` little-endian unsigned integer bytes.",351],[10,"read_le_int_n","","Reads `n` little-endian signed integer bytes.",351],[10,"read_be_uint_n","","Reads `n` big-endian unsigned integer bytes.",351],[10,"read_be_int_n","","Reads `n` big-endian signed integer bytes.",351],[10,"read_le_uint","","Reads a little-endian unsigned integer.",351],[10,"read_le_int","","Reads a little-endian integer.",351],[10,"read_be_uint","","Reads a big-endian unsigned integer.",351],[10,"read_be_int","","Reads a big-endian integer.",351],[10,"read_be_u64","","Reads a big-endian `u64`.",351],[10,"read_be_u32","","Reads a big-endian `u32`.",351],[10,"read_be_u16","","Reads a big-endian `u16`.",351],[10,"read_be_i64","","Reads a big-endian `i64`.",351],[10,"read_be_i32","","Reads a big-endian `i32`.",351],[10,"read_be_i16","","Reads a big-endian `i16`.",351],[10,"read_be_f64","","Reads a big-endian `f64`.",351],[10,"read_be_f32","","Reads a big-endian `f32`.",351],[10,"read_le_u64","","Reads a little-endian `u64`.",351],[10,"read_le_u32","","Reads a little-endian `u32`.",351],[10,"read_le_u16","","Reads a little-endian `u16`.",351],[10,"read_le_i64","","Reads a little-endian `i64`.",351],[10,"read_le_i32","","Reads a little-endian `i32`.",351],[10,"read_le_i16","","Reads a little-endian `i16`.",351],[10,"read_le_f64","","Reads a little-endian `f64`.",351],[10,"read_le_f32","","Reads a little-endian `f32`.",351],[10,"read_u8","","Read a u8.",351],[10,"read_i8","","Read an i8.",351],[10,"by_ref","","Creates a wrapper around a mutable reference to the reader.",351],[6,"Writer","","A trait for objects which are byte-oriented streams. Writers are defined by\none method, `write`. This function will block until the provided buffer of\nbytes has been entirely written, and it will return any failures which occur."],[9,"write","","Write the entirety of a given buffer",352],[10,"flush","","Flush this output stream, ensuring that all intermediately buffered\ncontents reach their destination.",352],[10,"write_fmt","","Writes a formatted string into this writer, returning any error\nencountered.",352],[10,"write_str","","Write a rust string into this sink.",352],[10,"write_line","","Writes a string into this sink, and then writes a literal newline (`\\n`)\nbyte afterwards. Note that the writing of the newline is *not* atomic in\nthe sense that the call to `write` is invoked twice (once with the\nstring and once with a newline character).",352],[10,"write_char","","Write a single char, encoded as UTF-8.",352],[10,"write_int","","Write the result of passing n through `int::to_str_bytes`.",352],[10,"write_uint","","Write the result of passing n through `uint::to_str_bytes`.",352],[10,"write_le_uint","","Write a little-endian uint (number of bytes depends on system).",352],[10,"write_le_int","","Write a little-endian int (number of bytes depends on system).",352],[10,"write_be_uint","","Write a big-endian uint (number of bytes depends on system).",352],[10,"write_be_int","","Write a big-endian int (number of bytes depends on system).",352],[10,"write_be_u64","","Write a big-endian u64 (8 bytes).",352],[10,"write_be_u32","","Write a big-endian u32 (4 bytes).",352],[10,"write_be_u16","","Write a big-endian u16 (2 bytes).",352],[10,"write_be_i64","","Write a big-endian i64 (8 bytes).",352],[10,"write_be_i32","","Write a big-endian i32 (4 bytes).",352],[10,"write_be_i16","","Write a big-endian i16 (2 bytes).",352],[10,"write_be_f64","","Write a big-endian IEEE754 double-precision floating-point (8 bytes).",352],[10,"write_be_f32","","Write a big-endian IEEE754 single-precision floating-point (4 bytes).",352],[10,"write_le_u64","","Write a little-endian u64 (8 bytes).",352],[10,"write_le_u32","","Write a little-endian u32 (4 bytes).",352],[10,"write_le_u16","","Write a little-endian u16 (2 bytes).",352],[10,"write_le_i64","","Write a little-endian i64 (8 bytes).",352],[10,"write_le_i32","","Write a little-endian i32 (4 bytes).",352],[10,"write_le_i16","","Write a little-endian i16 (2 bytes).",352],[10,"write_le_f64","","Write a little-endian IEEE754 double-precision floating-point\n(8 bytes).",352],[10,"write_le_f32","","Write a little-endian IEEE754 single-precision floating-point\n(4 bytes).",352],[10,"write_u8","","Write a u8 (1 byte).",352],[10,"write_i8","","Write an i8 (1 byte).",352],[10,"by_ref","","Creates a wrapper around a mutable reference to the writer.",352],[6,"Stream","","A Stream is a readable and a writable object. Data written is typically\nreceived by the object which reads receive data from."],[6,"Buffer","","A Buffer is a type of reader which has some form of internal buffering to\nallow certain kinds of reading operations to be more optimized than others.\nThis type extends the `Reader` trait with a few methods that are not\npossible to reasonably implement with purely a read interface."],[9,"fill_buf","","Fills the internal buffer of this object, returning the buffer contents.\nNote that none of the contents will be \"read\" in the sense that later\ncalling `read` may return the same contents.",353],[9,"consume","","Tells this buffer that `amt` bytes have been consumed from the buffer,\nso they should no longer be returned in calls to `read`.",353],[10,"read_line","","Reads the next line of input, interpreted as a sequence of UTF-8\nencoded unicode codepoints. If a newline is encountered, then the\nnewline is contained in the returned string.",353],[10,"lines","","Create an iterator that reads a line on each iteration until EOF.",353],[10,"read_until","","Reads a sequence of bytes leading up to a specified delimiter. Once the\nspecified byte is encountered, reading ceases and the bytes up to and\nincluding the delimiter are returned.",353],[10,"read_char","","Reads the next utf8-encoded character from the underlying stream.",353],[10,"chars","","Create an iterator that reads a utf8-encoded character on each iteration\nuntil EOF.",353],[6,"Seek","","An object implementing `Seek` internally has some form of cursor which can\nbe moved within a stream of bytes. The stream typically has a fixed size,\nallowing seeking relative to either end."],[9,"tell","","Return position of file cursor in the stream",354],[9,"seek","","Seek to an offset in a stream",354],[6,"Listener","","A listener is a value that can consume itself to start listening for\nconnections."],[9,"listen","","Spin up the listener and start queuing incoming connections",355],[6,"Acceptor","","An acceptor is a value that presents incoming connections"],[9,"accept","","Wait for and accept an incoming connection",356],[10,"incoming","","Create an iterator over incoming connection attempts.",356],[10,"clone","","",304],[10,"eq","","",304],[10,"ne","","",304],[10,"from_errno","","Convert an `errno` value into an `IoError`.",304],[10,"last_error","","Retrieve the last error to occur as a (detailed) IoError.",304],[10,"fmt","","",304],[10,"fmt","","",307],[10,"clone","","",307],[10,"eq","","",307],[10,"ne","","",307],[10,"update_err","","",357],[10,"update_detail","","",357],[10,"update_desc","","",357],[10,"read","alloc::boxed","",230],[10,"read","std::io","",358],[10,"fill_buf","","",358],[10,"consume","","",358],[10,"write","alloc::boxed","",230],[10,"flush","","",230],[10,"write","std::io","",359],[10,"flush","","",359],[10,"next","","",360],[10,"next","","",361],[10,"next","","",362],[10,"hash","","",311],[10,"fmt","","",311],[10,"eq","","",311],[10,"ne","","",311],[10,"hash","","",305],[10,"hash","","",306],[10,"hash","","",363],[10,"cmp","","",363],[10,"partial_cmp","","",363],[10,"lt","","",363],[10,"le","","",363],[10,"gt","","",363],[10,"ge","","",363],[10,"clone","","",363],[10,"eq","","",363],[10,"ne","","",363],[10,"fmt","","",363],[10,"empty","","Returns an empty set of flags.",363],[10,"all","","Returns the set containing all flags.",363],[10,"bits","","Returns the raw value of the flags currently stored.",363],[10,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",363],[10,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",363],[10,"is_empty","","Returns `true` if no flags are currently stored.",363],[10,"is_all","","Returns `true` if all flags are currently set.",363],[10,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",363],[10,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",363],[10,"insert","","Inserts the specified flags in-place.",363],[10,"remove","","Removes the specified flags in-place.",363],[10,"bitor","","Returns the union of the two sets of flags.",363],[10,"bitand","","Returns the intersection between the two sets of flags.",363],[10,"sub","","Returns the set difference of the two sets of flags.",363],[10,"not","","Returns the complement of this set of flags.",363],[10,"default","","",363],[0,"path","std","Cross-platform path support"],[1,"Display","std::path","Helper struct for printing paths with format!()"],[0,"posix","","POSIX file path handling"],[1,"Path","std::path::posix","Represents a POSIX file path"],[3,"is_sep_byte","","Returns whether the given byte is a path separator"],[3,"is_sep","","Returns whether the given char is a path separator"],[4,"Components","","Iterator that yields successive components of a Path as &[u8]"],[4,"StrComponents","","Iterator that yields successive components of a Path as Option<&str>"],[5,"SEP","","The standard path separator character"],[5,"SEP_BYTE","","The standard path separator byte"],[10,"clone","","",364],[10,"eq","","",364],[10,"partial_cmp","","",364],[10,"cmp","","",364],[10,"from_str","","",364],[10,"to_c_str","","",364],[10,"to_c_str_unchecked","","",364],[10,"hash","","",364],[10,"container_as_bytes","","",364],[10,"container_into_owned_bytes","","",364],[10,"new_unchecked","","",364],[10,"set_filename_unchecked","","",364],[10,"push_unchecked","","",364],[10,"as_vec","","",364],[10,"into_vec","","",364],[10,"dirname","","",364],[10,"filename","","",364],[10,"pop","","",364],[10,"root_path","","",364],[10,"is_absolute","","",364],[10,"is_ancestor_of","","",364],[10,"path_relative_from","","",364],[10,"ends_with_path","","",364],[10,"new","","Returns a new Path from a byte vector or string",364],[10,"new_opt","","Returns a new Path from a byte vector or string, if possible",364],[10,"components","","Returns an iterator that yields each component of the path in turn.\nDoes not distinguish between absolute and relative paths, e.g.\n/a/b/c and a/b/c yield the same set of components.\nA path of \"/\" yields no components. A path of \".\" yields one component.",364],[10,"str_components","","Returns an iterator that yields each component of the path as Option<&str>.\nSee components() for details.",364],[0,"windows","std::path","Windows file path handling"],[1,"Path","std::path::windows","Represents a Windows path"],[2,"PathPrefix","","Prefix types for Path"],[12,"VerbatimPrefix","","Prefix `\\\\?\\`, uint is the length of the following component",365],[12,"VerbatimUNCPrefix","","Prefix `\\\\?\\UNC\\`, uints are the lengths of the UNC components",365],[12,"VerbatimDiskPrefix","","Prefix `\\\\?\\C:\\` (for any alphabetic character)",365],[12,"DeviceNSPrefix","","Prefix `\\\\.\\`, uint is the length of the following component",365],[12,"UNCPrefix","","UNC prefix `\\\\server\\share`, uints are the lengths of the server/share",365],[12,"DiskPrefix","","Prefix `C:` for any alphabetic character",365],[3,"is_vol_relative","","Returns whether the path is considered \"volume-relative\", which means a path\nthat looks like \"\\foo\". Paths of this form are relative to the current volume,\nbut absolute within that volume."],[3,"is_cwd_relative","","Returns whether the path is considered \"cwd-relative\", which means a path\nwith a volume prefix that is not absolute. This look like \"C:foo.txt\". Paths\nof this form are relative to the cwd on the given volume."],[3,"prefix","","Returns the PathPrefix for this Path"],[3,"is_verbatim","","Returns whether the Path's prefix is a verbatim prefix, i.e. `\\\\?\\`"],[3,"make_non_verbatim","","Returns the non-verbatim equivalent of the input path, if possible.\nIf the input path is a device namespace path, None is returned.\nIf the input path is not verbatim, it is returned as-is.\nIf the input path is verbatim, but the same path can be expressed as\nnon-verbatim, the non-verbatim version is returned.\nOtherwise, None is returned."],[3,"is_sep","","Returns whether the given char is a path separator.\nAllows both the primary separator '\\' and the alternative separator '/'."],[3,"is_sep_verbatim","","Returns whether the given char is a path separator.\nOnly allows the primary separator '\\'; use is_sep to allow '/'."],[3,"is_sep_byte","","Returns whether the given byte is a path separator.\nAllows both the primary separator '\\' and the alternative separator '/'."],[3,"is_sep_byte_verbatim","","Returns whether the given byte is a path separator.\nOnly allows the primary separator '\\'; use is_sep_byte to allow '/'."],[4,"StrComponents","","Iterator that yields successive components of a Path as &str"],[4,"Components","","Iterator that yields successive components of a Path as &[u8]"],[5,"SEP","","The standard path separator character"],[5,"SEP_BYTE","","The standard path separator byte"],[5,"SEP2","","The alternative path separator character"],[5,"SEP2_BYTE","","The alternative path separator character"],[10,"clone","","",366],[10,"eq","","",366],[10,"partial_cmp","","",366],[10,"cmp","","",366],[10,"from_str","","",366],[10,"to_c_str","","",366],[10,"to_c_str_unchecked","","",366],[10,"hash","","",366],[10,"container_as_bytes","","",366],[10,"container_into_owned_bytes","","",366],[10,"container_as_str","","",366],[10,"is_str","","",366],[10,"new_unchecked","","See `GenericPathUnsafe::from_vec_unchecked`.",366],[10,"set_filename_unchecked","","See `GenericPathUnsafe::set_filename_unchecked`.",366],[10,"push_unchecked","","See `GenericPathUnsafe::push_unchecked`.",366],[10,"new_opt","","",366],[10,"as_str","","See `GenericPath::as_str` for info.\nAlways returns a `Some` value.",366],[10,"as_vec","","",366],[10,"into_vec","","",366],[10,"dirname","","",366],[10,"dirname_str","","See `GenericPath::dirname_str` for info.\nAlways returns a `Some` value.",366],[10,"filename","","",366],[10,"filename_str","","See `GenericPath::filename_str` for info.\nAlways returns a `Some` value if `filename` returns a `Some` value.",366],[10,"filestem_str","","See `GenericPath::filestem_str` for info.\nAlways returns a `Some` value if `filestem` returns a `Some` value.",366],[10,"extension_str","","",366],[10,"dir_path","","",366],[10,"pop","","",366],[10,"root_path","","",366],[10,"is_absolute","","See `GenericPath::is_absolute` for info.",366],[10,"is_relative","","",366],[10,"is_ancestor_of","","",366],[10,"path_relative_from","","",366],[10,"ends_with_path","","",366],[10,"new","","Returns a new Path from a byte vector or string",366],[10,"new_opt","","Returns a new Path from a byte vector or string, if possible",366],[10,"str_components","","Returns an iterator that yields each component of the path in turn as a Option<&str>.\nEvery component is guaranteed to be Some.\nDoes not yield the path prefix (including server/share components in UNC paths).\nDoes not distinguish between volume-relative and relative paths, e.g.\n\\a\\b\\c and a\\b\\c.\nDoes not distinguish between absolute and cwd-relative paths, e.g.\nC:\\foo and C:foo.",366],[10,"components","","Returns an iterator that yields each component of the path in turn as a &[u8].\nSee str_components() for details.",366],[10,"clone","","",365],[10,"eq","","",365],[10,"ne","","",365],[6,"GenericPath","std::path","A trait that represents the generic operations available on paths"],[10,"new","","Creates a new Path from a byte vector or string.\nThe resulting Path will always be normalized.",367],[10,"new_opt","","Creates a new Path from a byte vector or string, if possible.\nThe resulting Path will always be normalized.",367],[10,"as_str","","Returns the path as a string, if possible.\nIf the path is not representable in utf-8, this returns None.",367],[9,"as_vec","","Returns the path as a byte vector",367],[9,"into_vec","","Converts the Path into an owned byte vector",367],[10,"display","","Returns an object that implements `Show` for printing paths",367],[10,"filename_display","","Returns an object that implements `Show` for printing filenames",367],[9,"dirname","","Returns the directory component of `self`, as a byte vector (with no trailing separator).\nIf `self` has no directory component, returns ['.'].",367],[10,"dirname_str","","Returns the directory component of `self`, as a string, if possible.\nSee `dirname` for details.",367],[9,"filename","","Returns the file component of `self`, as a byte vector.\nIf `self` represents the root of the file hierarchy, returns None.\nIf `self` is \".\" or \"..\", returns None.",367],[10,"filename_str","","Returns the file component of `self`, as a string, if possible.\nSee `filename` for details.",367],[10,"filestem","","Returns the stem of the filename of `self`, as a byte vector.\nThe stem is the portion of the filename just before the last '.'.\nIf there is no '.', the entire filename is returned.",367],[10,"filestem_str","","Returns the stem of the filename of `self`, as a string, if possible.\nSee `filestem` for details.",367],[10,"extension","","Returns the extension of the filename of `self`, as an optional byte vector.\nThe extension is the portion of the filename just after the last '.'.\nIf there is no extension, None is returned.\nIf the filename ends in '.', the empty vector is returned.",367],[10,"extension_str","","Returns the extension of the filename of `self`, as a string, if possible.\nSee `extension` for details.",367],[10,"set_filename","","Replaces the filename portion of the path with the given byte vector or string.\nIf the replacement name is [], this is equivalent to popping the path.",367],[10,"set_extension","","Replaces the extension with the given byte vector or string.\nIf there is no extension in `self`, this adds one.\nIf the argument is [] or \"\", this removes the extension.\nIf `self` has no filename, this is a no-op.",367],[10,"with_filename","","Returns a new Path constructed by replacing the filename with the given\nbyte vector or string.\nSee `set_filename` for details.",367],[10,"with_extension","","Returns a new Path constructed by setting the extension to the given\nbyte vector or string.\nSee `set_extension` for details.",367],[10,"dir_path","","Returns the directory component of `self`, as a Path.\nIf `self` represents the root of the filesystem hierarchy, returns `self`.",367],[9,"root_path","","Returns a Path that represents the filesystem root that `self` is rooted in.",367],[10,"push","","Pushes a path (as a byte vector or string) onto `self`.\nIf the argument represents an absolute path, it replaces `self`.",367],[10,"push_many","","Pushes multiple paths (as byte vectors or strings) onto `self`.\nSee `push` for details.",367],[9,"pop","","Removes the last path component from the receiver.\nReturns `true` if the receiver was modified, or `false` if it already\nrepresented the root of the file hierarchy.",367],[10,"join","","Returns a new Path constructed by joining `self` with the given path\n(as a byte vector or string).\nIf the given path is absolute, the new Path will represent just that.",367],[10,"join_many","","Returns a new Path constructed by joining `self` with the given paths\n(as byte vectors or strings).\nSee `join` for details.",367],[9,"is_absolute","","Returns whether `self` represents an absolute path.\nAn absolute path is defined as one that, when joined to another path, will\nyield back the same absolute path.",367],[10,"is_relative","","Returns whether `self` represents a relative path.\nTypically this is the inverse of `is_absolute`.\nBut for Windows paths, it also means the path is not volume-relative or\nrelative to the current working directory.",367],[9,"is_ancestor_of","","Returns whether `self` is equal to, or is an ancestor of, the given path.\nIf both paths are relative, they are compared as though they are relative\nto the same parent path.",367],[9,"path_relative_from","","Returns the Path that, were it joined to `base`, would yield `self`.\nIf no such path exists, None is returned.\nIf `self` is absolute and `base` is relative, or on Windows if both\npaths refer to separate drives, an absolute path is returned.",367],[9,"ends_with_path","","Returns whether the relative path `child` is a suffix of `self`.",367],[6,"BytesContainer","","A trait that represents something bytes-like (e.g. a &[u8] or a &str)"],[9,"container_as_bytes","","Returns a &[u8] representing the receiver",368],[10,"container_into_owned_bytes","","Consumes the receiver and converts it into Vec<u8>",368],[10,"container_as_str","","Returns the receiver interpreted as a utf-8 string, if possible",368],[10,"is_str","","Returns whether .container_as_str() is guaranteed to not fail",368],[6,"GenericPathUnsafe","","A trait that represents the unsafe operations on GenericPaths"],[9,"new_unchecked","","Creates a new Path without checking for null bytes.\nThe resulting Path will always be normalized.",369],[9,"set_filename_unchecked","","Replaces the filename portion of the path without checking for null\nbytes.\nSee `set_filename` for details.",369],[9,"push_unchecked","","Pushes a path onto `self` without checking for null bytes.\nSee `push` for details.",369],[10,"fmt","","",370],[10,"as_maybe_owned","","Returns the path as a possibly-owned string.",370],[10,"container_as_bytes","collections::string","",42],[10,"container_as_str","","",42],[10,"is_str","","",42],[10,"container_as_bytes","collections::vec","",43],[10,"container_into_owned_bytes","","",43],[10,"container_as_bytes","rustrt::c_str","",371],[10,"container_as_bytes","collections::str","",226],[10,"container_as_str","","",226],[10,"is_str","","",226],[0,"fmt","std","Utilities for formatting and printing strings"],[3,"format","std::fmt","The format function takes a precompiled format string and a list of\narguments, to return the resulting formatted string."],[10,"write","core::fmt","",156],[1,"Formatter","std::fmt","A struct to represent both where to emit formatting strings to and how they\nshould be formatted. A mutable version of this is passed to all formatting\ntraits."],[11,"flags","","Flags for formatting (packed version of rt::Flag)",156],[11,"fill","","Character used as 'fill' whenever there is alignment",156],[11,"align","","Boolean indication of whether the output should be left-aligned",156],[11,"width","","Optionally specified integer width that the output should be",156],[11,"precision","","Optionally specified precision for numeric types",156],[4,"Result","",""],[6,"FormatWriter","","A collection of methods that are required to format a message into a stream."],[9,"write","","Writes a slice of bytes into this writer, returning whether the write\nsucceeded.",372],[9,"write_fmt","","Glue for usage of the `write!` macro with implementers of this trait.",372],[0,"rt","","This is an internal module used by the ifmt! runtime. These structures are\nemitted to static arrays to precompile format strings ahead of time."],[2,"Alignment","std::fmt::rt","Possible alignments that can be requested as part of a formatting directive."],[12,"AlignLeft","","Indication that contents should be left-aligned.",154],[12,"AlignRight","","Indication that contents should be right-aligned.",154],[12,"AlignUnknown","","No alignment was requested.",154],[2,"Flag","","Flags which can be passed to formatting via a directive."],[12,"FlagSignPlus","","A flag which enables number formatting to always print the sign of a\nnumber.",373],[12,"FlagSignMinus","","Currently not a used flag",373],[12,"FlagAlternate","","Indicates that the \"alternate formatting\" for a type should be used.",373],[12,"FlagSignAwareZeroPad","","Indicates that padding should be done with a `0` character as well as\nbeing aware of the sign to be printed.",373],[6,"Show","std::fmt","When a format is not otherwise specified, types are formatted by ascribing\nto this trait. There is not an explicit way of selecting this trait to be\nused for formatting, it is only if no other format is specified."],[9,"fmt","","Formats the value using the given formatter.",374],[6,"Bool","","Format trait for the `b` character"],[9,"fmt","","Formats the value using the given formatter.",375],[6,"Char","","Format trait for the `c` character"],[9,"fmt","","Formats the value using the given formatter.",376],[6,"Signed","","Format trait for the `i` and `d` characters"],[9,"fmt","","Formats the value using the given formatter.",377],[6,"Unsigned","","Format trait for the `u` character"],[9,"fmt","","Formats the value using the given formatter.",378],[6,"Octal","","Format trait for the `o` character"],[9,"fmt","","Formats the value using the given formatter.",379],[6,"Binary","","Format trait for the `t` character"],[9,"fmt","","Formats the value using the given formatter.",380],[6,"LowerHex","","Format trait for the `x` character"],[9,"fmt","","Formats the value using the given formatter.",381],[6,"UpperHex","","Format trait for the `X` character"],[9,"fmt","","Formats the value using the given formatter.",382],[6,"String","","Format trait for the `s` character"],[9,"fmt","","Formats the value using the given formatter.",383],[6,"Pointer","","Format trait for the `p` character"],[9,"fmt","","Formats the value using the given formatter.",384],[6,"Float","","Format trait for the `f` character"],[9,"fmt","","Formats the value using the given formatter.",385],[6,"LowerExp","","Format trait for the `e` character"],[9,"fmt","","Formats the value using the given formatter.",386],[6,"UpperExp","","Format trait for the `E` character"],[9,"fmt","","Formats the value using the given formatter.",387],[2,"FormatError","","The error type which is returned from formatting a message into a stream."],[12,"WriteError","","A generic write error occurred during formatting, no other information\nis transmitted via this variant.",388],[1,"Argument","","This struct represents the generic \"argument\" which is taken by the Xprintf\nfamily of functions. It contains a function to format the given value. At\ncompile time it is ensured that the function and the value have the correct\ntypes, and then this struct is used to canonicalize arguments to one type."],[1,"Arguments","","This structure represents a safely precompiled version of a format string\nand its arguments. This cannot be generated at runtime because it cannot\nsafely be done so, so no constructors are given and the fields are private\nto prevent modification."],[3,"write","","The `write` function takes an output stream, a precompiled format string,\nand a list of arguments. The arguments will be formatted according to the\nspecified format string into the output stream provided."],[3,"radix","","Constructs a radix formatter in the range of `2..36`."],[1,"Radix","","A radix with in the range of `2..36`."],[1,"RadixFmt","","A helper type for formatting radixes."],[0,"rt","std","Runtime services, including the task scheduler and I/O dispatcher"],[3,"default_sched_threads","std::rt","Get's the number of scheduler threads requested by the environment\neither `RUST_THREADS` or `num_cpus`."],[3,"min_stack","",""],[3,"running_on_valgrind","","Dynamically inquire about whether we're running under V.\nYou should usually not use this unless your test definitely\ncan't run correctly un-altered. Valgrind is there to help\nyou notice weirdness in normal, un-doctored code paths!"],[3,"init","","One-time runtime initialization."],[3,"cleanup","","One-time runtime cleanup."],[0,"backtrace","","Simple backtrace functionality (to print on failure)"],[3,"write","std::rt::backtrace",""],[3,"log_enabled","",""],[0,"heap","std::rt",""],[3,"allocate","std::rt::heap","Return a pointer to `size` bytes of memory."],[3,"reallocate","","Extend or shrink the allocation referenced by `ptr` to `size` bytes of\nmemory."],[3,"reallocate_inplace","","Extend or shrink the allocation referenced by `ptr` to `size` bytes of\nmemory in-place."],[3,"deallocate","","Deallocate the memory referenced by `ptr`."],[3,"usable_size","","Return the usable size of an allocation created with the specified the\n`size` and `align`."],[3,"stats_print","","Print implementation-defined allocator statistics."],[5,"EMPTY","",""],[0,"libc_heap","std::rt","The global (exchange) heap."],[3,"malloc_raw","std::rt::libc_heap","A wrapper around libc::malloc, aborting on out-of-memory"],[3,"realloc_raw","","A wrapper around libc::realloc, aborting on out-of-memory"],[0,"task","std::rt","Language-level runtime services that should reasonably expected\nto be available 'everywhere'. Local heaps, GC, unwinding,\nlocal storage, and logging. Even a 'freestanding' Rust would likely want\nto implement this."],[10,"new","rustrt::task","Creates a new uninitialized task.",389],[10,"run","","Consumes ownership of a task, runs some code, and returns the task back.",389],[10,"destroy","","Destroy all associated resources of this task.",389],[10,"is_destroyed","","Queries whether this can be destroyed or not.",389],[10,"put_runtime","","Inserts a runtime object into this task, transferring ownership to the\ntask. It is illegal to replace a previous runtime object in this task\nwith this argument.",389],[10,"take_runtime","","Removes the runtime from this task, transferring ownership to the\ncaller.",389],[10,"maybe_take_runtime","","Attempts to extract the runtime as a specific type. If the runtime does\nnot have the provided type, then the runtime is not removed. If the\nruntime does have the specified type, then it is removed and returned\n(transfer of ownership).",389],[10,"spawn_sibling","","Spawns a sibling to this task. The newly spawned task is configured with\nthe `opts` structure and will run `f` as the body of its code.",389],[10,"deschedule","","Deschedules the current task, invoking `f` `amt` times. It is not\nrecommended to use this function directly, but rather communication\nprimitives in `std::comm` should be used.",389],[10,"reawaken","","Wakes up a previously blocked task, optionally specifying whether the\ncurrent task can accept a change in scheduling. This function can only\nbe called on tasks that were previously blocked in `deschedule`.",389],[10,"yield_now","","Yields control of this task to another task. This function will\neventually return, but possibly not immediately. This is used as an\nopportunity to allow other tasks a chance to run.",389],[10,"maybe_yield","","Similar to `yield_now`, except that this function may immediately return\nwithout yielding (depending on what the runtime decides to do).",389],[10,"local_io","","Acquires a handle to the I/O factory that this task contains, normally\nstored in the task's runtime. This factory may not always be available,\nwhich is why the return type is `Option`",389],[10,"stack_bounds","","Returns the stack bounds for this task in (lo, hi) format. The stack\nbounds may not be known for all tasks, so the return value may be\n`None`.",389],[10,"can_block","","Returns whether it is legal for this task to block the OS thread that it\nis running on.",389],[10,"drop","","Consume this task, flagging it as a candidate for destruction.",389],[10,"drop","rustrt::local_ptr","",390],[10,"deref","","",390],[10,"deref_mut","","",390],[10,"write","rustrt::util","",391],[10,"write_fmt","","",391],[10,"drop","rustrt::bookkeeping","",392],[10,"clone","rustrt::c_str","Clone this CString into a new, uniquely owned CString. For safety\nreasons, this is always a deep clone, rather than the usual shallow\nclone.",371],[10,"clone_from","","",371],[10,"eq","","",371],[10,"ne","","",371],[10,"partial_cmp","","",371],[10,"lt","","",371],[10,"le","","",371],[10,"gt","","",371],[10,"ge","","",371],[10,"assert_receiver_is_total_eq","","",371],[10,"hash","","",371],[10,"new","","Create a C String from a pointer.",371],[10,"as_ptr","","Return a pointer to the NUL-terminated string data.",371],[10,"as_mut_ptr","","Return a mutable pointer to the NUL-terminated string data.",371],[10,"with_ref","","Calls a closure with a reference to the underlying `*libc::c_char`.",371],[10,"with_mut_ref","","Calls a closure with a mutable reference to the underlying `*libc::c_char`.",371],[10,"is_null","","Returns true if the CString is a null.",371],[10,"is_not_null","","Returns true if the CString is not null.",371],[10,"owns_buffer","","Returns whether or not the `CString` owns the buffer.",371],[10,"as_bytes","","Converts the CString into a `&[u8]` without copying.\nIncludes the terminating NUL byte.",371],[10,"as_bytes_no_nul","","Converts the CString into a `&[u8]` without copying.\nDoes not include the terminating NUL byte.",371],[10,"as_str","","Converts the CString into a `&str` without copying.\nReturns None if the CString is not UTF-8.",371],[10,"iter","","Return a CString iterator.",371],[10,"unwrap","","Unwraps the wrapped `*libc::c_char` from the `CString` wrapper.",371],[10,"drop","","",371],[10,"len","","Return the number of bytes in the CString (not including the NUL terminator).",371],[10,"is_empty","","",371],[10,"fmt","","",371],[10,"to_c_str","collections::string","",42],[10,"to_c_str_unchecked","","",42],[10,"with_c_str","","",42],[10,"with_c_str_unchecked","","",42],[10,"with_c_str","","",42],[10,"with_c_str_unchecked","","",42],[10,"next","rustrt::c_str","",393],[10,"size_hint","","",393],[10,"chain","","",393],[10,"zip","","",393],[10,"map","","",393],[10,"filter","","",393],[10,"filter_map","","",393],[10,"enumerate","","",393],[10,"peekable","","",393],[10,"skip_while","","",393],[10,"take_while","","",393],[10,"skip","","",393],[10,"take","","",393],[10,"scan","","",393],[10,"flat_map","","",393],[10,"fuse","","",393],[10,"inspect","","",393],[10,"by_ref","","",393],[10,"advance","","",393],[10,"collect","","",393],[10,"nth","","",393],[10,"last","","",393],[10,"fold","","",393],[10,"count","","",393],[10,"all","","",393],[10,"any","","",393],[10,"find","","",393],[10,"position","","",393],[10,"max_by","","",393],[10,"min_by","","",393],[10,"new","rustrt::exclusive","Creates a new `Exclusive` which will protect the data provided.",394],[10,"lock","","Acquires this lock, returning a guard which the data is accessed through\nand from which that lock will be unlocked.",394],[10,"signal","","",395],[10,"wait","","",395],[10,"deref","","",395],[10,"deref_mut","","",395],[10,"put","rustrt::task","",389],[10,"take","","",389],[10,"try_take","","",389],[10,"exists","","",389],[10,"borrow","","",389],[10,"unsafe_take","","",389],[10,"unsafe_borrow","","",389],[10,"try_unsafe_borrow","","",389],[10,"replace","rustrt::local_data","Replaces a value in task local data.",396],[10,"get","","Borrows a value from TLD.",396],[10,"deref","","",397],[10,"fmt","","",397],[10,"eq","","",397],[10,"ne","","",397],[10,"ne","","",397],[10,"assert_receiver_is_total_eq","","",397],[10,"partial_cmp","","",397],[10,"lt","","",397],[10,"le","","",397],[10,"gt","","",397],[10,"ge","","",397],[10,"lt","","",397],[10,"le","","",397],[10,"gt","","",397],[10,"ge","","",397],[10,"cmp","","",397],[10,"drop","","",397],[10,"drop","","",398],[10,"new","rustrt::local_heap","",399],[10,"alloc","","",399],[10,"realloc","","",399],[10,"free","","",399],[10,"immortalize","","Immortalize all pending allocations, forcing them to live forever.",399],[10,"drop","","",399],[10,"drop","","",400],[10,"new","rustrt::mutex","Creates a new mutex.",401],[10,"lock","","Acquires this lock. This assumes that the current thread does not\nalready hold the lock.",401],[10,"trylock","","Attempts to acquire the lock. The value returned is `Some` if\nthe attempt succeeded.",401],[10,"lock_noguard","","Acquire the lock without creating a `LockGuard`.",401],[10,"trylock_noguard","","Attempts to acquire the lock without creating a\n`LockGuard`. The value returned is whether the lock was\nacquired or not.",401],[10,"unlock_noguard","","Unlocks the lock. This assumes that the current thread already holds the\nlock.",401],[10,"wait_noguard","","Block on the internal condition variable.",401],[10,"signal_noguard","","Signals a thread in `wait` to wake up",401],[10,"destroy","","This function is especially unsafe because there are no guarantees made\nthat no other thread is currently holding the lock or waiting on the\ncondition variable contained inside.",401],[10,"new","","Creates a new mutex.",402],[10,"lock","","Acquires this lock. This assumes that the current thread does not\nalready hold the lock.",402],[10,"trylock","","Attempts to acquire the lock. The value returned is `Some` if\nthe attempt succeeded.",402],[10,"lock_noguard","","Acquire the lock without creating a `LockGuard`.",402],[10,"trylock_noguard","","Attempts to acquire the lock without creating a\n`LockGuard`. The value returned is whether the lock was\nacquired or not.",402],[10,"unlock_noguard","","Unlocks the lock. This assumes that the current thread already holds the\nlock.",402],[10,"wait_noguard","","Block on the internal condition variable.",402],[10,"signal_noguard","","Signals a thread in `wait` to wake up",402],[10,"drop","","",402],[10,"wait","","Block on the internal condition variable.",403],[10,"signal","","Signals a thread in `wait` to wake up.",403],[10,"drop","","",403],[10,"new","rustrt::mutex::imp","",404],[10,"lock","","",404],[10,"unlock","","",404],[10,"signal","","",404],[10,"wait","","",404],[10,"trylock","","",404],[10,"destroy","","",404],[10,"drop","rustrt::rtio","",405],[10,"borrow","","Returns the local I/O: either the local scheduler's I/O services or\nthe native I/O services.",405],[10,"maybe_raise","","",405],[10,"new","","",405],[10,"get","","Returns the underlying I/O factory as a trait reference.",405],[10,"assert_receiver_is_total_eq","","",406],[10,"eq","","",406],[10,"ne","","",406],[10,"ne","","",406],[10,"fmt","","",406],[10,"assert_receiver_is_total_eq","","",407],[10,"eq","","",407],[10,"ne","","",407],[10,"ne","","",407],[10,"eq","rustrt::task","",408],[10,"ne","","",408],[10,"ne","","",408],[10,"drop","","",389],[10,"new","","",409],[10,"next","","",410],[10,"size_hint","","",410],[10,"chain","","",410],[10,"zip","","",410],[10,"map","","",410],[10,"filter","","",410],[10,"filter_map","","",410],[10,"enumerate","","",410],[10,"peekable","","",410],[10,"skip_while","","",410],[10,"take_while","","",410],[10,"skip","","",410],[10,"take","","",410],[10,"scan","","",410],[10,"flat_map","","",410],[10,"fuse","","",410],[10,"inspect","","",410],[10,"by_ref","","",410],[10,"advance","","",410],[10,"collect","","",410],[10,"nth","","",410],[10,"last","","",410],[10,"fold","","",410],[10,"count","","",410],[10,"all","","",410],[10,"any","","",410],[10,"find","","",410],[10,"position","","",410],[10,"max_by","","",410],[10,"min_by","","",410],[10,"wake","","Returns Some if the task was successfully woken; None if already killed.",411],[10,"reawaken","","Reawakens this task if ownership is acquired. If finer-grained control\nis desired, use `wake` instead.",411],[10,"trash","","",411],[10,"block","","Create a blocked task, unless the task was already killed.",411],[10,"make_selectable","","Converts one blocked task handle to a list of many handles to the same.",411],[10,"cast_to_uint","","Convert to an unsafe uint value. Useful for storing in a pipe's state\nflag.",411],[10,"cast_from_uint","","Convert from an unsafe uint value. Useful for retrieving a pipe's state\nflag.",411],[10,"new","","",412],[10,"start","rustrt::thread","Starts execution of a new OS thread.",413],[10,"start_stack","","Performs the same functionality as `start`, but specifies an explicit\nstack size for the new thread.",413],[10,"spawn","","This will spawn a new thread, but it will not wait for the thread to\nfinish, nor is it possible to wait for the thread to finish.",413],[10,"spawn_stack","","Performs the same functionality as `spawn`, but explicitly specifies a\nstack size for the new thread.",413],[10,"yield_now","","Relinquishes the CPU slot that this OS-thread is currently using,\nallowing another thread to run for awhile.",413],[10,"join","","Wait for this thread to finish, returning the result of the thread's\ncalculation.",413],[10,"drop","","",413],[10,"new","rustrt::unwind","",414],[10,"unwinding","","",414],[1,"Task","std::rt::task","State associated with Rust tasks."],[11,"heap","","",389],[11,"gc","","",389],[11,"storage","","",389],[11,"unwinder","","",389],[11,"death","","",389],[11,"name","","",389],[1,"TaskOpts","",""],[11,"on_exit","","Invoke this procedure with the result of the task when it finishes.",409],[11,"name","","A name for the task-to-be, for identification in failure messages",409],[11,"stack_size","","The size of the stack for the spawned task",409],[4,"Result","",""],[1,"GarbageCollector","",""],[1,"LocalStorage","",""],[2,"BlockedTask","","A handle to a blocked task. Usually this means having the Box<Task>\npointer by ownership, but if the task is killable, a killer can steal it\nat any time."],[12,"Owned","","",411],[12,"Shared","","",411],[1,"Death","","Per-task state related to task death, killing, failure, etc."],[11,"on_exit","","",412],[1,"BlockedTasks","",""],[0,"local","std::rt",""],[6,"Local","std::rt::local","Encapsulates some task-local data."],[9,"put","","",415],[9,"take","","",415],[9,"try_take","","",415],[9,"exists","","",415],[9,"borrow","","",415],[9,"unsafe_take","","",415],[9,"unsafe_borrow","","",415],[9,"try_unsafe_borrow","","",415],[0,"mutex","std::rt","A native mutex and condition variable type."],[1,"StaticNativeMutex","std::rt::mutex","A native mutex suitable for storing in statics (that is, it has\nthe `destroy` method rather than a destructor)."],[1,"NativeMutex","","A native mutex with a destructor for clean-up."],[1,"LockGuard","","Automatically unlocks the mutex that it was created from on\ndestruction."],[5,"NATIVE_MUTEX_INIT","",""],[0,"exclusive","std::rt",""],[1,"Exclusive","std::rt::exclusive","An OS mutex over some data."],[1,"ExclusiveGuard","","An RAII guard returned via `lock`"],[0,"stack","std::rt","Rust stack-limit management"],[5,"RED_ZONE","std::rt::stack",""],[3,"record_stack_bounds","",""],[3,"record_sp_limit","","Records the current limit of the stack as specified by `end`."],[3,"get_sp_limit","","The counterpart of the function above, this function will fetch the current\nstack limit stored in TLS."],[0,"args","std::rt","Global storage for command line arguments"],[3,"init","std::rt::args","One-time global initialization."],[3,"cleanup","","One-time global cleanup."],[3,"take","","Take the global arguments from global storage."],[3,"put","","Give the global arguments to global storage."],[3,"clone","","Make a clone of the global arguments."],[0,"rtio","std::rt","The EventLoop and internal synchronous I/O interface."],[6,"EventLoop","std::rt::rtio",""],[9,"run","","",416],[9,"callback","","",416],[9,"pausable_idle_callback","","",416],[9,"remote_callback","","",416],[9,"io","","The asynchronous I/O services. Not all event loops may provide one.",416],[9,"has_active_io","","",416],[6,"Callback","",""],[9,"call","","",417],[6,"RemoteCallback","",""],[9,"fire","","Trigger the remote callback. Note that the number of times the\ncallback is run is not guaranteed. All that is guaranteed is\nthat, after calling 'fire', the callback will be called at\nleast once, but multiple callbacks may be coalesced and\ncallbacks may be called more often requested. Destruction also\ntriggers the callback.",418],[2,"CloseBehavior","","Description of what to do when a file handle is closed"],[12,"DontClose","","Do not close this handle when the object is destroyed",419],[12,"CloseSynchronously","","Synchronously close the handle, meaning that the task will block when\nthe handle is destroyed until it has been fully closed.",419],[12,"CloseAsynchronously","","Asynchronously closes a handle, meaning that the task will *not* block\nwhen the handle is destroyed, but the handle will still get deallocated\nand cleaned up (but this will happen asynchronously on the local event\nloop).",419],[1,"ProcessConfig","","Data needed to spawn a process. Serializes the `std::io::process::Command`\nbuilder."],[11,"program","","Path to the program to run.",420],[11,"args","","Arguments to pass to the program (doesn't include the program itself).",420],[11,"env","","Optional environment to specify for the program. If this is None, then\nit will inherit the current process's environment.",420],[11,"cwd","","Optional working directory for the new process. If this is None, then\nthe current directory of the running process is inherited.",420],[11,"stdin","","Configuration for the child process's stdin handle (file descriptor 0).\nThis field defaults to `CreatePipe(true, false)` so the input can be\nwritten to.",420],[11,"stdout","","Configuration for the child process's stdout handle (file descriptor 1).\nThis field defaults to `CreatePipe(false, true)` so the output can be\ncollected.",420],[11,"stderr","","Configuration for the child process's stdout handle (file descriptor 2).\nThis field defaults to `CreatePipe(false, true)` so the output can be\ncollected.",420],[11,"extra_io","","Any number of streams/file descriptors/pipes may be attached to this\nprocess. This list enumerates the file descriptors and such for the\nprocess to be spawned, and the file descriptors inherited will start at\n3 and go to the length of this array. The first three file descriptors\n(stdin/stdout/stderr) are configured with the `stdin`, `stdout`, and\n`stderr` fields.",420],[11,"uid","","Sets the child process's user id. This translates to a `setuid` call in\nthe child process. Setting this value on windows will cause the spawn to\nfail. Failure in the `setuid` call on unix will also cause the spawn to\nfail.",420],[11,"gid","","Similar to `uid`, but sets the group id of the child process. This has\nthe same semantics as the `uid` field.",420],[11,"detach","","If true, the child process is spawned in a detached state. On unix, this\nmeans that the child is the leader of a new process group.",420],[1,"LocalIo","",""],[6,"IoFactory","",""],[9,"tcp_connect","","",421],[9,"tcp_bind","","",421],[9,"udp_bind","","",421],[9,"unix_bind","","",421],[9,"unix_connect","","",421],[9,"get_host_addresses","","",421],[9,"fs_from_raw_fd","","",421],[9,"fs_open","","",421],[9,"fs_unlink","","",421],[9,"fs_stat","","",421],[9,"fs_mkdir","","",421],[9,"fs_chmod","","",421],[9,"fs_rmdir","","",421],[9,"fs_rename","","",421],[9,"fs_readdir","","",421],[9,"fs_lstat","","",421],[9,"fs_chown","","",421],[9,"fs_readlink","","",421],[9,"fs_symlink","","",421],[9,"fs_link","","",421],[9,"fs_utime","","",421],[9,"timer_init","","",421],[9,"spawn","","",421],[9,"kill","","",421],[9,"pipe_open","","",421],[9,"tty_open","","",421],[9,"signal","","",421],[6,"RtioTcpListener","",""],[9,"listen","","",422],[6,"RtioTcpAcceptor","",""],[9,"accept","","",423],[9,"accept_simultaneously","","",423],[9,"dont_accept_simultaneously","","",423],[9,"set_timeout","","",423],[6,"RtioTcpStream","",""],[9,"read","","",424],[9,"write","","",424],[9,"peer_name","","",424],[9,"control_congestion","","",424],[9,"nodelay","","",424],[9,"keepalive","","",424],[9,"letdie","","",424],[9,"clone","","",424],[9,"close_write","","",424],[9,"close_read","","",424],[9,"set_timeout","","",424],[9,"set_read_timeout","","",424],[9,"set_write_timeout","","",424],[6,"RtioSocket","",""],[9,"socket_name","","",425],[6,"RtioUdpSocket","",""],[9,"recv_from","","",426],[9,"send_to","","",426],[9,"join_multicast","","",426],[9,"leave_multicast","","",426],[9,"loop_multicast_locally","","",426],[9,"dont_loop_multicast_locally","","",426],[9,"multicast_time_to_live","","",426],[9,"time_to_live","","",426],[9,"hear_broadcasts","","",426],[9,"ignore_broadcasts","","",426],[9,"clone","","",426],[9,"set_timeout","","",426],[9,"set_read_timeout","","",426],[9,"set_write_timeout","","",426],[6,"RtioTimer","",""],[9,"sleep","","",427],[9,"oneshot","","",427],[9,"period","","",427],[6,"RtioFileStream","",""],[9,"read","","",428],[9,"write","","",428],[9,"pread","","",428],[9,"pwrite","","",428],[9,"seek","","",428],[9,"tell","","",428],[9,"fsync","","",428],[9,"datasync","","",428],[9,"truncate","","",428],[9,"fstat","","",428],[6,"RtioProcess","",""],[9,"id","","",429],[9,"kill","","",429],[9,"wait","","",429],[9,"set_timeout","","",429],[6,"RtioPipe","",""],[9,"read","","",430],[9,"write","","",430],[9,"clone","","",430],[9,"close_write","","",430],[9,"close_read","","",430],[9,"set_timeout","","",430],[9,"set_read_timeout","","",430],[9,"set_write_timeout","","",430],[6,"RtioUnixListener","",""],[9,"listen","","",431],[6,"RtioUnixAcceptor","",""],[9,"accept","","",432],[9,"set_timeout","","",432],[6,"RtioTTY","",""],[9,"read","","",433],[9,"write","","",433],[9,"set_raw","","",433],[9,"get_winsize","","",433],[9,"isatty","","",433],[6,"PausableIdleCallback","",""],[9,"pause","","",434],[9,"resume","","",434],[6,"RtioSignal","",""],[1,"IoError","",""],[11,"code","","",435],[11,"extra","","",435],[11,"detail","","",435],[4,"IoResult","",""],[2,"IpAddr","",""],[12,"Ipv4Addr","","",406],[12,"Ipv6Addr","","",406],[1,"SocketAddr","",""],[11,"ip","","",407],[11,"port","","",407],[2,"StdioContainer","",""],[12,"Ignored","","",436],[12,"InheritFd","","",436],[12,"CreatePipe","","",436],[2,"ProcessExit","",""],[12,"ExitStatus","","",437],[12,"ExitSignal","","",437],[2,"FileMode","",""],[12,"Open","","",438],[12,"Append","","",438],[12,"Truncate","","",438],[2,"FileAccess","",""],[12,"Read","","",439],[12,"Write","","",439],[12,"ReadWrite","","",439],[1,"FileStat","",""],[11,"size","","",440],[11,"kind","","",440],[11,"perm","","",440],[11,"created","","",440],[11,"modified","","",440],[11,"accessed","","",440],[11,"device","","",440],[11,"inode","","",440],[11,"rdev","","",440],[11,"nlink","","",440],[11,"uid","","",440],[11,"gid","","",440],[11,"blksize","","",440],[11,"blocks","","",440],[11,"flags","","",440],[11,"gen","","",440],[2,"SeekStyle","",""],[12,"SeekSet","","",441],[12,"SeekEnd","","",441],[12,"SeekCur","","",441],[1,"AddrinfoHint","",""],[11,"family","","",442],[11,"socktype","","",442],[11,"protocol","","",442],[11,"flags","","",442],[1,"AddrinfoInfo","",""],[11,"address","","",443],[11,"family","","",443],[11,"socktype","","",443],[11,"protocol","","",443],[11,"flags","","",443],[0,"thread","std::rt","Native os-thread management"],[1,"Thread","std::rt::thread","This struct represents a native thread's state. This is used to join on an\nexisting thread created in the join-able state."],[1,"Stdio","std::rt",""],[5,"Stdout","",""],[5,"Stderr","",""],[3,"begin_unwind","","This is the entry point of unwinding for fail!() and assert!()."],[3,"begin_unwind_fmt","","The entry point for unwinding with a formatted message."],[0,"bookkeeping","","Task bookkeeping"],[1,"Token","std::rt::bookkeeping",""],[3,"increment","","Increment the number of live tasks, returning a token which will decrement\nthe count when dropped."],[3,"decrement","",""],[3,"wait_for_other_tasks","","Waits for all other native tasks in the system to exit. This is only used by\nthe entry points of native programs"],[3,"at_exit","std::rt","Enqueues a procedure to run when the runtime is cleaned up"],[0,"unwind","","Implementation of Rust stack unwinding"],[1,"Unwinder","std::rt::unwind",""],[4,"Callback","",""],[3,"try","","Invoke a closure, capturing the cause of failure if one occurs."],[3,"rust_begin_unwind","",""],[3,"begin_unwind_fmt","","The entry point for unwinding with a formatted message."],[3,"begin_unwind","","This is the entry point of unwinding for fail!() and assert!()."],[3,"register","","Register a callback to be invoked when a task unwinds."],[5,"DEFAULT_ERROR_CODE","std::rt",""],[6,"Runtime","","The interface to the current runtime."],[9,"yield_now","","",444],[9,"maybe_yield","","",444],[9,"deschedule","","",444],[9,"reawaken","","",444],[9,"spawn_sibling","","",444],[9,"local_io","","",444],[9,"stack_bounds","","The (low, high) edges of the current stack.",444],[9,"can_block","","",444],[9,"wrap","","",444],[0,"any","std","Traits for dynamic typing of any `'static` type (through runtime reflection)"],[2,"Void","std::any","A type with no inhabitants"],[6,"Any","","The `Any` trait is implemented by all `'static` types, and can be used for\ndynamic typing"],[6,"AnyRefExt","","Extension methods for a referenced `Any` trait object"],[9,"is","","Returns true if the boxed type is the same as `T`",445],[9,"downcast_ref","","Returns some reference to the boxed value if it is of type `T`, or\n`None` if it isn't.",445],[9,"as_ref","","Returns some reference to the boxed value if it is of type `T`, or\n`None` if it isn't.",445],[6,"AnyMutRefExt","","Extension methods for a mutable referenced `Any` trait object"],[9,"downcast_mut","","Returns some mutable reference to the boxed value if it is of type `T`, or\n`None` if it isn't.",446],[9,"as_mut","","Returns some mutable reference to the boxed value if it is of type `T`, or\n`None` if it isn't.",446],[0,"bool","std","The boolean type"],[16,"bool","std::bool","The boolean type"],[0,"cell","std","Shareable mutable containers."],[1,"Cell","std::cell","A mutable memory location that admits only `Copy` data."],[1,"RefCell","","A mutable memory location with dynamically checked borrow rules"],[1,"Ref","","Wraps a borrowed reference to a value in a `RefCell` box."],[3,"clone_ref","","Copy a `Ref`."],[1,"RefMut","","Wraps a mutable borrowed reference to a value in a `RefCell` box."],[1,"UnsafeCell","","The core primitive for interior mutability in Rust."],[11,"value","","Wrapped value",87],[0,"clone","std","The `Clone` trait for types that cannot be 'implicitly copied'"],[6,"Clone","std::clone","A common trait for cloning an object."],[9,"clone","","Returns a copy of the value. The contents of owned pointers\nare copied to maintain uniqueness, while the contents of\nmanaged pointers are not copied.",447],[9,"clone_from","","Perform copy-assignment from `source`.",447],[0,"cmp","std","Defines the `PartialOrd` and `PartialEq` comparison traits."],[6,"PartialEq","std::cmp","Trait for values that can be compared for equality and inequality."],[9,"eq","","This method tests for `self` and `other` values to be equal, and is used by `==`.",448],[9,"ne","","This method tests for `!=`.",448],[6,"Eq","","Trait for equality comparisons which are [equivalence relations](\nhttps://en.wikipedia.org/wiki/Equivalence_relation)."],[2,"Ordering","","An ordering is, e.g, a result of a comparison between two values."],[12,"Less","","An ordering where a compared value is less [than another].",78],[12,"Equal","","An ordering where a compared value is equal [to another].",78],[12,"Greater","","An ordering where a compared value is greater [than another].",78],[6,"Ord","","Trait for types that form a [total order](\nhttps://en.wikipedia.org/wiki/Total_order)."],[9,"cmp","","This method returns an ordering between `self` and `other` values.",449],[3,"lexical_ordering","","Combine orderings, lexically."],[6,"PartialOrd","","Trait for values that can be compared for a sort-order."],[9,"partial_cmp","","This method returns an ordering between `self` and `other` values\nif one exists.",450],[9,"lt","","This method tests less than (for `self` and `other`) and is used by the `<` operator.",450],[9,"le","","This method tests less than or equal to (`<=`).",450],[9,"gt","","This method tests greater than (`>`).",450],[9,"ge","","This method tests greater than or equal to (`>=`).",450],[6,"Equiv","","The equivalence relation. Two values may be equivalent even if they are\nof different types. The most common use case for this relation is\ncontainer types; e.g. it is often desirable to be able to use `&str`\nvalues to look up entries in a container with `String` keys."],[9,"equiv","","Implement this function to decide equivalent values.",451],[3,"min","","Compare and return the minimum of two values."],[3,"max","","Compare and return the maximum of two values."],[0,"default","std","The `Default` trait for types which may have meaningful default values"],[6,"Default","std::default","A trait that types which have a useful default value should implement."],[9,"default","","Return the \"default value\" for a type.",452],[0,"finally","std","The Finally trait provides a method, `finally` on\nstack closures that emulates Java-style try/finally blocks."],[6,"Finally","std::finally","A trait for executing a destructor unconditionally after a block of code,\nregardless of whether the blocked fails."],[9,"finally","","Executes this object, unconditionally running `dtor` after this block of\ncode has run.",453],[3,"try_finally","","The most general form of the `finally` functions. The function\n`try_fn` will be invoked first; whether or not it fails, the\nfunction `finally_fn` will be invoked next. The two parameters\n`mutate` and `drop` are used to thread state through the two\nclosures. `mutate` is used for any shared, mutable state that both\nclosures require access to; `drop` is used for any state that the\n`try_fn` requires ownership of."],[0,"intrinsics","std","rustc compiler intrinsics."],[4,"GlueFn","std::intrinsics",""],[1,"TyDesc","",""],[11,"size","","",454],[11,"align","","",454],[11,"drop_glue","","",454],[11,"visit_glue","","",454],[11,"name","","",454],[2,"Opaque","",""],[4,"Disr","",""],[6,"TyVisitor","",""],[9,"visit_bot","","",455],[9,"visit_nil","","",455],[9,"visit_bool","","",455],[9,"visit_int","","",455],[9,"visit_i8","","",455],[9,"visit_i16","","",455],[9,"visit_i32","","",455],[9,"visit_i64","","",455],[9,"visit_uint","","",455],[9,"visit_u8","","",455],[9,"visit_u16","","",455],[9,"visit_u32","","",455],[9,"visit_u64","","",455],[9,"visit_f32","","",455],[9,"visit_f64","","",455],[9,"visit_char","","",455],[9,"visit_estr_slice","","",455],[9,"visit_estr_fixed","","",455],[9,"visit_box","","",455],[9,"visit_uniq","","",455],[9,"visit_ptr","","",455],[9,"visit_rptr","","",455],[9,"visit_evec_slice","","",455],[9,"visit_evec_fixed","","",455],[9,"visit_enter_rec","","",455],[9,"visit_rec_field","","",455],[9,"visit_leave_rec","","",455],[9,"visit_enter_class","","",455],[9,"visit_class_field","","",455],[9,"visit_leave_class","","",455],[9,"visit_enter_tup","","",455],[9,"visit_tup_field","","",455],[9,"visit_leave_tup","","",455],[9,"visit_enter_enum","","",455],[9,"visit_enter_enum_variant","","",455],[9,"visit_enum_variant_field","","",455],[9,"visit_leave_enum_variant","","",455],[9,"visit_leave_enum","","",455],[9,"visit_enter_fn","","",455],[9,"visit_fn_input","","",455],[9,"visit_fn_output","","",455],[9,"visit_leave_fn","","",455],[9,"visit_trait","","",455],[9,"visit_param","","",455],[9,"visit_self","","",455],[3,"atomic_cxchg","",""],[3,"atomic_cxchg_acq","",""],[3,"atomic_cxchg_rel","",""],[3,"atomic_cxchg_acqrel","",""],[3,"atomic_cxchg_relaxed","",""],[3,"atomic_load","",""],[3,"atomic_load_acq","",""],[3,"atomic_load_relaxed","",""],[3,"atomic_store","",""],[3,"atomic_store_rel","",""],[3,"atomic_store_relaxed","",""],[3,"atomic_xchg","",""],[3,"atomic_xchg_acq","",""],[3,"atomic_xchg_rel","",""],[3,"atomic_xchg_acqrel","",""],[3,"atomic_xchg_relaxed","",""],[3,"atomic_xadd","",""],[3,"atomic_xadd_acq","",""],[3,"atomic_xadd_rel","",""],[3,"atomic_xadd_acqrel","",""],[3,"atomic_xadd_relaxed","",""],[3,"atomic_xsub","",""],[3,"atomic_xsub_acq","",""],[3,"atomic_xsub_rel","",""],[3,"atomic_xsub_acqrel","",""],[3,"atomic_xsub_relaxed","",""],[3,"atomic_and","",""],[3,"atomic_and_acq","",""],[3,"atomic_and_rel","",""],[3,"atomic_and_acqrel","",""],[3,"atomic_and_relaxed","",""],[3,"atomic_nand","",""],[3,"atomic_nand_acq","",""],[3,"atomic_nand_rel","",""],[3,"atomic_nand_acqrel","",""],[3,"atomic_nand_relaxed","",""],[3,"atomic_or","",""],[3,"atomic_or_acq","",""],[3,"atomic_or_rel","",""],[3,"atomic_or_acqrel","",""],[3,"atomic_or_relaxed","",""],[3,"atomic_xor","",""],[3,"atomic_xor_acq","",""],[3,"atomic_xor_rel","",""],[3,"atomic_xor_acqrel","",""],[3,"atomic_xor_relaxed","",""],[3,"atomic_max","",""],[3,"atomic_max_acq","",""],[3,"atomic_max_rel","",""],[3,"atomic_max_acqrel","",""],[3,"atomic_max_relaxed","",""],[3,"atomic_min","",""],[3,"atomic_min_acq","",""],[3,"atomic_min_rel","",""],[3,"atomic_min_acqrel","",""],[3,"atomic_min_relaxed","",""],[3,"atomic_umin","",""],[3,"atomic_umin_acq","",""],[3,"atomic_umin_rel","",""],[3,"atomic_umin_acqrel","",""],[3,"atomic_umin_relaxed","",""],[3,"atomic_umax","",""],[3,"atomic_umax_acq","",""],[3,"atomic_umax_rel","",""],[3,"atomic_umax_acqrel","",""],[3,"atomic_umax_relaxed","",""],[3,"atomic_fence","",""],[3,"atomic_fence_acq","",""],[3,"atomic_fence_rel","",""],[3,"atomic_fence_acqrel","",""],[3,"abort","",""],[3,"breakpoint","",""],[3,"size_of","",""],[3,"move_val_init","",""],[3,"min_align_of","",""],[3,"pref_align_of","",""],[3,"get_tydesc","",""],[3,"type_id","",""],[3,"init","",""],[3,"uninit","",""],[3,"forget","",""],[3,"transmute","",""],[3,"needs_drop","",""],[3,"owns_managed","",""],[3,"visit_tydesc","",""],[3,"offset","",""],[3,"copy_nonoverlapping_memory","",""],[3,"copy_memory","",""],[3,"set_memory","",""],[3,"volatile_copy_nonoverlapping_memory","",""],[3,"volatile_copy_memory","",""],[3,"volatile_set_memory","",""],[3,"volatile_load","",""],[3,"volatile_store","",""],[3,"sqrtf32","",""],[3,"sqrtf64","",""],[3,"powif32","",""],[3,"powif64","",""],[3,"sinf32","",""],[3,"sinf64","",""],[3,"cosf32","",""],[3,"cosf64","",""],[3,"powf32","",""],[3,"powf64","",""],[3,"expf32","",""],[3,"expf64","",""],[3,"exp2f32","",""],[3,"exp2f64","",""],[3,"logf32","",""],[3,"logf64","",""],[3,"log10f32","",""],[3,"log10f64","",""],[3,"log2f32","",""],[3,"log2f64","",""],[3,"fmaf32","",""],[3,"fmaf64","",""],[3,"fabsf32","",""],[3,"fabsf64","",""],[3,"copysignf32","",""],[3,"copysignf64","",""],[3,"floorf32","",""],[3,"floorf64","",""],[3,"ceilf32","",""],[3,"ceilf64","",""],[3,"truncf32","",""],[3,"truncf64","",""],[3,"rintf32","",""],[3,"rintf64","",""],[3,"nearbyintf32","",""],[3,"nearbyintf64","",""],[3,"roundf32","",""],[3,"roundf64","",""],[3,"ctpop8","",""],[3,"ctpop16","",""],[3,"ctpop32","",""],[3,"ctpop64","",""],[3,"ctlz8","",""],[3,"ctlz16","",""],[3,"ctlz32","",""],[3,"ctlz64","",""],[3,"cttz8","",""],[3,"cttz16","",""],[3,"cttz32","",""],[3,"cttz64","",""],[3,"bswap16","",""],[3,"bswap32","",""],[3,"bswap64","",""],[3,"i8_add_with_overflow","",""],[3,"i16_add_with_overflow","",""],[3,"i32_add_with_overflow","",""],[3,"i64_add_with_overflow","",""],[3,"u8_add_with_overflow","",""],[3,"u16_add_with_overflow","",""],[3,"u32_add_with_overflow","",""],[3,"u64_add_with_overflow","",""],[3,"i8_sub_with_overflow","",""],[3,"i16_sub_with_overflow","",""],[3,"i32_sub_with_overflow","",""],[3,"i64_sub_with_overflow","",""],[3,"u8_sub_with_overflow","",""],[3,"u16_sub_with_overflow","",""],[3,"u32_sub_with_overflow","",""],[3,"u64_sub_with_overflow","",""],[3,"i8_mul_with_overflow","",""],[3,"i16_mul_with_overflow","",""],[3,"i32_mul_with_overflow","",""],[3,"i64_mul_with_overflow","",""],[3,"u8_mul_with_overflow","",""],[3,"u16_mul_with_overflow","",""],[3,"u32_mul_with_overflow","",""],[3,"u64_mul_with_overflow","",""],[1,"TypeId","","`TypeId` represents a globally unique identifier for a type"],[0,"iter","std","Composable external iterators"],[6,"FromIterator","std::iter","Conversion from an `Iterator`"],[9,"from_iter","","Build a container with elements from an external iterator.",456],[6,"Extendable","","A type growable from an `Iterator` implementation"],[9,"extend","","Extend a container with the elements yielded by an iterator",457],[6,"Iterator","","An interface for dealing with \"external iterators\". These types of iterators\ncan be resumed at any time as all state is stored internally as opposed to\nbeing located on the call stack."],[9,"next","","Advance the iterator and return the next value. Return `None` when the end is reached.",458],[9,"size_hint","","Returns a lower and upper bound on the remaining length of the iterator.",458],[9,"chain","","Chain this iterator with another, returning a new iterator which will\nfinish iterating over the current iterator, and then it will iterate\nover the other specified iterator.",458],[9,"zip","","Creates an iterator which iterates over both this and the specified\niterators simultaneously, yielding the two elements as pairs. When\neither iterator returns None, all further invocations of next() will\nreturn None.",458],[9,"map","","Creates a new iterator which will apply the specified function to each\nelement returned by the first, yielding the mapped element instead.",458],[9,"filter","","Creates an iterator which applies the predicate to each element returned\nby this iterator. Only elements which have the predicate evaluate to\n`true` will be yielded.",458],[9,"filter_map","","Creates an iterator which both filters and maps elements.\nIf the specified function returns None, the element is skipped.\nOtherwise the option is unwrapped and the new value is yielded.",458],[9,"enumerate","","Creates an iterator which yields a pair of the value returned by this\niterator plus the current index of iteration.",458],[9,"peekable","","Creates an iterator that has a `.peek()` method\nthat returns an optional reference to the next element.",458],[9,"skip_while","","Creates an iterator which invokes the predicate on elements until it\nreturns false. Once the predicate returns false, all further elements are\nyielded.",458],[9,"take_while","","Creates an iterator which yields elements so long as the predicate\nreturns true. After the predicate returns false for the first time, no\nfurther elements will be yielded.",458],[9,"skip","","Creates an iterator which skips the first `n` elements of this iterator,\nand then it yields all further items.",458],[9,"take","","Creates an iterator which yields the first `n` elements of this\niterator, and then it will always return None.",458],[9,"scan","","Creates a new iterator which behaves in a similar fashion to fold.\nThere is a state which is passed between each iteration and can be\nmutated as necessary. The yielded values from the closure are yielded\nfrom the Scan instance when not None.",458],[9,"flat_map","","Creates an iterator that maps each element to an iterator,\nand yields the elements of the produced iterators",458],[9,"fuse","","Creates an iterator that yields `None` forever after the underlying\niterator yields `None`. Random-access iterator behavior is not\naffected, only single and double-ended iterator behavior.",458],[9,"inspect","","Creates an iterator that calls a function with a reference to each\nelement before yielding it. This is often useful for debugging an\niterator pipeline.",458],[9,"by_ref","","Creates a wrapper around a mutable reference to the iterator.",458],[9,"advance","","Apply a function to each element, or stop iterating if the\nfunction returns `false`.",458],[9,"collect","","Loops through the entire iterator, collecting all of the elements into\na container implementing `FromIterator`.",458],[9,"nth","","Loops through `n` iterations, returning the `n`th element of the\niterator.",458],[9,"last","","Loops through the entire iterator, returning the last element of the\niterator.",458],[9,"fold","","Performs a fold operation over the entire iterator, returning the\neventual state at the end of the iteration.",458],[9,"count","","Counts the number of elements in this iterator.",458],[9,"all","","Tests whether the predicate holds true for all elements in the iterator.",458],[9,"any","","Tests whether any element of an iterator satisfies the specified\npredicate.",458],[9,"find","","Return the first element satisfying the specified predicate",458],[9,"position","","Return the index of the first element satisfying the specified predicate",458],[9,"max_by","","Return the element that gives the maximum value from the\nspecified function.",458],[9,"min_by","","Return the element that gives the minimum value from the\nspecified function.",458],[6,"DoubleEndedIterator","","A range iterator able to yield elements from both ends"],[9,"next_back","","Yield an element from the end of the range, returning `None` if the range is empty.",459],[9,"rev","","Change the direction of the iterator",459],[6,"MutableDoubleEndedIterator","","A double-ended iterator yielding mutable references"],[9,"reverse_","","Use an iterator to reverse a container in-place",460],[6,"RandomAccessIterator","","An object implementing random access indexing by `uint`"],[9,"indexable","","Return the number of indexable elements. At most `std::uint::MAX`\nelements are indexable, even if the iterator represents a longer range.",461],[9,"idx","","Return an element at an index, or `None` if the index is out of bounds",461],[6,"ExactSize","","An iterator that knows its exact length"],[9,"rposition","","Return the index of the last element satisfying the specified predicate",462],[9,"len","","Return the exact length of the iterator.",462],[1,"Rev","","An double-ended iterator with the direction inverted"],[1,"ByRef","","A mutable reference to an iterator"],[6,"AdditiveIterator","","A trait for iterators over elements which can be added together"],[9,"sum","","Iterates over the entire iterator, summing up all the elements",463],[6,"MultiplicativeIterator","","A trait for iterators over elements whose elements can be multiplied\ntogether."],[9,"product","","Iterates over the entire iterator, multiplying all the elements",464],[6,"OrdIterator","","A trait for iterators over elements which can be compared to one another.\nThe type of each element must ascribe to the `PartialOrd` trait."],[9,"max","","Consumes the entire iterator to return the maximum element.",465],[9,"min","","Consumes the entire iterator to return the minimum element.",465],[9,"min_max","","`min_max` finds the minimum and maximum elements in the iterator.",465],[2,"MinMaxResult","","`MinMaxResult` is an enum returned by `min_max`. See `OrdIterator::min_max` for more detail."],[12,"NoElements","","Empty iterator",95],[12,"OneElement","","Iterator with one element, so the minimum and maximum are the same",95],[12,"MinMax","","More than one element in the iterator, the first element is not larger than the second",95],[6,"CloneableIterator","","A trait for iterators that are cloneable."],[9,"cycle","","Repeats an iterator endlessly",466],[1,"Cycle","","An iterator that repeats endlessly"],[1,"Chain","","An iterator which strings two iterators together"],[1,"Zip","","An iterator which iterates two other iterators simultaneously"],[1,"Map","","An iterator which maps the values of `iter` with `f`"],[1,"Filter","","An iterator which filters the elements of `iter` with `predicate`"],[1,"FilterMap","","An iterator which uses `f` to both filter and map elements from `iter`"],[1,"Enumerate","","An iterator which yields the current count and the element during iteration"],[1,"Peekable","","An iterator with a `peek()` that returns an optional reference to the next element."],[1,"SkipWhile","","An iterator which rejects elements while `predicate` is true"],[1,"TakeWhile","","An iterator which only accepts elements while `predicate` is true"],[1,"Skip","","An iterator which skips over `n` elements of `iter`."],[1,"Take","","An iterator which only iterates over the first `n` iterations of `iter`."],[1,"Scan","","An iterator to maintain state while iterating another iterator"],[11,"state","","The current internal state to be passed to the closure next.",105],[1,"FlatMap","","An iterator that maps each element to an iterator,\nand yields the elements of the produced iterators\n"],[1,"Fuse","","An iterator that yields `None` forever after the underlying iterator\nyields `None` once."],[1,"Inspect","","An iterator that calls a function with a reference to each\nelement before yielding it."],[1,"Unfold","","An iterator which just modifies the contained state throughout iteration."],[11,"state","","Internal state that will be yielded on the next iteration",108],[1,"Counter","","An infinite iterator starting at `start` and advancing by `step` with each\niteration"],[3,"count","","Creates a new counter with the specified start/step"],[1,"Range","","An iterator over the range [start, stop)"],[3,"range","","Returns an iterator over the given range [start, stop) (that is, starting\nat start (inclusive), and ending at stop (exclusive))."],[1,"RangeInclusive","","An iterator over the range [start, stop]"],[3,"range_inclusive","","Return an iterator over the range [start, stop]"],[1,"RangeStep","","An iterator over the range [start, stop) by `step`. It handles overflow by stopping."],[3,"range_step","","Return an iterator over the range [start, stop) by `step`. It handles overflow by stopping."],[1,"RangeStepInclusive","","An iterator over the range [start, stop] by `step`. It handles overflow by stopping."],[3,"range_step_inclusive","","Return an iterator over the range [start, stop] by `step`. It handles overflow by stopping."],[1,"Repeat","","An iterator that repeats an element endlessly"],[4,"Iterate","",""],[3,"iterate","","Creates a new iterator that produces an infinite sequence of\nrepeated applications of the given function `f`."],[0,"order","","Functions for lexicographical ordering of sequences."],[3,"equals","std::iter::order","Compare `a` and `b` for equality using `Eq`"],[3,"cmp","","Order `a` and `b` lexicographically using `Ord`"],[3,"partial_cmp","","Order `a` and `b` lexicographically using `PartialOrd`"],[3,"eq","","Compare `a` and `b` for equality (Using partial equality, `PartialEq`)"],[3,"ne","","Compare `a` and `b` for nonequality (Using partial equality, `PartialEq`)"],[3,"lt","","Return `a` < `b` lexicographically (Using partial order, `PartialOrd`)"],[3,"le","","Return `a` <= `b` lexicographically (Using partial order, `PartialOrd`)"],[3,"gt","","Return `a` > `b` lexicographically (Using partial order, `PartialOrd`)"],[3,"ge","","Return `a` >= `b` lexicographically (Using partial order, `PartialOrd`)"],[0,"kinds","std","Primitive traits representing basic 'kinds' of types"],[6,"Send","std::kinds","Types able to be transferred across task boundaries."],[6,"Sized","","Types with a constant size known at compile-time."],[6,"Copy","","Types that can be copied by simply copying bits (i.e. `memcpy`)."],[6,"Share","","Types that can be safely shared between tasks when aliased."],[0,"marker","","Marker types are special types that are used with unsafe code to\ninform the compiler of special constraints. Marker types should\nonly be needed when you are creating an abstraction that is\nimplemented using unsafe code. In that case, you may want to embed\nsome of the marker types below into your type."],[1,"CovariantType","std::kinds::marker","A marker type whose type parameter `T` is considered to be\ncovariant with respect to the type itself. This is (typically)\nused to indicate that an instance of the type `T` is being stored\ninto memory and read from, even though that may not be apparent."],[1,"ContravariantType","","A marker type whose type parameter `T` is considered to be\ncontravariant with respect to the type itself. This is (typically)\nused to indicate that an instance of the type `T` will be consumed\n(but not read from), even though that may not be apparent."],[1,"InvariantType","","A marker type whose type parameter `T` is considered to be\ninvariant with respect to the type itself. This is (typically)\nused to indicate that instances of the type `T` may be read or\nwritten, even though that may not be apparent."],[1,"CovariantLifetime","","As `CovariantType`, but for lifetime parameters. Using\n`CovariantLifetime<'a>` indicates that it is ok to substitute\na *longer* lifetime for `'a` than the one you originally\nstarted with (e.g., you could convert any lifetime `'foo` to\n`'static`). You almost certainly want `ContravariantLifetime`\ninstead, or possibly `InvariantLifetime`. The only case where\nit would be appropriate is that you have a (type-casted, and\nhence hidden from the type system) function pointer with a\nsignature like `fn(&'a T)` (and no other uses of `'a`). In\nthis case, it is ok to substitute a larger lifetime for `'a`\n(e.g., `fn(&'static T)`), because the function is only\nbecoming more selective in terms of what it accepts as\nargument."],[1,"ContravariantLifetime","","As `ContravariantType`, but for lifetime parameters. Using\n`ContravariantLifetime<'a>` indicates that it is ok to\nsubstitute a *shorter* lifetime for `'a` than the one you\noriginally started with (e.g., you could convert `'static` to\nany lifetime `'foo`). This is appropriate for cases where you\nhave an unsafe pointer that is actually a pointer into some\nmemory with lifetime `'a`, and thus you want to limit the\nlifetime of your data structure to `'a`. An example of where\nthis is used is the iterator for vectors."],[1,"InvariantLifetime","","As `InvariantType`, but for lifetime parameters. Using\n`InvariantLifetime<'a>` indicates that it is not ok to\nsubstitute any other lifetime for `'a` besides its original\nvalue. This is appropriate for cases where you have an unsafe\npointer that is actually a pointer into memory with lifetime `'a`,\nand this pointer is itself stored in an inherently mutable\nlocation (such as a `Cell`)."],[1,"NoSend","","A type which is considered \"not sendable\", meaning that it cannot\nbe safely sent between tasks, even if it is owned. This is\ntypically embedded in other types, such as `Gc`, to ensure that\ntheir instances remain thread-local."],[1,"NoCopy","","A type which is considered \"not POD\", meaning that it is not\nimplicitly copyable. This is typically embedded in other types to\nensure that they are never copied, even if they lack a destructor."],[1,"NoShare","","A type which is considered \"not shareable\", meaning that\nits contents are not threadsafe, hence they cannot be\nshared between tasks."],[1,"Managed","","A type which is considered managed by the GC. This is typically\nembedded in other types."],[0,"mem","std","Basic functions for dealing with memory"],[3,"size_of","std::mem","Returns the size of a type in bytes."],[3,"size_of_val","","Returns the size of the type that `_val` points to in bytes."],[3,"nonzero_size_of","","Deprecated, this function will be removed soon"],[3,"nonzero_size_of_val","","Deprecated, this function will be removed soon"],[3,"min_align_of","","Returns the ABI-required minimum alignment of a type"],[3,"min_align_of_val","","Returns the ABI-required minimum alignment of the type of the value that\n`_val` points to"],[3,"align_of","","Returns the alignment in memory for a type."],[3,"align_of_val","","Returns the alignment of the type of the value that `_val` points to."],[3,"pref_align_of","","Deprecated, this function has been renamed to align_of"],[3,"pref_align_of_val","","Deprecated, this function has been renamed to align_of_val"],[3,"zeroed","","Create a value initialized to zero."],[3,"init","","Deprecated, use zeroed() instead"],[3,"uninitialized","","Create an uninitialized value."],[3,"uninit","","Deprecated, use `uninitialized` instead."],[3,"overwrite","","Unsafely overwrite a memory location with the given value without destroying\nthe old value."],[3,"move_val_init","","Deprecated, use `overwrite` instead"],[3,"to_le16","","Convert an u16 to little endian from the target's endianness."],[3,"to_le32","","Convert an u32 to little endian from the target's endianness."],[3,"to_le64","","Convert an u64 to little endian from the target's endianness."],[3,"to_be16","","Convert an u16 to big endian from the target's endianness."],[3,"to_be32","","Convert an u32 to big endian from the target's endianness."],[3,"to_be64","","Convert an u64 to big endian from the target's endianness."],[3,"from_le16","","Convert an u16 from little endian to the target's endianness."],[3,"from_le32","","Convert an u32 from little endian to the target's endianness."],[3,"from_le64","","Convert an u64 from little endian to the target's endianness."],[3,"from_be16","","Convert an u16 from big endian to the target's endianness."],[3,"from_be32","","Convert an u32 from big endian to the target's endianness."],[3,"from_be64","","Convert an u64 from big endian to the target's endianness."],[3,"swap","","Swap the values at two mutable locations of the same type, without\ndeinitialising or copying either one."],[3,"replace","","Replace the value at a mutable location with a new one, returning the old\nvalue, without deinitialising or copying either one."],[3,"drop","","Disposes of a value."],[3,"forget","","Moves a thing into the void."],[3,"transmute_copy","","Interprets `src` as `&U`, and then reads `src` without moving the contained\nvalue."],[3,"copy_lifetime","","Transforms lifetime of the second pointer to match the first."],[3,"copy_mut_lifetime","","Transforms lifetime of the second mutable pointer to match the first."],[3,"transmute","",""],[0,"ops","std","\nOverloadable operators"],[6,"Drop","std::ops","\nThe `Drop` trait is used to run some code when a value goes out of scope. This\nis sometimes called a 'destructor'."],[9,"drop","","The `drop` method, called when the value goes out of scope.",467],[6,"Add","","\nThe `Add` trait is used to specify the functionality of `+`."],[9,"add","","The method for the `+` operator",468],[6,"Sub","","\nThe `Sub` trait is used to specify the functionality of `-`."],[9,"sub","","The method for the `-` operator",469],[6,"Mul","","\nThe `Mul` trait is used to specify the functionality of `*`."],[9,"mul","","The method for the `*` operator",470],[6,"Div","","\nThe `Div` trait is used to specify the functionality of `/`."],[9,"div","","The method for the `/` operator",471],[6,"Rem","","\nThe `Rem` trait is used to specify the functionality of `%`."],[9,"rem","","The method for the `%` operator",472],[6,"Neg","","\nThe `Neg` trait is used to specify the functionality of unary `-`."],[9,"neg","","The method for the unary `-` operator",473],[6,"Not","","\nThe `Not` trait is used to specify the functionality of unary `!`."],[9,"not","","The method for the unary `!` operator",474],[6,"BitAnd","","\nThe `BitAnd` trait is used to specify the functionality of `&`."],[9,"bitand","","The method for the `&` operator",475],[6,"BitOr","","\nThe `BitOr` trait is used to specify the functionality of `|`."],[9,"bitor","","The method for the `|` operator",476],[6,"BitXor","","\nThe `BitXor` trait is used to specify the functionality of `^`."],[9,"bitxor","","The method for the `^` operator",477],[6,"Shl","","\nThe `Shl` trait is used to specify the functionality of `<<`."],[9,"shl","","The method for the `<<` operator",478],[6,"Shr","","\nThe `Shr` trait is used to specify the functionality of `>>`."],[9,"shr","","The method for the `>>` operator",479],[6,"Index","","\nThe `Index` trait is used to specify the functionality of indexing operations\nlike `arr[idx]` when used in an immutable context."],[9,"index","","The method for the indexing (`Foo[Bar]`) operation",480],[6,"IndexMut","","\nThe `IndexMut` trait is used to specify the functionality of indexing\noperations like `arr[idx]`, when used in a mutable context."],[9,"index_mut","","The method for the indexing (`Foo[Bar]`) operation",481],[6,"Deref","","\nThe `Deref` trait is used to specify the functionality of dereferencing\noperations like `*v`."],[9,"deref","","The method called to dereference a value",482],[6,"DerefMut","","\nThe `DerefMut` trait is used to specify the functionality of dereferencing\nmutably like `*v = 1;`"],[9,"deref_mut","","The method called to mutably dereference a value",483],[6,"Fn","","A version of the call operator that takes an immutable receiver."],[9,"call","","This is called when the call operator is used.",484],[6,"FnMut","","A version of the call operator that takes a mutable receiver."],[9,"call_mut","","This is called when the call operator is used.",485],[6,"FnOnce","","A version of the call operator that takes a by-value receiver."],[9,"call_once","","This is called when the call operator is used.",486],[0,"ptr","std","Operations on unsafe pointers, `*const T`, and `*mut T`."],[3,"null","std::ptr","Create a null pointer."],[3,"mut_null","","Create an unsafe mutable null pointer."],[3,"zero_memory","","Zeroes out `count * size_of::<T>` bytes of memory at `dst`"],[3,"swap","","Swap the values at two mutable locations of the same type, without\ndeinitialising either. They may overlap."],[3,"replace","","Replace the value at a mutable location with a new one, returning the old\nvalue, without deinitialising either."],[3,"read","","Reads the value from `*src` and returns it."],[3,"read_and_zero","","Reads the value from `*src` and nulls it out.\nThis currently prevents destructors from executing."],[3,"write","","Unsafely overwrite a memory location with the given value without destroying\nthe old value."],[3,"array_each_with_len","","Given a *const *const T (pointer to an array of pointers),\niterate through each *const T, up to the provided `len`,\npassing to the provided callback function"],[3,"array_each","","Given a null-pointer-terminated *const *const T (pointer to\nan array of pointers), iterate through each *const T,\npassing to the provided callback function"],[3,"buf_len","","Return the offset of the first null pointer in `buf`."],[3,"position","","Return the first offset `i` such that `f(buf[i]) == true`."],[6,"RawPtr","","Methods on raw pointers"],[9,"null","","Returns the null pointer.",487],[9,"is_null","","Returns true if the pointer is equal to the null pointer.",487],[9,"is_not_null","","Returns true if the pointer is not equal to the null pointer.",487],[9,"to_uint","","Returns the value of this pointer (ie, the address it points to)",487],[9,"to_option","","Returns `None` if the pointer is null, or else returns the value wrapped\nin `Some`.",487],[9,"offset","","Calculates the offset from a pointer. The offset *must* be in-bounds of\nthe object, or one-byte-past-the-end.  `count` is in units of T; e.g. a\n`count` of 3 represents a pointer offset of `3 * sizeof::<T>()` bytes.",487],[3,"set_memory","",""],[3,"copy_memory","",""],[3,"copy_nonoverlapping_memory","",""],[0,"raw","std","Contains struct definitions for the layout of compiler built-in types."],[1,"Box","std::raw","The representation of a Rust managed box"],[11,"ref_count","","",488],[11,"drop_glue","","",488],[11,"prev","","",488],[11,"next","","",488],[11,"data","","",488],[1,"Slice","","The representation of a Rust slice"],[11,"data","","",489],[11,"len","","",489],[1,"Closure","","The representation of a Rust closure"],[11,"code","","",490],[11,"env","","",490],[1,"Procedure","","The representation of a Rust procedure (`proc()`)"],[11,"code","","",491],[11,"env","","",491],[1,"TraitObject","","The representation of a Rust trait object."],[11,"vtable","","",492],[11,"data","","",492],[6,"Repr","","This trait is meant to map equivalences between raw structs and their\ncorresponding rust values."],[9,"repr","","This function \"unwraps\" a rust value (without consuming it) into its raw\nstruct representation. This can be used to read/write different values\nfor the struct. This is a safe method because by default it does not\nenable write-access to the fields of the return value in safe code.",493],[0,"simd","std","SIMD vectors."],[1,"i8x16","std::simd",""],[1,"i16x8","",""],[1,"i32x4","",""],[1,"i64x2","",""],[1,"u8x16","",""],[1,"u16x8","",""],[1,"u32x4","",""],[1,"u64x2","",""],[1,"f32x4","",""],[1,"f64x2","",""],[0,"tuple","std","Operations on tuples"],[6,"Tuple1","std::tuple",""],[9,"val0","","",494],[9,"ref0","","",494],[9,"mut0","","",494],[6,"Tuple2","",""],[9,"val0","","",495],[9,"ref0","","",495],[9,"mut0","","",495],[9,"val1","","",495],[9,"ref1","","",495],[9,"mut1","","",495],[6,"Tuple3","",""],[9,"val0","","",496],[9,"ref0","","",496],[9,"mut0","","",496],[9,"val1","","",496],[9,"ref1","","",496],[9,"mut1","","",496],[9,"val2","","",496],[9,"ref2","","",496],[9,"mut2","","",496],[6,"Tuple4","",""],[9,"val0","","",497],[9,"ref0","","",497],[9,"mut0","","",497],[9,"val1","","",497],[9,"ref1","","",497],[9,"mut1","","",497],[9,"val2","","",497],[9,"ref2","","",497],[9,"mut2","","",497],[9,"val3","","",497],[9,"ref3","","",497],[9,"mut3","","",497],[6,"Tuple5","",""],[9,"val0","","",498],[9,"ref0","","",498],[9,"mut0","","",498],[9,"val1","","",498],[9,"ref1","","",498],[9,"mut1","","",498],[9,"val2","","",498],[9,"ref2","","",498],[9,"mut2","","",498],[9,"val3","","",498],[9,"ref3","","",498],[9,"mut3","","",498],[9,"val4","","",498],[9,"ref4","","",498],[9,"mut4","","",498],[6,"Tuple6","",""],[9,"val0","","",499],[9,"ref0","","",499],[9,"mut0","","",499],[9,"val1","","",499],[9,"ref1","","",499],[9,"mut1","","",499],[9,"val2","","",499],[9,"ref2","","",499],[9,"mut2","","",499],[9,"val3","","",499],[9,"ref3","","",499],[9,"mut3","","",499],[9,"val4","","",499],[9,"ref4","","",499],[9,"mut4","","",499],[9,"val5","","",499],[9,"ref5","","",499],[9,"mut5","","",499],[6,"Tuple7","",""],[9,"val0","","",500],[9,"ref0","","",500],[9,"mut0","","",500],[9,"val1","","",500],[9,"ref1","","",500],[9,"mut1","","",500],[9,"val2","","",500],[9,"ref2","","",500],[9,"mut2","","",500],[9,"val3","","",500],[9,"ref3","","",500],[9,"mut3","","",500],[9,"val4","","",500],[9,"ref4","","",500],[9,"mut4","","",500],[9,"val5","","",500],[9,"ref5","","",500],[9,"mut5","","",500],[9,"val6","","",500],[9,"ref6","","",500],[9,"mut6","","",500],[6,"Tuple8","",""],[9,"val0","","",501],[9,"ref0","","",501],[9,"mut0","","",501],[9,"val1","","",501],[9,"ref1","","",501],[9,"mut1","","",501],[9,"val2","","",501],[9,"ref2","","",501],[9,"mut2","","",501],[9,"val3","","",501],[9,"ref3","","",501],[9,"mut3","","",501],[9,"val4","","",501],[9,"ref4","","",501],[9,"mut4","","",501],[9,"val5","","",501],[9,"ref5","","",501],[9,"mut5","","",501],[9,"val6","","",501],[9,"ref6","","",501],[9,"mut6","","",501],[9,"val7","","",501],[9,"ref7","","",501],[9,"mut7","","",501],[6,"Tuple9","",""],[9,"val0","","",502],[9,"ref0","","",502],[9,"mut0","","",502],[9,"val1","","",502],[9,"ref1","","",502],[9,"mut1","","",502],[9,"val2","","",502],[9,"ref2","","",502],[9,"mut2","","",502],[9,"val3","","",502],[9,"ref3","","",502],[9,"mut3","","",502],[9,"val4","","",502],[9,"ref4","","",502],[9,"mut4","","",502],[9,"val5","","",502],[9,"ref5","","",502],[9,"mut5","","",502],[9,"val6","","",502],[9,"ref6","","",502],[9,"mut6","","",502],[9,"val7","","",502],[9,"ref7","","",502],[9,"mut7","","",502],[9,"val8","","",502],[9,"ref8","","",502],[9,"mut8","","",502],[6,"Tuple10","",""],[9,"val0","","",503],[9,"ref0","","",503],[9,"mut0","","",503],[9,"val1","","",503],[9,"ref1","","",503],[9,"mut1","","",503],[9,"val2","","",503],[9,"ref2","","",503],[9,"mut2","","",503],[9,"val3","","",503],[9,"ref3","","",503],[9,"mut3","","",503],[9,"val4","","",503],[9,"ref4","","",503],[9,"mut4","","",503],[9,"val5","","",503],[9,"ref5","","",503],[9,"mut5","","",503],[9,"val6","","",503],[9,"ref6","","",503],[9,"mut6","","",503],[9,"val7","","",503],[9,"ref7","","",503],[9,"mut7","","",503],[9,"val8","","",503],[9,"ref8","","",503],[9,"mut8","","",503],[9,"val9","","",503],[9,"ref9","","",503],[9,"mut9","","",503],[6,"Tuple11","",""],[9,"val0","","",504],[9,"ref0","","",504],[9,"mut0","","",504],[9,"val1","","",504],[9,"ref1","","",504],[9,"mut1","","",504],[9,"val2","","",504],[9,"ref2","","",504],[9,"mut2","","",504],[9,"val3","","",504],[9,"ref3","","",504],[9,"mut3","","",504],[9,"val4","","",504],[9,"ref4","","",504],[9,"mut4","","",504],[9,"val5","","",504],[9,"ref5","","",504],[9,"mut5","","",504],[9,"val6","","",504],[9,"ref6","","",504],[9,"mut6","","",504],[9,"val7","","",504],[9,"ref7","","",504],[9,"mut7","","",504],[9,"val8","","",504],[9,"ref8","","",504],[9,"mut8","","",504],[9,"val9","","",504],[9,"ref9","","",504],[9,"mut9","","",504],[9,"val10","","",504],[9,"ref10","","",504],[9,"mut10","","",504],[6,"Tuple12","",""],[9,"val0","","",505],[9,"ref0","","",505],[9,"mut0","","",505],[9,"val1","","",505],[9,"ref1","","",505],[9,"mut1","","",505],[9,"val2","","",505],[9,"ref2","","",505],[9,"mut2","","",505],[9,"val3","","",505],[9,"ref3","","",505],[9,"mut3","","",505],[9,"val4","","",505],[9,"ref4","","",505],[9,"mut4","","",505],[9,"val5","","",505],[9,"ref5","","",505],[9,"mut5","","",505],[9,"val6","","",505],[9,"ref6","","",505],[9,"mut6","","",505],[9,"val7","","",505],[9,"ref7","","",505],[9,"mut7","","",505],[9,"val8","","",505],[9,"ref8","","",505],[9,"mut8","","",505],[9,"val9","","",505],[9,"ref9","","",505],[9,"mut9","","",505],[9,"val10","","",505],[9,"ref10","","",505],[9,"mut10","","",505],[9,"val11","","",505],[9,"ref11","","",505],[9,"mut11","","",505],[0,"unit","","The `()` type, sometimes called \"unit\" or \"nil\"."],[16,"tuple","","Operations on tuples"],[0,"unit","std","The `()` type, sometimes called \"unit\" or \"nil\"."],[16,"unit","std::unit","The `()` type, sometimes called \"unit\" or \"nil\"."],[0,"ty","std","Deprecated module in favor of `std::cell`"],[1,"UnsafeCell","std::ty","The core primitive for interior mutability in Rust."],[11,"value","","Wrapped value",87],[0,"result","std","Error handling with the `Result` type"],[2,"Result","std::result","`Result` is a type that represents either success (`Ok`) or failure (`Err`)."],[12,"Ok","","Contains the success value",116],[12,"Err","","Contains the error value",116],[3,"collect","","Takes each element in the `Iterator`: if it is an `Err`, no further\nelements are taken, and the `Err` is returned. Should no `Err` occur, a\nvector containing the values of each `Result` is returned."],[3,"fold","","Perform a fold operation over the result values from an iterator."],[3,"fold_","","Perform a trivial fold operation over the result values\nfrom an iterator."],[0,"option","std","Optional values"],[2,"Option","std::option","The `Option` type."],[12,"None","","No value",26],[12,"Some","","Some value `T`",26],[1,"Item","","An `Option` iterator that yields either one or zero elements"],[3,"collect","","Takes each element in the `Iterator`: if it is `None`, no further\nelements are taken, and the `None` is returned. Should no `None` occur, a\nvector containing the values of each `Option` is returned."],[0,"boxed","std","A unique pointer type"],[5,"HEAP","std::boxed",""],[1,"Box","","A type that represents a uniquely-owned value."],[6,"BoxAny","","Extension methods for an owning `Any` trait object"],[9,"downcast","","Returns the boxed value if it is of type `T`, or\n`Err(Self)` if it isn't.",506],[9,"move","","Deprecated; this method has been renamed to `downcast`.",506],[0,"owned","std","A unique pointer type"],[5,"HEAP","std::owned",""],[1,"Box","","A type that represents a uniquely-owned value."],[6,"BoxAny","","Extension methods for an owning `Any` trait object"],[9,"downcast","","Returns the boxed value if it is of type `T`, or\n`Err(Self)` if it isn't.",506],[9,"move","","Deprecated; this method has been renamed to `downcast`.",506],[0,"rc","std","Task-local reference-counted boxes (`Rc` type)"],[1,"Rc","std::rc","Immutable reference counted pointer type"],[3,"is_unique","","Returns true if the `Rc` currently has unique ownership."],[3,"try_unwrap","","Unwraps the contained value if the `Rc` has unique ownership."],[3,"get_mut","","Returns a mutable reference to the contained value if the `Rc` has\nunique ownership."],[1,"Weak","","Weak reference to a reference-counted box"],[0,"slice","std","Utilities for vector manipulation"],[6,"VectorVector","std::slice",""],[9,"concat_vec","","Flattens a vector of vectors of T into a single vector of T.",507],[9,"connect_vec","","Concatenate a vector of vectors, placing a given separator between each.",507],[1,"ElementSwaps","","An Iterator that yields the element swaps needed to produce\na sequence of all possible permutations for an indexed sequence of\nelements. Each permutation is only a single swap apart."],[1,"Permutations","","An Iterator that uses `ElementSwaps` to iterate through\nall possible permutations of a vector."],[6,"CloneableVector","","Extension methods for vector slices with cloneable elements"],[9,"to_vec","","Copy `self` into a new vector",508],[9,"to_owned","","Deprecated. Use `to_vec`",508],[9,"into_vec","","Convert `self` into an owned vector, not making a copy if possible.",508],[9,"into_owned","","Deprecated. Use `into_vec`",508],[6,"ImmutableCloneableVector","","Extension methods for vectors containing `Clone` elements."],[9,"partitioned","","Partitions the vector into two vectors `(A,B)`, where all\nelements of `A` satisfy `f` and all elements of `B` do not.",509],[9,"permutations","","Create an iterator that yields every possible permutation of the\nvector in succession.",509],[6,"MutableVectorAllocating","","Extension methods for vectors such that their elements are\nmutable."],[9,"sort_by","","Sort the vector, in place, using `compare` to compare\nelements.",510],[9,"move_from","","Consumes `src` and moves as many elements as it can into `self`\nfrom the range [start,end).",510],[6,"MutableOrdVector","","Methods for mutable vectors with orderable elements, such as\nin-place sorting."],[9,"sort","","Sort the vector, in place.",511],[9,"next_permutation","","Mutates the slice to the next lexicographic permutation.",511],[9,"prev_permutation","","Mutates the slice to the previous lexicographic permutation.",511],[0,"raw","","Unsafe operations"],[3,"shift_ptr","std::slice::raw","Returns a pointer to first element in slice and adjusts\nslice so it no longer contains that element. Returns None\nif the slice is empty. O(1)."],[3,"mut_buf_as_slice","","Form a slice from a pointer and length (as a number of units,\nnot bytes)."],[3,"pop_ptr","","Returns a pointer to last element in slice and adjusts\nslice so it no longer contains that element. Returns None\nif the slice is empty. O(1)."],[3,"buf_as_slice","","Form a slice from a pointer and length (as a number of units,\nnot bytes)."],[6,"ImmutableEqVector","std::slice","Extension methods for vectors contain `PartialEq` elements."],[9,"position_elem","","Find the first index containing a matching value",512],[9,"rposition_elem","","Find the last index containing a matching value",512],[9,"contains","","Return true if a vector contains an element with the given value",512],[9,"starts_with","","Returns true if `needle` is a prefix of the vector.",512],[9,"ends_with","","Returns true if `needle` is a suffix of the vector.",512],[1,"Items","","Immutable slice iterator"],[0,"bytes","","Operations on `[u8]`."],[6,"MutableByteVector","std::slice::bytes","A trait for operations on mutable `[u8]`s."],[9,"set_memory","","Sets all bytes of the receiver to the given value.",513],[3,"copy_memory","","Copies data from `src` to `dst`"],[1,"Windows","std::slice","An iterator over the (overlapping) slices of length `size` within\na vector."],[1,"MutSplits","","An iterator over the subslices of the vector which are separated\nby elements that match `pred`."],[6,"Vector","","Any vector that can be represented as a slice."],[9,"as_slice","","Work with `self` as a slice.",514],[1,"MutItems","","Mutable slice iterator"],[6,"ImmutableOrdVector","","Extension methods for vectors containing `Ord` elements."],[9,"bsearch_elem","","Binary search a sorted vector for a given element.",515],[1,"Splits","","An iterator over the slices of a vector separated by elements that\nmatch a predicate function."],[3,"ref_slice","","Converts a pointer to A into a slice of length 1 (without copying)."],[6,"MutableVector","","Extension methods for vectors such that their elements are\nmutable."],[9,"get_mut","","Returns a mutable reference to the element at the given index,\nor `None` if the index is out of bounds",516],[9,"as_mut_slice","","Work with `self` as a mut slice.\nPrimarily intended for getting a &mut [T] from a [T, ..N].",516],[9,"mut_slice","","Return a slice that points into another slice.",516],[9,"mut_slice_from","","Returns a slice of self from `start` to the end of the vec.",516],[9,"mut_slice_to","","Returns a slice of self from the start of the vec to `end`.",516],[9,"mut_iter","","Returns an iterator that allows modifying each value",516],[9,"mut_last","","Returns a mutable pointer to the last item in the vector.",516],[9,"mut_split","","Returns an iterator over the mutable subslices of the vector\nwhich are separated by elements that match `pred`.  The\nmatched element is not contained in the subslices.",516],[9,"mut_chunks","","Returns an iterator over `size` elements of the vector at a time.\nThe chunks are mutable and do not overlap. If `size` does not divide the\nlength of the vector, then the last chunk will not have length\n`size`.",516],[9,"mut_shift_ref","","Returns a mutable reference to the first element in this slice\nand adjusts the slice in place so that it no longer contains\nthat element. O(1).",516],[9,"mut_pop_ref","","Returns a mutable reference to the last element in this slice\nand adjusts the slice in place so that it no longer contains\nthat element. O(1).",516],[9,"swap","","Swaps two elements in a vector.",516],[9,"mut_split_at","","Divides one `&mut` into two at an index.",516],[9,"reverse","","Reverse the order of elements in a vector, in place.",516],[9,"unsafe_mut_ref","","Returns an unsafe mutable pointer to the element in index",516],[9,"as_mut_ptr","","Return an unsafe mutable pointer to the vector's buffer.",516],[9,"unsafe_set","","Unsafely sets the element in index to the value.",516],[9,"init_elem","","Unchecked vector index assignment.  Does not drop the\nold value and hence is only suitable when the vector\nis newly allocated.",516],[9,"copy_memory","","Copies raw bytes from `src` to `self`.",516],[3,"mut_ref_slice","","Converts a pointer to A into a slice of length 1 (without copying)."],[1,"Chunks","","An iterator over a vector in (non-overlapping) chunks (`size`\nelements at a time)."],[6,"MutableCloneableVector","","Trait for &[T] where T is Cloneable"],[9,"copy_from","","Copies as many elements from `src` as it can into `self` (the\nshorter of `self.len()` and `src.len()`). Returns the number\nof elements copied.",517],[6,"ImmutableVector","","Extension methods for vectors"],[9,"slice","","Returns a slice of self spanning the interval [`start`, `end`).",518],[9,"slice_from","","Returns a slice of self from `start` to the end of the vec.",518],[9,"slice_to","","Returns a slice of self from the start of the vec to `end`.",518],[9,"iter","","Returns an iterator over the vector",518],[9,"split","","Returns an iterator over the subslices of the vector which are\nseparated by elements that match `pred`.  The matched element\nis not contained in the subslices.",518],[9,"splitn","","Returns an iterator over the subslices of the vector which are\nseparated by elements that match `pred`, limited to splitting\nat most `n` times.  The matched element is not contained in\nthe subslices.",518],[9,"rsplitn","","Returns an iterator over the subslices of the vector which are\nseparated by elements that match `pred` limited to splitting\nat most `n` times. This starts at the end of the vector and\nworks backwards.  The matched element is not contained in the\nsubslices.",518],[9,"windows","","Returns an iterator over all contiguous windows of length\n`size`. The windows overlap. If the vector is shorter than\n`size`, the iterator returns no values.",518],[9,"chunks","","\nReturns an iterator over `size` elements of the vector at a\ntime. The chunks do not overlap. If `size` does not divide the\nlength of the vector, then the last chunk will not have length\n`size`.",518],[9,"get","","Returns the element of a vector at the given index, or `None` if the\nindex is out of bounds",518],[9,"head","","Returns the first element of a vector, or `None` if it is empty",518],[9,"tail","","Returns all but the first element of a vector",518],[9,"tailn","","Returns all but the first `n' elements of a vector",518],[9,"init","","Returns all but the last element of a vector",518],[9,"initn","","Returns all but the last `n' elements of a vector",518],[9,"last","","Returns the last element of a vector, or `None` if it is empty.",518],[9,"unsafe_ref","","Returns a pointer to the element at the given index, without doing\nbounds checking.",518],[9,"as_ptr","","Returns an unsafe pointer to the vector's buffer",518],[9,"bsearch","","Binary search a sorted vector with a comparator function.",518],[9,"shift_ref","","Returns an immutable reference to the first element in this slice\nand adjusts the slice in place so that it no longer contains\nthat element. O(1).",518],[9,"pop_ref","","Returns an immutable reference to the last element in this slice\nand adjusts the slice in place so that it no longer contains\nthat element. O(1).",518],[1,"MutChunks","","An iterator over a vector in (non-overlapping) mutable chunks (`size`  elements at a time). When\nthe vector len is not evenly divided by the chunk size, the last slice of the iteration will be\nthe remainder."],[16,"slice","","Utilities for vector manipulation"],[0,"str","std","Unicode string manipulation (`str` type)"],[3,"from_utf8_owned","std::str","Deprecated. Replaced by `String::from_utf8`"],[3,"from_byte","","Deprecated. Replaced by `String::from_byte`"],[3,"from_char","","Deprecated. Use `String::from_char` or `char::to_string()` instead"],[3,"from_chars","","Deprecated. Replaced by `String::from_chars`"],[6,"StrVector","","Methods for vectors of strings"],[9,"concat","","Concatenate a vector of strings.",519],[9,"connect","","Concatenate a vector of strings, placing a given separator between each.",519],[1,"Decompositions","","External iterator for a string's decomposition's characters.\nUse with the `std::iter` module."],[3,"replace","","Replace all occurrences of one string with another"],[3,"from_utf16","","Deprecated. Use `String::from_utf16`."],[3,"from_utf16_lossy","","Deprecated. Use `String::from_utf16_lossy`."],[3,"from_utf8_lossy","","Deprecated. Use `String::from_utf8_lossy`."],[2,"MaybeOwned","","A `MaybeOwned` is a string that can hold either a `String` or a `&str`.\nThis can be useful as an optimization when an allocation is sometimes\nneeded but not always."],[12,"Slice","","A borrowed string",226],[12,"Owned","","An owned string",226],[4,"SendStr","",""],[6,"IntoMaybeOwned","","Trait for moving into a `MaybeOwned`"],[9,"into_maybe_owned","","Moves self into a `MaybeOwned`",520],[0,"raw","","Unsafe operations"],[3,"from_buf_len","std::str::raw","Deprecated. Replaced by `string::raw::from_buf_len`"],[3,"from_c_str","","Deprecated. Use `string::raw::from_buf`"],[3,"from_utf8_owned","","Deprecated. Replaced by `string::raw::from_utf8`"],[3,"from_byte","","Deprecated. Use `string::raw::from_utf8`"],[3,"from_utf8","","Converts a slice of bytes to a string slice without checking\nthat the string contains valid UTF-8."],[3,"slice_bytes","","Takes a bytewise (not UTF-8) slice from a string."],[3,"slice_unchecked","","Takes a bytewise (not UTF-8) slice from a string."],[3,"c_str_to_static_slice","","Form a slice from a C string. Unsafe because the caller must ensure the\nC string has the static lifetime, or else the return value may be\ninvalidated later."],[6,"StrAllocating","std::str","Any string that can be represented as a slice"],[9,"into_string","","Convert `self` into a `String`, not making a copy if possible.",521],[9,"into_owned","","",521],[9,"escape_default","","Escape each char in `s` with `char::escape_default`.",521],[9,"escape_unicode","","Escape each char in `s` with `char::escape_unicode`.",521],[9,"replace","","Replace all occurrences of one string with another.",521],[9,"to_owned","","",521],[9,"to_utf16","","Converts to a vector of `u16` encoded as UTF-16.",521],[9,"repeat","","Given a string, make a new string with repeated copies of it.",521],[9,"lev_distance","","Levenshtein Distance between two strings.",521],[9,"nfd_chars","","An Iterator over the string in Unicode Normalization Form D\n(canonical decomposition).",521],[9,"nfkd_chars","","An Iterator over the string in Unicode Normalization Form KD\n(compatibility decomposition).",521],[2,"Utf16Item","","The possibilities for values decoded from a `u16` stream."],[12,"ScalarValue","","A valid codepoint.",146],[12,"LoneSurrogate","","An invalid surrogate without its pair.",146],[10,"clone","unicode::tables::grapheme","",522],[10,"clone_from","","",522],[10,"clone","unicode::u_str","",523],[10,"clone_from","","",523],[10,"next","","",523],[10,"size_hint","","",523],[10,"size_hint","","",523],[10,"chain","","",523],[10,"zip","","",523],[10,"map","","",523],[10,"filter","","",523],[10,"filter_map","","",523],[10,"enumerate","","",523],[10,"peekable","","",523],[10,"skip_while","","",523],[10,"take_while","","",523],[10,"skip","","",523],[10,"take","","",523],[10,"scan","","",523],[10,"flat_map","","",523],[10,"fuse","","",523],[10,"inspect","","",523],[10,"by_ref","","",523],[10,"advance","","",523],[10,"collect","","",523],[10,"nth","","",523],[10,"last","","",523],[10,"fold","","",523],[10,"count","","",523],[10,"all","","",523],[10,"any","","",523],[10,"find","","",523],[10,"position","","",523],[10,"max_by","","",523],[10,"min_by","","",523],[10,"next_back","","",523],[10,"rev","","",523],[10,"clone","","",524],[10,"clone_from","","",524],[10,"assert_receiver_is_total_eq","","",525],[10,"eq","","",525],[10,"ne","","",525],[10,"ne","","",525],[10,"size_hint","","",524],[10,"next","","",524],[10,"size_hint","","",524],[10,"chain","","",524],[10,"zip","","",524],[10,"map","","",524],[10,"filter","","",524],[10,"filter_map","","",524],[10,"enumerate","","",524],[10,"peekable","","",524],[10,"skip_while","","",524],[10,"take_while","","",524],[10,"skip","","",524],[10,"take","","",524],[10,"scan","","",524],[10,"flat_map","","",524],[10,"fuse","","",524],[10,"inspect","","",524],[10,"by_ref","","",524],[10,"advance","","",524],[10,"collect","","",524],[10,"nth","","",524],[10,"last","","",524],[10,"fold","","",524],[10,"count","","",524],[10,"all","","",524],[10,"any","","",524],[10,"find","","",524],[10,"position","","",524],[10,"max_by","","",524],[10,"min_by","","",524],[10,"next_back","","",524],[10,"rev","","",524],[4,"Words","std::str",""],[3,"is_utf16","","Determines if a vector of `u16` contains valid UTF-16"],[1,"GraphemeIndices","","External iterator for grapheme clusters and byte offsets."],[1,"MatchIndices","","An iterator over the start and end indices of the matches of a\nsubstring within a larger string"],[1,"CharSplitsN","","An iterator over the substrings of a string, separated by `sep`,\nsplitting at most `count` times."],[4,"Bytes","",""],[3,"from_utf8","","Converts a vector to a string slice without performing any allocations."],[3,"truncate_utf16_at_nul","","Return a slice of `v` ending at (and not including) the first NUL\n(0)."],[1,"CharSplits","","An iterator over the substrings of a string, separated by `sep`."],[6,"StrSlice","","Methods for string slices"],[9,"contains","","Returns true if one string contains another",526],[9,"contains_char","","Returns true if a string contains a char.",526],[9,"chars","","An iterator over the characters of `self`. Note, this iterates\nover unicode code-points, not unicode graphemes.",526],[9,"bytes","","An iterator over the bytes of `self`",526],[9,"char_indices","","An iterator over the characters of `self` and their byte offsets.",526],[9,"split","","An iterator over substrings of `self`, separated by characters\nmatched by `sep`.",526],[9,"splitn","","An iterator over substrings of `self`, separated by characters\nmatched by `sep`, restricted to splitting at most `count`\ntimes.",526],[9,"split_terminator","","An iterator over substrings of `self`, separated by characters\nmatched by `sep`.",526],[9,"rsplitn","","An iterator over substrings of `self`, separated by characters\nmatched by `sep`, starting from the end of the string.\nRestricted to splitting at most `count` times.",526],[9,"match_indices","","An iterator over the start and end indices of the disjoint\nmatches of `sep` within `self`.",526],[9,"split_str","","An iterator over the substrings of `self` separated by `sep`.",526],[9,"lines","","An iterator over the lines of a string (subsequences separated\nby `\\n`). This does not include the empty string after a\ntrailing `\\n`.",526],[9,"lines_any","","An iterator over the lines of a string, separated by either\n`\\n` or `\\r\\n`. As with `.lines()`, this does not include an\nempty trailing line.",526],[9,"char_len","","Returns the number of Unicode code points (`char`) that a\nstring holds.",526],[9,"slice","","Returns a slice of the given string from the byte range\n[`begin`..`end`).",526],[9,"slice_from","","Returns a slice of the string from `begin` to its end.",526],[9,"slice_to","","Returns a slice of the string from the beginning to byte\n`end`.",526],[9,"slice_chars","","Returns a slice of the string from the character range\n[`begin`..`end`).",526],[9,"starts_with","","Returns true if `needle` is a prefix of the string.",526],[9,"ends_with","","Returns true if `needle` is a suffix of the string.",526],[9,"trim_chars","","Returns a string with characters that match `to_trim` removed.",526],[9,"trim_left_chars","","Returns a string with leading `chars_to_trim` removed.",526],[9,"trim_right_chars","","Returns a string with trailing `chars_to_trim` removed.",526],[9,"is_char_boundary","","Check that `index`-th byte lies at the start and/or end of a\nUTF-8 code point sequence.",526],[9,"char_range_at","","Pluck a character out of a string and return the index of the next\ncharacter.",526],[9,"char_range_at_reverse","","Given a byte position and a str, return the previous char and its position.",526],[9,"char_at","","Plucks the character starting at the `i`th byte of a string.",526],[9,"char_at_reverse","","Plucks the character ending at the `i`th byte of a string.",526],[9,"as_bytes","","Work with the byte buffer of a string as a byte slice.",526],[9,"find","","Returns the byte index of the first character of `self` that\nmatches `search`.",526],[9,"rfind","","Returns the byte index of the last character of `self` that\nmatches `search`.",526],[9,"find_str","","Returns the byte index of the first matching substring",526],[9,"slice_shift_char","","Retrieves the first character from a string slice and returns\nit. This does not allocate a new string; instead, it returns a\nslice that point one character beyond the character that was\nshifted. If the string does not contain any characters,\na tuple of None and an empty string is returned instead.",526],[9,"subslice_offset","","Returns the byte offset of an inner slice relative to an enclosing outer slice.",526],[9,"as_ptr","","Return an unsafe pointer to the strings buffer.",526],[9,"utf16_units","","Return an iterator of `u16` over the string encoded as UTF-16.",526],[3,"eq_slice","","Bytewise slice equality\nNOTE: This function is (ab)used in rustc::middle::trans::_match\nto compare &[u8] byte slices that are not necessarily valid UTF-8."],[6,"CharEq","","Something that can be used to compare against a character"],[9,"matches","","Determine if the splitter should split at the given character",527],[9,"only_ascii","","Indicate if this is only concerned about ASCII characters,\nwhich can allow for a faster implementation.",527],[3,"is_utf8","","Determines if a vector of bytes contains valid UTF-8."],[1,"CharRange","","Struct that contains a `char` and the index of the first byte of\nthe next `char` in a string.  This can be used as a data structure\nfor iterating over the UTF-8 bytes of a string."],[11,"ch","","Current `char`",528],[11,"next","","Index of the first byte of the next `char`",528],[1,"StrSplits","","An iterator over the substrings of a string separated by a given\nsearch string"],[1,"Utf16Items","","An iterator that decodes UTF-16 encoded codepoints from a vector\nof `u16`s."],[3,"utf8_char_width","","Given a first byte, determine how many bytes are in this UTF-8 character"],[3,"utf16_items","","Create an iterator over the UTF-16 encoded codepoints in `v`,\nreturning invalid surrogates as `LoneSurrogate`s."],[1,"Graphemes","","External iterator for a string's\n[grapheme clusters](http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries)."],[6,"UnicodeStrSlice","","Methods for Unicode string slices"],[9,"graphemes","","Returns an iterator over the\n[grapheme clusters](http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries)\nof the string.",529],[9,"grapheme_indices","","Returns an iterator over the grapheme clusters of self and their byte offsets.\nSee `graphemes()` method for more information.",529],[9,"words","","An iterator over the words of a string (subsequences separated\nby any sequence of whitespace). Sequences of whitespace are\ncollapsed, so empty \"words\" are not included.",529],[9,"is_whitespace","","Returns true if the string contains only whitespace.",529],[9,"is_alphanumeric","","Returns true if the string contains only alphanumeric code\npoints.",529],[9,"width","","Returns a string's displayed width in columns, treating control\ncharacters as zero-width.",529],[9,"trim","","Returns a string with leading and trailing whitespace removed.",529],[9,"trim_left","","Returns a string with leading whitespace removed.",529],[9,"trim_right","","Returns a string with trailing whitespace removed.",529],[4,"AnyLines","",""],[6,"Str","","Any string that can be represented as a slice"],[9,"as_slice","","Work with `self` as a slice.",530],[1,"CharOffsets","","External iterator for a string's characters and their byte offsets.\nUse with the `std::iter` module."],[1,"Chars","","Iterator for the char (representing *Unicode Scalar Values*) of a string"],[16,"str","","Unicode string manipulation (`str` type)"],[0,"string","std","An owned, growable string that enforces that its contents are valid UTF-8."],[1,"String","std::string","A growable string stored as a UTF-8 encoded buffer."],[0,"raw","","Unsafe operations"],[3,"from_parts","std::string::raw","Creates a new `String` from length, capacity, and a pointer."],[3,"from_buf_len","","Create `String` from a *u8 buffer of the given length"],[3,"from_buf","","Create a `String` from a null-terminated *u8 buffer"],[3,"from_utf8","","Converts a vector of bytes to a new `String` without checking if\nit contains valid UTF-8. This is unsafe because it assumes that\nthe utf-8-ness of the vector has already been validated."],[0,"vec","std","An owned, growable vector."],[5,"PTR_MARKER","std::vec",""],[1,"Vec","","An owned, growable vector."],[1,"MoveItems","","An iterator that moves out of a vector."],[3,"unzip","","Convert an iterator of pairs into a pair of vectors."],[0,"raw","","Unsafe operations"],[3,"from_buf","std::vec::raw","Constructs a vector from an unsafe pointer to a buffer."],[0,"c_str","std","C-string manipulation and management"],[1,"CString","std::c_str","The representation of a C String."],[6,"ToCStr","","A generic trait for converting a value to a CString."],[9,"to_c_str","","Copy the receiver into a CString.",531],[9,"to_c_str_unchecked","","Unsafe variant of `to_c_str()` that doesn't check for nulls.",531],[9,"with_c_str","","Work with a temporary CString constructed from the receiver.\nThe provided `*libc::c_char` will be freed immediately upon return.",531],[9,"with_c_str_unchecked","","Unsafe variant of `with_c_str()` that doesn't check for nulls.",531],[1,"CChars","","External iterator for a CString's bytes."],[3,"from_c_multistring","","Parses a C \"multistring\", eg windows env values or\nthe req->ptr result in a uv_fs_readdir() call."],[0,"local_data","std","Task local data management"],[4,"Key","std::local_data",""],[2,"KeyValue","",""],[12,"Key","","",396],[4,"Map","",""],[1,"Ref","","A RAII immutable reference to a task-local value."],[0,"char","std","Character manipulation (`char` type, Unicode Scalar Value)"],[3,"is_alphabetic","std::char","Returns whether the specified `char` is considered a Unicode alphabetic\ncode point"],[3,"len_utf8_bytes","","Returns the amount of bytes this `char` would need if encoded in UTF-8"],[3,"is_alphanumeric","","\nIndicates whether a `char` is alphanumeric"],[3,"is_uppercase","","\nIndicates whether a `char` is in upper case"],[3,"is_XID_continue","","Returns whether the specified `char` satisfies the 'XID_Continue' Unicode property"],[3,"from_digit","","\nConverts a number to the character representing it"],[3,"is_digit","","Indicates whether the `char` is numeric (Nd, Nl, or No)"],[3,"to_lowercase","","Convert a char to its lowercase equivalent"],[6,"Char","","Basic `char` manipulations."],[9,"is_digit_radix","","Checks if a `char` parses as a numeric digit in the given radix.",532],[9,"to_digit","","Converts a character to the corresponding digit.",532],[9,"from_digit","","Converts a number to the character representing it.",532],[9,"escape_unicode","","Returns the hexadecimal Unicode escape of a character.",532],[9,"escape_default","","Returns a 'default' ASCII and C++11-like literal escape of a\ncharacter.",532],[9,"len_utf8_bytes","","Returns the amount of bytes this character would need if encoded in\nUTF-8.",532],[9,"encode_utf8","","Encodes this character as UTF-8 into the provided byte buffer.",532],[9,"encode_utf16","","Encodes this character as UTF-16 into the provided `u16` buffer.",532],[3,"decompose_canonical","","Compute canonical Unicode decomposition for character"],[3,"is_XID_start","","Returns whether the specified `char` satisfies the 'XID_Start' Unicode property"],[3,"to_uppercase","","Convert a char to its uppercase equivalent"],[3,"canonical_combining_class","",""],[3,"decompose_compatible","","Compute canonical or compatible Unicode decomposition for character"],[3,"is_control","","\nIndicates whether a `char` is a control code point"],[3,"to_digit","","\nConverts a `char` to the corresponding digit"],[6,"UnicodeChar","","Useful functions for Unicode characters."],[9,"is_alphabetic","","Returns whether the specified character is considered a Unicode\nalphabetic code point.",533],[9,"is_XID_start","","Returns whether the specified character satisfies the 'XID_Start'\nUnicode property.",533],[9,"is_XID_continue","","Returns whether the specified `char` satisfies the 'XID_Continue'\nUnicode property.",533],[9,"is_lowercase","","Indicates whether a character is in lowercase.",533],[9,"is_uppercase","","Indicates whether a character is in uppercase.",533],[9,"is_whitespace","","Indicates whether a character is whitespace.",533],[9,"is_alphanumeric","","Indicates whether a character is alphanumeric.",533],[9,"is_control","","Indicates whether a character is a control code point.",533],[9,"is_digit","","Indicates whether the character is numeric (Nd, Nl, or No).",533],[9,"to_lowercase","","Converts a character to its lowercase equivalent.",533],[9,"to_uppercase","","Converts a character to its uppercase equivalent.",533],[9,"width","","Returns this character's displayed width in columns, or `None` if it is a\ncontrol character other than `'\\x00'`.",533],[5,"MAX","",""],[3,"from_u32","","Converts from `u32` to a `char`"],[3,"is_lowercase","","\nIndicates whether a `char` is in lower case"],[3,"width","","Returns this character's displayed width in columns, or `None` if it is a\ncontrol character other than `'\\x00'`."],[3,"escape_unicode","","\nReturns the hexadecimal Unicode escape of a `char`"],[3,"is_digit_radix","","\nChecks if a `char` parses as a numeric digit in the given radix"],[3,"escape_default","","\nReturns a 'default' ASCII and C++11-like literal escape of a `char`"],[3,"is_whitespace","","\nIndicates whether a `char` is whitespace"],[0,"comm","std","Communication primitives for concurrent tasks"],[1,"Receiver","std::comm","The receiving-half of Rust's channel type. This half can only be owned by\none task"],[1,"Messages","","An iterator over messages on a receiver, this iterator will block\nwhenever `next` is called, waiting for a new message, and `None` will be\nreturned when the corresponding channel has hung up."],[1,"Sender","","The sending-half of Rust's asynchronous channel type. This half can only be\nowned by one task, but it can be cloned to send to other tasks."],[1,"SyncSender","","The sending-half of Rust's synchronous channel type. This half can only be\nowned by one task, but it can be cloned to send to other tasks."],[2,"TryRecvError","","This enumeration is the list of the possible reasons that try_recv could not\nreturn data when called."],[12,"Empty","","This channel is currently empty, but the sender(s) have not yet\ndisconnected, so data may yet become available.",277],[12,"Disconnected","","This channel's sending half has become disconnected, and there will\nnever be any more data received on this channel",277],[2,"TrySendError","","This enumeration is the list of the possible error outcomes for the\n`SyncSender::try_send` method."],[12,"Full","","The data could not be sent on the channel because it would require that\nthe callee block to send the data.",278],[12,"RecvDisconnected","","This channel's receiving half has disconnected, so the data could not be\nsent. The data is returned back to the callee in this case.",278],[3,"channel","","Creates a new asynchronous channel, returning the sender/receiver halves."],[3,"sync_channel","","Creates a new synchronous, bounded channel."],[1,"DuplexStream","","An extension of `pipes::stream` that allows both sending and receiving."],[1,"Select","","The \"receiver set\" of the select interface. This structure is used to manage\na set of receivers which are being selected over."],[3,"duplex","","Creates a bidirectional stream."],[1,"Handle","","A handle to a receiver which is currently a member of a `Select` set of\nreceivers.  This handle is used to keep the receiver in the set as well as\ninteract with the underlying receiver."],[15,"fail!","std","The entry point for failure of rust tasks."],[15,"assert!","","Ensure that a boolean expression is `true` at runtime."],[15,"assert_eq!","","Asserts that two expressions are equal to each other, testing equality in\nboth directions."],[15,"debug_assert!","","Ensure that a boolean expression is `true` at runtime."],[15,"debug_assert_eq!","","Asserts that two expressions are equal to each other, testing equality in\nboth directions."],[15,"unreachable!","","A utility macro for indicating unreachable code. It will fail if\nexecuted. This is occasionally useful to put after loops that never\nterminate normally, but instead directly return from a function."],[15,"unimplemented!","","A standardised placeholder for marking unfinished code. It fails with the\nmessage `\"not yet implemented\"` when executed."],[15,"format!","","Use the syntax described in `std::fmt` to create a value of type `String`.\nSee `std::fmt` for more information."],[15,"write!","","Use the `format!` syntax to write data into a buffer of type `&mut Writer`.\nSee `std::fmt` for more information."],[15,"writeln!","","Equivalent to the `write!` macro, except that a newline is appended after\nthe message is written."],[15,"print!","","Equivalent to the `println!` macro except that a newline is not printed at\nthe end of the message."],[15,"println!","","Macro for printing to a task's stdout handle."],[15,"local_data_key!","","Declare a task-local key with a specific type."],[15,"try!","","Helper macro for unwrapping `Result` values while returning early with an\nerror if the value of the expression is `Err`. For more information, see\n`std::io`."],[15,"vec!","","Create a `std::vec::Vec` containing the arguments."],[15,"select!","","A macro to select an event from a number of receivers."],[15,"format_args!","","The core macro for formatted string creation & output."],[15,"env!","","Inspect an environment variable at compile time."],[15,"option_env!","","Optionally inspect an environment variable at compile time."],[15,"bytes!","","Concatenate literals into a static byte slice."],[15,"concat_idents!","","Concatenate identifiers into one identifier."],[15,"concat!","","Concatenates literals into a static string slice."],[15,"line!","","A macro which expands to the line number on which it was invoked."],[15,"col!","","A macro which expands to the column number on which it was invoked."],[15,"file!","","A macro which expands to the file name from which it was invoked."],[15,"stringify!","","A macro which stringifies its argument."],[15,"include_str!","","Includes a utf8-encoded file as a string."],[15,"include_bin!","","Includes a file as a byte slice."],[15,"module_path!","","Expands to a string that represents the current module path."],[15,"cfg!","","Boolean evaluation of configuration flags."],[15,"bitflags!","",""],[16,"int","",""],[16,"i8","",""],[16,"i16","",""],[16,"i32","",""],[16,"i64","",""],[16,"uint","",""],[16,"u8","",""],[16,"u16","",""],[16,"u32","",""],[16,"u64","",""],[16,"f32","",""],[16,"f64","",""],[16,"bool","",""],[16,"tuple","",""],[16,"unit","",""],[16,"slice","",""],[16,"str","",""],[10,"stat","std::path::posix","Get information on the file, directory, etc at this path.",364],[10,"lstat","","Get information on the file, directory, etc at this path, not following\nsymlinks.",364],[10,"exists","","Boolean value indicator whether the underlying file exists on the local\nfilesystem. Returns false in exactly the cases where `fs::stat` fails.",364],[10,"is_file","","Whether the underlying implementation (be it a file path, or something\nelse) points at a \"regular file\" on the FS. Will return false for paths\nto non-existent locations or directories or other non-regular files\n(named pipes, etc). Follows links when making this determination.",364],[10,"is_dir","","Whether the underlying implementation (be it a file path, or something\nelse) is pointing at a directory in the underlying FS. Will return\nfalse for paths to non-existent locations or if the item is not a\ndirectory (eg files, named pipes, etc). Follows links when making this\ndetermination.",364]],"paths":[[1,"ReaderRng"],[1,"StdRng"],[1,"TaskRng"],[6,"Rand"],[6,"Rng"],[6,"SeedableRng"],[1,"Range"],[1,"Gamma"],[1,"GammaSmallShape"],[1,"GammaLargeShape"],[1,"ChiSquared"],[1,"FisherF"],[1,"StudentT"],[1,"StandardNormal"],[1,"Normal"],[1,"LogNormal"],[1,"Exp1"],[1,"Exp"],[1,"RandSample"],[1,"WeightedChoice"],[1,"IsaacRng"],[1,"Isaac64Rng"],[1,"ReseedingRng"],[1,"ReseedWithDefault"],[1,"Open01"],[1,"Closed01"],[2,"Option"],[1,"Generator"],[1,"AsciiGenerator"],[1,"XorShiftRng"],[6,"SampleRange"],[6,"Sample"],[6,"IndependentSample"],[1,"Weighted"],[6,"Reseeder"],[6,"AsciiCast"],[6,"OwnedAsciiCast"],[6,"AsciiStr"],[6,"IntoBytes"],[6,"OwnedAsciiExt"],[6,"AsciiExt"],[1,"Ascii"],[1,"String"],[1,"Vec"],[1,"Gc"],[6,"FromStr"],[2,"ExponentFormat"],[2,"SignificantDigits"],[2,"SignFormat"],[6,"NumStrConv"],[6,"FloatMath"],[6,"ToStrRadix"],[6,"FromStrRadix"],[6,"Zero"],[6,"One"],[6,"Signed"],[6,"Bounded"],[6,"Int"],[6,"Saturating"],[6,"CheckedAdd"],[6,"CheckedSub"],[6,"CheckedMul"],[6,"CheckedDiv"],[6,"FromPrimitive"],[6,"NumCast"],[6,"ToPrimitive"],[2,"FPCategory"],[1,"TypeId"],[1,"CovariantType"],[1,"ContravariantType"],[1,"InvariantType"],[1,"CovariantLifetime"],[1,"ContravariantLifetime"],[1,"InvariantLifetime"],[1,"NoSend"],[1,"NoCopy"],[1,"NoShare"],[1,"Managed"],[2,"Ordering"],[1,"AtomicBool"],[1,"AtomicInt"],[1,"AtomicUint"],[1,"AtomicPtr"],[1,"Cell"],[1,"RefCell"],[1,"Ref"],[1,"RefMut"],[1,"UnsafeCell"],[1,"Finallyalizer"],[1,"Enumerate"],[1,"Inspect"],[1,"Rev"],[1,"Map"],[1,"Zip"],[1,"ByRef"],[2,"MinMaxResult"],[1,"Cycle"],[1,"Chain"],[1,"Filter"],[1,"FilterMap"],[1,"Peekable"],[1,"SkipWhile"],[1,"TakeWhile"],[1,"Skip"],[1,"Take"],[1,"Scan"],[1,"FlatMap"],[1,"Fuse"],[1,"Unfold"],[1,"Counter"],[1,"Range"],[1,"RangeInclusive"],[1,"RangeStep"],[1,"RangeStepInclusive"],[1,"Repeat"],[1,"Item"],[2,"Result"],[1,"i8x16"],[1,"i16x8"],[1,"i32x4"],[1,"i64x2"],[1,"u8x16"],[1,"u16x8"],[1,"u32x4"],[1,"u64x2"],[1,"f32x4"],[1,"f64x2"],[1,"Items"],[1,"MutItems"],[1,"Splits"],[1,"MutSplits"],[1,"SplitsN"],[1,"Windows"],[1,"Chunks"],[1,"MutChunks"],[1,"Chars"],[1,"CharOffsets"],[1,"CharSplits"],[1,"CharSplitsN"],[1,"NaiveSearcher"],[1,"TwoWaySearcher"],[2,"Searcher"],[1,"MatchIndices"],[1,"StrSplits"],[1,"Utf16CodeUnits"],[1,"Utf16Items"],[2,"Utf16Item"],[1,"Binary"],[1,"Octal"],[1,"Decimal"],[1,"LowerHex"],[1,"UpperHex"],[1,"Radix"],[1,"RadixFmt"],[2,"Alignment"],[1,"Arguments"],[1,"Formatter"],[6,"Float"],[6,"ToString"],[6,"IntoStr"],[1,"HashMap"],[1,"HashSet"],[1,"LruCache"],[6,"Collection"],[6,"Mutable"],[6,"Map"],[6,"MutableMap"],[6,"Set"],[6,"MutableSet"],[6,"Deque"],[6,"MutableSeq"],[1,"Bitv"],[1,"SmallBitv"],[1,"BigBitv"],[2,"BitvVariant"],[1,"MaskWords"],[1,"Bits"],[1,"BitvSet"],[1,"BitPositions"],[1,"TwoBitPositions"],[1,"BTree"],[2,"Node"],[1,"Leaf"],[1,"Branch"],[1,"LeafElt"],[1,"BranchElt"],[1,"Items"],[1,"MoveItems"],[1,"Rawlink"],[1,"DList"],[1,"MutItems"],[1,"EnumSet"],[1,"Items"],[1,"PriorityQueue"],[1,"Items"],[1,"RingBuf"],[1,"Items"],[1,"MutItems"],[1,"SmallIntMap"],[1,"Entries"],[1,"MutEntries"],[1,"TreeMap"],[1,"Entries"],[1,"RevEntries"],[1,"MutEntries"],[1,"RevMutEntries"],[1,"MoveEntries"],[1,"SetItems"],[1,"RevSetItems"],[1,"TreeSet"],[1,"DifferenceItems"],[1,"SymDifferenceItems"],[1,"IntersectionItems"],[1,"UnionItems"],[1,"TreeNode"],[2,"Child"],[1,"TrieMap"],[1,"TrieSet"],[1,"TrieNode"],[1,"Entries"],[1,"MutEntries"],[1,"SetItems"],[1,"ElementSwaps"],[1,"Permutations"],[2,"DecompositionType"],[1,"Decompositions"],[2,"MaybeOwned"],[1,"MoveItems"],[1,"SipState"],[1,"SipHasher"],[1,"Box"],[1,"Rc"],[6,"ListInsertion"],[6,"CLike"],[1,"RandomSipHasher"],[6,"Hash"],[6,"Hasher"],[6,"Writer"],[6,"Spawner"],[1,"SiblingSpawner"],[1,"TaskBuilder"],[1,"AtomicOption"],[1,"Queue"],[1,"Node"],[1,"Consumer"],[1,"Producer"],[1,"Queue"],[1,"Queue"],[1,"Queue"],[2,"Stolen"],[1,"BufferPool"],[1,"Worker"],[1,"Stealer"],[1,"Deque"],[1,"Buffer"],[1,"Sem"],[1,"SemGuard"],[1,"Condvar"],[1,"Semaphore"],[1,"Mutex"],[1,"RWLock"],[1,"RWLockWriteGuard"],[1,"RWLockReadGuard"],[2,"Flavor"],[1,"StaticMutex"],[1,"Mutex"],[1,"Guard"],[1,"Once"],[1,"DuplexStream"],[1,"Packet"],[1,"Select"],[1,"Handle"],[1,"Packets"],[1,"Packet"],[1,"Packet"],[2,"Failure"],[1,"Packet"],[2,"TryRecvError"],[2,"TrySendError"],[1,"Sender"],[1,"SyncSender"],[1,"Receiver"],[1,"Messages"],[1,"PoisonOnFail"],[1,"Condvar"],[1,"Mutex"],[1,"MutexGuard"],[1,"RWLock"],[1,"RWLockWriteGuard"],[1,"RWLockReadGuard"],[1,"Barrier"],[2,"Ordering"],[2,"PopResult"],[1,"Arc"],[1,"Weak"],[1,"Weak"],[1,"CVec"],[2,"RTLD"],[1,"DynamicLibrary"],[1,"Pipe"],[2,"MemoryMapKind"],[2,"MapOption"],[2,"MapError"],[1,"MemoryMap"],[1,"IoError"],[1,"FileStat"],[1,"UnstableFileStat"],[2,"IoErrorKind"],[2,"SeekStyle"],[2,"FileMode"],[2,"FileAccess"],[2,"FileType"],[1,"Bytes"],[1,"File"],[1,"Directories"],[1,"Hint"],[1,"Info"],[2,"SocketType"],[2,"Flag"],[2,"Protocol"],[1,"TcpStream"],[1,"TcpListener"],[1,"TcpAcceptor"],[1,"UdpSocket"],[1,"UdpStream"],[1,"SocketAddr"],[2,"IpAddr"],[1,"UnixStream"],[1,"UnixListener"],[1,"UnixAcceptor"],[1,"PipePair"],[1,"PipeStream"],[1,"Process"],[1,"ProcessOutput"],[2,"StdioContainer"],[2,"ProcessExit"],[1,"Command"],[1,"Listener"],[2,"Signum"],[1,"StdReader"],[1,"StdWriter"],[1,"Timer"],[1,"LimitReader"],[1,"NullWriter"],[1,"ZeroReader"],[1,"NullReader"],[1,"MultiWriter"],[1,"ChainedReader"],[1,"TeeReader"],[1,"IterReader"],[6,"UpdateIoError"],[6,"Reader"],[6,"Writer"],[6,"Buffer"],[6,"Seek"],[6,"Listener"],[6,"Acceptor"],[4,"IoResult"],[1,"RefReader"],[1,"RefWriter"],[1,"Lines"],[1,"Chars"],[1,"IncomingConnections"],[1,"FilePermission"],[1,"Path"],[2,"PathPrefix"],[1,"Path"],[6,"GenericPath"],[6,"BytesContainer"],[6,"GenericPathUnsafe"],[1,"Display"],[1,"CString"],[6,"FormatWriter"],[2,"Flag"],[6,"Show"],[6,"Bool"],[6,"Char"],[6,"Signed"],[6,"Unsigned"],[6,"Octal"],[6,"Binary"],[6,"LowerHex"],[6,"UpperHex"],[6,"String"],[6,"Pointer"],[6,"Float"],[6,"LowerExp"],[6,"UpperExp"],[2,"FormatError"],[1,"Task"],[1,"Borrowed"],[1,"Stdio"],[1,"Token"],[1,"CChars"],[1,"Exclusive"],[1,"ExclusiveGuard"],[2,"KeyValue"],[1,"Ref"],[1,"TLDValue"],[1,"LocalHeap"],[1,"MemoryRegion"],[1,"StaticNativeMutex"],[1,"NativeMutex"],[1,"LockGuard"],[1,"Mutex"],[1,"LocalIo"],[2,"IpAddr"],[1,"SocketAddr"],[2,"TaskState"],[1,"TaskOpts"],[1,"BlockedTasks"],[2,"BlockedTask"],[1,"Death"],[1,"Thread"],[1,"Unwinder"],[6,"Local"],[6,"EventLoop"],[6,"Callback"],[6,"RemoteCallback"],[2,"CloseBehavior"],[1,"ProcessConfig"],[6,"IoFactory"],[6,"RtioTcpListener"],[6,"RtioTcpAcceptor"],[6,"RtioTcpStream"],[6,"RtioSocket"],[6,"RtioUdpSocket"],[6,"RtioTimer"],[6,"RtioFileStream"],[6,"RtioProcess"],[6,"RtioPipe"],[6,"RtioUnixListener"],[6,"RtioUnixAcceptor"],[6,"RtioTTY"],[6,"PausableIdleCallback"],[1,"IoError"],[2,"StdioContainer"],[2,"ProcessExit"],[2,"FileMode"],[2,"FileAccess"],[1,"FileStat"],[2,"SeekStyle"],[1,"AddrinfoHint"],[1,"AddrinfoInfo"],[6,"Runtime"],[6,"AnyRefExt"],[6,"AnyMutRefExt"],[6,"Clone"],[6,"PartialEq"],[6,"Ord"],[6,"PartialOrd"],[6,"Equiv"],[6,"Default"],[6,"Finally"],[1,"TyDesc"],[6,"TyVisitor"],[6,"FromIterator"],[6,"Extendable"],[6,"Iterator"],[6,"DoubleEndedIterator"],[6,"MutableDoubleEndedIterator"],[6,"RandomAccessIterator"],[6,"ExactSize"],[6,"AdditiveIterator"],[6,"MultiplicativeIterator"],[6,"OrdIterator"],[6,"CloneableIterator"],[6,"Drop"],[6,"Add"],[6,"Sub"],[6,"Mul"],[6,"Div"],[6,"Rem"],[6,"Neg"],[6,"Not"],[6,"BitAnd"],[6,"BitOr"],[6,"BitXor"],[6,"Shl"],[6,"Shr"],[6,"Index"],[6,"IndexMut"],[6,"Deref"],[6,"DerefMut"],[6,"Fn"],[6,"FnMut"],[6,"FnOnce"],[6,"RawPtr"],[1,"Box"],[1,"Slice"],[1,"Closure"],[1,"Procedure"],[1,"TraitObject"],[6,"Repr"],[6,"Tuple1"],[6,"Tuple2"],[6,"Tuple3"],[6,"Tuple4"],[6,"Tuple5"],[6,"Tuple6"],[6,"Tuple7"],[6,"Tuple8"],[6,"Tuple9"],[6,"Tuple10"],[6,"Tuple11"],[6,"Tuple12"],[6,"BoxAny"],[6,"VectorVector"],[6,"CloneableVector"],[6,"ImmutableCloneableVector"],[6,"MutableVectorAllocating"],[6,"MutableOrdVector"],[6,"ImmutableEqVector"],[6,"MutableByteVector"],[6,"Vector"],[6,"ImmutableOrdVector"],[6,"MutableVector"],[6,"MutableCloneableVector"],[6,"ImmutableVector"],[6,"StrVector"],[6,"IntoMaybeOwned"],[6,"StrAllocating"],[2,"GraphemeCat"],[1,"GraphemeIndices"],[1,"Graphemes"],[2,"GraphemeState"],[6,"StrSlice"],[6,"CharEq"],[1,"CharRange"],[6,"UnicodeStrSlice"],[6,"Str"],[6,"ToCStr"],[6,"Char"],[6,"UnicodeChar"]]};

searchIndex['libc'] = {"items":[[0,"","libc","Bindings for the C standard library and other platform libraries"],[2,"Nullable","","A wrapper for a nullable pointer. Don't use this except for interacting\nwith libc. Basically Option, but without the dependence on libstd."],[12,"Null","","",0],[12,"Some","","",0],[0,"types","",""],[0,"common","libc::types",""],[0,"c95","libc::types::common",""],[2,"c_void","libc::types::common::c95","Type used to construct void pointers for use with C."],[12,"__variant1","","",1],[12,"__variant2","","",1],[2,"FILE","",""],[2,"fpos_t","",""],[0,"c99","libc::types::common",""],[4,"int8_t","libc::types::common::c99",""],[4,"int16_t","",""],[4,"int32_t","",""],[4,"int64_t","",""],[4,"uint8_t","",""],[4,"uint16_t","",""],[4,"uint32_t","",""],[4,"uint64_t","",""],[0,"posix88","libc::types::common",""],[2,"DIR","libc::types::common::posix88",""],[2,"dirent_t","",""],[0,"os","libc::types",""],[0,"common","libc::types::os",""],[0,"posix01","libc::types::os::common",""],[1,"glob_t","libc::types::os::common::posix01",""],[11,"gl_pathc","","",2],[11,"gl_pathv","","",2],[11,"gl_offs","","",2],[11,"__unused1","","",2],[11,"__unused2","","",2],[11,"__unused3","","",2],[11,"__unused4","","",2],[11,"__unused5","","",2],[1,"timeval","",""],[11,"tv_sec","","",3],[11,"tv_usec","","",3],[1,"timespec","",""],[11,"tv_sec","","",4],[11,"tv_nsec","","",4],[2,"timezone","",""],[4,"pthread_t","",""],[4,"sighandler_t","",""],[0,"bsd44","libc::types::os::common",""],[1,"sockaddr","libc::types::os::common::bsd44",""],[11,"sa_family","","",5],[11,"sa_data","","",5],[1,"sockaddr_storage","",""],[11,"ss_family","","",6],[11,"__ss_align","","",6],[11,"__ss_pad2","","",6],[1,"sockaddr_in","",""],[11,"sin_family","","",7],[11,"sin_port","","",7],[11,"sin_addr","","",7],[11,"sin_zero","","",7],[1,"in_addr","",""],[11,"s_addr","","",8],[1,"sockaddr_in6","",""],[11,"sin6_family","","",9],[11,"sin6_port","","",9],[11,"sin6_flowinfo","","",9],[11,"sin6_addr","","",9],[11,"sin6_scope_id","","",9],[1,"in6_addr","",""],[11,"s6_addr","","",10],[1,"ip_mreq","",""],[11,"imr_multiaddr","","",11],[11,"imr_interface","","",11],[1,"ip6_mreq","",""],[11,"ipv6mr_multiaddr","","",12],[11,"ipv6mr_interface","","",12],[1,"addrinfo","",""],[11,"ai_flags","","",13],[11,"ai_family","","",13],[11,"ai_socktype","","",13],[11,"ai_protocol","","",13],[11,"ai_addrlen","","",13],[11,"ai_addr","","",13],[11,"ai_canonname","","",13],[11,"ai_next","","",13],[1,"sockaddr_un","",""],[11,"sun_family","","",14],[11,"sun_path","","",14],[4,"socklen_t","",""],[4,"sa_family_t","",""],[4,"in_port_t","",""],[4,"in_addr_t","",""],[0,"arch","libc::types::os",""],[0,"c95","libc::types::os::arch",""],[4,"c_char","libc::types::os::arch::c95",""],[4,"c_schar","",""],[4,"c_uchar","",""],[4,"c_short","",""],[4,"c_ushort","",""],[4,"c_int","",""],[4,"c_uint","",""],[4,"c_long","",""],[4,"c_ulong","",""],[4,"c_float","",""],[4,"c_double","",""],[4,"size_t","",""],[4,"ptrdiff_t","",""],[4,"clock_t","",""],[4,"time_t","",""],[4,"suseconds_t","",""],[4,"wchar_t","",""],[0,"c99","libc::types::os::arch",""],[4,"c_longlong","libc::types::os::arch::c99",""],[4,"c_ulonglong","",""],[4,"intptr_t","",""],[4,"uintptr_t","",""],[0,"posix88","libc::types::os::arch",""],[4,"off_t","libc::types::os::arch::posix88",""],[4,"dev_t","",""],[4,"ino_t","",""],[4,"pid_t","",""],[4,"uid_t","",""],[4,"gid_t","",""],[4,"useconds_t","",""],[4,"mode_t","",""],[4,"ssize_t","",""],[0,"posix01","libc::types::os::arch",""],[1,"stat","libc::types::os::arch::posix01",""],[11,"st_dev","","",15],[11,"st_ino","","",15],[11,"st_nlink","","",15],[11,"st_mode","","",15],[11,"st_uid","","",15],[11,"st_gid","","",15],[11,"__pad0","","",15],[11,"st_rdev","","",15],[11,"st_size","","",15],[11,"st_blksize","","",15],[11,"st_blocks","","",15],[11,"st_atime","","",15],[11,"st_atime_nsec","","",15],[11,"st_mtime","","",15],[11,"st_mtime_nsec","","",15],[11,"st_ctime","","",15],[11,"st_ctime_nsec","","",15],[11,"__unused","","",15],[1,"utimbuf","",""],[11,"actime","","",16],[11,"modtime","","",16],[1,"pthread_attr_t","",""],[11,"__size","","",17],[4,"nlink_t","",""],[4,"blksize_t","",""],[4,"blkcnt_t","",""],[0,"consts","libc",""],[0,"os","libc::consts",""],[0,"c95","libc::consts::os",""],[5,"EXIT_FAILURE","libc::consts::os::c95",""],[5,"EXIT_SUCCESS","",""],[5,"RAND_MAX","",""],[5,"EOF","",""],[5,"SEEK_SET","",""],[5,"SEEK_CUR","",""],[5,"SEEK_END","",""],[5,"_IOFBF","",""],[5,"_IONBF","",""],[5,"_IOLBF","",""],[5,"BUFSIZ","",""],[5,"FOPEN_MAX","",""],[5,"FILENAME_MAX","",""],[5,"L_tmpnam","",""],[5,"TMP_MAX","",""],[0,"posix88","libc::consts::os",""],[5,"O_RDONLY","libc::consts::os::posix88",""],[5,"O_WRONLY","",""],[5,"O_RDWR","",""],[5,"O_APPEND","",""],[5,"O_CREAT","",""],[5,"O_EXCL","",""],[5,"O_TRUNC","",""],[5,"S_IFIFO","",""],[5,"S_IFCHR","",""],[5,"S_IFBLK","",""],[5,"S_IFDIR","",""],[5,"S_IFREG","",""],[5,"S_IFLNK","",""],[5,"S_IFMT","",""],[5,"S_IEXEC","",""],[5,"S_IWRITE","",""],[5,"S_IREAD","",""],[5,"S_IRWXU","",""],[5,"S_IXUSR","",""],[5,"S_IWUSR","",""],[5,"S_IRUSR","",""],[5,"F_OK","",""],[5,"R_OK","",""],[5,"W_OK","",""],[5,"X_OK","",""],[5,"STDIN_FILENO","",""],[5,"STDOUT_FILENO","",""],[5,"STDERR_FILENO","",""],[5,"F_LOCK","",""],[5,"F_TEST","",""],[5,"F_TLOCK","",""],[5,"F_ULOCK","",""],[5,"SIGHUP","",""],[5,"SIGINT","",""],[5,"SIGQUIT","",""],[5,"SIGILL","",""],[5,"SIGABRT","",""],[5,"SIGFPE","",""],[5,"SIGKILL","",""],[5,"SIGSEGV","",""],[5,"SIGPIPE","",""],[5,"SIGALRM","",""],[5,"SIGTERM","",""],[5,"PROT_NONE","",""],[5,"PROT_READ","",""],[5,"PROT_WRITE","",""],[5,"PROT_EXEC","",""],[5,"MAP_FILE","",""],[5,"MAP_SHARED","",""],[5,"MAP_PRIVATE","",""],[5,"MAP_FIXED","",""],[5,"MAP_ANON","",""],[5,"MAP_FAILED","",""],[5,"MCL_CURRENT","",""],[5,"MCL_FUTURE","",""],[5,"MS_ASYNC","",""],[5,"MS_INVALIDATE","",""],[5,"MS_SYNC","",""],[5,"EPERM","",""],[5,"ENOENT","",""],[5,"ESRCH","",""],[5,"EINTR","",""],[5,"EIO","",""],[5,"ENXIO","",""],[5,"E2BIG","",""],[5,"ENOEXEC","",""],[5,"EBADF","",""],[5,"ECHILD","",""],[5,"EAGAIN","",""],[5,"ENOMEM","",""],[5,"EACCES","",""],[5,"EFAULT","",""],[5,"ENOTBLK","",""],[5,"EBUSY","",""],[5,"EEXIST","",""],[5,"EXDEV","",""],[5,"ENODEV","",""],[5,"ENOTDIR","",""],[5,"EISDIR","",""],[5,"EINVAL","",""],[5,"ENFILE","",""],[5,"EMFILE","",""],[5,"ENOTTY","",""],[5,"ETXTBSY","",""],[5,"EFBIG","",""],[5,"ENOSPC","",""],[5,"ESPIPE","",""],[5,"EROFS","",""],[5,"EMLINK","",""],[5,"EPIPE","",""],[5,"EDOM","",""],[5,"ERANGE","",""],[5,"EDEADLK","",""],[5,"ENAMETOOLONG","",""],[5,"ENOLCK","",""],[5,"ENOSYS","",""],[5,"ENOTEMPTY","",""],[5,"ELOOP","",""],[5,"EWOULDBLOCK","",""],[5,"ENOMSG","",""],[5,"EIDRM","",""],[5,"ECHRNG","",""],[5,"EL2NSYNC","",""],[5,"EL3HLT","",""],[5,"EL3RST","",""],[5,"ELNRNG","",""],[5,"EUNATCH","",""],[5,"ENOCSI","",""],[5,"EL2HLT","",""],[5,"EBADE","",""],[5,"EBADR","",""],[5,"EXFULL","",""],[5,"ENOANO","",""],[5,"EBADRQC","",""],[5,"EBADSLT","",""],[5,"EDEADLOCK","",""],[5,"EBFONT","",""],[5,"ENOSTR","",""],[5,"ENODATA","",""],[5,"ETIME","",""],[5,"ENOSR","",""],[5,"ENONET","",""],[5,"ENOPKG","",""],[5,"EREMOTE","",""],[5,"ENOLINK","",""],[5,"EADV","",""],[5,"ESRMNT","",""],[5,"ECOMM","",""],[5,"EPROTO","",""],[5,"EMULTIHOP","",""],[5,"EDOTDOT","",""],[5,"EBADMSG","",""],[5,"EOVERFLOW","",""],[5,"ENOTUNIQ","",""],[5,"EBADFD","",""],[5,"EREMCHG","",""],[5,"ELIBACC","",""],[5,"ELIBBAD","",""],[5,"ELIBSCN","",""],[5,"ELIBMAX","",""],[5,"ELIBEXEC","",""],[5,"EILSEQ","",""],[5,"ERESTART","",""],[5,"ESTRPIPE","",""],[5,"EUSERS","",""],[5,"ENOTSOCK","",""],[5,"EDESTADDRREQ","",""],[5,"EMSGSIZE","",""],[5,"EPROTOTYPE","",""],[5,"ENOPROTOOPT","",""],[5,"EPROTONOSUPPORT","",""],[5,"ESOCKTNOSUPPORT","",""],[5,"EOPNOTSUPP","",""],[5,"EPFNOSUPPORT","",""],[5,"EAFNOSUPPORT","",""],[5,"EADDRINUSE","",""],[5,"EADDRNOTAVAIL","",""],[5,"ENETDOWN","",""],[5,"ENETUNREACH","",""],[5,"ENETRESET","",""],[5,"ECONNABORTED","",""],[5,"ECONNRESET","",""],[5,"ENOBUFS","",""],[5,"EISCONN","",""],[5,"ENOTCONN","",""],[5,"ESHUTDOWN","",""],[5,"ETOOMANYREFS","",""],[5,"ETIMEDOUT","",""],[5,"ECONNREFUSED","",""],[5,"EHOSTDOWN","",""],[5,"EHOSTUNREACH","",""],[5,"EALREADY","",""],[5,"EINPROGRESS","",""],[5,"ESTALE","",""],[5,"EUCLEAN","",""],[5,"ENOTNAM","",""],[5,"ENAVAIL","",""],[5,"EISNAM","",""],[5,"EREMOTEIO","",""],[5,"EDQUOT","",""],[5,"ENOMEDIUM","",""],[5,"EMEDIUMTYPE","",""],[5,"ECANCELED","",""],[5,"ENOKEY","",""],[5,"EKEYEXPIRED","",""],[5,"EKEYREVOKED","",""],[5,"EKEYREJECTED","",""],[5,"EOWNERDEAD","",""],[5,"ENOTRECOVERABLE","",""],[5,"ERFKILL","",""],[5,"EHWPOISON","",""],[0,"posix01","libc::consts::os",""],[5,"SIGTRAP","libc::consts::os::posix01",""],[5,"SIGPIPE","",""],[5,"SIG_IGN","",""],[5,"GLOB_ERR","",""],[5,"GLOB_MARK","",""],[5,"GLOB_NOSORT","",""],[5,"GLOB_DOOFFS","",""],[5,"GLOB_NOCHECK","",""],[5,"GLOB_APPEND","",""],[5,"GLOB_NOESCAPE","",""],[5,"GLOB_NOSPACE","",""],[5,"GLOB_ABORTED","",""],[5,"GLOB_NOMATCH","",""],[5,"POSIX_MADV_NORMAL","",""],[5,"POSIX_MADV_RANDOM","",""],[5,"POSIX_MADV_SEQUENTIAL","",""],[5,"POSIX_MADV_WILLNEED","",""],[5,"POSIX_MADV_DONTNEED","",""],[5,"_SC_MQ_PRIO_MAX","",""],[5,"_SC_IOV_MAX","",""],[5,"_SC_GETGR_R_SIZE_MAX","",""],[5,"_SC_GETPW_R_SIZE_MAX","",""],[5,"_SC_LOGIN_NAME_MAX","",""],[5,"_SC_TTY_NAME_MAX","",""],[5,"_SC_THREADS","",""],[5,"_SC_THREAD_SAFE_FUNCTIONS","",""],[5,"_SC_THREAD_DESTRUCTOR_ITERATIONS","",""],[5,"_SC_THREAD_KEYS_MAX","",""],[5,"_SC_THREAD_STACK_MIN","",""],[5,"_SC_THREAD_THREADS_MAX","",""],[5,"_SC_THREAD_ATTR_STACKADDR","",""],[5,"_SC_THREAD_ATTR_STACKSIZE","",""],[5,"_SC_THREAD_PRIORITY_SCHEDULING","",""],[5,"_SC_THREAD_PRIO_INHERIT","",""],[5,"_SC_THREAD_PRIO_PROTECT","",""],[5,"_SC_THREAD_PROCESS_SHARED","",""],[5,"_SC_ATEXIT_MAX","",""],[5,"_SC_XOPEN_VERSION","",""],[5,"_SC_XOPEN_XCU_VERSION","",""],[5,"_SC_XOPEN_UNIX","",""],[5,"_SC_XOPEN_CRYPT","",""],[5,"_SC_XOPEN_ENH_I18N","",""],[5,"_SC_XOPEN_SHM","",""],[5,"_SC_XOPEN_LEGACY","",""],[5,"_SC_XOPEN_REALTIME","",""],[5,"_SC_XOPEN_REALTIME_THREADS","",""],[5,"PTHREAD_CREATE_JOINABLE","",""],[5,"PTHREAD_CREATE_DETACHED","",""],[5,"PTHREAD_STACK_MIN","",""],[5,"CLOCK_REALTIME","",""],[5,"CLOCK_MONOTONIC","",""],[0,"bsd44","libc::consts::os",""],[5,"MADV_NORMAL","libc::consts::os::bsd44",""],[5,"MADV_RANDOM","",""],[5,"MADV_SEQUENTIAL","",""],[5,"MADV_WILLNEED","",""],[5,"MADV_DONTNEED","",""],[5,"MADV_REMOVE","",""],[5,"MADV_DONTFORK","",""],[5,"MADV_DOFORK","",""],[5,"MADV_MERGEABLE","",""],[5,"MADV_UNMERGEABLE","",""],[5,"MADV_HWPOISON","",""],[5,"AF_UNIX","",""],[5,"AF_INET","",""],[5,"AF_INET6","",""],[5,"SOCK_STREAM","",""],[5,"SOCK_DGRAM","",""],[5,"IPPROTO_TCP","",""],[5,"IPPROTO_IP","",""],[5,"IPPROTO_IPV6","",""],[5,"IP_MULTICAST_TTL","",""],[5,"IP_MULTICAST_LOOP","",""],[5,"IP_TTL","",""],[5,"IP_ADD_MEMBERSHIP","",""],[5,"IP_DROP_MEMBERSHIP","",""],[5,"IPV6_ADD_MEMBERSHIP","",""],[5,"IPV6_DROP_MEMBERSHIP","",""],[5,"TCP_NODELAY","",""],[5,"SOL_SOCKET","",""],[5,"SO_KEEPALIVE","",""],[5,"SO_BROADCAST","",""],[5,"SO_REUSEADDR","",""],[5,"SO_ERROR","",""],[5,"SHUT_RD","",""],[5,"SHUT_WR","",""],[5,"SHUT_RDWR","",""],[0,"extra","libc::consts::os",""],[5,"O_RSYNC","libc::consts::os::extra",""],[5,"O_DSYNC","",""],[5,"O_SYNC","",""],[5,"PROT_GROWSDOWN","",""],[5,"PROT_GROWSUP","",""],[5,"MAP_TYPE","",""],[5,"MAP_ANONYMOUS","",""],[5,"MAP_32BIT","",""],[5,"MAP_GROWSDOWN","",""],[5,"MAP_DENYWRITE","",""],[5,"MAP_EXECUTABLE","",""],[5,"MAP_LOCKED","",""],[5,"MAP_NONRESERVE","",""],[5,"MAP_POPULATE","",""],[5,"MAP_NONBLOCK","",""],[5,"MAP_STACK","",""],[0,"sysconf","libc::consts::os",""],[5,"_SC_ARG_MAX","libc::consts::os::sysconf",""],[5,"_SC_CHILD_MAX","",""],[5,"_SC_CLK_TCK","",""],[5,"_SC_NGROUPS_MAX","",""],[5,"_SC_OPEN_MAX","",""],[5,"_SC_STREAM_MAX","",""],[5,"_SC_TZNAME_MAX","",""],[5,"_SC_JOB_CONTROL","",""],[5,"_SC_SAVED_IDS","",""],[5,"_SC_REALTIME_SIGNALS","",""],[5,"_SC_PRIORITY_SCHEDULING","",""],[5,"_SC_TIMERS","",""],[5,"_SC_ASYNCHRONOUS_IO","",""],[5,"_SC_PRIORITIZED_IO","",""],[5,"_SC_SYNCHRONIZED_IO","",""],[5,"_SC_FSYNC","",""],[5,"_SC_MAPPED_FILES","",""],[5,"_SC_MEMLOCK","",""],[5,"_SC_MEMLOCK_RANGE","",""],[5,"_SC_MEMORY_PROTECTION","",""],[5,"_SC_MESSAGE_PASSING","",""],[5,"_SC_SEMAPHORES","",""],[5,"_SC_SHARED_MEMORY_OBJECTS","",""],[5,"_SC_AIO_LISTIO_MAX","",""],[5,"_SC_AIO_MAX","",""],[5,"_SC_AIO_PRIO_DELTA_MAX","",""],[5,"_SC_DELAYTIMER_MAX","",""],[5,"_SC_MQ_OPEN_MAX","",""],[5,"_SC_VERSION","",""],[5,"_SC_PAGESIZE","",""],[5,"_SC_RTSIG_MAX","",""],[5,"_SC_SEM_NSEMS_MAX","",""],[5,"_SC_SEM_VALUE_MAX","",""],[5,"_SC_SIGQUEUE_MAX","",""],[5,"_SC_TIMER_MAX","",""],[5,"_SC_BC_BASE_MAX","",""],[5,"_SC_BC_DIM_MAX","",""],[5,"_SC_BC_SCALE_MAX","",""],[5,"_SC_BC_STRING_MAX","",""],[5,"_SC_COLL_WEIGHTS_MAX","",""],[5,"_SC_EXPR_NEST_MAX","",""],[5,"_SC_LINE_MAX","",""],[5,"_SC_RE_DUP_MAX","",""],[5,"_SC_2_VERSION","",""],[5,"_SC_2_C_BIND","",""],[5,"_SC_2_C_DEV","",""],[5,"_SC_2_FORT_DEV","",""],[5,"_SC_2_FORT_RUN","",""],[5,"_SC_2_SW_DEV","",""],[5,"_SC_2_LOCALEDEF","",""],[5,"_SC_2_CHAR_TERM","",""],[5,"_SC_2_C_VERSION","",""],[5,"_SC_2_UPE","",""],[5,"_SC_XBS5_ILP32_OFF32","",""],[5,"_SC_XBS5_ILP32_OFFBIG","",""],[5,"_SC_XBS5_LPBIG_OFFBIG","",""],[0,"funcs","libc",""],[0,"c95","libc::funcs",""],[0,"ctype","libc::funcs::c95",""],[13,"isalnum","libc::funcs::c95::ctype",""],[13,"isalpha","",""],[13,"iscntrl","",""],[13,"isdigit","",""],[13,"isgraph","",""],[13,"islower","",""],[13,"isprint","",""],[13,"ispunct","",""],[13,"isspace","",""],[13,"isupper","",""],[13,"isxdigit","",""],[13,"tolower","",""],[13,"toupper","",""],[0,"stdio","libc::funcs::c95",""],[13,"fopen","libc::funcs::c95::stdio",""],[13,"freopen","",""],[13,"fflush","",""],[13,"fclose","",""],[13,"remove","",""],[13,"rename","",""],[13,"tmpfile","",""],[13,"setvbuf","",""],[13,"setbuf","",""],[13,"fgetc","",""],[13,"fgets","",""],[13,"fputc","",""],[13,"fputs","",""],[13,"puts","",""],[13,"ungetc","",""],[13,"fread","",""],[13,"fwrite","",""],[13,"fseek","",""],[13,"ftell","",""],[13,"rewind","",""],[13,"fgetpos","",""],[13,"fsetpos","",""],[13,"feof","",""],[13,"ferror","",""],[13,"perror","",""],[0,"stdlib","libc::funcs::c95",""],[13,"abs","libc::funcs::c95::stdlib",""],[13,"labs","",""],[13,"atof","",""],[13,"atoi","",""],[13,"strtod","",""],[13,"strtol","",""],[13,"strtoul","",""],[13,"calloc","",""],[13,"malloc","",""],[13,"realloc","",""],[13,"free","",""],[13,"exit","",""],[13,"_exit","",""],[13,"system","",""],[13,"getenv","",""],[13,"rand","",""],[13,"srand","",""],[0,"string","libc::funcs::c95",""],[13,"strcpy","libc::funcs::c95::string",""],[13,"strncpy","",""],[13,"strcat","",""],[13,"strncat","",""],[13,"strcmp","",""],[13,"strncmp","",""],[13,"strcoll","",""],[13,"strchr","",""],[13,"strrchr","",""],[13,"strspn","",""],[13,"strcspn","",""],[13,"strpbrk","",""],[13,"strstr","",""],[13,"strlen","",""],[13,"strerror","",""],[13,"strtok","",""],[13,"strxfrm","",""],[13,"wcslen","",""],[13,"memcmp","",""],[13,"memchr","",""],[0,"posix88","libc::funcs",""],[0,"stat_","libc::funcs::posix88",""],[13,"chmod","libc::funcs::posix88::stat_",""],[13,"fchmod","",""],[13,"fstat","",""],[13,"mkdir","",""],[13,"mkfifo","",""],[13,"stat","",""],[0,"stdio","libc::funcs::posix88",""],[13,"popen","libc::funcs::posix88::stdio",""],[13,"pclose","",""],[13,"fdopen","",""],[13,"fileno","",""],[0,"fcntl","libc::funcs::posix88",""],[13,"open","libc::funcs::posix88::fcntl",""],[13,"creat","",""],[13,"fcntl","",""],[0,"dirent","libc::funcs::posix88",""],[13,"opendir","libc::funcs::posix88::dirent",""],[13,"readdir_r","",""],[13,"closedir","",""],[13,"rewinddir","",""],[13,"seekdir","",""],[13,"telldir","",""],[0,"unistd","libc::funcs::posix88",""],[13,"access","libc::funcs::posix88::unistd",""],[13,"alarm","",""],[13,"chdir","",""],[13,"chown","",""],[13,"close","",""],[13,"dup","",""],[13,"dup2","",""],[13,"execv","",""],[13,"execve","",""],[13,"execvp","",""],[13,"fork","",""],[13,"fpathconf","",""],[13,"getcwd","",""],[13,"getegid","",""],[13,"geteuid","",""],[13,"getgid","",""],[13,"getgroups","",""],[13,"getlogin","",""],[13,"getopt","",""],[13,"getpgrp","",""],[13,"getpid","",""],[13,"getppid","",""],[13,"getuid","",""],[13,"isatty","",""],[13,"link","",""],[13,"lseek","",""],[13,"pathconf","",""],[13,"pause","",""],[13,"pipe","",""],[13,"read","",""],[13,"rmdir","",""],[13,"setgid","",""],[13,"setpgid","",""],[13,"setsid","",""],[13,"setuid","",""],[13,"sleep","",""],[13,"usleep","",""],[13,"nanosleep","",""],[13,"sysconf","",""],[13,"tcgetpgrp","",""],[13,"ttyname","",""],[13,"unlink","",""],[13,"write","",""],[13,"pread","",""],[13,"pwrite","",""],[13,"utime","",""],[5,"_PC_NAME_MAX","",""],[0,"signal","libc::funcs::posix88",""],[13,"kill","libc::funcs::posix88::signal",""],[0,"mman","libc::funcs::posix88",""],[13,"mlock","libc::funcs::posix88::mman",""],[13,"munlock","",""],[13,"mlockall","",""],[13,"munlockall","",""],[13,"mmap","",""],[13,"munmap","",""],[13,"mprotect","",""],[13,"msync","",""],[13,"shm_open","",""],[13,"shm_unlink","",""],[0,"posix01","libc::funcs",""],[0,"stat_","libc::funcs::posix01",""],[13,"lstat","libc::funcs::posix01::stat_",""],[0,"unistd","libc::funcs::posix01",""],[13,"readlink","libc::funcs::posix01::unistd",""],[13,"fsync","",""],[13,"fdatasync","",""],[13,"setenv","",""],[13,"unsetenv","",""],[13,"putenv","",""],[13,"symlink","",""],[13,"ftruncate","",""],[0,"signal","libc::funcs::posix01",""],[13,"signal","libc::funcs::posix01::signal",""],[0,"glob","libc::funcs::posix01",""],[13,"glob","libc::funcs::posix01::glob",""],[13,"globfree","",""],[0,"mman","libc::funcs::posix01",""],[13,"posix_madvise","libc::funcs::posix01::mman",""],[0,"bsd43","libc::funcs",""],[13,"socket","libc::funcs::bsd43",""],[13,"connect","",""],[13,"bind","",""],[13,"listen","",""],[13,"accept","",""],[13,"getpeername","",""],[13,"getsockname","",""],[13,"setsockopt","",""],[13,"recv","",""],[13,"send","",""],[13,"recvfrom","",""],[13,"sendto","",""],[13,"shutdown","",""],[0,"bsd44","libc::funcs",""],[13,"getdtablesize","libc::funcs::bsd44",""],[13,"madvise","",""],[13,"mincore","",""]],"paths":[[2,"Nullable"],[2,"c_void"],[1,"glob_t"],[1,"timeval"],[1,"timespec"],[1,"sockaddr"],[1,"sockaddr_storage"],[1,"sockaddr_in"],[1,"in_addr"],[1,"sockaddr_in6"],[1,"in6_addr"],[1,"ip_mreq"],[1,"ip6_mreq"],[1,"addrinfo"],[1,"sockaddr_un"],[1,"stat"],[1,"utimbuf"],[1,"pthread_attr_t"]]};

searchIndex['syntax'] = {"items":[[0,"","syntax","The Rust parser and macro expander."],[0,"util","",""],[0,"interner","syntax::util","An \"interner\" is a data structure that associates values with uint tags and\nallows bidirectional lookup; i.e. given a value, one can easily find the\ntype, and vice versa."],[1,"Interner","syntax::util::interner",""],[1,"RcStr","",""],[1,"StrInterner","","A StrInterner differs from Interner<String> in that it accepts\n&str rather than RcStr, resulting in less allocation."],[10,"new","","",0],[10,"prefill","","",0],[10,"intern","","",0],[10,"gensym","","",0],[10,"get","","",0],[10,"len","","",0],[10,"find_equiv","","",0],[10,"clear","","",0],[10,"partial_cmp","","",1],[10,"lt","","",1],[10,"le","","",1],[10,"gt","","",1],[10,"ge","","",1],[10,"hash","","",1],[10,"eq","","",1],[10,"ne","","",1],[10,"clone","","",1],[10,"cmp","","",1],[10,"as_slice","","",1],[10,"fmt","","",1],[10,"new","","",1],[10,"new","","",2],[10,"prefill","","",2],[10,"intern","","",2],[10,"gensym","","",2],[10,"gensym_copy","","Create a gensym with the same name as an existing\nentry.",2],[10,"get","","",2],[10,"get_ref","","Returns this string with lifetime tied to the interner. Since\nstrings may never be removed from the interner, this is safe.",2],[10,"len","","",2],[10,"find_equiv","","",2],[10,"clear","","",2],[0,"small_vector","syntax::util",""],[1,"SmallVector","syntax::util::small_vector","A vector type optimized for cases where the size is almost always 0 or 1"],[1,"MoveItems","",""],[10,"len","","",3],[10,"from_iter","","",3],[10,"extend","","",3],[10,"zero","","",3],[10,"one","","",3],[10,"many","","",3],[10,"as_slice","","",3],[10,"push","","",3],[10,"push_all","","",3],[10,"get","","",3],[10,"expect_one","","",3],[10,"move_iter","","",3],[10,"next","","",4],[10,"size_hint","","",4],[0,"diagnostics","syntax",""],[0,"plugin","syntax::diagnostics",""],[3,"expand_diagnostic_used","syntax::diagnostics::plugin",""],[3,"expand_register_diagnostic","",""],[3,"expand_build_diagnostic_array","",""],[0,"registry","syntax::diagnostics",""],[1,"Registry","syntax::diagnostics::registry",""],[10,"new","","",5],[10,"find_description","","",5],[0,"syntax","syntax",""],[0,"abi","",""],[1,"AbiData","syntax::abi",""],[2,"Os","",""],[12,"OsWin32","","",6],[12,"OsMacos","","",6],[12,"OsLinux","","",6],[12,"OsAndroid","","",6],[12,"OsFreebsd","","",6],[12,"OsiOS","","",6],[12,"OsDragonfly","","",6],[2,"Abi","",""],[12,"Cdecl","","",7],[12,"Stdcall","","",7],[12,"Fastcall","","",7],[12,"Aapcs","","",7],[12,"Win64","","",7],[12,"Rust","","",7],[12,"C","","",7],[12,"System","","",7],[12,"RustIntrinsic","","",7],[12,"RustCall","","",7],[2,"Architecture","",""],[12,"X86","","",8],[12,"X86_64","","",8],[12,"Arm","","",8],[12,"Mips","","",8],[12,"Mipsel","","",8],[2,"AbiArchitecture","",""],[12,"RustArch","","Not a real ABI (e.g., intrinsic)",9],[12,"AllArch","","An ABI that specifies cross-platform defaults (e.g., \"C\")",9],[12,"Archs","","Multiple architectures (bitset)",9],[3,"lookup","","Returns the ABI with the given name (if any)."],[3,"all_names","",""],[10,"eq","","",6],[10,"ne","","",6],[10,"clone","","",7],[10,"decode","","",7],[10,"encode","","",7],[10,"hash","","",7],[10,"eq","","",7],[10,"ne","","",7],[10,"eq","","",8],[10,"ne","","",8],[10,"index","","",7],[10,"data","","",7],[10,"name","","",7],[10,"for_target","","",7],[10,"fmt","","",7],[10,"fmt","","",6],[0,"ast","syntax",""],[1,"Ident","syntax::ast","An identifier contains a Name (index into the interner\ntable) and a SyntaxContext to track renaming and\nmacro expansion per Flatt et al., \"Macros\nThat Work Together\""],[11,"name","","",10],[11,"ctxt","","",10],[1,"Name","","A name is a part of an identifier, representing a string or gensym. It's\nthe result of interning."],[1,"Lifetime","",""],[11,"id","","",11],[11,"span","","",11],[11,"name","","",11],[1,"Path","","A \"Path\" is essentially Rust's notion of a name; for instance:\nstd::cmp::PartialEq  .  It's represented as a sequence of identifiers,\nalong with a bunch of supporting information."],[11,"span","","",12],[11,"global","","A `::foo` path, is relative to the crate root rather than current\nmodule (like paths in an import).",12],[11,"segments","","The segments in the path: the things separated by `::`.",12],[1,"PathSegment","","A segment of a path: an identifier, an optional lifetime, and a set of\ntypes."],[11,"identifier","","The identifier portion of this path segment.",13],[11,"lifetimes","","The lifetime parameters for this path segment.",13],[11,"types","","The type parameters for this path segment, if present.",13],[1,"DefId","",""],[11,"krate","","",14],[11,"node","","",14],[1,"TyParam","",""],[11,"ident","","",15],[11,"id","","",15],[11,"bounds","","",15],[11,"unbound","","",15],[11,"default","","",15],[11,"span","","",15],[1,"Generics","","Represents lifetimes and type parameters attached to a declaration\nof a function, enum, trait, etc."],[11,"lifetimes","","",16],[11,"ty_params","","",16],[1,"Crate","",""],[11,"module","","",17],[11,"attrs","","",17],[11,"config","","",17],[11,"span","","",17],[11,"exported_macros","","",17],[1,"Block","",""],[11,"view_items","","",18],[11,"stmts","","",18],[11,"expr","","",18],[11,"id","","",18],[11,"rules","","",18],[11,"span","","",18],[1,"Pat","",""],[11,"id","","",19],[11,"node","","",19],[11,"span","","",19],[1,"FieldPat","",""],[11,"ident","","",20],[11,"pat","","",20],[1,"Local","","Local represents a `let` statement, e.g., `let <pat>:<ty> = <expr>;`"],[11,"ty","","",21],[11,"pat","","",21],[11,"init","","",21],[11,"id","","",21],[11,"span","","",21],[11,"source","","",21],[1,"Arm","","represents one arm of a 'match'"],[11,"attrs","","",22],[11,"pats","","",22],[11,"guard","","",22],[11,"body","","",22],[1,"Field","",""],[11,"ident","","",23],[11,"expr","","",23],[11,"span","","",23],[1,"Expr","",""],[11,"id","","",24],[11,"node","","",24],[11,"span","","",24],[1,"MutTy","",""],[11,"ty","","",25],[11,"mutbl","","",25],[1,"TypeField","",""],[11,"ident","","",26],[11,"mt","","",26],[11,"span","","",26],[1,"TypeMethod","","Represents a required method in a trait declaration,\none without a default implementation"],[11,"ident","","",27],[11,"attrs","","",27],[11,"fn_style","","",27],[11,"abi","","",27],[11,"decl","","",27],[11,"generics","","",27],[11,"explicit_self","","",27],[11,"id","","",27],[11,"span","","",27],[11,"vis","","",27],[1,"Ty","",""],[11,"id","","",28],[11,"node","","",28],[11,"span","","",28],[1,"ClosureTy","","Represents the type of a closure"],[11,"lifetimes","","",29],[11,"fn_style","","",29],[11,"onceness","","",29],[11,"decl","","",29],[11,"bounds","","Optional optvec distinguishes between \"fn()\" and \"fn:()\" so we can\nimplement issue #7264. None means \"fn()\", which means infer a default\nbound based on pointer sigil during typeck. Some(Empty) means \"fn:()\",\nwhich means use no bounds (e.g., not even Owned on a ~fn()).",29],[1,"BareFnTy","",""],[11,"fn_style","","",30],[11,"abi","","",30],[11,"lifetimes","","",30],[11,"decl","","",30],[1,"UnboxedFnTy","",""],[11,"decl","","",31],[1,"InlineAsm","",""],[11,"asm","","",32],[11,"asm_str_style","","",32],[11,"clobbers","","",32],[11,"inputs","","",32],[11,"outputs","","",32],[11,"volatile","","",32],[11,"alignstack","","",32],[11,"dialect","","",32],[1,"Arg","","represents an argument in a function header"],[11,"ty","","",33],[11,"pat","","",33],[11,"id","","",33],[1,"FnDecl","","represents the header (not the body) of a function declaration"],[11,"inputs","","",34],[11,"output","","",34],[11,"cf","","",34],[11,"variadic","","",34],[1,"Method","",""],[11,"attrs","","",35],[11,"id","","",35],[11,"span","","",35],[11,"node","","",35],[1,"Mod","",""],[11,"inner","","A span from the first token past `{` to the last token until `}`.\nFor `mod foo;`, the inner span ranges from the first token\nto the last token in the external file.",36],[11,"view_items","","",36],[11,"items","","",36],[1,"ForeignMod","",""],[11,"abi","","",37],[11,"view_items","","",37],[11,"items","","",37],[1,"VariantArg","",""],[11,"ty","","",38],[11,"id","","",38],[1,"EnumDef","",""],[11,"variants","","",39],[1,"Variant_","",""],[11,"name","","",40],[11,"attrs","","",40],[11,"kind","","",40],[11,"id","","",40],[11,"disr_expr","","",40],[11,"vis","","",40],[1,"ViewItem","",""],[11,"node","","",41],[11,"attrs","","",41],[11,"vis","","",41],[11,"span","","",41],[1,"AttrId","",""],[1,"Attribute_","","Doc-comments are promoted to attributes that have is_sugared_doc = true"],[11,"id","","",42],[11,"style","","",42],[11,"value","","",42],[11,"is_sugared_doc","","",42],[1,"TraitRef","","TraitRef's appear in impls.\nresolve maps each TraitRef's ref_id to its defining trait; that's all\nthat the ref_id is for. The impl_id maps to the \"self type\" of this impl.\nIf this impl is an ItemImpl, the impl_id is redundant (it could be the\nsame as the impl's node id)."],[11,"path","","",43],[11,"ref_id","","",43],[1,"StructField_","",""],[11,"kind","","",44],[11,"id","","",44],[11,"ty","","",44],[11,"attrs","","",44],[1,"StructDef","",""],[11,"fields","","Fields, not including ctor",45],[11,"ctor_id","","ID of the constructor. This is only used for tuple- or enum-like\nstructs.",45],[11,"super_struct","","Super struct, if specified.",45],[11,"is_virtual","","True iff the struct may be inherited from.",45],[1,"Item","",""],[11,"ident","","",46],[11,"attrs","","",46],[11,"id","","",46],[11,"node","","",46],[11,"vis","","",46],[11,"span","","",46],[1,"ForeignItem","",""],[11,"ident","","",47],[11,"attrs","","",47],[11,"node","","",47],[11,"id","","",47],[11,"span","","",47],[11,"vis","","",47],[2,"TyParamBound","","The AST represents all type param bounds as types.\ntypeck::collect::compute_bounds matches these against\nthe \"special\" built-in traits (see middle::lang_items) and\ndetects Copy, Send and Share."],[12,"TraitTyParamBound","","",48],[12,"StaticRegionTyParamBound","","",48],[12,"UnboxedFnTyParamBound","","",48],[12,"OtherRegionTyParamBound","","",48],[2,"MetaItem_","",""],[12,"MetaWord","","",49],[12,"MetaList","","",49],[12,"MetaNameValue","","",49],[2,"BindingMode","",""],[12,"BindByRef","","",50],[12,"BindByValue","","",50],[2,"Pat_","",""],[12,"PatWild","","",51],[12,"PatWildMulti","","",51],[12,"PatIdent","","A PatIdent may either be a new bound variable,\nor a nullary enum (in which case the third field\nis None).\nIn the nullary enum case, the parser can't determine\nwhich it is. The resolver determines this, and\nrecords this pattern's NodeId in an auxiliary\nset (of \"PatIdents that refer to nullary enums\")",51],[12,"PatEnum","","\"None\" means a * pattern where we don't bind the fields to names.",51],[12,"PatStruct","","",51],[12,"PatTup","","",51],[12,"PatBox","","",51],[12,"PatRegion","","",51],[12,"PatLit","","",51],[12,"PatRange","","",51],[12,"PatVec","","[a, b, ..i, y, z] is represented as:\nPatVec(~[a, b], Some(i), ~[y, z])",51],[12,"PatMac","","",51],[2,"Mutability","",""],[12,"MutMutable","","",52],[12,"MutImmutable","","",52],[2,"ExprVstore","",""],[12,"ExprVstoreUniq","","~[1, 2, 3, 4]",53],[12,"ExprVstoreSlice","","&[1, 2, 3, 4]",53],[12,"ExprVstoreMutSlice","","&mut [1, 2, 3, 4]",53],[2,"BinOp","",""],[12,"BiAdd","","",54],[12,"BiSub","","",54],[12,"BiMul","","",54],[12,"BiDiv","","",54],[12,"BiRem","","",54],[12,"BiAnd","","",54],[12,"BiOr","","",54],[12,"BiBitXor","","",54],[12,"BiBitAnd","","",54],[12,"BiBitOr","","",54],[12,"BiShl","","",54],[12,"BiShr","","",54],[12,"BiEq","","",54],[12,"BiLt","","",54],[12,"BiLe","","",54],[12,"BiNe","","",54],[12,"BiGe","","",54],[12,"BiGt","","",54],[2,"UnOp","",""],[12,"UnBox","","",55],[12,"UnUniq","","",55],[12,"UnDeref","","",55],[12,"UnNot","","",55],[12,"UnNeg","","",55],[2,"Stmt_","",""],[12,"StmtDecl","","Could be an item or a local (let) binding:",56],[12,"StmtExpr","","Expr without trailing semi-colon (must have unit type):",56],[12,"StmtSemi","","Expr with trailing semi-colon (may have any type):",56],[12,"StmtMac","","bool: is there a trailing sem-colon?",56],[2,"LocalSource","","Where a local declaration came from: either a true `let ... =\n...;`, or one desugared from the pattern of a for loop."],[12,"LocalLet","","",57],[12,"LocalFor","","",57],[2,"Decl_","",""],[12,"DeclLocal","","A local (let) binding:",58],[12,"DeclItem","","An item binding:",58],[2,"BlockCheckMode","",""],[12,"DefaultBlock","","",59],[12,"UnsafeBlock","","",59],[2,"UnsafeSource","",""],[12,"CompilerGenerated","","",60],[12,"UserProvided","","",60],[2,"Expr_","",""],[12,"ExprVstore","","",61],[12,"ExprBox","","First expr is the place; second expr is the value.",61],[12,"ExprVec","","",61],[12,"ExprCall","","",61],[12,"ExprMethodCall","","",61],[12,"ExprTup","","",61],[12,"ExprBinary","","",61],[12,"ExprUnary","","",61],[12,"ExprLit","","",61],[12,"ExprCast","","",61],[12,"ExprIf","","",61],[12,"ExprWhile","","",61],[12,"ExprForLoop","","",61],[12,"ExprLoop","","",61],[12,"ExprMatch","","",61],[12,"ExprFnBlock","","",61],[12,"ExprProc","","",61],[12,"ExprUnboxedFn","","",61],[12,"ExprBlock","","",61],[12,"ExprAssign","","",61],[12,"ExprAssignOp","","",61],[12,"ExprField","","",61],[12,"ExprIndex","","",61],[12,"ExprPath","","Variable reference, possibly containing `::` and/or\ntype parameters, e.g. foo::bar::<baz>",61],[12,"ExprAddrOf","","",61],[12,"ExprBreak","","",61],[12,"ExprAgain","","",61],[12,"ExprRet","","",61],[12,"ExprInlineAsm","","",61],[12,"ExprMac","","",61],[12,"ExprStruct","","A struct literal expression.",61],[12,"ExprRepeat","","A vector literal constructed from one repeated element.",61],[12,"ExprParen","","No-op: used solely so we can pretty-print faithfully",61],[2,"TokenTree","","When the main rust parser encounters a syntax-extension invocation, it\n parses the arguments to the invocation as a token-tree. This is a very\n loose structure, such that all sorts of different AST-fragments can\n be passed to syntax extensions using a uniform type."],[12,"TTTok","","A single token",62],[12,"TTDelim","","A delimited sequence (the delimiters appear as the first\nand last elements of the vector)",62],[12,"TTSeq","","A kleene-style repetition sequence with a span, a TTForest,\nan optional separator, and a boolean where true indicates\nzero or more (..), and false indicates one or more (+).",62],[12,"TTNonterminal","","A syntactic variable that will be filled in by macro expansion.",62],[2,"Matcher_","",""],[12,"MatchTok","","Match one token",63],[12,"MatchSeq","","Match repetitions of a sequence: body, separator, zero ok?,\nlo, hi position-in-match-array used:",63],[12,"MatchNonterminal","","Parse a Rust NT: name to bind, name of NT, position in match array:",63],[2,"Mac_","","Represents a macro invocation. The Path indicates which macro\nis being invoked, and the vector of token-trees contains the source\nof the macro invocation.\nThere's only one flavor, now, so this could presumably be simplified."],[12,"MacInvocTT","","",64],[2,"StrStyle","",""],[12,"CookedStr","","",65],[12,"RawStr","","",65],[2,"Lit_","",""],[12,"LitStr","","",66],[12,"LitBinary","","",66],[12,"LitByte","","",66],[12,"LitChar","","",66],[12,"LitInt","","",66],[12,"LitUint","","",66],[12,"LitIntUnsuffixed","","",66],[12,"LitFloat","","",66],[12,"LitFloatUnsuffixed","","",66],[12,"LitNil","","",66],[12,"LitBool","","",66],[2,"TraitMethod","","Represents a method declaration in a trait declaration, possibly including\na default implementation A trait method is either required (meaning it\ndoesn't have an implementation, just a signature) or provided (meaning it\nhas a default implementation)."],[12,"Required","","",67],[12,"Provided","","",67],[2,"IntTy","",""],[12,"TyI","","",68],[12,"TyI8","","",68],[12,"TyI16","","",68],[12,"TyI32","","",68],[12,"TyI64","","",68],[2,"UintTy","",""],[12,"TyU","","",69],[12,"TyU8","","",69],[12,"TyU16","","",69],[12,"TyU32","","",69],[12,"TyU64","","",69],[2,"FloatTy","",""],[12,"TyF32","","",70],[12,"TyF64","","",70],[2,"PrimTy","","Not represented directly in the AST, referred to by name through a ty_path."],[12,"TyInt","","",71],[12,"TyUint","","",71],[12,"TyFloat","","",71],[12,"TyStr","","",71],[12,"TyBool","","",71],[12,"TyChar","","",71],[2,"Onceness","",""],[12,"Once","","",72],[12,"Many","","",72],[2,"Ty_","",""],[12,"TyNil","","",73],[12,"TyBot","","",73],[12,"TyBox","","",73],[12,"TyUniq","","",73],[12,"TyVec","","",73],[12,"TyFixedLengthVec","","",73],[12,"TyPtr","","",73],[12,"TyRptr","","",73],[12,"TyClosure","","",73],[12,"TyProc","","",73],[12,"TyBareFn","","",73],[12,"TyUnboxedFn","","",73],[12,"TyTup","","",73],[12,"TyPath","","",73],[12,"TyParen","","No-op; kept solely so that we can pretty-print faithfully",73],[12,"TyTypeof","","",73],[12,"TyInfer","","TyInfer means the type should be inferred instead of it having been\nspecified. This can appear anywhere in a type.",73],[2,"AsmDialect","",""],[12,"AsmAtt","","",74],[12,"AsmIntel","","",74],[2,"FnStyle","",""],[12,"UnsafeFn","","Declared with \"unsafe fn\"",75],[12,"NormalFn","","Declared with \"fn\"",75],[2,"RetStyle","",""],[12,"NoReturn","","Functions with return type ! that always\nraise an error or exit (i.e. never return to the caller)",76],[12,"Return","","Everything else",76],[2,"ExplicitSelf_","","Represents the kind of 'self' associated with a method"],[12,"SelfStatic","","No self",77],[12,"SelfValue","","`self`",77],[12,"SelfRegion","","`&'lt self`, `&'lt mut self`",77],[12,"SelfExplicit","","`self: TYPE`",77],[2,"Method_","",""],[12,"MethDecl","","Represents a method declaration",78],[12,"MethMac","","Represents a macro in method position",78],[2,"VariantKind","",""],[12,"TupleVariantKind","","",79],[12,"StructVariantKind","","",79],[2,"PathListItem_","",""],[12,"PathListIdent","","",80],[11,"name","syntax::ast::PathListItem_","",80],[11,"id","","",80],[12,"PathListMod","syntax::ast","",80],[11,"id","syntax::ast::PathListItem_","",80],[2,"ViewPath_","syntax::ast",""],[12,"ViewPathSimple","","`quux = foo::bar::baz`",81],[12,"ViewPathGlob","","`foo::bar::*`",81],[12,"ViewPathList","","`foo::bar::{a,b,c}`",81],[2,"ViewItem_","",""],[12,"ViewItemExternCrate","","Ident: name used to refer to this crate in the code\noptional (InternedString,StrStyle): if present, this is a location\n(containing arbitrary characters) from which to fetch the crate sources\nFor example, extern crate whatever = \"github.com/rust-lang/rust\"",82],[12,"ViewItemUse","","",82],[2,"AttrStyle","","Distinguishes between Attributes that decorate items and Attributes that\nare contained as statements within items. These two cases need to be\ndistinguished for pretty-printing."],[12,"AttrOuter","","",83],[12,"AttrInner","","",83],[2,"Visibility","",""],[12,"Public","","",84],[12,"Inherited","","",84],[2,"StructFieldKind","",""],[12,"NamedField","","",85],[12,"UnnamedField","","Element of a tuple-like struct",85],[2,"Item_","",""],[12,"ItemStatic","","",86],[12,"ItemFn","","",86],[12,"ItemMod","","",86],[12,"ItemForeignMod","","",86],[12,"ItemTy","","",86],[12,"ItemEnum","","",86],[12,"ItemStruct","","",86],[12,"ItemTrait","","Represents a Trait Declaration",86],[12,"ItemImpl","","",86],[12,"ItemMac","","A macro invocation (which includes macro definition)",86],[2,"ForeignItem_","",""],[12,"ForeignItemFn","","",87],[12,"ForeignItemStatic","","",87],[2,"InlinedItem","","The data we save and restore about an inlined item or method.  This is not\npart of the AST that we parse from a file, but it becomes part of the tree\nthat we trans."],[12,"IIItem","","",88],[12,"IIMethod","","",88],[12,"IIForeign","","",88],[3,"P","","Construct a P<T> from a T value."],[4,"P","","A pointer abstraction."],[4,"SyntaxContext","","A SyntaxContext represents a chain of macro-expandings\nand renamings. Each macro expansion corresponds to\na fresh uint"],[4,"Mrk","","A mark represents a unique id associated with a macro expansion"],[4,"FnIdent","","Function name (not all functions have names)"],[4,"CrateNum","",""],[4,"NodeId","",""],[4,"CrateConfig","","The set of MetaItems that define the compilation environment of the crate,\nused to drive conditional compilation"],[4,"MetaItem","",""],[4,"Stmt","",""],[4,"Decl","",""],[4,"SpannedIdent","",""],[4,"Matcher","",""],[4,"Mac","",""],[4,"Lit","",""],[4,"ExplicitSelf","",""],[4,"Variant","",""],[4,"PathListItem","",""],[4,"ViewPath","",""],[4,"Attribute","","Meta-data associated with an item"],[4,"StructField","",""],[5,"EMPTY_CTXT","",""],[5,"ILLEGAL_CTXT","",""],[5,"LOCAL_CRATE","","Item definitions in the currently-compiled crate would have the CrateNum\nLOCAL_CRATE in their DefId."],[5,"CRATE_NODE_ID","",""],[5,"DUMMY_NODE_ID","","When parsing and doing expansions, we initially give all AST nodes this AST\nnode value. Then later, in the renumber pass, we renumber them to have\nsmall, positive ids."],[10,"cmp","","",10],[10,"partial_cmp","","",10],[10,"lt","","",10],[10,"le","","",10],[10,"gt","","",10],[10,"ge","","",10],[10,"hash","","",10],[10,"clone","","",10],[10,"new","","Construct an identifier with the given name and an empty context:",10],[10,"as_str","","",10],[10,"fmt","","",10],[10,"fmt","","",89],[10,"eq","","",10],[10,"ne","","",10],[10,"clone","","",89],[10,"decode","","",89],[10,"encode","","",89],[10,"hash","","",89],[10,"partial_cmp","","",89],[10,"lt","","",89],[10,"le","","",89],[10,"gt","","",89],[10,"ge","","",89],[10,"eq","","",89],[10,"ne","","",89],[10,"cmp","","",89],[10,"as_str","","",89],[10,"uint","","",89],[10,"ident","","",89],[10,"encode","","",10],[10,"decode","","",10],[10,"fmt","","",11],[10,"hash","","",11],[10,"decode","","",11],[10,"encode","","",11],[10,"eq","","",11],[10,"ne","","",11],[10,"clone","","",11],[10,"fmt","","",12],[10,"hash","","",12],[10,"decode","","",12],[10,"encode","","",12],[10,"eq","","",12],[10,"ne","","",12],[10,"clone","","",12],[10,"fmt","","",13],[10,"hash","","",13],[10,"decode","","",13],[10,"encode","","",13],[10,"eq","","",13],[10,"ne","","",13],[10,"clone","","",13],[10,"fmt","","",14],[10,"hash","","",14],[10,"decode","","",14],[10,"encode","","",14],[10,"eq","","",14],[10,"ne","","",14],[10,"partial_cmp","","",14],[10,"lt","","",14],[10,"le","","",14],[10,"gt","","",14],[10,"ge","","",14],[10,"cmp","","",14],[10,"clone","","",14],[10,"fmt","","",48],[10,"hash","","",48],[10,"decode","","",48],[10,"encode","","",48],[10,"eq","","",48],[10,"ne","","",48],[10,"clone","","",48],[10,"fmt","","",15],[10,"hash","","",15],[10,"decode","","",15],[10,"encode","","",15],[10,"eq","","",15],[10,"ne","","",15],[10,"clone","","",15],[10,"fmt","","",16],[10,"hash","","",16],[10,"decode","","",16],[10,"encode","","",16],[10,"eq","","",16],[10,"ne","","",16],[10,"clone","","",16],[10,"is_parameterized","","",16],[10,"is_lt_parameterized","","",16],[10,"is_type_parameterized","","",16],[10,"fmt","","",17],[10,"hash","","",17],[10,"decode","","",17],[10,"encode","","",17],[10,"eq","","",17],[10,"ne","","",17],[10,"clone","","",17],[10,"fmt","","",49],[10,"hash","","",49],[10,"decode","","",49],[10,"encode","","",49],[10,"clone","","",49],[10,"eq","","",49],[10,"fmt","","",18],[10,"hash","","",18],[10,"decode","","",18],[10,"encode","","",18],[10,"eq","","",18],[10,"ne","","",18],[10,"clone","","",18],[10,"fmt","","",19],[10,"hash","","",19],[10,"decode","","",19],[10,"encode","","",19],[10,"eq","","",19],[10,"ne","","",19],[10,"clone","","",19],[10,"fmt","","",20],[10,"hash","","",20],[10,"decode","","",20],[10,"encode","","",20],[10,"eq","","",20],[10,"ne","","",20],[10,"clone","","",20],[10,"fmt","","",50],[10,"hash","","",50],[10,"decode","","",50],[10,"encode","","",50],[10,"eq","","",50],[10,"ne","","",50],[10,"clone","","",50],[10,"fmt","","",51],[10,"hash","","",51],[10,"decode","","",51],[10,"encode","","",51],[10,"eq","","",51],[10,"ne","","",51],[10,"clone","","",51],[10,"fmt","","",52],[10,"hash","","",52],[10,"decode","","",52],[10,"encode","","",52],[10,"eq","","",52],[10,"ne","","",52],[10,"clone","","",52],[10,"fmt","","",53],[10,"hash","","",53],[10,"decode","","",53],[10,"encode","","",53],[10,"eq","","",53],[10,"ne","","",53],[10,"clone","","",53],[10,"fmt","","",54],[10,"hash","","",54],[10,"decode","","",54],[10,"encode","","",54],[10,"eq","","",54],[10,"ne","","",54],[10,"clone","","",54],[10,"fmt","","",55],[10,"hash","","",55],[10,"decode","","",55],[10,"encode","","",55],[10,"eq","","",55],[10,"ne","","",55],[10,"clone","","",55],[10,"fmt","","",56],[10,"hash","","",56],[10,"decode","","",56],[10,"encode","","",56],[10,"eq","","",56],[10,"ne","","",56],[10,"clone","","",56],[10,"fmt","","",57],[10,"hash","","",57],[10,"decode","","",57],[10,"encode","","",57],[10,"eq","","",57],[10,"ne","","",57],[10,"clone","","",57],[10,"fmt","","",21],[10,"hash","","",21],[10,"decode","","",21],[10,"encode","","",21],[10,"eq","","",21],[10,"ne","","",21],[10,"clone","","",21],[10,"fmt","","",58],[10,"hash","","",58],[10,"decode","","",58],[10,"encode","","",58],[10,"eq","","",58],[10,"ne","","",58],[10,"clone","","",58],[10,"fmt","","",22],[10,"hash","","",22],[10,"decode","","",22],[10,"encode","","",22],[10,"eq","","",22],[10,"ne","","",22],[10,"clone","","",22],[10,"fmt","","",23],[10,"hash","","",23],[10,"decode","","",23],[10,"encode","","",23],[10,"eq","","",23],[10,"ne","","",23],[10,"clone","","",23],[10,"fmt","","",59],[10,"hash","","",59],[10,"decode","","",59],[10,"encode","","",59],[10,"eq","","",59],[10,"ne","","",59],[10,"clone","","",59],[10,"fmt","","",60],[10,"hash","","",60],[10,"decode","","",60],[10,"encode","","",60],[10,"eq","","",60],[10,"ne","","",60],[10,"clone","","",60],[10,"fmt","","",24],[10,"hash","","",24],[10,"decode","","",24],[10,"encode","","",24],[10,"eq","","",24],[10,"ne","","",24],[10,"clone","","",24],[10,"fmt","","",61],[10,"hash","","",61],[10,"decode","","",61],[10,"encode","","",61],[10,"eq","","",61],[10,"ne","","",61],[10,"clone","","",61],[10,"fmt","","",62],[10,"hash","","",62],[10,"decode","","",62],[10,"encode","","",62],[10,"eq","","",62],[10,"ne","","",62],[10,"clone","","",62],[10,"fmt","","",63],[10,"hash","","",63],[10,"decode","","",63],[10,"encode","","",63],[10,"eq","","",63],[10,"ne","","",63],[10,"clone","","",63],[10,"fmt","","",64],[10,"hash","","",64],[10,"decode","","",64],[10,"encode","","",64],[10,"eq","","",64],[10,"ne","","",64],[10,"clone","","",64],[10,"fmt","","",65],[10,"hash","","",65],[10,"decode","","",65],[10,"encode","","",65],[10,"eq","","",65],[10,"ne","","",65],[10,"clone","","",65],[10,"fmt","","",66],[10,"hash","","",66],[10,"decode","","",66],[10,"encode","","",66],[10,"eq","","",66],[10,"ne","","",66],[10,"clone","","",66],[10,"fmt","","",25],[10,"hash","","",25],[10,"decode","","",25],[10,"encode","","",25],[10,"eq","","",25],[10,"ne","","",25],[10,"clone","","",25],[10,"fmt","","",26],[10,"hash","","",26],[10,"decode","","",26],[10,"encode","","",26],[10,"eq","","",26],[10,"ne","","",26],[10,"clone","","",26],[10,"fmt","","",27],[10,"hash","","",27],[10,"decode","","",27],[10,"encode","","",27],[10,"eq","","",27],[10,"ne","","",27],[10,"clone","","",27],[10,"fmt","","",67],[10,"hash","","",67],[10,"decode","","",67],[10,"encode","","",67],[10,"eq","","",67],[10,"ne","","",67],[10,"clone","","",67],[10,"hash","","",68],[10,"decode","","",68],[10,"encode","","",68],[10,"eq","","",68],[10,"ne","","",68],[10,"clone","","",68],[10,"fmt","","",68],[10,"suffix_len","","",68],[10,"hash","","",69],[10,"decode","","",69],[10,"encode","","",69],[10,"eq","","",69],[10,"ne","","",69],[10,"clone","","",69],[10,"suffix_len","","",69],[10,"fmt","","",69],[10,"hash","","",70],[10,"decode","","",70],[10,"encode","","",70],[10,"eq","","",70],[10,"ne","","",70],[10,"clone","","",70],[10,"fmt","","",70],[10,"suffix_len","","",70],[10,"fmt","","",28],[10,"hash","","",28],[10,"decode","","",28],[10,"encode","","",28],[10,"eq","","",28],[10,"ne","","",28],[10,"clone","","",28],[10,"fmt","","",71],[10,"hash","","",71],[10,"decode","","",71],[10,"encode","","",71],[10,"eq","","",71],[10,"ne","","",71],[10,"clone","","",71],[10,"hash","","",72],[10,"decode","","",72],[10,"encode","","",72],[10,"eq","","",72],[10,"ne","","",72],[10,"clone","","",72],[10,"fmt","","",72],[10,"fmt","","",29],[10,"hash","","",29],[10,"decode","","",29],[10,"encode","","",29],[10,"eq","","",29],[10,"ne","","",29],[10,"fmt","","",30],[10,"hash","","",30],[10,"decode","","",30],[10,"encode","","",30],[10,"eq","","",30],[10,"ne","","",30],[10,"fmt","","",31],[10,"hash","","",31],[10,"decode","","",31],[10,"encode","","",31],[10,"eq","","",31],[10,"ne","","",31],[10,"clone","","",31],[10,"fmt","","",73],[10,"hash","","",73],[10,"decode","","",73],[10,"encode","","",73],[10,"eq","","",73],[10,"ne","","",73],[10,"clone","","",73],[10,"fmt","","",74],[10,"hash","","",74],[10,"decode","","",74],[10,"encode","","",74],[10,"eq","","",74],[10,"ne","","",74],[10,"clone","","",74],[10,"fmt","","",32],[10,"hash","","",32],[10,"decode","","",32],[10,"encode","","",32],[10,"eq","","",32],[10,"ne","","",32],[10,"clone","","",32],[10,"fmt","","",33],[10,"hash","","",33],[10,"decode","","",33],[10,"encode","","",33],[10,"eq","","",33],[10,"ne","","",33],[10,"clone","","",33],[10,"new_self","","",33],[10,"fmt","","",34],[10,"hash","","",34],[10,"decode","","",34],[10,"encode","","",34],[10,"eq","","",34],[10,"ne","","",34],[10,"clone","","",34],[10,"hash","","",75],[10,"decode","","",75],[10,"encode","","",75],[10,"eq","","",75],[10,"ne","","",75],[10,"clone","","",75],[10,"fmt","","",75],[10,"fmt","","",76],[10,"hash","","",76],[10,"decode","","",76],[10,"encode","","",76],[10,"eq","","",76],[10,"ne","","",76],[10,"clone","","",76],[10,"fmt","","",77],[10,"hash","","",77],[10,"decode","","",77],[10,"encode","","",77],[10,"eq","","",77],[10,"ne","","",77],[10,"clone","","",77],[10,"fmt","","",35],[10,"hash","","",35],[10,"decode","","",35],[10,"encode","","",35],[10,"eq","","",35],[10,"ne","","",35],[10,"clone","","",35],[10,"fmt","","",78],[10,"hash","","",78],[10,"decode","","",78],[10,"encode","","",78],[10,"eq","","",78],[10,"ne","","",78],[10,"clone","","",78],[10,"fmt","","",36],[10,"hash","","",36],[10,"decode","","",36],[10,"encode","","",36],[10,"eq","","",36],[10,"ne","","",36],[10,"clone","","",36],[10,"fmt","","",37],[10,"hash","","",37],[10,"decode","","",37],[10,"encode","","",37],[10,"eq","","",37],[10,"ne","","",37],[10,"clone","","",37],[10,"fmt","","",38],[10,"hash","","",38],[10,"decode","","",38],[10,"encode","","",38],[10,"eq","","",38],[10,"ne","","",38],[10,"clone","","",38],[10,"fmt","","",79],[10,"hash","","",79],[10,"decode","","",79],[10,"encode","","",79],[10,"eq","","",79],[10,"ne","","",79],[10,"clone","","",79],[10,"fmt","","",39],[10,"hash","","",39],[10,"decode","","",39],[10,"encode","","",39],[10,"eq","","",39],[10,"ne","","",39],[10,"clone","","",39],[10,"fmt","","",40],[10,"hash","","",40],[10,"decode","","",40],[10,"encode","","",40],[10,"eq","","",40],[10,"ne","","",40],[10,"clone","","",40],[10,"fmt","","",80],[10,"hash","","",80],[10,"decode","","",80],[10,"encode","","",80],[10,"eq","","",80],[10,"ne","","",80],[10,"clone","","",80],[10,"id","","",80],[10,"fmt","","",81],[10,"hash","","",81],[10,"decode","","",81],[10,"encode","","",81],[10,"eq","","",81],[10,"ne","","",81],[10,"clone","","",81],[10,"fmt","","",41],[10,"hash","","",41],[10,"decode","","",41],[10,"encode","","",41],[10,"eq","","",41],[10,"ne","","",41],[10,"clone","","",41],[10,"fmt","","",82],[10,"hash","","",82],[10,"decode","","",82],[10,"encode","","",82],[10,"eq","","",82],[10,"ne","","",82],[10,"clone","","",82],[10,"fmt","","",83],[10,"hash","","",83],[10,"decode","","",83],[10,"encode","","",83],[10,"eq","","",83],[10,"ne","","",83],[10,"clone","","",83],[10,"fmt","","",90],[10,"hash","","",90],[10,"decode","","",90],[10,"encode","","",90],[10,"eq","","",90],[10,"ne","","",90],[10,"clone","","",90],[10,"fmt","","",42],[10,"hash","","",42],[10,"decode","","",42],[10,"encode","","",42],[10,"eq","","",42],[10,"ne","","",42],[10,"clone","","",42],[10,"fmt","","",43],[10,"hash","","",43],[10,"decode","","",43],[10,"encode","","",43],[10,"eq","","",43],[10,"ne","","",43],[10,"clone","","",43],[10,"fmt","","",84],[10,"hash","","",84],[10,"decode","","",84],[10,"encode","","",84],[10,"eq","","",84],[10,"ne","","",84],[10,"clone","","",84],[10,"inherit_from","","",84],[10,"fmt","","",44],[10,"hash","","",44],[10,"decode","","",44],[10,"encode","","",44],[10,"eq","","",44],[10,"ne","","",44],[10,"clone","","",44],[10,"ident","","",44],[10,"fmt","","",85],[10,"hash","","",85],[10,"decode","","",85],[10,"encode","","",85],[10,"eq","","",85],[10,"ne","","",85],[10,"clone","","",85],[10,"is_unnamed","","",85],[10,"fmt","","",45],[10,"hash","","",45],[10,"decode","","",45],[10,"encode","","",45],[10,"eq","","",45],[10,"ne","","",45],[10,"clone","","",45],[10,"fmt","","",46],[10,"hash","","",46],[10,"decode","","",46],[10,"encode","","",46],[10,"eq","","",46],[10,"ne","","",46],[10,"clone","","",46],[10,"fmt","","",86],[10,"hash","","",86],[10,"decode","","",86],[10,"encode","","",86],[10,"eq","","",86],[10,"ne","","",86],[10,"clone","","",86],[10,"fmt","","",47],[10,"hash","","",47],[10,"decode","","",47],[10,"encode","","",47],[10,"eq","","",47],[10,"ne","","",47],[10,"clone","","",47],[10,"fmt","","",87],[10,"hash","","",87],[10,"decode","","",87],[10,"encode","","",87],[10,"eq","","",87],[10,"ne","","",87],[10,"clone","","",87],[10,"fmt","","",88],[10,"hash","","",88],[10,"decode","","",88],[10,"encode","","",88],[10,"eq","","",88],[10,"ne","","",88],[10,"clone","","",88],[0,"ast_map","syntax",""],[1,"Values","syntax::ast_map",""],[1,"Map","","Represents a mapping from Node IDs to AST elements and their parent\nNode IDs"],[1,"Ctx","","A Folder that walks over an AST and constructs a Node ID Map. Its\nfold_ops argument has the opportunity to replace Node IDs and spans."],[2,"PathElem","",""],[12,"PathMod","","",91],[12,"PathName","","",91],[2,"Node","",""],[12,"NodeItem","","",92],[12,"NodeForeignItem","","",92],[12,"NodeTraitMethod","","",92],[12,"NodeMethod","","",92],[12,"NodeVariant","","",92],[12,"NodeExpr","","",92],[12,"NodeStmt","","",92],[12,"NodeArg","","",92],[12,"NodeLocal","","",92],[12,"NodePat","","",92],[12,"NodeBlock","","",92],[12,"NodeStructCtor","","NodeStructCtor represents a tuple struct.",92],[12,"NodeLifetime","","",92],[3,"path_to_string","",""],[3,"map_crate","",""],[3,"map_decoded_item","","Used for items loaded from external crate that are being inlined into this\ncrate.  The `path` should be the path to the item but should not include\nthe item itself."],[0,"blocks","","This module provides a simplified abstraction for working with\ncode blocks identified by their integer node-id.  In particular,\nit captures a common set of attributes that all \"function-like\nthings\" (represented by `FnLike` instances) share.  For example,\nall `FnLike` instances have a type signature (be it explicit or\ninferred).  And all `FnLike` instances have a body, i.e. the code\nthat is run when the function-like thing it represents is invoked."],[1,"FnLikeNode","syntax::ast_map::blocks","An FnLikeNode is a Node that is like a fn, in that it has a decl\nand a body (as well as a NodeId, a span, etc)."],[1,"FnParts","","Components shared by fn-like things (fn items, methods, closures)."],[11,"decl","","",93],[11,"body","","",93],[11,"kind","","",93],[11,"span","","",93],[11,"id","","",93],[2,"Code","","Carries either an FnLikeNode or a Block, as these are the two\nconstructs that correspond to \"code\" (as in, something from which\nwe can construct a control-flow graph)."],[12,"FnLikeCode","","",94],[12,"BlockCode","","",94],[6,"MaybeFnLike","","MaybeFnLike wraps a method that indicates if an object\ncorresponds to some FnLikeNode."],[9,"is_fn_like","","",95],[10,"is_fn_like","syntax::ast","",46],[10,"is_fn_like","","",67],[10,"is_fn_like","","",24],[10,"id","syntax::ast_map::blocks","",94],[10,"from_node","","Attempts to construct a Code from presumed FnLike or Block node input.",94],[10,"to_fn_parts","","",96],[10,"body","","",96],[10,"decl","","",96],[10,"span","","",96],[10,"id","","",96],[10,"kind","","",96],[4,"PathElems","syntax::ast_map","The type of the iterator used by with_path."],[6,"FoldOps","",""],[10,"new_id","","",97],[10,"new_span","","",97],[10,"eq","","",91],[10,"ne","","",91],[10,"clone","","",91],[10,"name","","",91],[10,"fmt","","",91],[10,"clone","","",98],[10,"next","","",98],[10,"clone","","",92],[10,"get","","Retrieve the Node corresponding to `id`, failing if it cannot\nbe found.",99],[10,"find","","Retrieve the Node corresponding to `id`, returning None if\ncannot be found.",99],[10,"get_parent","","Retrieve the parent NodeId for `id`, or `id` itself if no\nparent is registered in this map.",99],[10,"get_parent_did","","",99],[10,"get_foreign_abi","","",99],[10,"get_foreign_vis","","",99],[10,"expect_item","","",99],[10,"expect_struct","","",99],[10,"expect_variant","","",99],[10,"expect_foreign_item","","",99],[10,"get_path_elem","","returns the name associated with the given NodeId's AST",99],[10,"with_path","","",99],[10,"path_to_string","","",99],[10,"with_attrs","","Given a node ID and a closure, apply the closure to the array\nof attributes associated with the AST corresponding to the Node ID",99],[10,"opt_span","","",99],[10,"span","","",99],[10,"node_to_string","","",99],[10,"new_id","","",100],[10,"new_span","","",100],[10,"fold_item","","",100],[10,"fold_pat","","",100],[10,"fold_expr","","",100],[10,"fold_stmt","","",100],[10,"fold_type_method","","",100],[10,"fold_method","","",100],[10,"fold_fn_decl","","",100],[10,"fold_block","","",100],[10,"fold_lifetime","","",100],[10,"fold_mac","","",100],[0,"ast_util","syntax",""],[1,"IdRange","syntax::ast_util",""],[11,"min","","",101],[11,"max","","",101],[1,"IdVisitor","","A visitor that applies its operation to all of the node IDs\nin a visitable thing."],[11,"operation","","",102],[11,"pass_through_items","","",102],[11,"visited_outermost","","",102],[3,"path_name_i","",""],[3,"local_def","",""],[3,"is_local","",""],[3,"stmt_id","",""],[3,"binop_to_string","",""],[3,"lazy_binop","",""],[3,"is_shift_binop","",""],[3,"unop_to_string","",""],[3,"is_path","",""],[3,"int_ty_to_string","","Get a string representation of a signed int type, with its value.\nWe want to avoid \"45int\" and \"-3int\" in favor of \"45\" and \"-3\""],[3,"int_ty_max","",""],[3,"uint_ty_to_string","","Get a string representation of an unsigned int type, with its value.\nWe want to avoid \"42uint\" in favor of \"42u\""],[3,"uint_ty_max","",""],[3,"float_ty_to_string","",""],[3,"is_call_expr","",""],[3,"block_from_expr","",""],[3,"ident_to_path","",""],[3,"ident_to_pat","",""],[3,"name_to_dummy_lifetime","",""],[3,"is_unguarded","",""],[3,"unguarded_pat","",""],[3,"impl_pretty_name","","Generate a \"pretty\" name for an `impl` from its type and trait.\nThis is designed so that symbols of `impl`'d methods give some\nhint of where they came from, (previously they would all just be\nlisted as `__extensions__::method_name::hash`, with no indication\nof the type)."],[3,"trait_method_to_ty_method","","extract a TypeMethod from a TraitMethod. if the TraitMethod is\na default, pull out the useful fields to make a TypeMethod"],[3,"split_trait_methods","",""],[3,"struct_field_visibility","",""],[3,"operator_prec","","Maps a binary operator to its precedence"],[3,"empty_generics","",""],[3,"visit_ids_for_inlined_item","",""],[3,"compute_id_range_for_inlined_item","",""],[3,"compute_id_range_for_fn_body","","Computes the id range for a single fn body,\nignoring nested items."],[3,"is_item_impl","",""],[3,"walk_pat","",""],[3,"view_path_id","",""],[3,"struct_def_is_tuple_like","","Returns true if the given struct def is tuple-like; i.e. that its fields\nare unnamed."],[3,"pat_is_ident","","Returns true if the given pattern consists solely of an identifier\nand false otherwise."],[3,"path_name_eq","",""],[3,"segments_name_eq","",""],[3,"lit_is_str","","Returns true if this literal is a string and false otherwise."],[3,"get_inner_tys","",""],[3,"static_has_significant_address","","Returns true if the static with the given mutability and attributes\nhas a significant address and false otherwise."],[5,"as_prec","","Precedence of the `as` operator, which is a binary operator\nnot appearing in the prior table."],[6,"IdVisitingOperation","",""],[9,"visit_id","","",103],[6,"EachViewItem","",""],[9,"each_view_item","","",104],[6,"PostExpansionMethod","","Macro invocations are guaranteed not to occur after expansion is complete.\nExtracting fields of a method requires a dynamic check to make sure that it's\nnot a macro invocation. This check is guaranteed to succeed, assuming\nthat the invocations are indeed gone."],[9,"pe_ident","","",105],[9,"pe_generics","","",105],[9,"pe_abi","","",105],[9,"pe_explicit_self","","",105],[9,"pe_fn_style","","",105],[9,"pe_fn_decl","","",105],[9,"pe_body","","",105],[9,"pe_vis","","",105],[10,"decode","","",101],[10,"encode","","",101],[10,"max","","",101],[10,"empty","","",101],[10,"add","","",101],[10,"visit_mod","","",102],[10,"visit_view_item","","",102],[10,"visit_foreign_item","","",102],[10,"visit_item","","",102],[10,"visit_local","","",102],[10,"visit_block","","",102],[10,"visit_stmt","","",102],[10,"visit_pat","","",102],[10,"visit_expr","","",102],[10,"visit_ty","","",102],[10,"visit_generics","","",102],[10,"visit_fn","","",102],[10,"visit_struct_field","","",102],[10,"visit_struct_def","","",102],[10,"visit_trait_method","","",102],[10,"each_view_item","syntax::ast","",17],[10,"pe_ident","","",35],[10,"pe_generics","","",35],[10,"pe_abi","","",35],[10,"pe_explicit_self","","",35],[10,"pe_fn_style","","",35],[10,"pe_fn_decl","","",35],[10,"pe_body","","",35],[10,"pe_vis","","",35],[0,"attr","syntax",""],[1,"Stability","syntax::attr","Represents the #[deprecated=\"foo\"] and friends attributes."],[11,"level","","",106],[11,"text","","",106],[2,"InlineAttr","",""],[12,"InlineNone","","",107],[12,"InlineHint","","",107],[12,"InlineAlways","","",107],[12,"InlineNever","","",107],[2,"StabilityLevel","","The available stability levels."],[12,"Deprecated","","",108],[12,"Experimental","","",108],[12,"Unstable","","",108],[12,"Stable","","",108],[12,"Frozen","","",108],[12,"Locked","","",108],[2,"ReprAttr","",""],[12,"ReprAny","","",109],[12,"ReprInt","","",109],[12,"ReprExtern","","",109],[2,"IntType","",""],[12,"SignedInt","","",110],[12,"UnsignedInt","","",110],[3,"mark_used","",""],[3,"is_used","",""],[3,"mk_name_value_item_str","",""],[3,"mk_name_value_item","",""],[3,"mk_list_item","",""],[3,"mk_word_item","",""],[3,"mk_attr_id","",""],[3,"mk_attr_inner","","Returns an inner attribute with the given value."],[3,"mk_attr_outer","","Returns an outer attribute with the given value."],[3,"mk_sugared_doc_attr","",""],[3,"contains","","Check if `needle` occurs in `haystack` by a structural\ncomparison. This is slightly subtle, and relies on ignoring the\nspan included in the `==` comparison a plain MetaItem."],[3,"contains_name","",""],[3,"first_attr_value_str_by_name","",""],[3,"last_meta_item_value_str_by_name","",""],[3,"sort_meta_items","",""],[3,"find_crate_name","",""],[3,"find_inline_attr","","True if something like #[inline] is found in the list of attrs."],[3,"test_cfg","","Tests if any `cfg(...)` meta items in `metas` match `cfg`. e.g."],[3,"find_stability_generic","",""],[3,"find_stability","","Find the first stability attribute. `None` if none exists."],[3,"require_unique_names","",""],[3,"find_repr_attr","","Fold this over attributes to parse #[repr(...)] forms."],[6,"AttrMetaMethods","",""],[10,"check_name","","",111],[9,"name","","Retrieve the name of the meta item, e.g. foo in #[foo],\n#[foo=\"bar\"] and #[foo(bar)]",111],[9,"value_str","","Gets the string value if self is a MetaNameValue variant\ncontaining a string, otherwise None.",111],[9,"meta_item_list","","Gets a list of inner meta items from a list MetaItem type.",111],[6,"AttributeMethods","",""],[9,"meta","","",112],[9,"desugar_doc","","",112],[10,"check_name","","",113],[10,"name","","",113],[10,"value_str","","",113],[10,"meta_item_list","","",113],[10,"name","","",114],[10,"value_str","","",114],[10,"meta_item_list","","",114],[10,"name","std::gc","",115],[10,"value_str","","",115],[10,"meta_item_list","","",115],[10,"meta","syntax::attr","Extract the MetaItem from inside this Attribute.",113],[10,"desugar_doc","","Convert self to a normal #[doc=\"foo\"] comment, if it is a\ncomment like `///` or `/** */`. (Returns self unchanged for\nnon-sugared doc attributes.)",113],[10,"eq","","",107],[10,"ne","","",107],[10,"fmt","","",106],[10,"clone","","",106],[10,"decode","","",106],[10,"encode","","",106],[10,"fmt","","",108],[10,"clone","","",108],[10,"partial_cmp","","",108],[10,"lt","","",108],[10,"le","","",108],[10,"gt","","",108],[10,"ge","","",108],[10,"eq","","",108],[10,"ne","","",108],[10,"decode","","",108],[10,"encode","","",108],[10,"fmt","","",109],[10,"eq","","",109],[10,"ne","","",109],[10,"is_ffi_safe","","",109],[10,"fmt","","",110],[10,"eq","","",110],[10,"ne","","",110],[10,"is_signed","","",110],[0,"codemap","syntax","The CodeMap tracks all the source code used within a single crate, mapping\nfrom integer byte positions to the original source code location. Each bit of\nsource parsed during crate parsing (typically files, in-memory strings, or\nvarious bits of macro expansion) cover a continuous range of bytes in the\nCodeMap and are represented by FileMaps. Byte positions are stored in `spans`\nand used pervasively in the compiler. They are absolute positions within the\nCodeMap, which upon request can be converted to line and column information,\nsource code snippets, etc."],[1,"BytePos","syntax::codemap","A byte offset. Keep this small (currently 32-bits), as AST contains\na lot of them."],[1,"CharPos","","A character offset. Because of multibyte utf8 characters, a byte offset\nis not equivalent to a character offset. The CodeMap will convert BytePos\nvalues to CharPos values as necessary."],[1,"Span","","Spans represent a region of code, used for error reporting. Positions in spans\nare *absolute* positions from the beginning of the codemap, not positions\nrelative to FileMaps. Methods on the CodeMap can be used to relate spans back\nto the original source."],[11,"lo","","",116],[11,"hi","","",116],[11,"expn_info","","Information about where the macro came from, if this piece of\ncode was created by a macro expansion.",116],[1,"Spanned","",""],[11,"node","","",117],[11,"span","","",117],[1,"Loc","","A source code location used for error reporting"],[11,"file","","Information about the original source",118],[11,"line","","The (1-based) line number",118],[11,"col","","The (0-based) column offset",118],[1,"LocWithOpt","","A source code location used as the result of lookup_char_pos_adj"],[11,"filename","","",119],[11,"line","","",119],[11,"col","","",119],[11,"file","","",119],[1,"FileMapAndLine","",""],[11,"fm","","",120],[11,"line","","",120],[1,"FileMapAndBytePos","",""],[11,"fm","","",121],[11,"pos","","",121],[1,"NameAndSpan","",""],[11,"name","","The name of the macro that was invoked to create the thing\nwith this Span.",122],[11,"format","","The format with which the macro was invoked.",122],[11,"span","","The span of the macro definition itself. The macro may not\nhave a sensible definition span (e.g. something defined\ncompletely inside libsyntax) in which case this is None.",122],[1,"ExpnInfo","","Extra information for tracking macro expansion of spans"],[11,"call_site","","The location of the actual macro invocation, e.g. `let x =\nfoo!();`",123],[11,"callee","","Information about the macro and its definition.",123],[1,"FileLines","",""],[11,"file","","",124],[11,"lines","","",124],[1,"MultiByteChar","","Identifies an offset of a multi-byte character in a FileMap"],[11,"pos","","The absolute offset of the character in the CodeMap",125],[11,"bytes","","The number of bytes, >=2",125],[1,"FileMap","","A single source in the CodeMap"],[11,"name","","The name of the file that the source came from, source that doesn't\noriginate from files has names between angle brackets by convention,\ne.g. `<anon>`",126],[11,"src","","The complete source code",126],[11,"start_pos","","The start position of this source in the CodeMap",126],[11,"lines","","Locations of lines beginnings in the source code",126],[11,"multibyte_chars","","Locations of multi-byte characters in the source code",126],[1,"CodeMap","",""],[11,"files","","",127],[2,"MacroFormat","","The syntax with which a macro was invoked."],[12,"MacroAttribute","","e.g. #[deriving(...)] <item>",128],[12,"MacroBang","","e.g. `format!()`",128],[3,"spanned","",""],[3,"respan","",""],[3,"dummy_spanned","",""],[3,"mk_sp","",""],[3,"original_sp","","Return the span itself if it doesn't come from a macro expansion,\notherwise return the call site span up to the `enclosing_sp` by\nfollowing the `expn_info` chain."],[4,"FileName","",""],[5,"DUMMY_SP","",""],[6,"Pos","",""],[9,"from_uint","","",129],[9,"to_uint","","",129],[10,"fmt","","",130],[10,"partial_cmp","","",130],[10,"lt","","",130],[10,"le","","",130],[10,"gt","","",130],[10,"ge","","",130],[10,"hash","","",130],[10,"eq","","",130],[10,"ne","","",130],[10,"clone","","",130],[10,"fmt","","",131],[10,"partial_cmp","","",131],[10,"lt","","",131],[10,"le","","",131],[10,"gt","","",131],[10,"ge","","",131],[10,"hash","","",131],[10,"eq","","",131],[10,"ne","","",131],[10,"from_uint","","",130],[10,"to_uint","","",130],[10,"add","","",130],[10,"sub","","",130],[10,"from_uint","","",131],[10,"to_uint","","",131],[10,"add","","",131],[10,"sub","","",131],[10,"hash","","",116],[10,"fmt","","",116],[10,"clone","","",116],[10,"fmt","","",117],[10,"hash","","",117],[10,"decode","","",117],[10,"encode","","",117],[10,"eq","","",117],[10,"ne","","",117],[10,"clone","","",117],[10,"eq","","",116],[10,"ne","","",116],[10,"encode","","",116],[10,"decode","","",116],[10,"fmt","","",128],[10,"hash","","",128],[10,"clone","","",128],[10,"fmt","","",122],[10,"hash","","",122],[10,"clone","","",122],[10,"fmt","","",123],[10,"hash","","",123],[10,"next_line","","EFFECT: register a start-of-line offset in the\ntable of line-beginnings.\nUNCHECKED INVARIANT: these offsets must be added in the right\norder and must be in the right places; there is shared knowledge\nabout what ends a line between this file and parse.rs\nWARNING: pos param here is the offset relative to start of CodeMap,\nand CodeMap will append a newline when adding a filemap without a newline at the end,\nso the safe way to call this is with value calculated as\nfilemap.start_pos + newline_offset_relative_to_the_start_of_filemap.",126],[10,"get_line","","get a line from the list of pre-computed line-beginnings",126],[10,"record_multibyte_char","","",126],[10,"is_real_file","","",126],[10,"new","","",127],[10,"new_filemap","","",127],[10,"mk_substr_filename","","",127],[10,"lookup_char_pos","","Lookup source information about a BytePos",127],[10,"lookup_char_pos_adj","","",127],[10,"span_to_string","","",127],[10,"span_to_filename","","",127],[10,"span_to_lines","","",127],[10,"span_to_snippet","","",127],[10,"get_filemap","","",127],[10,"lookup_byte_offset","","",127],[10,"bytepos_to_file_charpos","","Converts an absolute BytePos to a CharPos relative to the filemap and above.",127],[0,"crateid","syntax",""],[1,"CrateId","syntax::crateid",""],[11,"path","","A path which represents the codes origin. By convention this is the\nURL, without `http://` or `https://` prefix, to the crate's repository",132],[11,"name","","The name of the crate.",132],[11,"version","","The version of the crate.",132],[10,"eq","","",132],[10,"ne","","",132],[10,"clone","","",132],[10,"fmt","","",132],[10,"from_str","","",132],[10,"version_or_default","","",132],[10,"short_name_with_version","","",132],[10,"matches","","",132],[0,"diagnostic","syntax",""],[1,"FatalError","syntax::diagnostic","This structure is used to signify that a task has failed with a fatal error\nfrom the diagnostics. You can use this with the `Any` trait to figure out\nhow a rustc task died (if so desired)."],[1,"ExplicitBug","","Signifies that the compiler died with an explicit call to `.bug`\nor `.span_bug` rather than a failed assertion, etc."],[1,"SpanHandler","","A span-handler is like a handler but also\naccepts span information for source-location\nreporting."],[11,"handler","","",133],[11,"cm","","",133],[1,"Handler","","A handler deals with errors; certain errors\n(fatal, bug, unimpl) may cause immediate exit,\nothers log errors for later reporting."],[1,"EmitterWriter","",""],[2,"RenderSpan","",""],[12,"FullSpan","","A FullSpan renders with both with an initial line for the\nmessage, prefixed by file:linenum, followed by a summary of\nthe source code covered by the span.",134],[12,"FileLine","","A FileLine renders with just a line for the message prefixed\nby file:linenum.",134],[2,"ColorConfig","",""],[12,"Auto","","",135],[12,"Always","","",135],[12,"Never","","",135],[2,"Level","",""],[12,"Bug","","",136],[12,"Fatal","","",136],[12,"Error","","",136],[12,"Warning","","",136],[12,"Note","","",136],[3,"mk_span_handler","",""],[3,"default_handler","",""],[3,"mk_handler","",""],[3,"expect","",""],[6,"Emitter","",""],[9,"emit","","",137],[9,"custom_emit","","",137],[10,"clone","","",134],[10,"clone","","",135],[10,"span_fatal","","",133],[10,"span_err","","",133],[10,"span_err_with_code","","",133],[10,"span_warn","","",133],[10,"span_warn_with_code","","",133],[10,"span_note","","",133],[10,"span_end_note","","",133],[10,"fileline_note","","",133],[10,"span_bug","","",133],[10,"span_unimpl","","",133],[10,"handler","","",133],[10,"fatal","","",138],[10,"err","","",138],[10,"bump_err_count","","",138],[10,"err_count","","",138],[10,"has_errors","","",138],[10,"abort_if_errors","","",138],[10,"warn","","",138],[10,"note","","",138],[10,"bug","","",138],[10,"unimpl","","",138],[10,"emit","","",138],[10,"emit_with_code","","",138],[10,"custom_emit","","",138],[10,"eq","","",136],[10,"ne","","",136],[10,"fmt","","",136],[10,"stderr","","",139],[10,"new","","",139],[10,"emit","","",139],[10,"custom_emit","","",139],[0,"fold","syntax","A Folder represents an AST->AST fold; it accepts an AST piece,\nand returns a piece of the same type. So, for instance, macro\nexpansion is a Folder that walks over an AST and produces another\nAST."],[3,"noop_fold_meta_items","syntax::fold",""],[3,"noop_fold_view_path","",""],[3,"noop_fold_arm","",""],[3,"noop_fold_decl","",""],[3,"noop_fold_ty","",""],[3,"noop_fold_foreign_mod","",""],[3,"noop_fold_variant","",""],[3,"noop_fold_ident","",""],[3,"noop_fold_path","",""],[3,"noop_fold_local","",""],[3,"noop_fold_attribute","",""],[3,"noop_fold_explicit_self_underscore","",""],[3,"noop_fold_explicit_self","",""],[3,"noop_fold_mac","",""],[3,"noop_fold_meta_item","",""],[3,"noop_fold_arg","",""],[3,"noop_fold_tt","",""],[3,"noop_fold_tts","",""],[3,"noop_fold_token","",""],[3,"noop_fold_interpolated","","apply folder to elements of interpolated nodes"],[3,"noop_fold_fn_decl","",""],[3,"noop_fold_ty_param_bound","",""],[3,"noop_fold_ty_param","",""],[3,"noop_fold_ty_params","",""],[3,"noop_fold_lifetime","",""],[3,"noop_fold_lifetimes","",""],[3,"noop_fold_opt_lifetime","",""],[3,"noop_fold_generics","",""],[3,"noop_fold_struct_def","",""],[3,"noop_fold_trait_ref","",""],[3,"noop_fold_struct_field","",""],[3,"noop_fold_field","",""],[3,"noop_fold_mt","",""],[3,"noop_fold_opt_bounds","",""],[3,"noop_fold_variant_arg","",""],[3,"noop_fold_view_item","",""],[3,"noop_fold_block","",""],[3,"noop_fold_item_underscore","",""],[3,"noop_fold_type_method","",""],[3,"noop_fold_mod","",""],[3,"noop_fold_crate","",""],[3,"noop_fold_item","",""],[3,"noop_fold_item_simple","",""],[3,"noop_fold_foreign_item","",""],[3,"noop_fold_method","",""],[3,"noop_fold_pat","",""],[3,"noop_fold_expr","",""],[3,"noop_fold_stmt","",""],[6,"Folder","",""],[10,"fold_crate","","",140],[10,"fold_meta_items","","",140],[10,"fold_meta_item","","",140],[10,"fold_view_path","","",140],[10,"fold_view_item","","",140],[10,"fold_foreign_item","","",140],[10,"fold_item","","",140],[10,"fold_item_simple","","",140],[10,"fold_struct_field","","",140],[10,"fold_item_underscore","","",140],[10,"fold_fn_decl","","",140],[10,"fold_type_method","","",140],[10,"fold_method","","",140],[10,"fold_block","","",140],[10,"fold_stmt","","",140],[10,"fold_arm","","",140],[10,"fold_pat","","",140],[10,"fold_decl","","",140],[10,"fold_expr","","",140],[10,"fold_ty","","",140],[10,"fold_mod","","",140],[10,"fold_foreign_mod","","",140],[10,"fold_variant","","",140],[10,"fold_ident","","",140],[10,"fold_path","","",140],[10,"fold_local","","",140],[10,"fold_mac","","",140],[10,"fold_explicit_self","","",140],[10,"fold_explicit_self_underscore","","",140],[10,"fold_lifetime","","",140],[10,"fold_attribute","","",140],[10,"fold_arg","","",140],[10,"fold_generics","","",140],[10,"fold_trait_ref","","",140],[10,"fold_struct_def","","",140],[10,"fold_lifetimes","","",140],[10,"fold_ty_param","","",140],[10,"fold_ty_params","","",140],[10,"fold_tt","","",140],[10,"fold_tts","","",140],[10,"fold_token","","",140],[10,"fold_interpolated","","",140],[10,"fold_opt_lifetime","","",140],[10,"fold_variant_arg","","",140],[10,"fold_ty_param_bound","","",140],[10,"fold_opt_bounds","","",140],[10,"fold_mt","","",140],[10,"fold_field","","",140],[10,"map_exprs","","",140],[10,"new_id","","",140],[10,"new_span","","",140],[0,"owned_slice","syntax",""],[1,"OwnedSlice","syntax::owned_slice","A non-growable owned slice. This would preferably become `~[T]`\nunder DST."],[10,"fmt","","",141],[10,"drop","","",141],[10,"empty","","",141],[10,"from_vec","","",141],[10,"into_vec","","",141],[10,"as_slice","","",141],[10,"get","","",141],[10,"iter","","",141],[10,"map","","",141],[10,"default","","",141],[10,"clone","","",141],[10,"hash","","",141],[10,"eq","","",141],[10,"len","","",141],[10,"from_iter","","",141],[10,"encode","","",141],[10,"decode","","",141],[0,"parse","syntax","The main parser interface"],[1,"ParseSess","syntax::parse","Info about a parsing session."],[11,"span_diagnostic","","",142],[3,"new_parse_sess","",""],[3,"new_parse_sess_special_handler","",""],[3,"parse_crate_from_file","",""],[3,"parse_crate_attrs_from_file","",""],[3,"parse_crate_from_source_str","",""],[3,"parse_crate_attrs_from_source_str","",""],[3,"parse_expr_from_source_str","",""],[3,"parse_item_from_source_str","",""],[3,"parse_meta_from_source_str","",""],[3,"parse_stmt_from_source_str","",""],[3,"parse_tts_from_source_str","",""],[3,"new_parser_from_source_str","",""],[3,"new_parser_from_file","","Create a new parser, handling errors as appropriate\nif the file doesn't exist"],[3,"new_sub_parser_from_file","","Given a session, a crate config, a path, and a span, add\nthe file at the given path to the codemap, and return a parser.\nOn an error, use the given span as the source of the problem."],[3,"filemap_to_parser","","Given a filemap and config, return a parser"],[3,"new_parser_from_tts","",""],[3,"file_to_filemap","","Given a session and a path and an optional span (for error reporting),\nadd the path to the session's codemap and return the new filemap."],[3,"string_to_filemap","","Given a session and a string, add the string to\nthe session's codemap and return the new filemap"],[3,"filemap_to_tts","","Given a filemap, produce a sequence of token-trees"],[3,"tts_to_parser","","Given tts and cfg, produce a parser"],[3,"maybe_aborted","","Abort if necessary"],[3,"char_lit","","Parse a string representing a character literal into its final form.\nRather than just accepting/rejecting a given literal, unescapes it as\nwell. Can take any slice prefixed by a character escape. Returns the\ncharacter and the number of characters consumed."],[3,"str_lit","","Parse a string representing a string literal into its final form. Does\nunescaping."],[3,"raw_str_lit","","Parse a string representing a raw string literal into its final form. The\nonly operation this does is convert embedded CRLF into a single LF."],[3,"float_lit","",""],[3,"byte_lit","","Parse a string representing a byte literal into its final form. Similar to `char_lit`"],[3,"binary_lit","",""],[3,"integer_lit","",""],[0,"lexer","",""],[1,"TokenAndSpan","syntax::parse::lexer",""],[11,"tok","","",143],[11,"sp","","",143],[1,"StringReader","",""],[11,"span_diagnostic","","",144],[11,"pos","","The absolute offset within the codemap of the next character to read",144],[11,"last_pos","","The absolute offset within the codemap of the last character read(curr)",144],[11,"col","","The column of the next character to read",144],[11,"curr","","The last character to be read",144],[11,"filemap","","",144],[11,"peek_tok","","",144],[11,"peek_span","","",144],[3,"is_whitespace","",""],[3,"is_doc_comment","",""],[3,"is_block_doc_comment","",""],[0,"comments","",""],[1,"Comment","syntax::parse::lexer::comments",""],[11,"style","","",145],[11,"lines","","",145],[11,"pos","","",145],[1,"Literal","",""],[11,"lit","","",146],[11,"pos","","",146],[2,"CommentStyle","",""],[12,"Isolated","","No code on either side of each line of the comment",147],[12,"Trailing","","Code exists to the left of the comment",147],[12,"Mixed","","Code before /* foo */ and after the comment",147],[12,"BlankLine","","Just a manual blank line \"\\n\\n\", for layout",147],[3,"is_doc_comment","",""],[3,"doc_comment_style","",""],[3,"strip_doc_comment_decoration","",""],[3,"gather_comments_and_literals","",""],[10,"eq","","",147],[10,"ne","","",147],[10,"clone","","",147],[10,"clone","","",145],[10,"clone","","",146],[6,"Reader","syntax::parse::lexer",""],[9,"is_eof","","",148],[9,"next_token","","",148],[9,"fatal","","Report a fatal error with the current span.",148],[9,"err","","Report a non-fatal error with the current span.",148],[9,"peek","","",148],[10,"fmt","","",143],[10,"eq","","",143],[10,"ne","","",143],[10,"clone","","",143],[10,"is_eof","","",144],[10,"next_token","","Return the next token. EFFECT: advances the string_reader.",144],[10,"fatal","","",144],[10,"err","","",144],[10,"peek","","",144],[10,"new_raw","","For comments.rs, which hackily pokes into pos and curr",144],[10,"new","","",144],[10,"curr_is","","",144],[10,"fatal_span","","Report a fatal lexical error with a given span.",144],[10,"err_span","","Report a lexical error with a given span.",144],[10,"with_str_from","","Calls `f` with a string slice of the source text spanning from `start`\nup to but excluding `self.last_pos`, meaning the slice does not include\nthe character `self.curr`.",144],[10,"name_from","","Create a Name from a given offset to the current offset, each\nadjusted 1 towards each other (assumes that on either side there is a\nsingle-byte delimiter).",144],[10,"name_from_to","","As name_from, with an explicit endpoint.",144],[10,"bump","","Advance the StringReader by one character. If a newline is\ndiscovered, add it to the FileMap's list of line start offsets.",144],[10,"nextch","","",144],[10,"nextch_is","","",144],[10,"nextnextch","","",144],[10,"nextnextch_is","","",144],[0,"parser","syntax::parse",""],[1,"PathAndBounds","syntax::parse::parser","A path paired with optional type bounds."],[11,"path","","",149],[11,"bounds","","",149],[1,"Parser","",""],[11,"sess","","",150],[11,"token","","the current token:",150],[11,"span","","the span of the current token:",150],[11,"last_span","","the span of the prior token:",150],[11,"cfg","","",150],[11,"last_token","","the previous token or None (only stashed sometimes).",150],[11,"buffer","","",150],[11,"buffer_start","","",150],[11,"buffer_end","","",150],[11,"tokens_consumed","","",150],[11,"restriction","","",150],[11,"quote_depth","","",150],[11,"reader","","",150],[11,"interner","","",150],[11,"obsolete_set","","The set of seen errors about obsolete syntax. Used to suppress\nextra detail when the same error is seen twice",150],[11,"mod_path_stack","","Used to determine the path to externally loaded source files",150],[11,"open_braces","","Stack of spans of open delimiters. Used for error message.",150],[11,"owns_directory","","Flag if this parser \"owns\" the directory that it is currently parsing\nin. This will affect how nested files are looked up.",150],[11,"root_module_name","","Name of the root module this parser originated from. If `None`, then the\nname is not known. This does not change while the parser is descending\ninto modules, and sub-parsers have new values for this name.",150],[2,"restriction","",""],[12,"UNRESTRICTED","","",151],[12,"RESTRICT_STMT_EXPR","","",151],[12,"RESTRICT_NO_BAR_OP","","",151],[12,"RESTRICT_NO_BAR_OR_DOUBLEBAR_OP","","",151],[12,"RESTRICT_NO_STRUCT_LITERAL","","",151],[2,"PathParsingMode","","How to parse a path. There are four different kinds of paths, all of which\nare parsed somewhat differently."],[12,"NoTypesAllowed","","A path with no type parameters; e.g. `foo::bar::Baz`",152],[12,"LifetimeAndTypesWithoutColons","","A path with a lifetime and type parameters, with no double colons\nbefore the type parameters; e.g. `foo::bar<'a>::Baz<T>`",152],[12,"LifetimeAndTypesWithColons","","A path with a lifetime and type parameters with double colons before\nthe type parameters; e.g. `foo::bar::<'a>::Baz::<T>`",152],[12,"LifetimeAndTypesAndBounds","","A path with a lifetime and type parameters with bounds before the last\nset of type parameters only; e.g. `foo::bar<'a>::Baz+X+Y<T>` This\nform does not use extra double colons.",152],[10,"eq","","",151],[10,"ne","","",151],[10,"eq","","",152],[10,"ne","","",152],[10,"new","","",150],[10,"token_to_string","","Convert a token to a string using self's reader",150],[10,"this_token_to_string","","Convert the current token to a string using self's reader",150],[10,"unexpected_last","","",150],[10,"unexpected","","",150],[10,"expect","","Expect and consume the token t. Signal an error if\nthe next token is not t.",150],[10,"expect_one_of","","Expect next token to be edible or inedible token.  If edible,\nthen consume it; if inedible, then return without consuming\nanything.  Signal a fatal error if next token is unexpected.",150],[10,"check_for_erroneous_unit_struct_expecting","","Check for erroneous `ident { }`; if matches, signal error and\nrecover (without consuming any expected input token).  Returns\ntrue if and only if input was consumed for recovery.",150],[10,"commit_expr","","Commit to parsing a complete expression `e` expected to be\nfollowed by some token from the set edible + inedible.  Recover\nfrom anticipated input errors, discarding erroneous characters.",150],[10,"commit_expr_expecting","","",150],[10,"commit_stmt","","Commit to parsing a complete statement `s`, which expects to be\nfollowed by some token from the set edible + inedible.  Check\nfor recoverable input errors, discarding erroneous characters.",150],[10,"commit_stmt_expecting","","",150],[10,"parse_ident","","",150],[10,"parse_path_list_item","","",150],[10,"eat","","Consume token 'tok' if it exists. Returns true if the given\ntoken was present, false otherwise.",150],[10,"is_keyword","","",150],[10,"eat_keyword","","If the next token is the given keyword, eat it and return\ntrue. Otherwise, return false.",150],[10,"expect_keyword","","If the given word is not a keyword, signal an error.\nIf the next token is not the given word, signal an error.\nOtherwise, eat it.",150],[10,"check_strict_keywords","","Signal an error if the given string is a strict keyword",150],[10,"check_reserved_keywords","","Signal an error if the current token is a reserved keyword",150],[10,"expect_gt","","Expect and consume a GT. if a >> is seen, replace it\nwith a single > and continue. If a GT is not seen,\nsignal an error.",150],[10,"parse_seq_to_before_gt","","Parse a sequence bracketed by '<' and '>', stopping\nbefore the '>'.",150],[10,"parse_seq_to_gt","","",150],[10,"parse_seq_to_end","","Parse a sequence, including the closing delimiter. The function\nf must consume tokens until reaching the next separator or\nclosing bracket.",150],[10,"parse_seq_to_before_end","","Parse a sequence, not including the closing delimiter. The function\nf must consume tokens until reaching the next separator or\nclosing bracket.",150],[10,"parse_unspanned_seq","","Parse a sequence, including the closing delimiter. The function\nf must consume tokens until reaching the next separator or\nclosing bracket.",150],[10,"parse_enum_variant_seq","","Parse a sequence parameter of enum variant. For consistency purposes,\nthese should not be empty.",150],[10,"parse_seq","","",150],[10,"bump","","Advance the parser by one token",150],[10,"bump_and_get","","Advance the parser by one token and return the bumped token.",150],[10,"replace_token","","EFFECT: replace the current token and span with the given one",150],[10,"buffer_length","","",150],[10,"look_ahead","","",150],[10,"fatal","","",150],[10,"span_fatal","","",150],[10,"span_note","","",150],[10,"bug","","",150],[10,"warn","","",150],[10,"span_warn","","",150],[10,"span_err","","",150],[10,"abort_if_errors","","",150],[10,"id_to_interned_str","","",150],[10,"token_is_bare_fn_keyword","","Is the current token one of the keywords that signals a bare function\ntype?",150],[10,"token_is_closure_keyword","","Is the current token one of the keywords that signals a closure type?",150],[10,"token_is_old_style_closure_keyword","","Is the current token one of the keywords that signals an old-style\nclosure type (with explicit sigil)?",150],[10,"token_is_lifetime","","",150],[10,"get_lifetime","","",150],[10,"parse_ty_bare_fn","","parse a TyBareFn type:",150],[10,"parse_proc_type","","Parses a procedure type (`proc`). The initial `proc` keyword must\nalready have been parsed.",150],[10,"parse_ty_closure","","Parse a TyClosure type",150],[10,"parse_unsafety","","",150],[10,"parse_ty_fn_decl","","Parse a function type (following the 'fn')",150],[10,"parse_trait_methods","","Parse the methods in a trait declaration",150],[10,"parse_mt","","Parse a possibly mutable type",150],[10,"parse_ty_field","","Parse [mut/const/imm] ID : TY\nnow used only by obsolete record syntax parser...",150],[10,"parse_ret_ty","","Parse optional return type [ -> TY ] in function decl",150],[10,"parse_ty","","Parse a type.",150],[10,"parse_borrowed_pointee","","",150],[10,"parse_ptr","","",150],[10,"is_named_argument","","",150],[10,"parse_arg_general","","This version of parse arg doesn't necessarily require\nidentifier names.",150],[10,"parse_arg","","Parse a single function argument",150],[10,"parse_fn_block_arg","","Parse an argument in a lambda header e.g. |arg, arg|",150],[10,"maybe_parse_fixed_vstore","","",150],[10,"lit_from_token","","Matches token_lit = LIT_INTEGER | ...",150],[10,"parse_lit","","Matches lit = true | false | token_lit",150],[10,"parse_literal_maybe_minus","","matches '-' lit | lit",150],[10,"parse_path","","Parses a path and optional type parameter bounds, depending on the\nmode. The `mode` parameter determines whether lifetimes, types, and/or\nbounds are permitted and whether `::` must precede type parameter\ngroups.",150],[10,"parse_opt_lifetime","","parses 0 or 1 lifetime",150],[10,"parse_lifetime","","Parses a single lifetime\nMatches lifetime = LIFETIME",150],[10,"parse_lifetimes","","\nParses zero or more comma separated lifetimes.\nExpects each lifetime to be followed by either\na comma or `>`.  Used when parsing type parameter\nlists, where we expect something like `<'a, 'b, T>`.",150],[10,"token_is_mutability","","",150],[10,"parse_mutability","","Parse mutability declaration (mut/const/imm)",150],[10,"parse_field","","Parse ident COLON expr",150],[10,"mk_expr","","",150],[10,"mk_unary","","",150],[10,"mk_binary","","",150],[10,"mk_call","","",150],[10,"mk_index","","",150],[10,"mk_field","","",150],[10,"mk_assign_op","","",150],[10,"mk_mac_expr","","",150],[10,"mk_lit_u32","","",150],[10,"parse_bottom_expr","","At the bottom (top?) of the precedence hierarchy,\nparse things like parenthesized exprs,\nmacros, return, etc.",150],[10,"parse_block_expr","","Parse a block or unsafe block",150],[10,"parse_dot_or_call_expr","","parse a.b or a(13) or a[4] or just a",150],[10,"parse_dot_or_call_expr_with","","",150],[10,"parse_sep_and_zerok","","Parse an optional separator followed by a kleene-style\nrepetition token (+ or *).",150],[10,"parse_token_tree","","parse a single token tree from the input.",150],[10,"parse_all_token_trees","","",150],[10,"parse_matchers","","",150],[10,"parse_matcher_subseq_upto","","This goofy function is necessary to correctly match parens in Matcher's.\nOtherwise, `$( ( )` would be a valid Matcher, and `$( () )` would be\ninvalid. It's similar to common::parse_seq.",150],[10,"parse_matcher","","",150],[10,"parse_prefix_expr","","Parse a prefix-operator expr",150],[10,"parse_binops","","Parse an expression of binops",150],[10,"parse_more_binops","","Parse an expression of binops of at least min_prec precedence",150],[10,"parse_assign_expr","","Parse an assignment expression....\nactually, this seems to be the main entry point for\nparsing an arbitrary expression.",150],[10,"parse_if_expr","","Parse an 'if' expression ('if' token already eaten)",150],[10,"parse_lambda_expr","","",150],[10,"parse_else_expr","","",150],[10,"parse_for_expr","","Parse a 'for' .. 'in' expression ('for' token already eaten)",150],[10,"parse_while_expr","","",150],[10,"parse_loop_expr","","",150],[10,"parse_arm","","",150],[10,"parse_expr","","Parse an expression",150],[10,"parse_expr_res","","Parse an expression, subject to the given restriction",150],[10,"parse_pat","","Parse a pattern.",150],[10,"parse_stmt","","Parse a statement. may include decl.\nPrecondition: any attributes are parsed already",150],[10,"parse_block","","Parse a block. No inner attrs are allowed.",150],[10,"parse_generics","","Parse a set of optional generic type parameter declarations\nmatches generics = ( ) | ( < > ) | ( < typaramseq ( , )? > ) | ( < lifetimes ( , )? > )\n                 | ( < lifetimes , typaramseq ( , )? > )\nwhere   typaramseq = ( typaram ) | ( typaram , typaramseq )",150],[10,"parse_fn_decl","","Parse the argument list and result type of a function declaration",150],[10,"parse_method","","Parse a method in a trait impl, starting with `attrs` attributes.",150],[10,"parse_single_struct_field","","Parse a structure field declaration",150],[10,"parse_item_with_outer_attributes","","",150],[10,"parse_item","","",150],[10,"parse_crate_mod","","Parses a source module as a crate. This is the main\nentry point for the parser.",150],[10,"parse_optional_str","","",150],[10,"parse_str","","",150],[0,"token","syntax::parse",""],[1,"InternedString","syntax::parse::token","Represents a string stored in the task-local interner. Because the\ninterner lives for the life of the task, this can be safely treated as an\nimmortal string, as long as it never crosses between tasks."],[2,"BinOp","",""],[12,"PLUS","","",153],[12,"MINUS","","",153],[12,"STAR","","",153],[12,"SLASH","","",153],[12,"PERCENT","","",153],[12,"CARET","","",153],[12,"AND","","",153],[12,"OR","","",153],[12,"SHL","","",153],[12,"SHR","","",153],[2,"Token","",""],[12,"EQ","","",154],[12,"LT","","",154],[12,"LE","","",154],[12,"EQEQ","","",154],[12,"NE","","",154],[12,"GE","","",154],[12,"GT","","",154],[12,"ANDAND","","",154],[12,"OROR","","",154],[12,"NOT","","",154],[12,"TILDE","","",154],[12,"BINOP","","",154],[12,"BINOPEQ","","",154],[12,"AT","","",154],[12,"DOT","","",154],[12,"DOTDOT","","",154],[12,"DOTDOTDOT","","",154],[12,"COMMA","","",154],[12,"SEMI","","",154],[12,"COLON","","",154],[12,"MOD_SEP","","",154],[12,"RARROW","","",154],[12,"LARROW","","",154],[12,"FAT_ARROW","","",154],[12,"LPAREN","","",154],[12,"RPAREN","","",154],[12,"LBRACKET","","",154],[12,"RBRACKET","","",154],[12,"LBRACE","","",154],[12,"RBRACE","","",154],[12,"POUND","","",154],[12,"DOLLAR","","",154],[12,"QUESTION","","",154],[12,"LIT_BYTE","","",154],[12,"LIT_CHAR","","",154],[12,"LIT_INTEGER","","",154],[12,"LIT_FLOAT","","",154],[12,"LIT_STR","","",154],[12,"LIT_STR_RAW","","",154],[12,"LIT_BINARY","","",154],[12,"LIT_BINARY_RAW","","",154],[12,"IDENT","","An identifier contains an \"is_mod_name\" boolean,\nindicating whether :: follows this token with no\nwhitespace in between.",154],[12,"UNDERSCORE","","",154],[12,"LIFETIME","","",154],[12,"INTERPOLATED","","",154],[12,"DOC_COMMENT","","",154],[12,"WS","","Whitespace",154],[12,"COMMENT","","Comment",154],[12,"SHEBANG","","",154],[12,"EOF","","",154],[2,"Nonterminal","","For interpolation during macro expansion."],[12,"NtItem","","",155],[12,"NtBlock","","",155],[12,"NtStmt","","",155],[12,"NtPat","","",155],[12,"NtExpr","","",155],[12,"NtTy","","",155],[12,"NtIdent","","See IDENT, above, for meaning of bool in NtIdent:",155],[12,"NtMeta","","Stuff inside brackets for attributes",155],[12,"NtPath","","",155],[12,"NtTT","","",155],[12,"NtMatchers","","",155],[3,"binop_to_string","",""],[3,"to_string","",""],[3,"can_begin_expr","",""],[3,"close_delimiter_for","","Returns the matching close delimiter if this is an open delimiter,\notherwise `None`."],[3,"is_lit","",""],[3,"is_ident","",""],[3,"is_ident_or_path","",""],[3,"is_plain_ident","",""],[3,"token_to_binop","","Maps a token to a record specifying the corresponding binary\noperator"],[3,"get_ident_interner","",""],[3,"get_name","","Returns the string contents of a name, using the task-local interner."],[3,"get_ident","","Returns the string contents of an identifier, using the task-local\ninterner."],[3,"intern_and_get_ident","","Interns and returns the string contents of an identifier, using the\ntask-local interner."],[3,"intern","","Maps a string to its interned representation."],[3,"gensym","","gensym's a new uint, using the current interner."],[3,"str_to_ident","","Maps a string to an identifier with an empty syntax context."],[3,"gensym_ident","","Maps a string to a gensym'ed identifier."],[3,"fresh_name","",""],[3,"fresh_mark","",""],[3,"is_keyword","",""],[3,"is_any_keyword","",""],[3,"is_strict_keyword","",""],[3,"is_reserved_keyword","",""],[3,"mtwt_token_eq","",""],[0,"special_idents","",""],[5,"invalid","syntax::parse::token::special_idents",""],[5,"self_","",""],[5,"statik","",""],[5,"static_lifetime","",""],[5,"tt","",""],[5,"matchers","",""],[5,"clownshoe_abi","",""],[5,"opaque","",""],[5,"unnamed_field","",""],[5,"type_self","",""],[0,"special_names","syntax::parse::token",""],[5,"invalid","syntax::parse::token::special_names",""],[5,"self_","",""],[5,"statik","",""],[5,"static_lifetime","",""],[5,"tt","",""],[5,"matchers","",""],[5,"clownshoe_abi","",""],[5,"opaque","",""],[5,"unnamed_field","",""],[5,"type_self","",""],[0,"keywords","syntax::parse::token","All the valid words that have meaning in the Rust language."],[2,"Keyword","syntax::parse::token::keywords",""],[12,"As","","",156],[12,"Break","","",156],[12,"Crate","","",156],[12,"Else","","",156],[12,"Enum","","",156],[12,"Extern","","",156],[12,"False","","",156],[12,"Fn","","",156],[12,"For","","",156],[12,"If","","",156],[12,"Impl","","",156],[12,"In","","",156],[12,"Let","","",156],[12,"Loop","","",156],[12,"Match","","",156],[12,"Mod","","",156],[12,"Mut","","",156],[12,"Once","","",156],[12,"Pub","","",156],[12,"Ref","","",156],[12,"Return","","",156],[12,"Static","","",156],[12,"Self","","",156],[12,"Struct","","",156],[12,"Super","","",156],[12,"True","","",156],[12,"Trait","","",156],[12,"Type","","",156],[12,"Unsafe","","",156],[12,"Use","","",156],[12,"Virtual","","",156],[12,"While","","",156],[12,"Continue","","",156],[12,"Proc","","",156],[12,"Box","","",156],[12,"Const","","",156],[12,"Alignof","","",156],[12,"Be","","",156],[12,"Offsetof","","",156],[12,"Priv","","",156],[12,"Pure","","",156],[12,"Sizeof","","",156],[12,"Typeof","","",156],[12,"Unsized","","",156],[12,"Yield","","",156],[12,"Do","","",156],[10,"to_name","","",156],[4,"IdentInterner","syntax::parse::token",""],[5,"SELF_KEYWORD_NAME","",""],[5,"SELF_KEYWORD_NAME_NUM","",""],[10,"fmt","","",153],[10,"hash","","",153],[10,"eq","","",153],[10,"ne","","",153],[10,"decode","","",153],[10,"encode","","",153],[10,"clone","","",153],[10,"fmt","","",154],[10,"hash","","",154],[10,"eq","","",154],[10,"ne","","",154],[10,"decode","","",154],[10,"encode","","",154],[10,"clone","","",154],[10,"hash","","",155],[10,"eq","","",155],[10,"ne","","",155],[10,"decode","","",155],[10,"encode","","",155],[10,"clone","","",155],[10,"fmt","","",155],[10,"cmp","","",157],[10,"partial_cmp","","",157],[10,"lt","","",157],[10,"le","","",157],[10,"gt","","",157],[10,"ge","","",157],[10,"hash","","",157],[10,"eq","","",157],[10,"ne","","",157],[10,"clone","","",157],[10,"new","","",157],[10,"get","","",157],[10,"container_as_bytes","","",157],[10,"fmt","","",157],[10,"equiv","","",157],[10,"decode","","",157],[10,"encode","","",157],[0,"attr","syntax::parse",""],[6,"ParserAttr","syntax::parse::attr","A parser that can parse attributes."],[9,"parse_outer_attributes","","",158],[9,"parse_attribute","","",158],[9,"parse_inner_attrs_and_next","","",158],[9,"parse_meta_item","","",158],[9,"parse_meta_seq","","",158],[9,"parse_optional_meta","","",158],[10,"parse_outer_attributes","syntax::parse::parser","Parse attributes that appear before an item",150],[10,"parse_attribute","","Matches `attribute = # ! [ meta_item ]`",150],[10,"parse_inner_attrs_and_next","","Parse attributes that appear after the opening of an item. These should\nbe preceded by an exclamation mark, but we accept and warn about one\nterminated by a semicolon. In addition to a vector of inner attributes,\nthis function also returns a vector that may contain the first outer\nattribute of the next item (since we can't know whether the attribute\nis an inner attribute of the containing item or an outer attribute of\nthe first contained item until we see the semi).\nmatches inner_attrs* outer_attr?\nyou can make the 'next' field an Option, but the result is going to be\nmore useful as a vector.",150],[10,"parse_meta_item","","matches meta_item = IDENT\n| IDENT = lit\n| IDENT meta_seq",150],[10,"parse_meta_seq","","matches meta_seq = ( COMMASEP(meta_item) )",150],[10,"parse_optional_meta","","",150],[0,"common","syntax::parse","Common routines shared by parser mods"],[1,"SeqSep","syntax::parse::common","SeqSep : a sequence separator (token)\nand whether a trailing separator is allowed."],[11,"sep","","",159],[11,"trailing_sep_allowed","","",159],[3,"seq_sep_trailing_disallowed","",""],[3,"seq_sep_trailing_allowed","",""],[3,"seq_sep_none","",""],[0,"classify","syntax::parse","Routines the parser uses to classify AST nodes"],[3,"expr_requires_semi_to_be_stmt","syntax::parse::classify","Does this expression require a semicolon to be treated\nas a statement? The negation of this: 'can this expression\nbe used as a statement without a semicolon' -- is used\nas an early-bail-out in the parser so that, for instance,\n    if true {...} else {...}\n     |x| 5\nisn't parsed as (if true {...} else {...} | x) | 5"],[3,"expr_is_simple_block","",""],[3,"stmt_ends_with_semi","","this statement requires a semicolon after it.\nnote that in one case (stmt_semi), we've already\nseen the semicolon, and thus don't need another."],[0,"obsolete","syntax::parse","Support for parsing unsupported, old syntaxes, for the\npurpose of reporting errors. Parsing of these syntaxes\nis tested by compile-test/obsolete-syntax.rs."],[2,"ObsoleteSyntax","syntax::parse::obsolete","The specific types of unsupported syntax"],[12,"ObsoleteOwnedType","","",160],[12,"ObsoleteOwnedExpr","","",160],[12,"ObsoleteOwnedPattern","","",160],[12,"ObsoleteOwnedVector","","",160],[12,"ObsoleteOwnedSelf","","",160],[12,"ObsoleteManagedType","","",160],[12,"ObsoleteManagedExpr","","",160],[6,"ParserObsoleteMethods","",""],[9,"obsolete","","Reports an obsolete syntax non-fatal error.",161],[9,"obsolete_expr","","Reports an obsolete syntax non-fatal error, and returns\na placeholder expression",161],[9,"report","","",161],[9,"is_obsolete_ident","","",161],[9,"eat_obsolete_ident","","",161],[10,"hash","","",160],[10,"eq","","",160],[10,"ne","","",160],[10,"obsolete","syntax::parse::parser","Reports an obsolete syntax non-fatal error.",150],[10,"obsolete_expr","","Reports an obsolete syntax non-fatal error, and returns\na placeholder expression",150],[10,"report","","",150],[10,"is_obsolete_ident","","",150],[10,"eat_obsolete_ident","","",150],[0,"visit","syntax","Context-passing AST walker. Each overridden visit method has full control\nover what happens with its node, it can do its own traversal of the node's\nchildren (potentially passing in different contexts to each), call\n`visit::visit_*` to apply the default traversal algorithm (again, it can\noverride the context), or prevent deeper traversal by doing nothing."],[2,"FnKind","syntax::visit",""],[12,"FkItemFn","","fn foo() or extern \"Abi\" fn foo()",162],[12,"FkMethod","","fn foo(&self)",162],[12,"FkFnBlock","","|x, y| ...\nproc(x, y) ...",162],[3,"name_of_fn","",""],[3,"generics_of_fn","",""],[3,"walk_inlined_item","",""],[3,"walk_crate","",""],[3,"walk_mod","",""],[3,"walk_view_item","",""],[3,"walk_local","",""],[3,"walk_explicit_self","",""],[3,"walk_trait_ref_helper","","Like with walk_method_helper this doesn't correspond to a method\nin Visitor, and so it gets a _helper suffix."],[3,"walk_item","",""],[3,"walk_enum_def","",""],[3,"walk_variant","",""],[3,"skip_ty","",""],[3,"walk_ty","",""],[3,"walk_path","",""],[3,"walk_pat","",""],[3,"walk_foreign_item","",""],[3,"walk_ty_param_bounds","",""],[3,"walk_generics","",""],[3,"walk_fn_decl","",""],[3,"walk_method_helper","",""],[3,"walk_fn","",""],[3,"walk_ty_method","",""],[3,"walk_trait_method","",""],[3,"walk_struct_def","",""],[3,"walk_struct_field","",""],[3,"walk_block","",""],[3,"walk_stmt","",""],[3,"walk_decl","",""],[3,"walk_expr_opt","",""],[3,"walk_exprs","",""],[3,"walk_mac","",""],[3,"walk_expr","",""],[3,"walk_arm","",""],[6,"Visitor","","Each method of the Visitor trait is a hook to be potentially\noverridden.  Each method's default implementation recursively visits\nthe substructure of the input via the corresponding `walk` method;\ne.g. the `visit_mod` method by default calls `visit::walk_mod`."],[10,"visit_ident","","Visit the idents",163],[10,"visit_mod","","",163],[10,"visit_view_item","","",163],[10,"visit_foreign_item","","",163],[10,"visit_item","","",163],[10,"visit_local","","",163],[10,"visit_block","","",163],[10,"visit_stmt","","",163],[10,"visit_arm","","",163],[10,"visit_pat","","",163],[10,"visit_decl","","",163],[10,"visit_expr","","",163],[10,"visit_expr_post","","",163],[10,"visit_ty","","",163],[10,"visit_generics","","",163],[10,"visit_fn","","",163],[10,"visit_ty_method","","",163],[10,"visit_trait_method","","",163],[10,"visit_struct_def","","",163],[10,"visit_struct_field","","",163],[10,"visit_variant","","",163],[10,"visit_opt_lifetime_ref","","Visits an optional reference to a lifetime. The `span` is\nthe span of some surrounding reference should opt_lifetime\nbe None.",163],[10,"visit_lifetime_ref","","Visits a reference to a lifetime",163],[10,"visit_lifetime_decl","","Visits a declaration of a lifetime",163],[10,"visit_explicit_self","","",163],[10,"visit_mac","","",163],[10,"visit_path","","",163],[10,"visit_attribute","","",163],[0,"print","syntax",""],[0,"pp","syntax::print","This pretty-printer is a direct reimplementation of Philip Karlton's\nMesa pretty-printer, as described in appendix A of"],[1,"BreakToken","syntax::print::pp",""],[1,"BeginToken","",""],[1,"PrintStackElem","",""],[1,"Printer","","In case you do not have the paper, here is an explanation of what's going\non."],[11,"out","","",164],[2,"Breaks","",""],[12,"Consistent","","",165],[12,"Inconsistent","","",165],[2,"Token","",""],[12,"String","","",166],[12,"Break","","",166],[12,"Begin","","",166],[12,"End","","",166],[12,"Eof","","",166],[2,"PrintStackBreak","",""],[12,"Fits","","",167],[12,"Broken","","",167],[3,"tok_str","",""],[3,"buf_str","",""],[3,"mk_printer","",""],[3,"rbox","",""],[3,"ibox","",""],[3,"cbox","",""],[3,"break_offset","",""],[3,"end","",""],[3,"eof","",""],[3,"word","",""],[3,"huge_word","",""],[3,"zero_word","",""],[3,"spaces","",""],[3,"zerobreak","",""],[3,"space","",""],[3,"hardbreak","",""],[3,"hardbreak_tok_offset","",""],[3,"hardbreak_tok","",""],[10,"eq","","",165],[10,"ne","","",165],[10,"clone","","",165],[10,"clone","","",168],[10,"clone","","",169],[10,"clone","","",166],[10,"is_eof","","",166],[10,"is_hardbreak_tok","","",166],[10,"last_token","","",164],[10,"replace_last_token","","",164],[10,"pretty_print","","",164],[10,"check_stream","","",164],[10,"scan_push","","",164],[10,"scan_pop","","",164],[10,"scan_top","","",164],[10,"scan_pop_bottom","","",164],[10,"advance_right","","",164],[10,"advance_left","","",164],[10,"check_stack","","",164],[10,"print_newline","","",164],[10,"indent","","",164],[10,"get_top","","",164],[10,"print_str","","",164],[10,"print","","",164],[0,"pprust","syntax::print",""],[1,"NoAnn","syntax::print::pprust",""],[1,"CurrentCommentAndLiteral","",""],[1,"State","",""],[11,"s","","",170],[2,"AnnNode","",""],[12,"NodeBlock","","",171],[12,"NodeItem","","",171],[12,"NodeExpr","","",171],[12,"NodePat","","",171],[3,"rust_printer","",""],[3,"rust_printer_annotated","",""],[3,"print_crate","","Requires you to pass an input filename and reader so that\nit can scan the input text for comments and literals to\ncopy forward."],[3,"to_string","",""],[3,"ty_to_string","",""],[3,"pat_to_string","",""],[3,"arm_to_string","",""],[3,"expr_to_string","",""],[3,"lifetime_to_string","",""],[3,"tt_to_string","",""],[3,"tts_to_string","",""],[3,"stmt_to_string","",""],[3,"item_to_string","",""],[3,"generics_to_string","",""],[3,"ty_method_to_string","",""],[3,"method_to_string","",""],[3,"fn_block_to_string","",""],[3,"path_to_string","",""],[3,"ident_to_string","",""],[3,"fun_to_string","",""],[3,"block_to_string","",""],[3,"meta_item_to_string","",""],[3,"attribute_to_string","",""],[3,"lit_to_string","",""],[3,"explicit_self_to_string","",""],[3,"variant_to_string","",""],[3,"arg_to_string","",""],[3,"mac_to_string","",""],[3,"visibility_qualified","",""],[5,"indent_unit","",""],[5,"default_columns","",""],[6,"PpAnn","",""],[10,"pre","","",172],[10,"post","","",172],[10,"ibox","","",170],[10,"end","","",170],[10,"cbox","","",170],[10,"rbox","","",170],[10,"nbsp","","",170],[10,"word_nbsp","","",170],[10,"word_space","","",170],[10,"popen","","",170],[10,"pclose","","",170],[10,"head","","",170],[10,"bopen","","",170],[10,"bclose_","","",170],[10,"bclose_maybe_open","","",170],[10,"bclose","","",170],[10,"is_begin","","",170],[10,"is_end","","",170],[10,"is_bol","","",170],[10,"in_cbox","","",170],[10,"hardbreak_if_not_bol","","",170],[10,"space_if_not_bol","","",170],[10,"break_offset_if_not_bol","","",170],[10,"synth_comment","","",170],[10,"commasep","","",170],[10,"commasep_cmnt","","",170],[10,"commasep_exprs","","",170],[10,"print_mod","","",170],[10,"print_foreign_mod","","",170],[10,"print_opt_lifetime","","",170],[10,"print_type","","",170],[10,"print_type_ref","","",170],[10,"print_foreign_item","","",170],[10,"print_item","","Pretty-print an item",170],[10,"print_enum_def","","",170],[10,"print_variants","","",170],[10,"print_visibility","","",170],[10,"print_struct","","",170],[10,"print_tt","","This doesn't deserve to be called \"pretty\" printing, but it should be\nmeaning-preserving. A quick hack that might help would be to look at the\nspans embedded in the TTs to decide where to put spaces and newlines.\nBut it'd be better to parse these according to the grammar of the\nappropriate macro, transcribe back into the grammar we just parsed from,\nand then pretty-print the resulting AST nodes (so, e.g., we print\nexpression arguments as expressions). It can be done! I think.",170],[10,"print_tts","","",170],[10,"print_variant","","",170],[10,"print_ty_method","","",170],[10,"print_trait_method","","",170],[10,"print_method","","",170],[10,"print_outer_attributes","","",170],[10,"print_inner_attributes","","",170],[10,"print_attribute","","",170],[10,"print_stmt","","",170],[10,"print_block","","",170],[10,"print_block_unclosed","","",170],[10,"print_block_unclosed_indent","","",170],[10,"print_block_with_attrs","","",170],[10,"print_block_maybe_unclosed","","",170],[10,"print_if","","",170],[10,"print_mac","","",170],[10,"print_expr_vstore","","",170],[10,"print_expr_maybe_paren","","",170],[10,"print_expr","","",170],[10,"print_local_decl","","",170],[10,"print_decl","","",170],[10,"print_ident","","",170],[10,"print_name","","",170],[10,"print_for_decl","","",170],[10,"print_pat","","",170],[10,"print_fn","","",170],[10,"print_fn_args","","",170],[10,"print_fn_args_and_ret","","",170],[10,"print_fn_block_args","","",170],[10,"print_proc_args","","",170],[10,"print_bounds","","",170],[10,"print_lifetime","","",170],[10,"print_generics","","",170],[10,"print_meta_item","","",170],[10,"print_view_path","","",170],[10,"print_view_item","","",170],[10,"print_mutability","","",170],[10,"print_mt","","",170],[10,"print_arg","","",170],[10,"print_ty_fn","","",170],[10,"maybe_print_trailing_comment","","",170],[10,"print_remaining_comments","","",170],[10,"print_literal","","",170],[10,"next_lit","","",170],[10,"maybe_print_comment","","",170],[10,"print_comment","","",170],[10,"print_string","","",170],[10,"next_comment","","",170],[10,"print_opt_fn_style","","",170],[10,"print_opt_abi_and_extern_if_nondefault","","",170],[10,"print_extern_opt_abi","","",170],[10,"print_fn_header_info","","",170],[10,"print_fn_style","","",170],[10,"print_onceness","","",170],[0,"ext","syntax",""],[0,"asm","syntax::ext",""],[3,"expand_asm","syntax::ext::asm",""],[0,"base","syntax::ext",""],[1,"MacroDef","syntax::ext::base",""],[11,"name","","",173],[11,"ext","","",173],[1,"BasicMacroExpander","",""],[11,"expander","","",174],[11,"span","","",174],[1,"BasicIdentMacroExpander","",""],[11,"expander","","",175],[11,"span","","",175],[1,"MacExpr","","A convenience type for macros that return a single expression."],[1,"MacPat","","A convenience type for macros that return a single pattern."],[1,"MacItem","","A convenience type for macros that return a single item."],[1,"DummyResult","","Fill-in macro expansion result, to allow compilation to continue\nafter hitting errors."],[1,"BlockInfo","",""],[11,"macros_escape","","Should macros escape from this scope?",176],[11,"pending_renames","","What are the pending renames?",176],[1,"ExtCtxt","","One of these is made during expansion and incrementally updated as we go;\nwhen a macro expansion occurs, the resulting nodes have the backtrace()\n-> expn_info of their expansion context stored into their span."],[11,"parse_sess","","",177],[11,"cfg","","",177],[11,"backtrace","","",177],[11,"ecfg","","",177],[11,"mod_path","","",177],[11,"trace_mac","","",177],[11,"exported_macros","","",177],[11,"syntax_env","","",177],[1,"SyntaxEnv","","In order to have some notion of scoping for macros,\nwe want to implement the notion of a transformation\nenvironment."],[2,"SyntaxExtension","","An enum representing the different kinds of syntax extensions."],[12,"ItemDecorator","","A syntax extension that is attached to an item and creates new items\nbased upon it.",178],[12,"ItemModifier","","A syntax extension that is attached to an item and modifies it\nin-place.",178],[12,"NormalTT","","A normal, function-like syntax extension.",178],[12,"IdentTT","","A function-like syntax extension that has an extra ident before\nthe block.\n",178],[12,"LetSyntaxTT","","An ident macro that has two properties:\n- it adds a macro definition to the environment, and\n- the definition it adds doesn't introduce any new\n  identifiers.",178],[3,"expr_to_string","","Extract a string literal from the macro expanded version of `expr`,\nemitting `err_msg` if `expr` is not a string literal. This does not stop\ncompilation on error, merely emits a non-fatal error and returns None."],[3,"check_zero_tts","","Non-fatally assert that `tts` is empty. Note that this function\nreturns even when `tts` is non-empty, macros that *need* to stop\ncompilation should call\n`cx.parse_sess.span_diagnostic.abort_if_errors()` (this should be\ndone as rarely as possible)."],[3,"get_single_str_from_tts","","Extract the string literal from the first token of `tts`. If this\nis not a string literal, emit an error and return None."],[3,"get_exprs_from_tts","","Extract comma-separated expressions from `tts`. If there is a\nparsing error, emit a non-fatal error and return None."],[4,"ItemDecorator","",""],[4,"ItemModifier","",""],[4,"MacroExpanderFn","",""],[4,"IdentMacroExpanderFn","",""],[4,"NamedSyntaxExtension","",""],[6,"TTMacroExpander","","Represents a thing that maps token trees to Macro Results"],[9,"expand","","",179],[6,"IdentMacroExpander","",""],[9,"expand","","",180],[6,"MacResult","","The result of a macro expansion. The return values of the various\nmethods are spliced into the AST at the callsite of the macro (or\njust into the compiler's internal macro table, for `make_def`)."],[10,"make_def","","Define a new macro.",181],[10,"make_expr","","Create an expression.",181],[10,"make_items","","Create zero or more items.",181],[10,"make_methods","","Create zero or more methods.",181],[10,"make_pat","","Create a pattern.",181],[10,"make_stmt","","Create a statement.",181],[10,"expand","","",174],[10,"expand","","",175],[10,"new","","",182],[10,"make_expr","","",182],[10,"new","","",183],[10,"make_pat","","",183],[10,"new","","",184],[10,"make_items","","",184],[10,"make_stmt","","",184],[10,"any","","Create a default MacResult that can be anything.",185],[10,"expr","","Create a default MacResult that can only be an expression.",185],[10,"raw_expr","","A plain dummy expression.",185],[10,"raw_pat","","A plain dummy pattern.",185],[10,"make_expr","","",185],[10,"make_pat","","",185],[10,"make_items","","",185],[10,"make_methods","","",185],[10,"make_stmt","","",185],[10,"new","","",176],[10,"new","","",177],[10,"expand_expr","","",177],[10,"expander","","Returns a `Folder` for deeply expanding all macros in a AST node.",177],[10,"new_parser_from_tts","","",177],[10,"codemap","","",177],[10,"parse_sess","","",177],[10,"cfg","","",177],[10,"call_site","","",177],[10,"print_backtrace","","",177],[10,"backtrace","","",177],[10,"mod_push","","",177],[10,"mod_pop","","",177],[10,"mod_path","","",177],[10,"bt_push","","",177],[10,"bt_pop","","",177],[10,"span_fatal","","Emit `msg` attached to `sp`, and stop compilation immediately.",177],[10,"span_err","","Emit `msg` attached to `sp`, without immediately stopping\ncompilation.",177],[10,"span_warn","","",177],[10,"span_unimpl","","",177],[10,"span_bug","","",177],[10,"span_note","","",177],[10,"bug","","",177],[10,"trace_macros","","",177],[10,"set_trace_macros","","",177],[10,"ident_of","","",177],[10,"name_of","","",177],[10,"push_frame","","",186],[10,"pop_frame","","",186],[10,"find","","",186],[10,"insert","","",186],[10,"info","","",186],[0,"build","syntax::ext",""],[6,"AstBuilder","syntax::ext::build",""],[9,"path","","",187],[9,"path_ident","","",187],[9,"path_global","","",187],[9,"path_all","","",187],[9,"ty_mt","","",187],[9,"ty","","",187],[9,"ty_path","","",187],[9,"ty_ident","","",187],[9,"ty_rptr","","",187],[9,"ty_uniq","","",187],[9,"ty_option","","",187],[9,"ty_infer","","",187],[9,"ty_nil","","",187],[9,"ty_vars","","",187],[9,"ty_vars_global","","",187],[9,"ty_field_imm","","",187],[9,"strip_bounds","","",187],[9,"typaram","","",187],[9,"trait_ref","","",187],[9,"typarambound","","",187],[9,"lifetime","","",187],[9,"stmt_expr","","",187],[9,"stmt_let","","",187],[9,"stmt_let_typed","","",187],[9,"stmt_item","","",187],[9,"block","","",187],[9,"block_expr","","",187],[9,"block_all","","",187],[9,"expr","","",187],[9,"expr_path","","",187],[9,"expr_ident","","",187],[9,"expr_self","","",187],[9,"expr_binary","","",187],[9,"expr_deref","","",187],[9,"expr_unary","","",187],[9,"expr_managed","","",187],[9,"expr_addr_of","","",187],[9,"expr_mut_addr_of","","",187],[9,"expr_field_access","","",187],[9,"expr_call","","",187],[9,"expr_call_ident","","",187],[9,"expr_call_global","","",187],[9,"expr_method_call","","",187],[9,"expr_block","","",187],[9,"expr_cast","","",187],[9,"field_imm","","",187],[9,"expr_struct","","",187],[9,"expr_struct_ident","","",187],[9,"expr_lit","","",187],[9,"expr_uint","","",187],[9,"expr_int","","",187],[9,"expr_u8","","",187],[9,"expr_bool","","",187],[9,"expr_vstore","","",187],[9,"expr_vec","","",187],[9,"expr_vec_ng","","",187],[9,"expr_vec_slice","","",187],[9,"expr_str","","",187],[9,"expr_str_uniq","","",187],[9,"expr_some","","",187],[9,"expr_none","","",187],[9,"expr_tuple","","",187],[9,"expr_fail","","",187],[9,"expr_unreachable","","",187],[9,"expr_ok","","",187],[9,"expr_err","","",187],[9,"expr_try","","",187],[9,"pat","","",187],[9,"pat_wild","","",187],[9,"pat_lit","","",187],[9,"pat_ident","","",187],[9,"pat_ident_binding_mode","","",187],[9,"pat_enum","","",187],[9,"pat_struct","","",187],[9,"pat_tuple","","",187],[9,"pat_some","","",187],[9,"pat_none","","",187],[9,"pat_ok","","",187],[9,"pat_err","","",187],[9,"arm","","",187],[9,"arm_unreachable","","",187],[9,"expr_match","","",187],[9,"expr_if","","",187],[9,"expr_loop","","",187],[9,"lambda_fn_decl","","",187],[9,"lambda","","",187],[9,"lambda0","","",187],[9,"lambda1","","",187],[9,"lambda_expr","","",187],[9,"lambda_expr_0","","",187],[9,"lambda_expr_1","","",187],[9,"lambda_stmts","","",187],[9,"lambda_stmts_0","","",187],[9,"lambda_stmts_1","","",187],[9,"item","","",187],[9,"arg","","",187],[9,"fn_decl","","",187],[9,"item_fn_poly","","",187],[9,"item_fn","","",187],[9,"variant","","",187],[9,"item_enum_poly","","",187],[9,"item_enum","","",187],[9,"item_struct_poly","","",187],[9,"item_struct","","",187],[9,"item_mod","","",187],[9,"item_static","","",187],[9,"item_ty_poly","","",187],[9,"item_ty","","",187],[9,"attribute","","",187],[9,"meta_word","","",187],[9,"meta_list","","",187],[9,"meta_name_value","","",187],[9,"view_use","","",187],[9,"view_use_simple","","",187],[9,"view_use_simple_","","",187],[9,"view_use_list","","",187],[9,"view_use_glob","","",187],[6,"Duplicate","",""],[9,"duplicate","","",188],[10,"path","syntax::ext::base","",177],[10,"path_ident","","",177],[10,"path_global","","",177],[10,"path_all","","",177],[10,"ty_mt","","",177],[10,"ty","","",177],[10,"ty_path","","",177],[10,"ty_ident","","",177],[10,"ty_rptr","","",177],[10,"ty_uniq","","",177],[10,"ty_option","","",177],[10,"ty_field_imm","","",177],[10,"ty_infer","","",177],[10,"ty_nil","","",177],[10,"typaram","","",177],[10,"ty_vars","","",177],[10,"ty_vars_global","","",177],[10,"strip_bounds","","",177],[10,"trait_ref","","",177],[10,"typarambound","","",177],[10,"lifetime","","",177],[10,"stmt_expr","","",177],[10,"stmt_let","","",177],[10,"stmt_let_typed","","",177],[10,"block","","",177],[10,"stmt_item","","",177],[10,"block_expr","","",177],[10,"block_all","","",177],[10,"expr","","",177],[10,"expr_path","","",177],[10,"expr_ident","","",177],[10,"expr_self","","",177],[10,"expr_binary","","",177],[10,"expr_deref","","",177],[10,"expr_unary","","",177],[10,"expr_managed","","",177],[10,"expr_field_access","","",177],[10,"expr_addr_of","","",177],[10,"expr_mut_addr_of","","",177],[10,"expr_call","","",177],[10,"expr_call_ident","","",177],[10,"expr_call_global","","",177],[10,"expr_method_call","","",177],[10,"expr_block","","",177],[10,"field_imm","","",177],[10,"expr_struct","","",177],[10,"expr_struct_ident","","",177],[10,"expr_lit","","",177],[10,"expr_uint","","",177],[10,"expr_int","","",177],[10,"expr_u8","","",177],[10,"expr_bool","","",177],[10,"expr_vstore","","",177],[10,"expr_vec","","",177],[10,"expr_vec_ng","","",177],[10,"expr_vec_slice","","",177],[10,"expr_str","","",177],[10,"expr_str_uniq","","",177],[10,"expr_cast","","",177],[10,"expr_some","","",177],[10,"expr_none","","",177],[10,"expr_tuple","","",177],[10,"expr_fail","","",177],[10,"expr_unreachable","","",177],[10,"expr_ok","","",177],[10,"expr_err","","",177],[10,"expr_try","","",177],[10,"pat","","",177],[10,"pat_wild","","",177],[10,"pat_lit","","",177],[10,"pat_ident","","",177],[10,"pat_ident_binding_mode","","",177],[10,"pat_enum","","",177],[10,"pat_struct","","",177],[10,"pat_tuple","","",177],[10,"pat_some","","",177],[10,"pat_none","","",177],[10,"pat_ok","","",177],[10,"pat_err","","",177],[10,"arm","","",177],[10,"arm_unreachable","","",177],[10,"expr_match","","",177],[10,"expr_if","","",177],[10,"expr_loop","","",177],[10,"lambda_fn_decl","","",177],[10,"lambda","","",177],[10,"lambda0","","",177],[10,"lambda1","","",177],[10,"lambda_expr","","",177],[10,"lambda_expr_0","","",177],[10,"lambda_expr_1","","",177],[10,"lambda_stmts","","",177],[10,"lambda_stmts_0","","",177],[10,"lambda_stmts_1","","",177],[10,"arg","","",177],[10,"fn_decl","","",177],[10,"item","","",177],[10,"item_fn_poly","","",177],[10,"item_fn","","",177],[10,"variant","","",177],[10,"item_enum_poly","","",177],[10,"item_enum","","",177],[10,"item_struct","","",177],[10,"item_struct_poly","","",177],[10,"item_mod","","",177],[10,"item_static","","",177],[10,"item_ty_poly","","",177],[10,"item_ty","","",177],[10,"attribute","","",177],[10,"meta_word","","",177],[10,"meta_list","","",177],[10,"meta_name_value","","",177],[10,"view_use","","",177],[10,"view_use_simple","","",177],[10,"view_use_simple_","","",177],[10,"view_use_list","","",177],[10,"view_use_glob","","",177],[10,"duplicate","std::gc","",115],[0,"bytes","syntax::ext",""],[3,"expand_syntax_ext","syntax::ext::bytes",""],[0,"cfg","syntax::ext",""],[3,"expand_cfg","syntax::ext::cfg",""],[0,"concat","syntax::ext",""],[3,"expand_syntax_ext","syntax::ext::concat",""],[0,"concat_idents","syntax::ext",""],[3,"expand_syntax_ext","syntax::ext::concat_idents",""],[0,"deriving","syntax::ext","The compiler code necessary to implement the `#[deriving]` extensions."],[3,"expand_meta_deriving","syntax::ext::deriving",""],[0,"bounds","",""],[3,"expand_deriving_bound","syntax::ext::deriving::bounds",""],[0,"clone","syntax::ext::deriving",""],[3,"expand_deriving_clone","syntax::ext::deriving::clone",""],[0,"encodable","syntax::ext::deriving","The compiler code necessary to implement the `#[deriving(Encodable)]`\n(and `Decodable`, in decodable.rs) extension.  The idea here is that\ntype-defining items may be tagged with `#[deriving(Encodable, Decodable)]`."],[3,"expand_deriving_encodable","syntax::ext::deriving::encodable",""],[0,"decodable","syntax::ext::deriving","The compiler code necessary for `#[deriving(Decodable)]`. See\nencodable.rs for more."],[3,"expand_deriving_decodable","syntax::ext::deriving::decodable",""],[0,"hash","syntax::ext::deriving",""],[3,"expand_deriving_hash","syntax::ext::deriving::hash",""],[0,"rand","syntax::ext::deriving",""],[3,"expand_deriving_rand","syntax::ext::deriving::rand",""],[0,"show","syntax::ext::deriving",""],[3,"expand_deriving_show","syntax::ext::deriving::show",""],[0,"zero","syntax::ext::deriving",""],[3,"expand_deriving_zero","syntax::ext::deriving::zero",""],[0,"default","syntax::ext::deriving",""],[3,"expand_deriving_default","syntax::ext::deriving::default",""],[0,"primitive","syntax::ext::deriving",""],[3,"expand_deriving_from_primitive","syntax::ext::deriving::primitive",""],[0,"eq","syntax::ext::deriving",""],[3,"expand_deriving_eq","syntax::ext::deriving::eq",""],[0,"totaleq","syntax::ext::deriving",""],[3,"expand_deriving_totaleq","syntax::ext::deriving::totaleq",""],[0,"ord","syntax::ext::deriving",""],[2,"OrderingOp","syntax::ext::deriving::ord",""],[12,"PartialCmpOp","","",189],[12,"LtOp","","",189],[12,"LeOp","","",189],[12,"GtOp","","",189],[12,"GeOp","","",189],[3,"expand_deriving_ord","",""],[3,"some_ordering_collapsed","",""],[3,"cs_partial_cmp","",""],[0,"totalord","syntax::ext::deriving",""],[3,"expand_deriving_totalord","syntax::ext::deriving::totalord",""],[3,"ordering_collapsed","",""],[3,"cs_cmp","",""],[0,"generic","syntax::ext::deriving","Some code that abstracts away much of the boilerplate of writing\n`deriving` instances for traits. Among other things it manages getting\naccess to the fields of the 4 different sorts of structs and enum\nvariants, as well as creating the method and impl ast instances."],[1,"TraitDef","syntax::ext::deriving::generic",""],[11,"span","","The span for the current #[deriving(Foo)] header.",190],[11,"attributes","","",190],[11,"path","","Path of the trait, including any type parameters",190],[11,"additional_bounds","","Additional bounds required of any type parameters of the type,\nother than the current trait",190],[11,"generics","","Any extra lifetimes and/or bounds, e.g. `D: serialize::Decoder`",190],[11,"methods","","",190],[1,"MethodDef","",""],[11,"name","","name of the method",191],[11,"generics","","List of generics, e.g. `R: rand::Rng`",191],[11,"explicit_self","","Whether there is a self argument (outer Option) i.e. whether\nthis is a static function, and whether it is a pointer (inner\nOption)",191],[11,"args","","Arguments other than the self argument",191],[11,"ret_ty","","Return type",191],[11,"attributes","","",191],[11,"combine_substructure","","",191],[1,"Substructure","","All the data about the data structure/method being derived upon."],[11,"type_ident","","ident of self",192],[11,"method_ident","","ident of the method",192],[11,"self_args","","dereferenced access to any Self or Ptr(Self, _) arguments",192],[11,"nonself_args","","verbatim access to any other arguments",192],[11,"fields","","",192],[1,"FieldInfo","","Summary of the relevant parts of a struct/enum field."],[11,"span","","",193],[11,"name","","None for tuple structs/normal enum variants, Some for normal\nstructs/struct enum variants.",193],[11,"self_","","The expression corresponding to this field of `self`\n(specifically, a reference to it).",193],[11,"other","","The expressions corresponding to references to this field in\nthe other Self arguments.",193],[2,"StaticFields","","Fields for a static method"],[12,"Unnamed","","Tuple structs/enum variants like this",194],[12,"Named","","Normal structs/struct variants.",194],[2,"SubstructureFields","","A summary of the possible sets of fields. See above for details\nand examples"],[12,"Struct","","",195],[12,"EnumMatching","","Matching variants of the enum: variant index, ast::Variant,\nfields: the field name is only non-`None` in the case of a struct\nvariant.",195],[12,"EnumNonMatchingCollapsed","","non-matching variants of the enum, but with all state hidden from\nthe consequent code.  The first component holds Idents for all of\nthe Self arguments; the second component is a slice of all of the\nvariants for the enum itself, and the third component is a list of\nIdents bound to the variant index values for each of the actual\ninput Self arguments.",195],[12,"StaticStruct","","A static method where Self is a struct.",195],[12,"StaticEnum","","A static method where Self is an enum.",195],[3,"combine_substructure","",""],[3,"cs_fold","","Fold the fields. `use_foldl` controls whether this is done\nleft-to-right (`true`) or right-to-left (`false`)."],[3,"cs_same_method","","Call the method that is being derived on all the fields, and then\nprocess the collected results. i.e."],[3,"cs_same_method_fold","","Fold together the results of calling the derived method on all the\nfields. `use_foldl` controls whether this is done left-to-right\n(`true`) or right-to-left (`false`)."],[3,"cs_binop","","Use a given binop to combine the result of calling the derived method\non all the fields."],[3,"cs_or","","cs_binop with binop == or"],[3,"cs_and","","cs_binop with binop == and"],[0,"ty","","A mini version of ast::Ty, which is easier to use, and features an\nexplicit `Self` type to use when specifying impls to be derived."],[1,"Path","syntax::ext::deriving::generic::ty","A path, e.g. `::std::option::Option::<int>` (global). Has support\nfor type parameters and a lifetime."],[11,"path","","",196],[11,"lifetime","","",196],[11,"params","","",196],[11,"global","","",196],[1,"LifetimeBounds","","Lifetimes and bounds on type parameters"],[11,"lifetimes","","",197],[11,"bounds","","",197],[2,"PtrTy","","The types of pointers"],[12,"Borrowed","","&'lifetime mut",198],[2,"Ty","","A type. Supports pointers (except for *), Self, and literals"],[12,"Self","","",199],[12,"Ptr","","&/Box/ Ty",199],[12,"Literal","","mod::mod::Type<[lifetime], [Params...]>, including a plain type\nparameter, and things like `int`",199],[12,"Tuple","","includes unit",199],[3,"borrowed_ptrty","",""],[3,"borrowed","",""],[3,"borrowed_explicit_self","",""],[3,"borrowed_self","",""],[3,"nil_ty","",""],[3,"get_explicit_self","",""],[10,"clone","","",198],[10,"clone","","",196],[10,"new","","",196],[10,"new_local","","",196],[10,"new_","","",196],[10,"to_ty","","",196],[10,"to_path","","",196],[10,"clone","","",199],[10,"to_ty","","",199],[10,"to_path","","",199],[10,"clone","","",197],[10,"empty","","",197],[10,"to_generics","","",197],[4,"CombineSubstructureFunc","syntax::ext::deriving::generic","Combine the values of all the fields together. The last argument is\nall the fields of all the structures, see above for details."],[4,"EnumNonMatchCollapsedFunc","","Deal with non-matching enum variants.  The tuple is a list of\nidentifiers (one for each Self argument, which could be any of the\nvariants since they have been collapsed together) and the identifiers\nholding the variant index value for each of the Self arguments.  The\nlast argument is all the non-Self args of the method being derived."],[10,"expand","","",190],[0,"env","syntax::ext",""],[3,"expand_option_env","syntax::ext::env",""],[3,"expand_env","",""],[0,"expand","syntax::ext",""],[1,"IdentRenamer","syntax::ext::expand","A tree-folder that applies every rename in its (mutable) list\nto every identifier, including both bindings and varrefs\n(and lots of things that will turn out to be neither)"],[1,"PatIdentRenamer","","A tree-folder that applies every rename in its list to\nthe idents that are in PatIdent patterns. This is more narrowly\nfocused than IdentRenamer, and is needed for FnDecl,\nwhere we want to rename the args but not the fn name or the generics etc."],[1,"MacroExpander","","A tree-folder that performs macro expansion"],[11,"cx","","",200],[1,"ExpansionConfig","",""],[11,"deriving_hash_type_parameter","","",201],[11,"crate_name","","",201],[1,"ExportedMacros","",""],[11,"crate_name","","",202],[11,"macros","","",202],[3,"expand_crate","",""],[3,"check_for_macros","","Check that there are no macro invocations left in the AST:"],[10,"fold_ident","","",203],[10,"fold_mac","","",203],[10,"fold_pat","","",204],[10,"fold_mac","","",204],[10,"fold_expr","","",200],[10,"fold_pat","","",200],[10,"fold_item","","",200],[10,"fold_item_underscore","","",200],[10,"fold_stmt","","",200],[10,"fold_block","","",200],[10,"fold_arm","","",200],[10,"fold_method","","",200],[10,"new_span","","",200],[0,"fmt","syntax::ext",""],[3,"expand_syntax_ext","syntax::ext::fmt",""],[0,"format","syntax::ext",""],[2,"Invocation","syntax::ext::format",""],[12,"Call","","",205],[12,"MethodCall","","",205],[3,"expand_format_args","",""],[3,"expand_format_args_method","",""],[3,"expand_preparsed_format_args","","Take the various parts of `format_args!(extra, efmt, args...,\nname=names...)` and construct the appropriate formatting\nexpression."],[0,"log_syntax","syntax::ext",""],[3,"expand_syntax_ext","syntax::ext::log_syntax",""],[0,"mtwt","syntax::ext","Machinery for hygienic macros, as described in the MTWT[1] paper."],[1,"SCTable","syntax::ext::mtwt","The SCTable contains a table of SyntaxContext_'s. It\nrepresents a flattened tree structure, to avoid having\nmanaged pointers everywhere (that caused an ICE).\nthe mark_memo and rename_memo fields are side-tables\nthat ensure that adding the same mark to the same context\ngives you back the same context as before. This shouldn't\nchange the semantics--everything here is immutable--but\nit should cut down on memory use *a lot*; applying a mark\nto a tree containing 50 identifiers would otherwise generate\n50 new contexts"],[2,"SyntaxContext_","",""],[12,"EmptyCtxt","","",206],[12,"Mark","","",206],[12,"Rename","","flattening the name and syntaxcontext into the rename...\nHIDDEN INVARIANTS:\n1) the first name in a Rename node\ncan only be a programmer-supplied name.\n2) Every Rename node with a given Name in the\n\"to\" slot must have the same name and context\nin the \"from\" slot. In essence, they're all\npointers to a single \"rename\" event node.",206],[12,"IllegalCtxt","","actually, IllegalCtxt may not be necessary.",206],[3,"apply_mark","","Extend a syntax context with a given mark"],[3,"apply_rename","","Extend a syntax context with a given rename"],[3,"apply_renames","","Apply a list of renamings to a context"],[3,"with_sctable","","Fetch the SCTable from TLS, create one if it doesn't yet exist."],[3,"display_sctable","","Print out an SCTable for debugging"],[3,"clear_tables","","Clear the tables from TLD to reclaim memory."],[3,"resolve","","Resolve a syntax object to a name, per MTWT."],[3,"marksof","","Compute the marks associated with a syntax context."],[3,"outer_mark","","Return the outer mark for a context with a mark at the outside.\nFAILS when outside is not a mark."],[4,"RenameList","","A list of ident->name renamings"],[10,"hash","","",206],[10,"decode","","",206],[10,"encode","","",206],[10,"eq","","",206],[10,"ne","","",206],[0,"quote","syntax::ext",""],[3,"expand_quote_tokens","syntax::ext::quote",""],[3,"expand_quote_expr","",""],[3,"expand_quote_item","",""],[3,"expand_quote_pat","",""],[3,"expand_quote_arm","",""],[3,"expand_quote_ty","",""],[3,"expand_quote_method","",""],[3,"expand_quote_stmt","",""],[0,"rt","","\nQuasiquoting works via token trees."],[6,"ToTokens","syntax::ext::quote::rt",""],[9,"to_tokens","","",207],[6,"ToSource","",""],[9,"to_source","","",208],[6,"ExtParseUtils","",""],[9,"parse_item","","",209],[9,"parse_expr","","",209],[9,"parse_stmt","","",209],[9,"parse_tts","","",209],[10,"to_tokens","syntax::ast","",62],[10,"to_tokens","collections::vec","",210],[10,"to_tokens","syntax::codemap","",117],[10,"to_tokens","core::option","",211],[10,"to_source","syntax::ast","",10],[10,"to_source","","",28],[10,"to_source","","",18],[10,"to_source","","",33],[10,"to_source","","",16],[10,"to_source","std::gc","",115],[10,"to_source","","",115],[10,"to_source","","",115],[10,"to_source","","",115],[10,"to_source","","",115],[10,"to_source","syntax::ast","",22],[10,"to_source","","",42],[10,"to_tokens","","",10],[10,"to_tokens","std::gc","",115],[10,"to_tokens","","",115],[10,"to_tokens","syntax::ast","",22],[10,"to_tokens","std::gc","",115],[10,"to_tokens","syntax::ast","",28],[10,"to_tokens","","",16],[10,"to_tokens","std::gc","",115],[10,"to_tokens","","",115],[10,"to_tokens","syntax::ast","",18],[10,"to_tokens","","",33],[10,"to_tokens","","",42],[10,"parse_item","syntax::ext::base","",177],[10,"parse_stmt","","",177],[10,"parse_expr","","",177],[10,"parse_tts","","",177],[0,"source_util","syntax::ext",""],[3,"expand_line","syntax::ext::source_util","line!(): expands to the current line number"],[3,"expand_col","",""],[3,"expand_file","","file!(): expands to the current filename */\nThe filemap (`loc.file`) contains a bunch more information we could spit\nout if we wanted."],[3,"expand_stringify","",""],[3,"expand_mod","",""],[3,"expand_include","","include! : parse the given file as an expr\nThis is generally a bad idea because it's going to behave\nunhygienically."],[3,"expand_include_str","",""],[3,"expand_include_bin","",""],[0,"trace_macros","syntax::ext",""],[3,"expand_trace_macros","syntax::ext::trace_macros",""],[0,"tt","syntax::ext",""],[0,"transcribe","syntax::ext::tt",""],[1,"TtReader","syntax::ext::tt::transcribe",""],[11,"sp_diag","","",212],[11,"cur_tok","","",212],[11,"cur_span","","",212],[3,"new_tt_reader","","This can do Macro-By-Example transcription. On the other hand, if\n`src` contains no `TTSeq`s and `TTNonterminal`s, `interp` can (and\nshould) be none."],[3,"tt_next_token","","Return the next token from the TtReader.\nEFFECT: advances the reader's token field"],[10,"clone","","",212],[0,"macro_parser","syntax::ext::tt","This is an Earley-like parser, without support for in-grammar nonterminals,\nonly by calling out to the main rust parser for named nonterminals (which it\ncommits to fully when it hits one in a grammar). This means that there are no\ncompleter or predictor rules, and therefore no need to store one column per\ntoken: instead, there's a set of current Earley items and a set of next\nones. Instead of NTs, we have a special case for Kleene star. The big-O, in\npathological cases, is worse than traditional Earley parsing, but it's an\neasier fit for Macro-by-Example-style rules, and I think the overhead is\nlower. (In order to prevent the pathological case, we'd need to lazily\nconstruct the resulting `NamedMatch`es at the very end. It'd be a pain,\nand require more memory to keep around old items, but it would also save\noverhead)"],[1,"MatcherPos","syntax::ext::tt::macro_parser",""],[2,"NamedMatch","","NamedMatch is a pattern-match result for a single ast::MatchNonterminal:\nso it is associated with a single ident in a parse, and all\nMatchedNonterminal's in the NamedMatch have the same nonterminal type\n(expr, item, etc). All the leaves in a single NamedMatch correspond to a\nsingle matcher_nonterminal in the ast::Matcher that produced it."],[12,"MatchedSeq","","",213],[12,"MatchedNonterminal","","",213],[2,"ParseResult","",""],[12,"Success","","",214],[12,"Failure","","",214],[12,"Error","","",214],[3,"count_names","",""],[3,"initial_matcher_pos","",""],[3,"nameize","",""],[3,"parse_or_else","",""],[3,"token_name_eq","","Perform a token equality check, ignoring syntax context (that is, an\nunhygienic comparison)"],[3,"parse","",""],[3,"parse_nt","",""],[10,"clone","","",215],[0,"macro_rules","syntax::ext::tt",""],[3,"add_new_extension","syntax::ext::tt::macro_rules","This procedure performs the expansion of the\nmacro_rules! macro. It parses the RHS and adds\nan extension to the current context."],[15,"register_diagnostic!","syntax",""],[15,"span_err!","",""],[15,"span_warn!","",""],[15,"span_note!","",""],[15,"register_diagnostics!","",""],[10,"is_eof","syntax::ext::tt::transcribe","",212],[10,"next_token","","",212],[10,"fatal","","",212],[10,"err","","",212],[10,"peek","","",212]],"paths":[[1,"Interner"],[1,"RcStr"],[1,"StrInterner"],[1,"SmallVector"],[1,"MoveItems"],[1,"Registry"],[2,"Os"],[2,"Abi"],[2,"Architecture"],[2,"AbiArchitecture"],[1,"Ident"],[1,"Lifetime"],[1,"Path"],[1,"PathSegment"],[1,"DefId"],[1,"TyParam"],[1,"Generics"],[1,"Crate"],[1,"Block"],[1,"Pat"],[1,"FieldPat"],[1,"Local"],[1,"Arm"],[1,"Field"],[1,"Expr"],[1,"MutTy"],[1,"TypeField"],[1,"TypeMethod"],[1,"Ty"],[1,"ClosureTy"],[1,"BareFnTy"],[1,"UnboxedFnTy"],[1,"InlineAsm"],[1,"Arg"],[1,"FnDecl"],[1,"Method"],[1,"Mod"],[1,"ForeignMod"],[1,"VariantArg"],[1,"EnumDef"],[1,"Variant_"],[1,"ViewItem"],[1,"Attribute_"],[1,"TraitRef"],[1,"StructField_"],[1,"StructDef"],[1,"Item"],[1,"ForeignItem"],[2,"TyParamBound"],[2,"MetaItem_"],[2,"BindingMode"],[2,"Pat_"],[2,"Mutability"],[2,"ExprVstore"],[2,"BinOp"],[2,"UnOp"],[2,"Stmt_"],[2,"LocalSource"],[2,"Decl_"],[2,"BlockCheckMode"],[2,"UnsafeSource"],[2,"Expr_"],[2,"TokenTree"],[2,"Matcher_"],[2,"Mac_"],[2,"StrStyle"],[2,"Lit_"],[2,"TraitMethod"],[2,"IntTy"],[2,"UintTy"],[2,"FloatTy"],[2,"PrimTy"],[2,"Onceness"],[2,"Ty_"],[2,"AsmDialect"],[2,"FnStyle"],[2,"RetStyle"],[2,"ExplicitSelf_"],[2,"Method_"],[2,"VariantKind"],[2,"PathListItem_"],[2,"ViewPath_"],[2,"ViewItem_"],[2,"AttrStyle"],[2,"Visibility"],[2,"StructFieldKind"],[2,"Item_"],[2,"ForeignItem_"],[2,"InlinedItem"],[1,"Name"],[1,"AttrId"],[2,"PathElem"],[2,"Node"],[1,"FnParts"],[2,"Code"],[6,"MaybeFnLike"],[1,"FnLikeNode"],[6,"FoldOps"],[1,"Values"],[1,"Map"],[1,"Ctx"],[1,"IdRange"],[1,"IdVisitor"],[6,"IdVisitingOperation"],[6,"EachViewItem"],[6,"PostExpansionMethod"],[1,"Stability"],[2,"InlineAttr"],[2,"StabilityLevel"],[2,"ReprAttr"],[2,"IntType"],[6,"AttrMetaMethods"],[6,"AttributeMethods"],[4,"Attribute"],[4,"MetaItem"],[1,"Gc"],[1,"Span"],[1,"Spanned"],[1,"Loc"],[1,"LocWithOpt"],[1,"FileMapAndLine"],[1,"FileMapAndBytePos"],[1,"NameAndSpan"],[1,"ExpnInfo"],[1,"FileLines"],[1,"MultiByteChar"],[1,"FileMap"],[1,"CodeMap"],[2,"MacroFormat"],[6,"Pos"],[1,"BytePos"],[1,"CharPos"],[1,"CrateId"],[1,"SpanHandler"],[2,"RenderSpan"],[2,"ColorConfig"],[2,"Level"],[6,"Emitter"],[1,"Handler"],[1,"EmitterWriter"],[6,"Folder"],[1,"OwnedSlice"],[1,"ParseSess"],[1,"TokenAndSpan"],[1,"StringReader"],[1,"Comment"],[1,"Literal"],[2,"CommentStyle"],[6,"Reader"],[1,"PathAndBounds"],[1,"Parser"],[2,"restriction"],[2,"PathParsingMode"],[2,"BinOp"],[2,"Token"],[2,"Nonterminal"],[2,"Keyword"],[1,"InternedString"],[6,"ParserAttr"],[1,"SeqSep"],[2,"ObsoleteSyntax"],[6,"ParserObsoleteMethods"],[2,"FnKind"],[6,"Visitor"],[1,"Printer"],[2,"Breaks"],[2,"Token"],[2,"PrintStackBreak"],[1,"BreakToken"],[1,"BeginToken"],[1,"State"],[2,"AnnNode"],[6,"PpAnn"],[1,"MacroDef"],[1,"BasicMacroExpander"],[1,"BasicIdentMacroExpander"],[1,"BlockInfo"],[1,"ExtCtxt"],[2,"SyntaxExtension"],[6,"TTMacroExpander"],[6,"IdentMacroExpander"],[6,"MacResult"],[1,"MacExpr"],[1,"MacPat"],[1,"MacItem"],[1,"DummyResult"],[1,"SyntaxEnv"],[6,"AstBuilder"],[6,"Duplicate"],[2,"OrderingOp"],[1,"TraitDef"],[1,"MethodDef"],[1,"Substructure"],[1,"FieldInfo"],[2,"StaticFields"],[2,"SubstructureFields"],[1,"Path"],[1,"LifetimeBounds"],[2,"PtrTy"],[2,"Ty"],[1,"MacroExpander"],[1,"ExpansionConfig"],[1,"ExportedMacros"],[1,"IdentRenamer"],[1,"PatIdentRenamer"],[2,"Invocation"],[2,"SyntaxContext_"],[6,"ToTokens"],[6,"ToSource"],[6,"ExtParseUtils"],[1,"Vec"],[2,"Option"],[1,"TtReader"],[2,"NamedMatch"],[2,"ParseResult"],[1,"MatcherPos"]]};

initSearch(searchIndex);
