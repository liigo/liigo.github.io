<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="The std library documentation.">

    <title>std::rc - Rust</title>

    <link rel="stylesheet" type="text/css" href="../../main.css">

    <link rel="shortcut icon" href="http://www.rust-lang.org/favicon.ico">
    
</head>
<body>
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <section class="sidebar">
        <a href='../../std/index.html'><img src='http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png' alt='' width='100'></a>
        <p class='location'><a href='../index.html'>std</a></p><div class='block mod'><h2>Modules</h2><a class='mod ' href='../any/index.html' title='Traits for dynamic typing of any `'static` type (through runtime reflection)'>any</a><a class='mod ' href='../ascii/index.html' title='Operations on ASCII strings and characters'>ascii</a><a class='mod ' href='../bitflags/index.html' title='The `bitflags!` macro generates a `struct` that holds a set of C-style bitmask flags. It is useful for creating typesafe wrappers for C APIs.'>bitflags</a><a class='mod ' href='../bool/index.html' title='The boolean type'>bool</a><a class='mod ' href='../boxed/index.html' title='A unique pointer type'>boxed</a><a class='mod ' href='../c_str/index.html' title='C-string manipulation and management'>c_str</a><a class='mod ' href='../c_vec/index.html' title='Library to interface with chunks of memory allocated in C.'>c_vec</a><a class='mod ' href='../cell/index.html' title='Shareable mutable containers.'>cell</a><a class='mod ' href='../char/index.html' title='Character manipulation (`char` type, Unicode Scalar Value)'>char</a><a class='mod ' href='../clone/index.html' title='The `Clone` trait for types that cannot be 'implicitly copied''>clone</a><a class='mod ' href='../cmp/index.html' title='Defines the `PartialOrd` and `PartialEq` comparison traits.'>cmp</a><a class='mod ' href='../collections/index.html' title='Collection types.'>collections</a><a class='mod ' href='../comm/index.html' title='Communication primitives for concurrent tasks'>comm</a><a class='mod ' href='../default/index.html' title='The `Default` trait for types which may have meaningful default values'>default</a><a class='mod ' href='../dynamic_lib/index.html' title='Dynamic library facilities.'>dynamic_lib</a><a class='mod ' href='../f32/index.html' title='Operations and constants for 32-bits floats (`f32` type)'>f32</a><a class='mod ' href='../f64/index.html' title='Operations and constants for 64-bits floats (`f64` type)'>f64</a><a class='mod ' href='../finally/index.html' title='The Finally trait provides a method, `finally` on stack closures that emulates Java-style try/finally blocks.'>finally</a><a class='mod ' href='../fmt/index.html' title='Utilities for formatting and printing strings'>fmt</a><a class='mod ' href='../from_str/index.html' title='The `FromStr` trait for types that can be created from strings'>from_str</a><a class='mod ' href='../gc/index.html' title='Task-local garbage-collected boxes'>gc</a><a class='mod ' href='../hash/index.html' title='Generic hashing support.'>hash</a><a class='mod ' href='../i16/index.html' title='Operations and constants for signed 16-bits integers (`i16` type)'>i16</a><a class='mod ' href='../i32/index.html' title='Operations and constants for signed 32-bits integers (`i32` type)'>i32</a><a class='mod ' href='../i64/index.html' title='Operations and constants for signed 64-bits integers (`i64` type)'>i64</a><a class='mod ' href='../i8/index.html' title='Operations and constants for signed 8-bits integers (`i8` type)'>i8</a><a class='mod ' href='../int/index.html' title='Operations and constants for architecture-sized signed integers (`int` type)'>int</a><a class='mod ' href='../intrinsics/index.html' title='rustc compiler intrinsics.'>intrinsics</a><a class='mod ' href='../io/index.html' title='I/O, including files, networking, timers, and processes'>io</a><a class='mod ' href='../iter/index.html' title='Composable external iterators'>iter</a><a class='mod ' href='../kinds/index.html' title='Primitive traits representing basic 'kinds' of types'>kinds</a><a class='mod ' href='../local_data/index.html' title='Task local data management'>local_data</a><a class='mod ' href='../macros/index.html' title='Standard library macros'>macros</a><a class='mod ' href='../mem/index.html' title='Basic functions for dealing with memory'>mem</a><a class='mod ' href='../num/index.html' title='Numeric traits and functions for generic mathematics'>num</a><a class='mod ' href='../ops/index.html' title=' Overloadable operators'>ops</a><a class='mod ' href='../option/index.html' title='Optional values'>option</a><a class='mod ' href='../os/index.html' title='Higher-level interfaces to libc::* functions and operating system services.'>os</a><a class='mod ' href='../owned/index.html' title='A unique pointer type'>owned</a><a class='mod ' href='../path/index.html' title='Cross-platform path support'>path</a><a class='mod ' href='../prelude/index.html' title='The Rust prelude'>prelude</a><a class='mod ' href='../ptr/index.html' title='Operations on unsafe pointers, `*const T`, and `*mut T`.'>ptr</a><a class='mod ' href='../rand/index.html' title='Utilities for random number generation'>rand</a><a class='mod ' href='../raw/index.html' title='Contains struct definitions for the layout of compiler built-in types.'>raw</a><a class='mod current' href='../rc/index.html' title='Task-local reference-counted boxes (`Rc` type)'>rc</a><a class='mod ' href='../result/index.html' title='Error handling with the `Result` type'>result</a><a class='mod ' href='../rt/index.html' title='Runtime services, including the task scheduler and I/O dispatcher'>rt</a><a class='mod ' href='../simd/index.html' title='SIMD vectors.'>simd</a><a class='mod ' href='../slice/index.html' title='Utilities for vector manipulation'>slice</a><a class='mod ' href='../str/index.html' title='Unicode string manipulation (`str` type)'>str</a><a class='mod ' href='../string/index.html' title='An owned, growable string that enforces that its contents are valid UTF-8.'>string</a><a class='mod ' href='../sync/index.html' title='Useful synchronization primitives'>sync</a><a class='mod ' href='../task/index.html' title='Task creation'>task</a><a class='mod ' href='../to_string/index.html' title='The `ToString` trait for converting to strings'>to_string</a><a class='mod ' href='../tuple/index.html' title='Operations on tuples'>tuple</a><a class='mod ' href='../ty/index.html' title='Deprecated module in favor of `std::cell`'>ty</a><a class='mod ' href='../u16/index.html' title='Operations and constants for unsigned 16-bits integers (`u16` type)'>u16</a><a class='mod ' href='../u32/index.html' title='Operations and constants for unsigned 32-bits integers (`u32` type)'>u32</a><a class='mod ' href='../u64/index.html' title='Operations and constants for unsigned 64-bits integer (`u64` type)'>u64</a><a class='mod ' href='../u8/index.html' title='Operations and constants for unsigned 8-bits integers (`u8` type)'>u8</a><a class='mod ' href='../uint/index.html' title='Operations and constants for architecture-sized unsigned integers (`uint` type)'>uint</a><a class='mod ' href='../unit/index.html' title='The `()` type, sometimes called "unit" or "nil".'>unit</a><a class='mod ' href='../vec/index.html' title='An owned, growable vector.'>vec</a></div><div class='block macro'><h2>Macros</h2><a class='macro ' href='../macro.assert!.html' title='Ensure that a boolean expression is `true` at runtime.'>assert!</a><a class='macro ' href='../macro.assert_eq!.html' title='Asserts that two expressions are equal to each other, testing equality in both directions.'>assert_eq!</a><a class='macro ' href='../macro.bitflags!.html' title=''>bitflags!</a><a class='macro ' href='../macro.bytes!.html' title='Concatenate literals into a static byte slice.'>bytes!</a><a class='macro ' href='../macro.cfg!.html' title='Boolean evaluation of configuration flags.'>cfg!</a><a class='macro ' href='../macro.col!.html' title='A macro which expands to the column number on which it was invoked.'>col!</a><a class='macro ' href='../macro.concat!.html' title='Concatenates literals into a static string slice.'>concat!</a><a class='macro ' href='../macro.concat_idents!.html' title='Concatenate identifiers into one identifier.'>concat_idents!</a><a class='macro ' href='../macro.debug_assert!.html' title='Ensure that a boolean expression is `true` at runtime.'>debug_assert!</a><a class='macro ' href='../macro.debug_assert_eq!.html' title='Asserts that two expressions are equal to each other, testing equality in both directions.'>debug_assert_eq!</a><a class='macro ' href='../macro.env!.html' title='Inspect an environment variable at compile time.'>env!</a><a class='macro ' href='../macro.fail!.html' title='The entry point for failure of rust tasks.'>fail!</a><a class='macro ' href='../macro.file!.html' title='A macro which expands to the file name from which it was invoked.'>file!</a><a class='macro ' href='../macro.format!.html' title='Use the syntax described in `std::fmt` to create a value of type `String`. See `std::fmt` for more information.'>format!</a><a class='macro ' href='../macro.format_args!.html' title='The core macro for formatted string creation & output.'>format_args!</a><a class='macro ' href='../macro.include_bin!.html' title='Includes a file as a byte slice.'>include_bin!</a><a class='macro ' href='../macro.include_str!.html' title='Includes a utf8-encoded file as a string.'>include_str!</a><a class='macro ' href='../macro.line!.html' title='A macro which expands to the line number on which it was invoked.'>line!</a><a class='macro ' href='../macro.local_data_key!.html' title='Declare a task-local key with a specific type.'>local_data_key!</a><a class='macro ' href='../macro.module_path!.html' title='Expands to a string that represents the current module path.'>module_path!</a><a class='macro ' href='../macro.option_env!.html' title='Optionally inspect an environment variable at compile time.'>option_env!</a><a class='macro ' href='../macro.print!.html' title='Equivalent to the `println!` macro except that a newline is not printed at the end of the message.'>print!</a><a class='macro ' href='../macro.println!.html' title='Macro for printing to a task's stdout handle.'>println!</a><a class='macro ' href='../macro.select!.html' title='A macro to select an event from a number of receivers.'>select!</a><a class='macro ' href='../macro.stringify!.html' title='A macro which stringifies its argument.'>stringify!</a><a class='macro ' href='../macro.try!.html' title='Helper macro for unwrapping `Result` values while returning early with an error if the value of the expression is `Err`. For more information, see `std::io`.'>try!</a><a class='macro ' href='../macro.unimplemented!.html' title='A standardised placeholder for marking unfinished code. It fails with the message `"not yet implemented"` when executed.'>unimplemented!</a><a class='macro ' href='../macro.unreachable!.html' title='A utility macro for indicating unreachable code. It will fail if executed. This is occasionally useful to put after loops that never terminate normally, but instead directly return from a function.'>unreachable!</a><a class='macro ' href='../macro.vec!.html' title='Create a `std::vec::Vec` containing the arguments.'>vec!</a><a class='macro ' href='../macro.write!.html' title='Use the `format!` syntax to write data into a buffer of type `&mut Writer`. See `std::fmt` for more information.'>write!</a><a class='macro ' href='../macro.writeln!.html' title='Equivalent to the `write!` macro, except that a newline is appended after the message is written.'>writeln!</a></div>
    </section>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press 'S' to search, '?' for more options..."
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content mod">
<h1 class='fqn'>Module <a href='../index.html'>std</a>::<a class='mod' href=''>rc</a><a class='stability Stable' title=''>Stable</a><span class='out-of-band'><a id='src-1757' href='../../alloc/rc/index.html?gotosrc=1757'>[src]</a></span></h1>
<div class='docblock'><p>Task-local reference-counted boxes (<code>Rc</code> type)</p>

<p>The <code>Rc</code> type provides shared ownership of an immutable value. Destruction is
deterministic, and will occur as soon as the last owner is gone. It is marked
as non-sendable because it avoids the overhead of atomic reference counting.</p>

<p>The <code>downgrade</code> method can be used to create a non-owning <code>Weak</code> pointer to the
box. A <code>Weak</code> pointer can be upgraded to an <code>Rc</code> pointer, but will return
<code>None</code> if the value has already been freed.</p>

<p>For example, a tree with parent pointers can be represented by putting the
nodes behind strong <code>Rc</code> pointers, and then storing the parent pointers as
<code>Weak</code> pointers.</p>

<h2 id="examples" class='section-header'><a
                           href="#examples">Examples</a></h2>
<p>Consider a scenario where a set of Gadgets are owned by a given Owner.  We want
to have our Gadgets point to their Owner.  We can&#39;t do this with unique
ownership, because more than one gadget may belong to the same Owner.  Rc
allows us to share an Owner between multiple Gadgets, and have the Owner kept
alive as long as any Gadget points at it.</p>
<span id='rust-example-raw-0' class='rusttest'>use std::rc::Rc;

struct Owner {
    name: String
    // ...other fields
}

struct Gadget {
    id: int,
    owner: Rc&lt;Owner&gt;
    // ...other fields
}

fn main() {
    // Create a reference counted Owner.
    let gadget_owner : Rc&lt;Owner&gt; = Rc::new(
            Owner { name: String::from_str(&quot;Gadget Man&quot;) }
    );

    // Create Gadgets belonging to gadget_owner.  To increment the reference
    // count we clone the Rc object.
    let gadget1 = Gadget { id: 1, owner: gadget_owner.clone() };
    let gadget2 = Gadget { id: 2, owner: gadget_owner.clone() };

    drop(gadget_owner);

    // Despite dropping gadget_owner, we&#39;re still able to print out the name of
    // the Owner of the Gadgets. This is because we&#39;ve only dropped the
    // reference count object, not the Owner it wraps. As long as there are
    // other Rc objects pointing at the same Owner, it will stay alive. Notice
    // that the Rc wrapper around Gadget.owner gets automatically dereferenced
    // for us.
    println!(&quot;Gadget {} owned by {}&quot;, gadget1.id, gadget1.owner.name);
    println!(&quot;Gadget {} owned by {}&quot;, gadget2.id, gadget2.owner.name);

    // At the end of the method, gadget1 and gadget2 get destroyed, and with
    // them the last counted references to our Owner.  Gadget Man now gets
    // destroyed as well.
}</span><pre id='rust-example-rendered-0' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>rc</span>::<span class='ident'>Rc</span>;

<span class='kw'>struct</span> <span class='ident'>Owner</span> {
    <span class='ident'>name</span>: <span class='ident'>String</span>
    <span class='comment'>// ...other fields</span>
}

<span class='kw'>struct</span> <span class='ident'>Gadget</span> {
    <span class='ident'>id</span>: <span class='ident'>int</span>,
    <span class='ident'>owner</span>: <span class='ident'>Rc</span><span class='op'>&lt;</span><span class='ident'>Owner</span><span class='op'>&gt;</span>
    <span class='comment'>// ...other fields</span>
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='comment'>// Create a reference counted Owner.</span>
    <span class='kw'>let</span> <span class='ident'>gadget_owner</span> : <span class='ident'>Rc</span><span class='op'>&lt;</span><span class='ident'>Owner</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>Rc</span>::<span class='ident'>new</span>(
            <span class='ident'>Owner</span> { <span class='ident'>name</span>: <span class='ident'>String</span>::<span class='ident'>from_str</span>(<span class='string'>&quot;Gadget Man&quot;</span>) }
    );

    <span class='comment'>// Create Gadgets belonging to gadget_owner.  To increment the reference</span>
    <span class='comment'>// count we clone the Rc object.</span>
    <span class='kw'>let</span> <span class='ident'>gadget1</span> <span class='op'>=</span> <span class='ident'>Gadget</span> { <span class='ident'>id</span>: <span class='number'>1</span>, <span class='ident'>owner</span>: <span class='ident'>gadget_owner</span>.<span class='ident'>clone</span>() };
    <span class='kw'>let</span> <span class='ident'>gadget2</span> <span class='op'>=</span> <span class='ident'>Gadget</span> { <span class='ident'>id</span>: <span class='number'>2</span>, <span class='ident'>owner</span>: <span class='ident'>gadget_owner</span>.<span class='ident'>clone</span>() };

    <span class='ident'>drop</span>(<span class='ident'>gadget_owner</span>);

    <span class='comment'>// Despite dropping gadget_owner, we&#39;re still able to print out the name of</span>
    <span class='comment'>// the Owner of the Gadgets. This is because we&#39;ve only dropped the</span>
    <span class='comment'>// reference count object, not the Owner it wraps. As long as there are</span>
    <span class='comment'>// other Rc objects pointing at the same Owner, it will stay alive. Notice</span>
    <span class='comment'>// that the Rc wrapper around Gadget.owner gets automatically dereferenced</span>
    <span class='comment'>// for us.</span>
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Gadget {} owned by {}&quot;</span>, <span class='ident'>gadget1</span>.<span class='ident'>id</span>, <span class='ident'>gadget1</span>.<span class='ident'>owner</span>.<span class='ident'>name</span>);
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Gadget {} owned by {}&quot;</span>, <span class='ident'>gadget2</span>.<span class='ident'>id</span>, <span class='ident'>gadget2</span>.<span class='ident'>owner</span>.<span class='ident'>name</span>);

    <span class='comment'>// At the end of the method, gadget1 and gadget2 get destroyed, and with</span>
    <span class='comment'>// them the last counted references to our Owner.  Gadget Man now gets</span>
    <span class='comment'>// destroyed as well.</span>
}
</pre>

<p>If our requirements change, and we also need to be able to traverse from
Owner-&gt;Gadget, we will run into problems: an Rc pointer from Owner-&gt;Gadget
introduces a cycle between the objects.  This means that their reference counts
can never reach 0, and the objects will stay alive: a memory leak.  In order to
get around this, we can use <code>Weak</code> pointers.  These are reference counted
pointers that don&#39;t keep an object alive if there are no normal <code>Rc</code> (or
<em>strong</em>) pointers left.</p>

<p>Rust actually makes it somewhat difficult to produce this loop in the first
place: in order to end up with two objects that point at each other, one of
them needs to be mutable.  This is problematic because Rc enforces memory
safety by only giving out shared references to the object it wraps, and these
don&#39;t allow direct mutation.  We need to wrap the part of the object we wish to
mutate in a <code>RefCell</code>, which provides <em>interior mutability</em>: a method to
achieve mutability through a shared reference.  <code>RefCell</code> enforces Rust&#39;s
borrowing rules at runtime.  Read the <code>Cell</code> documentation for more details on
interior mutability.</p>
<span id='rust-example-raw-1' class='rusttest'>use std::rc::Rc;
use std::rc::Weak;
use std::cell::RefCell;

struct Owner {
    name: String,
    gadgets: RefCell&lt;Vec&lt;Weak&lt;Gadget&gt;&gt;&gt;
    // ...other fields
}

struct Gadget {
    id: int,
    owner: Rc&lt;Owner&gt;
    // ...other fields
}

fn main() {
    // Create a reference counted Owner.  Note the fact that we&#39;ve put the
    // Owner&#39;s vector of Gadgets inside a RefCell so that we can mutate it
    // through a shared reference.
    let gadget_owner : Rc&lt;Owner&gt; = Rc::new(
            Owner {
                name: &quot;Gadget Man&quot;.to_string(),
                gadgets: RefCell::new(Vec::new())
            }
    );

    // Create Gadgets belonging to gadget_owner as before.
    let gadget1 = Rc::new(Gadget{id: 1, owner: gadget_owner.clone()});
    let gadget2 = Rc::new(Gadget{id: 2, owner: gadget_owner.clone()});

    // Add the Gadgets to their Owner.  To do this we mutably borrow from
    // the RefCell holding the Owner&#39;s Gadgets.
    gadget_owner.gadgets.borrow_mut().push(gadget1.clone().downgrade());
    gadget_owner.gadgets.borrow_mut().push(gadget2.clone().downgrade());

    // Iterate over our Gadgets, printing their details out
    for gadget_opt in gadget_owner.gadgets.borrow().iter() {

        // gadget_opt is a Weak&lt;Gadget&gt;.  Since weak pointers can&#39;t guarantee
        // that their object is still alive, we need to call upgrade() on them
        // to turn them into a strong reference.  This returns an Option, which
        // contains a reference to our object if it still exists.
        let gadget = gadget_opt.upgrade().unwrap();
        println!(&quot;Gadget {} owned by {}&quot;, gadget.id, gadget.owner.name);
    }

    // At the end of the method, gadget_owner, gadget1 and gadget2 get
    // destroyed.  There are now no strong (Rc) references to the gadgets.
    // Once they get destroyed, the Gadgets get destroyed.  This zeroes the
    // reference count on Gadget Man, so he gets destroyed as well.
}</span><pre id='rust-example-rendered-1' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>rc</span>::<span class='ident'>Rc</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>rc</span>::<span class='ident'>Weak</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>cell</span>::<span class='ident'>RefCell</span>;

<span class='kw'>struct</span> <span class='ident'>Owner</span> {
    <span class='ident'>name</span>: <span class='ident'>String</span>,
    <span class='ident'>gadgets</span>: <span class='ident'>RefCell</span><span class='op'>&lt;</span><span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>Weak</span><span class='op'>&lt;</span><span class='ident'>Gadget</span><span class='op'>&gt;&gt;</span><span class='op'>&gt;</span>
    <span class='comment'>// ...other fields</span>
}

<span class='kw'>struct</span> <span class='ident'>Gadget</span> {
    <span class='ident'>id</span>: <span class='ident'>int</span>,
    <span class='ident'>owner</span>: <span class='ident'>Rc</span><span class='op'>&lt;</span><span class='ident'>Owner</span><span class='op'>&gt;</span>
    <span class='comment'>// ...other fields</span>
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='comment'>// Create a reference counted Owner.  Note the fact that we&#39;ve put the</span>
    <span class='comment'>// Owner&#39;s vector of Gadgets inside a RefCell so that we can mutate it</span>
    <span class='comment'>// through a shared reference.</span>
    <span class='kw'>let</span> <span class='ident'>gadget_owner</span> : <span class='ident'>Rc</span><span class='op'>&lt;</span><span class='ident'>Owner</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>Rc</span>::<span class='ident'>new</span>(
            <span class='ident'>Owner</span> {
                <span class='ident'>name</span>: <span class='string'>&quot;Gadget Man&quot;</span>.<span class='ident'>to_string</span>(),
                <span class='ident'>gadgets</span>: <span class='ident'>RefCell</span>::<span class='ident'>new</span>(<span class='ident'>Vec</span>::<span class='ident'>new</span>())
            }
    );

    <span class='comment'>// Create Gadgets belonging to gadget_owner as before.</span>
    <span class='kw'>let</span> <span class='ident'>gadget1</span> <span class='op'>=</span> <span class='ident'>Rc</span>::<span class='ident'>new</span>(<span class='ident'>Gadget</span>{<span class='ident'>id</span>: <span class='number'>1</span>, <span class='ident'>owner</span>: <span class='ident'>gadget_owner</span>.<span class='ident'>clone</span>()});
    <span class='kw'>let</span> <span class='ident'>gadget2</span> <span class='op'>=</span> <span class='ident'>Rc</span>::<span class='ident'>new</span>(<span class='ident'>Gadget</span>{<span class='ident'>id</span>: <span class='number'>2</span>, <span class='ident'>owner</span>: <span class='ident'>gadget_owner</span>.<span class='ident'>clone</span>()});

    <span class='comment'>// Add the Gadgets to their Owner.  To do this we mutably borrow from</span>
    <span class='comment'>// the RefCell holding the Owner&#39;s Gadgets.</span>
    <span class='ident'>gadget_owner</span>.<span class='ident'>gadgets</span>.<span class='ident'>borrow_mut</span>().<span class='ident'>push</span>(<span class='ident'>gadget1</span>.<span class='ident'>clone</span>().<span class='ident'>downgrade</span>());
    <span class='ident'>gadget_owner</span>.<span class='ident'>gadgets</span>.<span class='ident'>borrow_mut</span>().<span class='ident'>push</span>(<span class='ident'>gadget2</span>.<span class='ident'>clone</span>().<span class='ident'>downgrade</span>());

    <span class='comment'>// Iterate over our Gadgets, printing their details out</span>
    <span class='kw'>for</span> <span class='ident'>gadget_opt</span> <span class='kw'>in</span> <span class='ident'>gadget_owner</span>.<span class='ident'>gadgets</span>.<span class='ident'>borrow</span>().<span class='ident'>iter</span>() {

        <span class='comment'>// gadget_opt is a Weak&lt;Gadget&gt;.  Since weak pointers can&#39;t guarantee</span>
        <span class='comment'>// that their object is still alive, we need to call upgrade() on them</span>
        <span class='comment'>// to turn them into a strong reference.  This returns an Option, which</span>
        <span class='comment'>// contains a reference to our object if it still exists.</span>
        <span class='kw'>let</span> <span class='ident'>gadget</span> <span class='op'>=</span> <span class='ident'>gadget_opt</span>.<span class='ident'>upgrade</span>().<span class='ident'>unwrap</span>();
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Gadget {} owned by {}&quot;</span>, <span class='ident'>gadget</span>.<span class='ident'>id</span>, <span class='ident'>gadget</span>.<span class='ident'>owner</span>.<span class='ident'>name</span>);
    }

    <span class='comment'>// At the end of the method, gadget_owner, gadget1 and gadget2 get</span>
    <span class='comment'>// destroyed.  There are now no strong (Rc) references to the gadgets.</span>
    <span class='comment'>// Once they get destroyed, the Gadgets get destroyed.  This zeroes the</span>
    <span class='comment'>// reference count on Gadget Man, so he gets destroyed as well.</span>
}
</pre>
</div><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table>
                    <tr>
                        <td><a class='stability Stable' title='Stable'></a><a class='struct' href='struct.Rc.html'
                               title='std::rc::Rc'>Rc</a></td>
                        <td class='docblock short'><p>Immutable reference counted pointer type</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental: Weak pointers may not belong in this module.'></a><a class='struct' href='struct.Weak.html'
                               title='std::rc::Weak'>Weak</a></td>
                        <td class='docblock short'><p>Weak reference to a reference-counted box</p>
</td>
                    </tr>
                </table><h2 id='functions' class='section-header'><a href="#functions">Functions</a></h2>
<table>
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='fn' href='fn.get_mut.html'
                               title='std::rc::get_mut'>get_mut</a></td>
                        <td class='docblock short'><p>Returns a mutable reference to the contained value if the <code>Rc</code> has
unique ownership.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='fn' href='fn.is_unique.html'
                               title='std::rc::is_unique'>is_unique</a></td>
                        <td class='docblock short'><p>Returns true if the <code>Rc</code> currently has unique ownership.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='fn' href='fn.try_unwrap.html'
                               title='std::rc::try_unwrap'>try_unwrap</a></td>
                        <td class='docblock short'><p>Unwraps the contained value if the <code>Rc</code> has unique ownership.</p>
</td>
                    </tr>
                </table></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <div id="help" class="hidden">
        <div class="shortcuts">
            <h1>Keyboard shortcuts</h1>
            <dl>
                <dt>?</dt>
                <dd>Show this help dialog</dd>
                <dt>S</dt>
                <dd>Focus the search field</dd>
                <dt>&larrb;</dt>
                <dd>Move up in search results</dd>
                <dt>&rarrb;</dt>
                <dd>Move down in search results</dd>
                <dt>&#9166;</dt>
                <dd>Go to active search result</dd>
            </dl>
        </div>
        <div class="infos">
            <h1>Search tricks</h1>
            <p>
                Prefix searches with a type followed by a colon (e.g.
                <code>fn:</code>) to restrict the search to a given type.
            </p>
            <p>
                Accepted types are: <code>fn</code>, <code>mod</code>,
                <code>struct</code> (or <code>str</code>), <code>enum</code>,
                <code>trait</code>, <code>typedef</code> (or
                <code>tdef</code>).
            </p>
        </div>
    </div>

    

    <script>
        window.rootPath = "../../";
        window.currentCrate = "std";
        window.playgroundUrl = "http://play.rust-lang.org/";
    </script>
    <script src="../../jquery.js"></script>
    <script src="../../main.js"></script>
    <script src="../../playpen.js"></script>
    <script async src="../../search-index.js"></script>
</body>
</html>