<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `Mutex` struct in crate `std`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, Mutex">

    <title>std::sync::Mutex - Rust</title>

    <link rel="stylesheet" type="text/css" href="../../main.css">

    <link rel="shortcut icon" href="http://www.rust-lang.org/favicon.ico">
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <section class="sidebar">
        <a href='../../std/index.html'><img src='http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png' alt='' width='100'></a>
        <p class='location'><a href='../index.html'>std</a>::<wbr><a href='index.html'>sync</a></p><div class='block mod'><h2>Modules</h2><a class='mod ' href='atomic/index.html' title='Atomic types'>atomic</a></div><div class='block struct'><h2>Structs</h2><a class='struct ' href='struct.Arc.html' title='An atomically reference counted wrapper for shared state.'>Arc</a><a class='struct ' href='struct.Barrier.html' title='A barrier enables multiple tasks to synchronize the beginning of some computation.'>Barrier</a><a class='struct ' href='struct.Condvar.html' title='A Condition Variable'>Condvar</a><a class='struct ' href='struct.Future.html' title='A type encapsulating the result of a computation which may not be complete'>Future</a><a class='struct current' href='struct.Mutex.html' title='A mutual exclusion primitive useful for protecting shared data'>Mutex</a><a class='struct ' href='struct.MutexGuard.html' title='An RAII implementation of a &quot;scoped lock&quot; of a mutex. When this structure is dropped (falls out of scope), the lock will be unlocked.'>MutexGuard</a><a class='struct ' href='struct.Once.html' title='A synchronization primitive which can be used to run a one-time global initialization. Useful for one-time initialization for FFI or related functionality. This type can only be constructed with the `ONCE_INIT` value.'>Once</a><a class='struct ' href='struct.RWLock.html' title='A reader-writer lock'>RWLock</a><a class='struct ' href='struct.RWLockReadGuard.html' title='RAII structure used to release the shared read access of a lock when dropped.'>RWLockReadGuard</a><a class='struct ' href='struct.RWLockWriteGuard.html' title='RAII structure used to release the exclusive write access of a lock when dropped.'>RWLockWriteGuard</a><a class='struct ' href='struct.Semaphore.html' title='A counting, blocking, semaphore.'>Semaphore</a><a class='struct ' href='struct.SemaphoreGuard.html' title='An RAII guard which will release a resource acquired from a semaphore when dropped.'>SemaphoreGuard</a><a class='struct ' href='struct.StaticCondvar.html' title='Statically allocated condition variables.'>StaticCondvar</a><a class='struct ' href='struct.StaticMutex.html' title='The static mutex type is provided to allow for static allocation of mutexes.'>StaticMutex</a><a class='struct ' href='struct.StaticMutexGuard.html' title='An RAII implementation of a &quot;scoped lock&quot; of a static mutex. When this structure is dropped (falls out of scope), the lock will be unlocked.'>StaticMutexGuard</a><a class='struct ' href='struct.StaticRWLock.html' title='Structure representing a statically allocated RWLock.'>StaticRWLock</a><a class='struct ' href='struct.StaticRWLockReadGuard.html' title='RAII structure used to release the shared read access of a lock when dropped.'>StaticRWLockReadGuard</a><a class='struct ' href='struct.StaticRWLockWriteGuard.html' title='RAII structure used to release the exclusive write access of a lock when dropped.'>StaticRWLockWriteGuard</a><a class='struct ' href='struct.TaskPool.html' title='A task pool used to execute functions in parallel.'>TaskPool</a><a class='struct ' href='struct.Weak.html' title='A weak pointer to an `Arc`.'>Weak</a></div><div class='block trait'><h2>Traits</h2><a class='trait ' href='trait.AsMutexGuard.html' title='A trait for vaules which can be passed to the waiting methods of condition variables. This is implemented by the mutex guards in this module.'>AsMutexGuard</a></div>
    </section>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press 'S' to search, '?' for more options..."
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content struct">
<h1 class='fqn'><span class='in-band'>Struct <a href='../index.html'>std</a>::<wbr><a href='index.html'>sync</a>::<wbr><a class='struct' href=''>Mutex</a><wbr><a class='stability Experimental' title=''>Experimental</a></span><span class='out-of-band'><span id='render-detail'>
            <a id="collapse-all" href="#">[-]
            </a>&nbsp;<a id="expand-all" href="#">[+]</a>
        </span><a id='src-61631' href='../../src/std/sync/mutex.rs.html#66-74'>[src]</a></span></h1>
<pre class='rust struct'>pub struct Mutex&lt;T&gt; {
    // some fields omitted
}</pre><div class='docblock'><p>A mutual exclusion primitive useful for protecting shared data</p>

<p>This mutex will block threads waiting for the lock to become available. The
mutex can also be statically initialized or created via a <code>new</code>
constructor. Each mutex has a type parameter which represents the data that
it is protecting. The data can only be accessed through the RAII guards
returned from <code>lock</code> and <code>try_lock</code>, which guarantees that the data is only
ever accessed when the mutex is locked.</p>

<h1 id="poisoning" class='section-header'><a
                           href="#poisoning">Poisoning</a></h1>
<p>In order to prevent access to otherwise invalid data, each mutex will
propagate any panics which occur while the lock is held. Once a thread has
panicked while holding the lock, then all other threads will immediately
panic as well once they hold the lock.</p>

<h1 id="example" class='section-header'><a
                           href="#example">Example</a></h1><span id='rust-example-raw-0' class='rusttest'>fn main() {
    use std::sync::{Arc, Mutex};
    use std::thread::Thread;
    const N: uint = 10;
    
    // Spawn a few threads to increment a shared variable (non-atomically), and
    // let the main thread know once all increments are done.
    //
    // Here we&#39;re using an Arc to share memory among tasks, and the data inside
    // the Arc is protected with a mutex.
    let data = Arc::new(Mutex::new(0));
    
    let (tx, rx) = channel();
    for _ in range(0u, 10) {
        let (data, tx) = (data.clone(), tx.clone());
        Thread::spawn(move|| {
            // The shared static can only be accessed once the lock is held.
            // Our non-atomic increment is safe because we&#39;re the only thread
            // which can access the shared state when the lock is held.
            let mut data = data.lock();
            *data += 1;
            if *data == N {
                tx.send(());
            }
            // the lock is unlocked here when `data` goes out of scope.
        }).detach();
    }
    
    rx.recv();
}</span><pre id='rust-example-rendered-0' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>sync</span>::{<span class='ident'>Arc</span>, <span class='ident'>Mutex</span>};
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>thread</span>::<span class='ident'>Thread</span>;
<span class='kw'>const</span> <span class='ident'>N</span>: <span class='ident'>uint</span> <span class='op'>=</span> <span class='number'>10</span>;

<span class='comment'>// Spawn a few threads to increment a shared variable (non-atomically), and</span>
<span class='comment'>// let the main thread know once all increments are done.</span>
<span class='comment'>//</span>
<span class='comment'>// Here we&#39;re using an Arc to share memory among tasks, and the data inside</span>
<span class='comment'>// the Arc is protected with a mutex.</span>
<span class='kw'>let</span> <span class='ident'>data</span> <span class='op'>=</span> <span class='ident'>Arc</span>::<span class='ident'>new</span>(<span class='ident'>Mutex</span>::<span class='ident'>new</span>(<span class='number'>0</span>));

<span class='kw'>let</span> (<span class='ident'>tx</span>, <span class='ident'>rx</span>) <span class='op'>=</span> <span class='ident'>channel</span>();
<span class='kw'>for</span> _ <span class='kw'>in</span> <span class='ident'>range</span>(<span class='number'>0u</span>, <span class='number'>10</span>) {
    <span class='kw'>let</span> (<span class='ident'>data</span>, <span class='ident'>tx</span>) <span class='op'>=</span> (<span class='ident'>data</span>.<span class='ident'>clone</span>(), <span class='ident'>tx</span>.<span class='ident'>clone</span>());
    <span class='ident'>Thread</span>::<span class='ident'>spawn</span>(<span class='kw'>move</span><span class='op'>||</span> {
        <span class='comment'>// The shared static can only be accessed once the lock is held.</span>
        <span class='comment'>// Our non-atomic increment is safe because we&#39;re the only thread</span>
        <span class='comment'>// which can access the shared state when the lock is held.</span>
        <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>data</span> <span class='op'>=</span> <span class='ident'>data</span>.<span class='ident'>lock</span>();
        <span class='op'>*</span><span class='ident'>data</span> <span class='op'>+=</span> <span class='number'>1</span>;
        <span class='kw'>if</span> <span class='op'>*</span><span class='ident'>data</span> <span class='op'>==</span> <span class='ident'>N</span> {
            <span class='ident'>tx</span>.<span class='ident'>send</span>(());
        }
        <span class='comment'>// the lock is unlocked here when `data` goes out of scope.</span>
    }).<span class='ident'>detach</span>();
}

<span class='ident'>rx</span>.<span class='ident'>recv</span>();
</pre>
</div><h2 id='methods'>Methods</h2><h3 class='impl'><a class='stability Experimental' title='Experimental'></a><code>impl&lt;T: <a class='trait' href='../../std/kinds/trait.Send.html' title='std::kinds::Send'>Send</a>&gt; <a class='struct' href='../../std/sync/struct.Mutex.html' title='std::sync::Mutex'>Mutex</a>&lt;T&gt;</code></h3><div class='impl-items'><h4 id='method.new' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.new' class='fnname'>new</a>(t: T) -&gt; <a class='struct' href='../../std/sync/struct.Mutex.html' title='std::sync::Mutex'>Mutex</a>&lt;T&gt;</code></h4>
<div class='docblock'><p>Creates a new mutex in an unlocked state ready for use.</p>
</div><h4 id='method.lock' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.lock' class='fnname'>lock</a>(&amp;self) -&gt; <a class='struct' href='../../std/sync/struct.MutexGuard.html' title='std::sync::MutexGuard'>MutexGuard</a>&lt;T&gt;</code></h4>
<div class='docblock'><p>Acquires a mutex, blocking the current task until it is able to do so.</p>

<p>This function will block the local task until it is available to acquire
the mutex. Upon returning, the task is the only task with the mutex
held. An RAII guard is returned to allow scoped unlock of the lock. When
the guard goes out of scope, the mutex will be unlocked.</p>

<h1 id="panics" class='section-header'><a
                           href="#panics">Panics</a></h1>
<p>If another user of this mutex panicked while holding the mutex, then
this call will immediately panic once the mutex is acquired.</p>
</div><h4 id='method.try_lock' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.try_lock' class='fnname'>try_lock</a>(&amp;self) -&gt; <a class='enum' href='../../std/option/enum.Option.html' title='std::option::Option'>Option</a>&lt;<a class='struct' href='../../std/sync/struct.MutexGuard.html' title='std::sync::MutexGuard'>MutexGuard</a>&lt;T&gt;&gt;</code></h4>
<div class='docblock'><p>Attempts to acquire this lock.</p>

<p>If the lock could not be acquired at this time, then <code>None</code> is returned.
Otherwise, an RAII guard is returned. The lock will be unlocked when the
guard is dropped.</p>

<p>This function does not block.</p>

<h1 id="panics" class='section-header'><a
                           href="#panics">Panics</a></h1>
<p>If another user of this mutex panicked while holding the mutex, then
this call will immediately panic if the mutex would otherwise be
acquired.</p>
</div></div><h2 id='implementations'>Trait Implementations</h2><h3 class='impl'><a class='stability Experimental' title='Experimental'></a><code>impl&lt;T: <a class='trait' href='../../std/kinds/trait.Send.html' title='std::kinds::Send'>Send</a>&gt; <a class='trait' href='../../std/ops/trait.Drop.html' title='std::ops::Drop'>Drop</a> for <a class='struct' href='../../std/sync/struct.Mutex.html' title='std::sync::Mutex'>Mutex</a>&lt;T&gt;</code></h3><div class='impl-items'><h4 id='method.drop' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.drop' class='fnname'>drop</a>(&amp;mut self)</code></h4>
</div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <div id="help" class="hidden">
        <div class="shortcuts">
            <h1>Keyboard shortcuts</h1>
            <dl>
                <dt>?</dt>
                <dd>Show this help dialog</dd>
                <dt>S</dt>
                <dd>Focus the search field</dd>
                <dt>&larrb;</dt>
                <dd>Move up in search results</dd>
                <dt>&rarrb;</dt>
                <dd>Move down in search results</dd>
                <dt>&#9166;</dt>
                <dd>Go to active search result</dd>
            </dl>
        </div>
        <div class="infos">
            <h1>Search tricks</h1>
            <p>
                Prefix searches with a type followed by a colon (e.g.
                <code>fn:</code>) to restrict the search to a given type.
            </p>
            <p>
                Accepted types are: <code>fn</code>, <code>mod</code>,
                <code>struct</code>, <code>enum</code>,
                <code>trait</code>, <code>typedef</code> (or
                <code>tdef</code>).
            </p>
        </div>
    </div>

    

    <script>
        window.rootPath = "../../";
        window.currentCrate = "std";
        window.playgroundUrl = "http://play.rust-lang.org/";
    </script>
    <script src="../../jquery.js"></script>
    <script src="../../main.js"></script>
    <script src="../../playpen.js"></script>
    <script async src="../../search-index.js"></script>
</body>
</html>