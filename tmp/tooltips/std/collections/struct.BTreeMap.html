<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `BTreeMap` struct in crate `std`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, BTreeMap">

    <title>std::collections::BTreeMap - Rust</title>

    <link rel="stylesheet" type="text/css" href="../../main.css">

    <link rel="shortcut icon" href="http://www.rust-lang.org/favicon.ico">
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <section class="sidebar">
        <a href='../../std/index.html'><img src='http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png' alt='' width='100'></a>
        <p class='location'><a href='../index.html'>std</a>::<wbr><a href='index.html'>collections</a></p><div class='block mod'><h2>Modules</h2><a class='mod ' href='binary_heap/index.html' title='A priority queue implemented with a binary heap.'>binary_heap</a><a class='mod ' href='bitv/index.html' title=''>bitv</a><a class='mod ' href='bitv_set/index.html' title=''>bitv_set</a><a class='mod ' href='btree_map/index.html' title=''>btree_map</a><a class='mod ' href='btree_set/index.html' title=''>btree_set</a><a class='mod ' href='dlist/index.html' title='A doubly-linked list with owned nodes.'>dlist</a><a class='mod ' href='enum_set/index.html' title='A structure for holding a set of enum variants.'>enum_set</a><a class='mod ' href='hash_map/index.html' title='A hashmap'>hash_map</a><a class='mod ' href='hash_set/index.html' title='A hashset'>hash_set</a><a class='mod ' href='ring_buf/index.html' title='This crate implements a double-ended queue with `O(1)` amortized inserts and removals from both ends of the container. It also has `O(1)` indexing like a vector. The contained elements are not required to be copyable, and the queue will be sendable if the contained type is sendable.'>ring_buf</a><a class='mod ' href='vec_map/index.html' title='A simple map based on a vector for small integer keys. Space requirements are O(highest integer key).'>vec_map</a></div><div class='block struct'><h2>Structs</h2><a class='struct current' href='struct.BTreeMap.html' title='A map based on a B-Tree.'>BTreeMap</a><a class='struct ' href='struct.BTreeSet.html' title='A set based on a B-Tree.'>BTreeSet</a><a class='struct ' href='struct.BinaryHeap.html' title='A priority queue implemented with a binary heap.'>BinaryHeap</a><a class='struct ' href='struct.Bitv.html' title='The bitvector type.'>Bitv</a><a class='struct ' href='struct.BitvSet.html' title='An implementation of a set using a bit vector as an underlying representation for holding unsigned numerical elements.'>BitvSet</a><a class='struct ' href='struct.DList.html' title='A doubly-linked list.'>DList</a><a class='struct ' href='struct.EnumSet.html' title='A specialized set implementation to use enum types.'>EnumSet</a><a class='struct ' href='struct.HashMap.html' title='A hash map implementation which uses linear probing with Robin Hood bucket stealing.'>HashMap</a><a class='struct ' href='struct.HashSet.html' title='An implementation of a hash set using the underlying representation of a HashMap where the value is (). As with the `HashMap` type, a `HashSet` requires that the elements implement the `Eq` and `Hash` traits.'>HashSet</a><a class='struct ' href='struct.RingBuf.html' title='`RingBuf` is a circular buffer, which can be used as a double-ended queue efficiently.'>RingBuf</a><a class='struct ' href='struct.VecMap.html' title='A map optimized for small integer keys.'>VecMap</a></div>
    </section>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press 'S' to search, '?' for more options..."
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content struct">
<h1 class='fqn'><span class='in-band'>Struct <a href='../index.html'>std</a>::<wbr><a href='index.html'>collections</a>::<wbr><a class='struct' href=''>BTreeMap</a><wbr><a class='stability Experimental' title=''>Experimental</a></span><span class='out-of-band'><span id='render-detail'>
            <a id="collapse-all" href="#">[-]
            </a>&nbsp;<a id="expand-all" href="#">[+]</a>
        </span><a id='src-10451' href='../../collections/btree/map/struct.BTreeMap.html?gotosrc=10451'>[src]</a></span></h1>
<pre class='rust struct'>pub struct BTreeMap&lt;K, V&gt; {
    // some fields omitted
}</pre><div class='docblock'><p>A map based on a B-Tree.</p>

<p>B-Trees represent a fundamental compromise between cache-efficiency and actually minimizing
the amount of work performed in a search. In theory, a binary search tree (BST) is the optimal
choice for a sorted map, as a perfectly balanced BST performs the theoretical minimum amount of
comparisons necessary to find an element (log<sub>2</sub>n). However, in practice the way this
is done is <em>very</em> inefficient for modern computer architectures. In particular, every element
is stored in its own individually heap-allocated node. This means that every single insertion
triggers a heap-allocation, and every single comparison should be a cache-miss. Since these
are both notably expensive things to do in practice, we are forced to at very least reconsider
the BST strategy.</p>

<p>A B-Tree instead makes each node contain B-1 to 2B-1 elements in a contiguous array. By doing
this, we reduce the number of allocations by a factor of B, and improve cache efficiency in
searches. However, this does mean that searches will have to do <em>more</em> comparisons on average.
The precise number of comparisons depends on the node search strategy used. For optimal cache
efficiency, one could search the nodes linearly. For optimal comparisons, one could search
the node using binary search. As a compromise, one could also perform a linear search
that initially only checks every i<sup>th</sup> element for some choice of i.</p>

<p>Currently, our implementation simply performs naive linear search. This provides excellent
performance on <em>small</em> nodes of elements which are cheap to compare. However in the future we
would like to further explore choosing the optimal search strategy based on the choice of B,
and possibly other factors. Using linear search, searching for a random element is expected
to take O(B log<sub>B</sub>n) comparisons, which is generally worse than a BST. In practice,
however, performance is excellent. <code>BTreeMap</code> is able to readily outperform <code>TreeMap</code> under
many workloads, and is competitive where it doesn&#39;t. BTreeMap also generally <em>scales</em> better
than TreeMap, making it more appropriate for large datasets.</p>

<p>However, <code>TreeMap</code> may still be more appropriate to use in many contexts. If elements are very
large or expensive to compare, <code>TreeMap</code> may be more appropriate. It won&#39;t allocate any
more space than is needed, and will perform the minimal number of comparisons necessary.
<code>TreeMap</code> also provides much better performance stability guarantees. Generally, very few
changes need to be made to update a BST, and two updates are expected to take about the same
amount of time on roughly equal sized BSTs. However a B-Tree&#39;s performance is much more
amortized. If a node is overfull, it must be split into two nodes. If a node is underfull, it
may be merged with another. Both of these operations are relatively expensive to perform, and
it&#39;s possible to force one to occur at every single level of the tree in a single insertion or
deletion. In fact, a malicious or otherwise unlucky sequence of insertions and deletions can
force this degenerate behaviour to occur on every operation. While the total amount of work
done on each operation isn&#39;t <em>catastrophic</em>, and <em>is</em> still bounded by O(B log<sub>B</sub>n),
it is certainly much slower when it does.</p>
</div><h2 id='methods'>Methods</h2><h3 class='impl'><a class='stability Experimental' title='Experimental'></a><code>impl&lt;K: <a class='trait' href='../../std/cmp/trait.Ord.html' title='std::cmp::Ord'>Ord</a>&lt;K&gt;, V&gt; <a class='struct' href='../../std/collections/btree_map/struct.BTreeMap.html' title='std::collections::btree_map::BTreeMap'>BTreeMap</a>&lt;K, V&gt;</code></h3><div class='impl-items'><h4 id='method.new' class='method'><a class='stability Unstable' title='Unstable: matches collection reform specification, waiting for dust to settle'></a><code>fn <a href='#method.new' class='fnname'>new</a>() -&gt; <a class='struct' href='../../std/collections/btree_map/struct.BTreeMap.html' title='std::collections::btree_map::BTreeMap'>BTreeMap</a>&lt;K, V&gt;</code></h4>
<div class='docblock'><p>Makes a new empty BTreeMap with a reasonable choice for B.</p>
</div><h4 id='method.with_b' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.with_b' class='fnname'>with_b</a>(b: <a href='../primitive.uint.html'>uint</a>) -&gt; <a class='struct' href='../../std/collections/btree_map/struct.BTreeMap.html' title='std::collections::btree_map::BTreeMap'>BTreeMap</a>&lt;K, V&gt;</code></h4>
<div class='docblock'><p>Makes a new empty BTreeMap with the given B.</p>

<p>B cannot be less than 2.</p>
</div><h4 id='method.clear' class='method'><a class='stability Unstable' title='Unstable: matches collection reform specification, waiting for dust to settle'></a><code>fn <a href='#method.clear' class='fnname'>clear</a>(&amp;mut self)</code></h4>
<div class='docblock'><p>Clears the map, removing all values.</p>

<h1 id="examples" class='section-header'><a
                           href="#examples">Examples</a></h1><span id='rust-example-raw-0' class='rusttest'>fn main() {
    use std::collections::BTreeMap;
    
    let mut a = BTreeMap::new();
    a.insert(1u, &quot;a&quot;);
    a.clear();
    assert!(a.is_empty());
}</span><pre id='rust-example-rendered-0' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>BTreeMap</span>;

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>a</span> <span class='op'>=</span> <span class='ident'>BTreeMap</span>::<span class='ident'>new</span>();
<span class='ident'>a</span>.<span class='ident'>insert</span>(<span class='number'>1u</span>, <span class='string'>&quot;a&quot;</span>);
<span class='ident'>a</span>.<span class='ident'>clear</span>();
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>a</span>.<span class='ident'>is_empty</span>());
</pre>
</div><h4 id='method.find' class='method'><a class='stability Deprecated' title='Deprecated: renamed to `get`'></a><code>fn <a href='#method.find' class='fnname'>find</a>(&amp;self, key: &amp;K) -&gt; <a class='enum' href='../../std/option/enum.Option.html' title='std::option::Option'>Option</a>&lt;&amp;V&gt;</code></h4>
<div class='docblock'><p>Deprecated: renamed to <code>get</code>.</p>
</div><h4 id='method.get' class='method'><a class='stability Unstable' title='Unstable: matches collection reform specification, waiting for dust to settle'></a><code>fn <a href='#method.get' class='fnname'>get</a>&lt;<a class='trait' href='../../std/kinds/trait.Sized.html' title='std::kinds::Sized'>Sized</a>? Q&gt;(&amp;self, key: &amp;Q) -&gt; <a class='enum' href='../../std/option/enum.Option.html' title='std::option::Option'>Option</a>&lt;&amp;V&gt;</code></h4>
<div class='docblock'><p>Returns a reference to the value corresponding to the key.</p>

<p>The key may be any borrowed form of the map&#39;s key type, but the ordering
on the borrowed form <em>must</em> match the ordering on the key type.</p>

<h1 id="examples" class='section-header'><a
                           href="#examples">Examples</a></h1><span id='rust-example-raw-0' class='rusttest'>fn main() {
    use std::collections::BTreeMap;
    
    let mut map = BTreeMap::new();
    map.insert(1u, &quot;a&quot;);
    assert_eq!(map.get(&amp;1), Some(&amp;&quot;a&quot;));
    assert_eq!(map.get(&amp;2), None);
}</span><pre id='rust-example-rendered-0' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>BTreeMap</span>;

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>map</span> <span class='op'>=</span> <span class='ident'>BTreeMap</span>::<span class='ident'>new</span>();
<span class='ident'>map</span>.<span class='ident'>insert</span>(<span class='number'>1u</span>, <span class='string'>&quot;a&quot;</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>map</span>.<span class='ident'>get</span>(<span class='kw-2'>&amp;</span><span class='number'>1</span>), <span class='prelude-val'>Some</span>(<span class='kw-2'>&amp;</span><span class='string'>&quot;a&quot;</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>map</span>.<span class='ident'>get</span>(<span class='kw-2'>&amp;</span><span class='number'>2</span>), <span class='prelude-val'>None</span>);
</pre>
</div><h4 id='method.contains_key' class='method'><a class='stability Unstable' title='Unstable: matches collection reform specification, waiting for dust to settle'></a><code>fn <a href='#method.contains_key' class='fnname'>contains_key</a>&lt;<a class='trait' href='../../std/kinds/trait.Sized.html' title='std::kinds::Sized'>Sized</a>? Q&gt;(&amp;self, key: &amp;Q) -&gt; <a href='../primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>Returns true if the map contains a value for the specified key.</p>

<p>The key may be any borrowed form of the map&#39;s key type, but the ordering
on the borrowed form <em>must</em> match the ordering on the key type.</p>

<h1 id="examples" class='section-header'><a
                           href="#examples">Examples</a></h1><span id='rust-example-raw-0' class='rusttest'>fn main() {
    use std::collections::BTreeMap;
    
    let mut map = BTreeMap::new();
    map.insert(1u, &quot;a&quot;);
    assert_eq!(map.contains_key(&amp;1), true);
    assert_eq!(map.contains_key(&amp;2), false);
}</span><pre id='rust-example-rendered-0' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>BTreeMap</span>;

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>map</span> <span class='op'>=</span> <span class='ident'>BTreeMap</span>::<span class='ident'>new</span>();
<span class='ident'>map</span>.<span class='ident'>insert</span>(<span class='number'>1u</span>, <span class='string'>&quot;a&quot;</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>map</span>.<span class='ident'>contains_key</span>(<span class='kw-2'>&amp;</span><span class='number'>1</span>), <span class='boolval'>true</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>map</span>.<span class='ident'>contains_key</span>(<span class='kw-2'>&amp;</span><span class='number'>2</span>), <span class='boolval'>false</span>);
</pre>
</div><h4 id='method.find_mut' class='method'><a class='stability Deprecated' title='Deprecated: renamed to `get_mut`'></a><code>fn <a href='#method.find_mut' class='fnname'>find_mut</a>(&amp;mut self, key: &amp;K) -&gt; <a class='enum' href='../../std/option/enum.Option.html' title='std::option::Option'>Option</a>&lt;&amp;mut V&gt;</code></h4>
<div class='docblock'><p>Deprecated: renamed to <code>get_mut</code>.</p>
</div><h4 id='method.get_mut' class='method'><a class='stability Unstable' title='Unstable: matches collection reform specification, waiting for dust to settle'></a><code>fn <a href='#method.get_mut' class='fnname'>get_mut</a>&lt;<a class='trait' href='../../std/kinds/trait.Sized.html' title='std::kinds::Sized'>Sized</a>? Q&gt;(&amp;mut self, key: &amp;Q) -&gt; <a class='enum' href='../../std/option/enum.Option.html' title='std::option::Option'>Option</a>&lt;&amp;mut V&gt;</code></h4>
<div class='docblock'><p>Returns a mutable reference to the value corresponding to the key.</p>

<p>The key may be any borrowed form of the map&#39;s key type, but the ordering
on the borrowed form <em>must</em> match the ordering on the key type.</p>

<h1 id="examples" class='section-header'><a
                           href="#examples">Examples</a></h1><span id='rust-example-raw-0' class='rusttest'>fn main() {
    use std::collections::BTreeMap;
    
    let mut map = BTreeMap::new();
    map.insert(1u, &quot;a&quot;);
    match map.get_mut(&amp;1) {
        Some(x) =&gt; *x = &quot;b&quot;,
        None =&gt; (),
    }
    assert_eq!(map[1], &quot;b&quot;);
}</span><pre id='rust-example-rendered-0' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>BTreeMap</span>;

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>map</span> <span class='op'>=</span> <span class='ident'>BTreeMap</span>::<span class='ident'>new</span>();
<span class='ident'>map</span>.<span class='ident'>insert</span>(<span class='number'>1u</span>, <span class='string'>&quot;a&quot;</span>);
<span class='kw'>match</span> <span class='ident'>map</span>.<span class='ident'>get_mut</span>(<span class='kw-2'>&amp;</span><span class='number'>1</span>) {
    <span class='prelude-val'>Some</span>(<span class='ident'>x</span>) <span class='op'>=&gt;</span> <span class='op'>*</span><span class='ident'>x</span> <span class='op'>=</span> <span class='string'>&quot;b&quot;</span>,
    <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> (),
}
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>map</span>[<span class='number'>1</span>], <span class='string'>&quot;b&quot;</span>);
</pre>
</div><h4 id='method.swap' class='method'><a class='stability Deprecated' title='Deprecated: renamed to `insert`'></a><code>fn <a href='#method.swap' class='fnname'>swap</a>(&amp;mut self, key: K, value: V) -&gt; <a class='enum' href='../../std/option/enum.Option.html' title='std::option::Option'>Option</a>&lt;V&gt;</code></h4>
<div class='docblock'><p>Deprecated: renamed to <code>insert</code>.</p>
</div><h4 id='method.insert' class='method'><a class='stability Unstable' title='Unstable: matches collection reform specification, waiting for dust to settle'></a><code>fn <a href='#method.insert' class='fnname'>insert</a>(&amp;mut self, key: K, value: V) -&gt; <a class='enum' href='../../std/option/enum.Option.html' title='std::option::Option'>Option</a>&lt;V&gt;</code></h4>
<div class='docblock'><p>Inserts a key-value pair from the map. If the key already had a value
present in the map, that value is returned. Otherwise, <code>None</code> is returned.</p>

<h1 id="examples" class='section-header'><a
                           href="#examples">Examples</a></h1><span id='rust-example-raw-0' class='rusttest'>fn main() {
    use std::collections::BTreeMap;
    
    let mut map = BTreeMap::new();
    assert_eq!(map.insert(37u, &quot;a&quot;), None);
    assert_eq!(map.is_empty(), false);
    
    map.insert(37, &quot;b&quot;);
    assert_eq!(map.insert(37, &quot;c&quot;), Some(&quot;b&quot;));
    assert_eq!(map[37], &quot;c&quot;);
}</span><pre id='rust-example-rendered-0' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>BTreeMap</span>;

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>map</span> <span class='op'>=</span> <span class='ident'>BTreeMap</span>::<span class='ident'>new</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>map</span>.<span class='ident'>insert</span>(<span class='number'>37u</span>, <span class='string'>&quot;a&quot;</span>), <span class='prelude-val'>None</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>map</span>.<span class='ident'>is_empty</span>(), <span class='boolval'>false</span>);

<span class='ident'>map</span>.<span class='ident'>insert</span>(<span class='number'>37</span>, <span class='string'>&quot;b&quot;</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>map</span>.<span class='ident'>insert</span>(<span class='number'>37</span>, <span class='string'>&quot;c&quot;</span>), <span class='prelude-val'>Some</span>(<span class='string'>&quot;b&quot;</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>map</span>[<span class='number'>37</span>], <span class='string'>&quot;c&quot;</span>);
</pre>
</div><h4 id='method.pop' class='method'><a class='stability Deprecated' title='Deprecated: renamed to `remove`'></a><code>fn <a href='#method.pop' class='fnname'>pop</a>(&amp;mut self, key: &amp;K) -&gt; <a class='enum' href='../../std/option/enum.Option.html' title='std::option::Option'>Option</a>&lt;V&gt;</code></h4>
<div class='docblock'><p>Deprecated: renamed to <code>remove</code>.</p>
</div><h4 id='method.remove' class='method'><a class='stability Unstable' title='Unstable: matches collection reform specification, waiting for dust to settle'></a><code>fn <a href='#method.remove' class='fnname'>remove</a>&lt;<a class='trait' href='../../std/kinds/trait.Sized.html' title='std::kinds::Sized'>Sized</a>? Q&gt;(&amp;mut self, key: &amp;Q) -&gt; <a class='enum' href='../../std/option/enum.Option.html' title='std::option::Option'>Option</a>&lt;V&gt;</code></h4>
<div class='docblock'><p>Removes a key from the map, returning the value at the key if the key
was previously in the map.</p>

<p>The key may be any borrowed form of the map&#39;s key type, but the ordering
on the borrowed form <em>must</em> match the ordering on the key type.</p>

<h1 id="examples" class='section-header'><a
                           href="#examples">Examples</a></h1><span id='rust-example-raw-0' class='rusttest'>fn main() {
    use std::collections::BTreeMap;
    
    let mut map = BTreeMap::new();
    map.insert(1u, &quot;a&quot;);
    assert_eq!(map.remove(&amp;1), Some(&quot;a&quot;));
    assert_eq!(map.remove(&amp;1), None);
}</span><pre id='rust-example-rendered-0' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>BTreeMap</span>;

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>map</span> <span class='op'>=</span> <span class='ident'>BTreeMap</span>::<span class='ident'>new</span>();
<span class='ident'>map</span>.<span class='ident'>insert</span>(<span class='number'>1u</span>, <span class='string'>&quot;a&quot;</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>map</span>.<span class='ident'>remove</span>(<span class='kw-2'>&amp;</span><span class='number'>1</span>), <span class='prelude-val'>Some</span>(<span class='string'>&quot;a&quot;</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>map</span>.<span class='ident'>remove</span>(<span class='kw-2'>&amp;</span><span class='number'>1</span>), <span class='prelude-val'>None</span>);
</pre>
</div></div><h3 class='impl'><a class='stability Experimental' title='Experimental'></a><code>impl&lt;K, V&gt; <a class='struct' href='../../std/collections/btree_map/struct.BTreeMap.html' title='std::collections::btree_map::BTreeMap'>BTreeMap</a>&lt;K, V&gt;</code></h3><div class='impl-items'><h4 id='method.iter' class='method'><a class='stability Unstable' title='Unstable: matches collection reform specification, waiting for dust to settle'></a><code>fn <a href='#method.iter' class='fnname'>iter</a>(&amp;'a self) -&gt; <a class='struct' href='../../std/collections/btree_map/struct.Iter.html' title='std::collections::btree_map::Iter'>Iter</a>&lt;'a, K, V&gt;</code></h4>
<div class='docblock'><p>Gets an iterator over the entries of the map.</p>

<h1 id="example" class='section-header'><a
                           href="#example">Example</a></h1><span id='rust-example-raw-0' class='rusttest'>fn main() {
    use std::collections::BTreeMap;
    
    let mut map = BTreeMap::new();
    map.insert(1u, &quot;a&quot;);
    map.insert(2u, &quot;b&quot;);
    map.insert(3u, &quot;c&quot;);
    
    for (key, value) in map.iter() {
        println!(&quot;{}: {}&quot;, key, value);
    }
    
    let (first_key, first_value) = map.iter().next().unwrap();
    assert_eq!((*first_key, *first_value), (1u, &quot;a&quot;));
}</span><pre id='rust-example-rendered-0' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>BTreeMap</span>;

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>map</span> <span class='op'>=</span> <span class='ident'>BTreeMap</span>::<span class='ident'>new</span>();
<span class='ident'>map</span>.<span class='ident'>insert</span>(<span class='number'>1u</span>, <span class='string'>&quot;a&quot;</span>);
<span class='ident'>map</span>.<span class='ident'>insert</span>(<span class='number'>2u</span>, <span class='string'>&quot;b&quot;</span>);
<span class='ident'>map</span>.<span class='ident'>insert</span>(<span class='number'>3u</span>, <span class='string'>&quot;c&quot;</span>);

<span class='kw'>for</span> (<span class='ident'>key</span>, <span class='ident'>value</span>) <span class='kw'>in</span> <span class='ident'>map</span>.<span class='ident'>iter</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}: {}&quot;</span>, <span class='ident'>key</span>, <span class='ident'>value</span>);
}

<span class='kw'>let</span> (<span class='ident'>first_key</span>, <span class='ident'>first_value</span>) <span class='op'>=</span> <span class='ident'>map</span>.<span class='ident'>iter</span>().<span class='ident'>next</span>().<span class='ident'>unwrap</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>((<span class='op'>*</span><span class='ident'>first_key</span>, <span class='op'>*</span><span class='ident'>first_value</span>), (<span class='number'>1u</span>, <span class='string'>&quot;a&quot;</span>));
</pre>
</div><h4 id='method.iter_mut' class='method'><a class='stability Unstable' title='Unstable: matches collection reform specification, waiting for dust to settle'></a><code>fn <a href='#method.iter_mut' class='fnname'>iter_mut</a>(&amp;'a mut self) -&gt; <a class='struct' href='../../std/collections/btree_map/struct.IterMut.html' title='std::collections::btree_map::IterMut'>IterMut</a>&lt;'a, K, V&gt;</code></h4>
<div class='docblock'><p>Gets a mutable iterator over the entries of the map.</p>

<h1 id="examples" class='section-header'><a
                           href="#examples">Examples</a></h1><span id='rust-example-raw-0' class='rusttest'>fn main() {
    use std::collections::BTreeMap;
    
    let mut map = BTreeMap::new();
    map.insert(&quot;a&quot;, 1u);
    map.insert(&quot;b&quot;, 2u);
    map.insert(&quot;c&quot;, 3u);
    
    // add 10 to the value if the key isn&#39;t &quot;a&quot;
    for (key, value) in map.iter_mut() {
        if key != &amp;&quot;a&quot; {
            *value += 10;
        }
    }
}</span><pre id='rust-example-rendered-0' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>BTreeMap</span>;

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>map</span> <span class='op'>=</span> <span class='ident'>BTreeMap</span>::<span class='ident'>new</span>();
<span class='ident'>map</span>.<span class='ident'>insert</span>(<span class='string'>&quot;a&quot;</span>, <span class='number'>1u</span>);
<span class='ident'>map</span>.<span class='ident'>insert</span>(<span class='string'>&quot;b&quot;</span>, <span class='number'>2u</span>);
<span class='ident'>map</span>.<span class='ident'>insert</span>(<span class='string'>&quot;c&quot;</span>, <span class='number'>3u</span>);

<span class='comment'>// add 10 to the value if the key isn&#39;t &quot;a&quot;</span>
<span class='kw'>for</span> (<span class='ident'>key</span>, <span class='ident'>value</span>) <span class='kw'>in</span> <span class='ident'>map</span>.<span class='ident'>iter_mut</span>() {
    <span class='kw'>if</span> <span class='ident'>key</span> <span class='op'>!=</span> <span class='kw-2'>&amp;</span><span class='string'>&quot;a&quot;</span> {
        <span class='op'>*</span><span class='ident'>value</span> <span class='op'>+=</span> <span class='number'>10</span>;
    }
}
</pre>
</div><h4 id='method.into_iter' class='method'><a class='stability Unstable' title='Unstable: matches collection reform specification, waiting for dust to settle'></a><code>fn <a href='#method.into_iter' class='fnname'>into_iter</a>(self) -&gt; <a class='struct' href='../../std/collections/btree_map/struct.IntoIter.html' title='std::collections::btree_map::IntoIter'>IntoIter</a>&lt;K, V&gt;</code></h4>
<div class='docblock'><p>Gets an owning iterator over the entries of the map.</p>

<h1 id="examples" class='section-header'><a
                           href="#examples">Examples</a></h1><span id='rust-example-raw-0' class='rusttest'>fn main() {
    use std::collections::BTreeMap;
    
    let mut map = BTreeMap::new();
    map.insert(1u, &quot;a&quot;);
    map.insert(2u, &quot;b&quot;);
    map.insert(3u, &quot;c&quot;);
    
    for (key, value) in map.into_iter() {
        println!(&quot;{}: {}&quot;, key, value);
    }
}</span><pre id='rust-example-rendered-0' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>BTreeMap</span>;

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>map</span> <span class='op'>=</span> <span class='ident'>BTreeMap</span>::<span class='ident'>new</span>();
<span class='ident'>map</span>.<span class='ident'>insert</span>(<span class='number'>1u</span>, <span class='string'>&quot;a&quot;</span>);
<span class='ident'>map</span>.<span class='ident'>insert</span>(<span class='number'>2u</span>, <span class='string'>&quot;b&quot;</span>);
<span class='ident'>map</span>.<span class='ident'>insert</span>(<span class='number'>3u</span>, <span class='string'>&quot;c&quot;</span>);

<span class='kw'>for</span> (<span class='ident'>key</span>, <span class='ident'>value</span>) <span class='kw'>in</span> <span class='ident'>map</span>.<span class='ident'>into_iter</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}: {}&quot;</span>, <span class='ident'>key</span>, <span class='ident'>value</span>);
}
</pre>
</div><h4 id='method.keys' class='method'><a class='stability Unstable' title='Unstable: matches collection reform specification, waiting for dust to settle'></a><code>fn <a href='#method.keys' class='fnname'>keys</a>(&amp;'a self) -&gt; <a class='struct' href='../../std/collections/btree_map/struct.Keys.html' title='std::collections::btree_map::Keys'>Keys</a>&lt;'a, K, V&gt;</code></h4>
<div class='docblock'><p>Gets an iterator over the keys of the map.</p>

<h1 id="examples" class='section-header'><a
                           href="#examples">Examples</a></h1><span id='rust-example-raw-0' class='rusttest'>fn main() {
    use std::collections::BTreeMap;
    
    let mut a = BTreeMap::new();
    a.insert(1u, &quot;a&quot;);
    a.insert(2u, &quot;b&quot;);
    
    let keys: Vec&lt;uint&gt; = a.keys().cloned().collect();
    assert_eq!(keys, vec![1u,2,]);
}</span><pre id='rust-example-rendered-0' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>BTreeMap</span>;

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>a</span> <span class='op'>=</span> <span class='ident'>BTreeMap</span>::<span class='ident'>new</span>();
<span class='ident'>a</span>.<span class='ident'>insert</span>(<span class='number'>1u</span>, <span class='string'>&quot;a&quot;</span>);
<span class='ident'>a</span>.<span class='ident'>insert</span>(<span class='number'>2u</span>, <span class='string'>&quot;b&quot;</span>);

<span class='kw'>let</span> <span class='ident'>keys</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>uint</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>a</span>.<span class='ident'>keys</span>().<span class='ident'>cloned</span>().<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>keys</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1u</span>,<span class='number'>2</span>,]);
</pre>
</div><h4 id='method.values' class='method'><a class='stability Unstable' title='Unstable: matches collection reform specification, waiting for dust to settle'></a><code>fn <a href='#method.values' class='fnname'>values</a>(&amp;'a self) -&gt; <a class='struct' href='../../std/collections/btree_map/struct.Values.html' title='std::collections::btree_map::Values'>Values</a>&lt;'a, K, V&gt;</code></h4>
<div class='docblock'><p>Gets an iterator over the values of the map.</p>

<h1 id="examples" class='section-header'><a
                           href="#examples">Examples</a></h1><span id='rust-example-raw-0' class='rusttest'>fn main() {
    use std::collections::BTreeMap;
    
    let mut a = BTreeMap::new();
    a.insert(1u, &quot;a&quot;);
    a.insert(2u, &quot;b&quot;);
    
    let values: Vec&lt;&amp;str&gt; = a.values().cloned().collect();
    assert_eq!(values, vec![&quot;a&quot;,&quot;b&quot;]);
}</span><pre id='rust-example-rendered-0' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>BTreeMap</span>;

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>a</span> <span class='op'>=</span> <span class='ident'>BTreeMap</span>::<span class='ident'>new</span>();
<span class='ident'>a</span>.<span class='ident'>insert</span>(<span class='number'>1u</span>, <span class='string'>&quot;a&quot;</span>);
<span class='ident'>a</span>.<span class='ident'>insert</span>(<span class='number'>2u</span>, <span class='string'>&quot;b&quot;</span>);

<span class='kw'>let</span> <span class='ident'>values</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>str</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>a</span>.<span class='ident'>values</span>().<span class='ident'>cloned</span>().<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>values</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;a&quot;</span>,<span class='string'>&quot;b&quot;</span>]);
</pre>
</div><h4 id='method.len' class='method'><a class='stability Unstable' title='Unstable: matches collection reform specification, waiting for dust to settle'></a><code>fn <a href='#method.len' class='fnname'>len</a>(&amp;self) -&gt; <a href='../primitive.uint.html'>uint</a></code></h4>
<div class='docblock'><p>Return the number of elements in the map.</p>

<h1 id="examples" class='section-header'><a
                           href="#examples">Examples</a></h1><span id='rust-example-raw-0' class='rusttest'>fn main() {
    use std::collections::BTreeMap;
    
    let mut a = BTreeMap::new();
    assert_eq!(a.len(), 0);
    a.insert(1u, &quot;a&quot;);
    assert_eq!(a.len(), 1);
}</span><pre id='rust-example-rendered-0' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>BTreeMap</span>;

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>a</span> <span class='op'>=</span> <span class='ident'>BTreeMap</span>::<span class='ident'>new</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>a</span>.<span class='ident'>len</span>(), <span class='number'>0</span>);
<span class='ident'>a</span>.<span class='ident'>insert</span>(<span class='number'>1u</span>, <span class='string'>&quot;a&quot;</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>a</span>.<span class='ident'>len</span>(), <span class='number'>1</span>);
</pre>
</div><h4 id='method.is_empty' class='method'><a class='stability Unstable' title='Unstable: matches collection reform specification, waiting for dust to settle'></a><code>fn <a href='#method.is_empty' class='fnname'>is_empty</a>(&amp;self) -&gt; <a href='../primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>Return true if the map contains no elements.</p>

<h1 id="examples" class='section-header'><a
                           href="#examples">Examples</a></h1><span id='rust-example-raw-0' class='rusttest'>fn main() {
    use std::collections::BTreeMap;
    
    let mut a = BTreeMap::new();
    assert!(a.is_empty());
    a.insert(1u, &quot;a&quot;);
    assert!(!a.is_empty());
}</span><pre id='rust-example-rendered-0' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>BTreeMap</span>;

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>a</span> <span class='op'>=</span> <span class='ident'>BTreeMap</span>::<span class='ident'>new</span>();
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>a</span>.<span class='ident'>is_empty</span>());
<span class='ident'>a</span>.<span class='ident'>insert</span>(<span class='number'>1u</span>, <span class='string'>&quot;a&quot;</span>);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='op'>!</span><span class='ident'>a</span>.<span class='ident'>is_empty</span>());
</pre>
</div></div><h3 class='impl'><a class='stability Experimental' title='Experimental'></a><code>impl&lt;K: <a class='trait' href='../../std/cmp/trait.Ord.html' title='std::cmp::Ord'>Ord</a>&lt;K&gt;, V&gt; <a class='struct' href='../../std/collections/btree_map/struct.BTreeMap.html' title='std::collections::btree_map::BTreeMap'>BTreeMap</a>&lt;K, V&gt;</code></h3><div class='impl-items'><h4 id='method.entry' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.entry' class='fnname'>entry</a>(&amp;'a mut self, key: K) -&gt; <a class='enum' href='../../std/collections/btree_map/enum.Entry.html' title='std::collections::btree_map::Entry'>Entry</a>&lt;'a, K, V&gt;</code></h4>
<div class='docblock'><p>Gets the given key&#39;s corresponding entry in the map for in-place manipulation.</p>

<h1 id="examples" class='section-header'><a
                           href="#examples">Examples</a></h1><span id='rust-example-raw-0' class='rusttest'>fn main() {
    use std::collections::BTreeMap;
    use std::collections::btree_map::Entry;
    
    let mut count: BTreeMap&lt;&amp;str, uint&gt; = BTreeMap::new();
    
    // count the number of occurrences of letters in the vec
    for x in vec![&quot;a&quot;,&quot;b&quot;,&quot;a&quot;,&quot;c&quot;,&quot;a&quot;,&quot;b&quot;].iter() {
        match count.entry(*x) {
            Entry::Vacant(view) =&gt; {
                view.set(1);
            },
            Entry::Occupied(mut view) =&gt; {
                let v = view.get_mut();
                *v += 1;
            },
        }
    }
    
    assert_eq!(count[&quot;a&quot;], 3u);
}</span><pre id='rust-example-rendered-0' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>BTreeMap</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>btree_map</span>::<span class='ident'>Entry</span>;

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>count</span>: <span class='ident'>BTreeMap</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>str</span>, <span class='ident'>uint</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>BTreeMap</span>::<span class='ident'>new</span>();

<span class='comment'>// count the number of occurrences of letters in the vec</span>
<span class='kw'>for</span> <span class='ident'>x</span> <span class='kw'>in</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;a&quot;</span>,<span class='string'>&quot;b&quot;</span>,<span class='string'>&quot;a&quot;</span>,<span class='string'>&quot;c&quot;</span>,<span class='string'>&quot;a&quot;</span>,<span class='string'>&quot;b&quot;</span>].<span class='ident'>iter</span>() {
    <span class='kw'>match</span> <span class='ident'>count</span>.<span class='ident'>entry</span>(<span class='op'>*</span><span class='ident'>x</span>) {
        <span class='ident'>Entry</span>::<span class='ident'>Vacant</span>(<span class='ident'>view</span>) <span class='op'>=&gt;</span> {
            <span class='ident'>view</span>.<span class='ident'>set</span>(<span class='number'>1</span>);
        },
        <span class='ident'>Entry</span>::<span class='ident'>Occupied</span>(<span class='kw-2'>mut</span> <span class='ident'>view</span>) <span class='op'>=&gt;</span> {
            <span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='ident'>view</span>.<span class='ident'>get_mut</span>();
            <span class='op'>*</span><span class='ident'>v</span> <span class='op'>+=</span> <span class='number'>1</span>;
        },
    }
}

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>count</span>[<span class='string'>&quot;a&quot;</span>], <span class='number'>3u</span>);
</pre>
</div></div><h2 id='implementations'>Trait Implementations</h2><h3 class='impl'><a class='stability Unstable' title='Unstable: may be replaced by a more general conversion trait'></a><code>impl&lt;K: <a class='trait' href='../../std/cmp/trait.Ord.html' title='std::cmp::Ord'>Ord</a>&lt;K&gt;, V&gt; <a class='trait' href='../../std/iter/trait.FromIterator.html' title='std::iter::FromIterator'>FromIterator</a>&lt;<a href='../primitive.tuple.html'>(K, V)</a>&gt; for <a class='struct' href='../../std/collections/btree_map/struct.BTreeMap.html' title='std::collections::btree_map::BTreeMap'>BTreeMap</a>&lt;K, V&gt;</code></h3><div class='impl-items'><h4 id='method.from_iter' class='method'><a class='stability Unstable' title='Unstable: may be replaced by a more general conversion trait'></a><code>fn <a href='#method.from_iter' class='fnname'>from_iter</a>&lt;T: <a class='trait' href='../../std/iter/trait.Iterator.html' title='std::iter::Iterator'>Iterator</a>&lt;<a href='../primitive.tuple.html'>(K, V)</a>&gt;&gt;(iter: T) -&gt; <a class='struct' href='../../std/collections/btree_map/struct.BTreeMap.html' title='std::collections::btree_map::BTreeMap'>BTreeMap</a>&lt;K, V&gt;</code></h4>
</div><h3 class='impl'><a class='stability Unstable' title='Unstable: just renamed as part of collections reform'></a><code>impl&lt;K: <a class='trait' href='../../std/cmp/trait.Ord.html' title='std::cmp::Ord'>Ord</a>&lt;K&gt;, V&gt; <a class='trait' href='../../std/iter/trait.Extend.html' title='std::iter::Extend'>Extend</a>&lt;<a href='../primitive.tuple.html'>(K, V)</a>&gt; for <a class='struct' href='../../std/collections/btree_map/struct.BTreeMap.html' title='std::collections::btree_map::BTreeMap'>BTreeMap</a>&lt;K, V&gt;</code></h3><div class='impl-items'><h4 id='method.extend' class='method'><a class='stability Unstable' title='Unstable: just renamed as part of collections reform'></a><code>fn <a href='#method.extend' class='fnname'>extend</a>&lt;T: <a class='trait' href='../../std/iter/trait.Iterator.html' title='std::iter::Iterator'>Iterator</a>&lt;<a href='../primitive.tuple.html'>(K, V)</a>&gt;&gt;(&amp;mut self, iter: T)</code></h4>
</div><h3 class='impl'><a class='stability Experimental' title='Experimental'></a><code>impl&lt;S: <a class='trait' href='../../std/hash/trait.Writer.html' title='std::hash::Writer'>Writer</a>, K: <a class='trait' href='../../std/hash/trait.Hash.html' title='std::hash::Hash'>Hash</a>&lt;S&gt;, V: <a class='trait' href='../../std/hash/trait.Hash.html' title='std::hash::Hash'>Hash</a>&lt;S&gt;&gt; <a class='trait' href='../../std/hash/trait.Hash.html' title='std::hash::Hash'>Hash</a>&lt;S&gt; for <a class='struct' href='../../std/collections/btree_map/struct.BTreeMap.html' title='std::collections::btree_map::BTreeMap'>BTreeMap</a>&lt;K, V&gt;</code></h3><div class='impl-items'><h4 id='method.hash' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.hash' class='fnname'>hash</a>(&amp;self, state: &amp;mut S)</code></h4>
</div><h3 class='impl'><a class='stability Stable' title='Stable'></a><code>impl&lt;K: <a class='trait' href='../../std/cmp/trait.Ord.html' title='std::cmp::Ord'>Ord</a>&lt;K&gt;, V&gt; <a class='trait' href='../../std/default/trait.Default.html' title='std::default::Default'>Default</a> for <a class='struct' href='../../std/collections/btree_map/struct.BTreeMap.html' title='std::collections::btree_map::BTreeMap'>BTreeMap</a>&lt;K, V&gt;</code></h3><div class='impl-items'><h4 id='method.default' class='method'><a class='stability Stable' title='Stable'></a><code>fn <a href='#method.default' class='fnname'>default</a>() -&gt; <a class='struct' href='../../std/collections/btree_map/struct.BTreeMap.html' title='std::collections::btree_map::BTreeMap'>BTreeMap</a>&lt;K, V&gt;</code></h4>
</div><h3 class='impl'><a class='stability Unstable' title='Unstable: Definition may change slightly after trait reform'></a><code>impl&lt;K: <a class='trait' href='../../std/cmp/trait.PartialEq.html' title='std::cmp::PartialEq'>PartialEq</a>&lt;K&gt;, V: <a class='trait' href='../../std/cmp/trait.PartialEq.html' title='std::cmp::PartialEq'>PartialEq</a>&lt;V&gt;&gt; <a class='trait' href='../../std/cmp/trait.PartialEq.html' title='std::cmp::PartialEq'>PartialEq</a>&lt;<a class='struct' href='../../std/collections/btree_map/struct.BTreeMap.html' title='std::collections::btree_map::BTreeMap'>BTreeMap</a>&lt;K, V&gt;&gt; for <a class='struct' href='../../std/collections/btree_map/struct.BTreeMap.html' title='std::collections::btree_map::BTreeMap'>BTreeMap</a>&lt;K, V&gt;</code></h3><div class='impl-items'><h4 id='method.eq' class='method'><a class='stability Unstable' title='Unstable: Definition may change slightly after trait reform'></a><code>fn <a href='#method.eq' class='fnname'>eq</a>(&amp;self, other: &amp;<a class='struct' href='../../std/collections/btree_map/struct.BTreeMap.html' title='std::collections::btree_map::BTreeMap'>BTreeMap</a>&lt;K, V&gt;) -&gt; <a href='../primitive.bool.html'>bool</a></code></h4>
<h4 id='method.ne' class='method'><a class='stability Unstable' title='Unstable: Definition may change slightly after trait reform'></a><code>fn <a href='#method.ne' class='fnname'>ne</a>(&amp;self, &amp;<a class='struct' href='../../std/collections/btree_map/struct.BTreeMap.html' title='std::collections::btree_map::BTreeMap'>BTreeMap</a>&lt;K, V&gt;) -&gt; <a href='../primitive.bool.html'>bool</a></code></h4>
</div><h3 class='impl'><a class='stability Unstable' title='Unstable: Definition may change slightly after trait reform'></a><code>impl&lt;K: <a class='trait' href='../../std/cmp/trait.Eq.html' title='std::cmp::Eq'>Eq</a>&lt;K&gt;, V: <a class='trait' href='../../std/cmp/trait.Eq.html' title='std::cmp::Eq'>Eq</a>&lt;V&gt;&gt; <a class='trait' href='../../std/cmp/trait.Eq.html' title='std::cmp::Eq'>Eq</a>&lt;<a class='struct' href='../../std/collections/btree_map/struct.BTreeMap.html' title='std::collections::btree_map::BTreeMap'>BTreeMap</a>&lt;K, V&gt;&gt; for <a class='struct' href='../../std/collections/btree_map/struct.BTreeMap.html' title='std::collections::btree_map::BTreeMap'>BTreeMap</a>&lt;K, V&gt;</code></h3><div class='impl-items'><h4 id='method.assert_receiver_is_total_eq' class='method'><a class='stability Unstable' title='Unstable: Definition may change slightly after trait reform'></a><code>fn <a href='#method.assert_receiver_is_total_eq' class='fnname'>assert_receiver_is_total_eq</a>(&amp;self)</code></h4>
</div><h3 class='impl'><a class='stability Unstable' title='Unstable: Definition may change slightly after trait reform'></a><code>impl&lt;K: <a class='trait' href='../../std/cmp/trait.PartialOrd.html' title='std::cmp::PartialOrd'>PartialOrd</a>&lt;K&gt;, V: <a class='trait' href='../../std/cmp/trait.PartialOrd.html' title='std::cmp::PartialOrd'>PartialOrd</a>&lt;V&gt;&gt; <a class='trait' href='../../std/cmp/trait.PartialOrd.html' title='std::cmp::PartialOrd'>PartialOrd</a>&lt;<a class='struct' href='../../std/collections/btree_map/struct.BTreeMap.html' title='std::collections::btree_map::BTreeMap'>BTreeMap</a>&lt;K, V&gt;&gt; for <a class='struct' href='../../std/collections/btree_map/struct.BTreeMap.html' title='std::collections::btree_map::BTreeMap'>BTreeMap</a>&lt;K, V&gt;</code></h3><div class='impl-items'><h4 id='method.partial_cmp' class='method'><a class='stability Unstable' title='Unstable: Definition may change slightly after trait reform'></a><code>fn <a href='#method.partial_cmp' class='fnname'>partial_cmp</a>(&amp;self, other: &amp;<a class='struct' href='../../std/collections/btree_map/struct.BTreeMap.html' title='std::collections::btree_map::BTreeMap'>BTreeMap</a>&lt;K, V&gt;) -&gt; <a class='enum' href='../../std/option/enum.Option.html' title='std::option::Option'>Option</a>&lt;<a class='enum' href='../../std/cmp/enum.Ordering.html' title='std::cmp::Ordering'>Ordering</a>&gt;</code></h4>
<h4 id='method.lt' class='method'><a class='stability Unstable' title='Unstable: Definition may change slightly after trait reform'></a><code>fn <a href='#method.lt' class='fnname'>lt</a>(&amp;self, &amp;<a class='struct' href='../../std/collections/btree_map/struct.BTreeMap.html' title='std::collections::btree_map::BTreeMap'>BTreeMap</a>&lt;K, V&gt;) -&gt; <a href='../primitive.bool.html'>bool</a></code></h4>
<h4 id='method.le' class='method'><a class='stability Unstable' title='Unstable: Definition may change slightly after trait reform'></a><code>fn <a href='#method.le' class='fnname'>le</a>(&amp;self, &amp;<a class='struct' href='../../std/collections/btree_map/struct.BTreeMap.html' title='std::collections::btree_map::BTreeMap'>BTreeMap</a>&lt;K, V&gt;) -&gt; <a href='../primitive.bool.html'>bool</a></code></h4>
<h4 id='method.gt' class='method'><a class='stability Unstable' title='Unstable: Definition may change slightly after trait reform'></a><code>fn <a href='#method.gt' class='fnname'>gt</a>(&amp;self, &amp;<a class='struct' href='../../std/collections/btree_map/struct.BTreeMap.html' title='std::collections::btree_map::BTreeMap'>BTreeMap</a>&lt;K, V&gt;) -&gt; <a href='../primitive.bool.html'>bool</a></code></h4>
<h4 id='method.ge' class='method'><a class='stability Unstable' title='Unstable: Definition may change slightly after trait reform'></a><code>fn <a href='#method.ge' class='fnname'>ge</a>(&amp;self, &amp;<a class='struct' href='../../std/collections/btree_map/struct.BTreeMap.html' title='std::collections::btree_map::BTreeMap'>BTreeMap</a>&lt;K, V&gt;) -&gt; <a href='../primitive.bool.html'>bool</a></code></h4>
</div><h3 class='impl'><a class='stability Unstable' title='Unstable: Definition may change slightly after trait reform'></a><code>impl&lt;K: <a class='trait' href='../../std/cmp/trait.Ord.html' title='std::cmp::Ord'>Ord</a>&lt;K&gt;, V: <a class='trait' href='../../std/cmp/trait.Ord.html' title='std::cmp::Ord'>Ord</a>&lt;V&gt;&gt; <a class='trait' href='../../std/cmp/trait.Ord.html' title='std::cmp::Ord'>Ord</a>&lt;<a class='struct' href='../../std/collections/btree_map/struct.BTreeMap.html' title='std::collections::btree_map::BTreeMap'>BTreeMap</a>&lt;K, V&gt;&gt; for <a class='struct' href='../../std/collections/btree_map/struct.BTreeMap.html' title='std::collections::btree_map::BTreeMap'>BTreeMap</a>&lt;K, V&gt;</code></h3><div class='impl-items'><h4 id='method.cmp' class='method'><a class='stability Unstable' title='Unstable: Definition may change slightly after trait reform'></a><code>fn <a href='#method.cmp' class='fnname'>cmp</a>(&amp;self, other: &amp;<a class='struct' href='../../std/collections/btree_map/struct.BTreeMap.html' title='std::collections::btree_map::BTreeMap'>BTreeMap</a>&lt;K, V&gt;) -&gt; <a class='enum' href='../../std/cmp/enum.Ordering.html' title='std::cmp::Ordering'>Ordering</a></code></h4>
</div><h3 class='impl'><a class='stability Unstable' title='Unstable: I/O and core have yet to be reconciled'></a><code>impl&lt;K: <a class='trait' href='../../std/fmt/trait.Show.html' title='std::fmt::Show'>Show</a>, V: <a class='trait' href='../../std/fmt/trait.Show.html' title='std::fmt::Show'>Show</a>&gt; <a class='trait' href='../../std/fmt/trait.Show.html' title='std::fmt::Show'>Show</a> for <a class='struct' href='../../std/collections/btree_map/struct.BTreeMap.html' title='std::collections::btree_map::BTreeMap'>BTreeMap</a>&lt;K, V&gt;</code></h3><div class='impl-items'><h4 id='method.fmt' class='method'><a class='stability Unstable' title='Unstable: I/O and core have yet to be reconciled'></a><code>fn <a href='#method.fmt' class='fnname'>fmt</a>(&amp;self, f: &amp;mut <a class='struct' href='../../std/fmt/struct.Formatter.html' title='std::fmt::Formatter'>Formatter</a>) -&gt; <a class='enum' href='../../std/result/enum.Result.html' title='std::result::Result'>Result</a>&lt;<a href='../primitive.tuple.html'>()</a>, <a class='struct' href='../../std/fmt/struct.Error.html' title='std::fmt::Error'>Error</a>&gt;</code></h4>
</div><h3 class='impl'><a class='stability Experimental' title='Experimental'></a><code>impl&lt;K: <a class='trait' href='../../std/cmp/trait.Ord.html' title='std::cmp::Ord'>Ord</a>&lt;K&gt;, <a class='trait' href='../../std/kinds/trait.Sized.html' title='std::kinds::Sized'>Sized</a>? Q, V&gt; <a class='trait' href='../../std/ops/trait.Index.html' title='std::ops::Index'>Index</a>&lt;Q, V&gt; for <a class='struct' href='../../std/collections/btree_map/struct.BTreeMap.html' title='std::collections::btree_map::BTreeMap'>BTreeMap</a>&lt;K, V&gt;</code></h3><div class='impl-items'><h4 id='method.index' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.index' class='fnname'>index</a>(&amp;self, key: &amp;Q) -&gt; &amp;V</code></h4>
</div><h3 class='impl'><a class='stability Experimental' title='Experimental'></a><code>impl&lt;K: <a class='trait' href='../../std/cmp/trait.Ord.html' title='std::cmp::Ord'>Ord</a>&lt;K&gt;, <a class='trait' href='../../std/kinds/trait.Sized.html' title='std::kinds::Sized'>Sized</a>? Q, V&gt; <a class='trait' href='../../std/ops/trait.IndexMut.html' title='std::ops::IndexMut'>IndexMut</a>&lt;Q, V&gt; for <a class='struct' href='../../std/collections/btree_map/struct.BTreeMap.html' title='std::collections::btree_map::BTreeMap'>BTreeMap</a>&lt;K, V&gt;</code></h3><div class='impl-items'><h4 id='method.index_mut' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.index_mut' class='fnname'>index_mut</a>(&amp;mut self, key: &amp;Q) -&gt; &amp;mut V</code></h4>
</div><h3 id='derived_implementations'>Derived Implementations </h3><h3 class='impl'><a class='stability Stable' title='Stable'></a><code>impl&lt;K: <a class='trait' href='../../std/clone/trait.Clone.html' title='std::clone::Clone'>Clone</a>, V: <a class='trait' href='../../std/clone/trait.Clone.html' title='std::clone::Clone'>Clone</a>&gt; <a class='trait' href='../../std/clone/trait.Clone.html' title='std::clone::Clone'>Clone</a> for <a class='struct' href='../../std/collections/btree_map/struct.BTreeMap.html' title='std::collections::btree_map::BTreeMap'>BTreeMap</a>&lt;K, V&gt;</code></h3><div class='impl-items'><h4 id='method.clone' class='method'><a class='stability Stable' title='Stable'></a><code>fn <a href='#method.clone' class='fnname'>clone</a>(&amp;self) -&gt; <a class='struct' href='../../std/collections/btree_map/struct.BTreeMap.html' title='std::collections::btree_map::BTreeMap'>BTreeMap</a>&lt;K, V&gt;</code></h4>
<h4 id='method.clone_from' class='method'><a class='stability Unstable' title='Unstable: this function rarely unused'></a><code>fn <a href='#method.clone_from' class='fnname'>clone_from</a>(&amp;mut self, &amp;<a class='struct' href='../../std/collections/btree_map/struct.BTreeMap.html' title='std::collections::btree_map::BTreeMap'>BTreeMap</a>&lt;K, V&gt;)</code></h4>
</div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <div id="help" class="hidden">
        <div class="shortcuts">
            <h1>Keyboard shortcuts</h1>
            <dl>
                <dt>?</dt>
                <dd>Show this help dialog</dd>
                <dt>S</dt>
                <dd>Focus the search field</dd>
                <dt>&larrb;</dt>
                <dd>Move up in search results</dd>
                <dt>&rarrb;</dt>
                <dd>Move down in search results</dd>
                <dt>&#9166;</dt>
                <dd>Go to active search result</dd>
            </dl>
        </div>
        <div class="infos">
            <h1>Search tricks</h1>
            <p>
                Prefix searches with a type followed by a colon (e.g.
                <code>fn:</code>) to restrict the search to a given type.
            </p>
            <p>
                Accepted types are: <code>fn</code>, <code>mod</code>,
                <code>struct</code>, <code>enum</code>,
                <code>trait</code>, <code>typedef</code> (or
                <code>tdef</code>).
            </p>
        </div>
    </div>

    

    <script>
        window.rootPath = "../../";
        window.currentCrate = "std";
        window.playgroundUrl = "http://play.rust-lang.org/";
    </script>
    <script src="../../jquery.js"></script>
    <script src="../../main.js"></script>
    <script src="../../playpen.js"></script>
    <script async src="../../search-index.js"></script>
</body>
</html>