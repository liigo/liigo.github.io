<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `comm` mod in crate `std`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, comm">

    <title>std::comm - Rust</title>

    <link rel="stylesheet" type="text/css" href="../../main.css">

    <link rel="shortcut icon" href="http://www.rust-lang.org/favicon.ico">
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <section class="sidebar">
        <a href='../../std/index.html'><img src='http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png' alt='' width='100'></a>
        <p class='location'><a href='../index.html'>std</a></p><div class='block mod'><h2>Modules</h2><a class='mod ' href='../any/index.html' title='Traits for dynamic typing of any `&#39;static` type (through runtime reflection)'>any</a><a class='mod ' href='../ascii/index.html' title='Operations on ASCII strings and characters'>ascii</a><a class='mod ' href='../bitflags/index.html' title='A typesafe bitmask flag generator.'>bitflags</a><a class='mod ' href='../borrow/index.html' title='A module for working with borrowed data.'>borrow</a><a class='mod ' href='../boxed/index.html' title='A unique pointer type.'>boxed</a><a class='mod ' href='../c_str/index.html' title='C-string manipulation and management'>c_str</a><a class='mod ' href='../c_vec/index.html' title='Library to interface with chunks of memory allocated in C.'>c_vec</a><a class='mod ' href='../cell/index.html' title='Shareable mutable containers.'>cell</a><a class='mod ' href='../char/index.html' title='Character manipulation (`char` type, Unicode Scalar Value)'>char</a><a class='mod ' href='../clone/index.html' title='The `Clone` trait for types that cannot be &#39;implicitly copied&#39;'>clone</a><a class='mod ' href='../cmp/index.html' title='Defines the `PartialOrd` and `PartialEq` comparison traits.'>cmp</a><a class='mod ' href='../collections/index.html' title='Collection types.'>collections</a><a class='mod current' href='../comm/index.html' title='Communication primitives for concurrent tasks'>comm</a><a class='mod ' href='../default/index.html' title='The `Default` trait for types which may have meaningful default values.'>default</a><a class='mod ' href='../dynamic_lib/index.html' title='Dynamic library facilities.'>dynamic_lib</a><a class='mod ' href='../error/index.html' title='Traits for working with Errors.'>error</a><a class='mod ' href='../f32/index.html' title='Operations and constants for 32-bits floats (`f32` type)'>f32</a><a class='mod ' href='../f64/index.html' title='Operations and constants for 64-bits floats (`f64` type)'>f64</a><a class='mod ' href='../finally/index.html' title='The Finally trait provides a method, `finally` on stack closures that emulates Java-style try/finally blocks.'>finally</a><a class='mod ' href='../fmt/index.html' title='Utilities for formatting and printing strings'>fmt</a><a class='mod ' href='../hash/index.html' title='Generic hashing support.'>hash</a><a class='mod ' href='../i16/index.html' title='Operations and constants for signed 16-bits integers (`i16` type)'>i16</a><a class='mod ' href='../i32/index.html' title='Operations and constants for signed 32-bits integers (`i32` type)'>i32</a><a class='mod ' href='../i64/index.html' title='Operations and constants for signed 64-bits integers (`i64` type)'>i64</a><a class='mod ' href='../i8/index.html' title='Operations and constants for signed 8-bits integers (`i8` type)'>i8</a><a class='mod ' href='../int/index.html' title='Operations and constants for architecture-sized signed integers (`int` type)'>int</a><a class='mod ' href='../intrinsics/index.html' title='rustc compiler intrinsics.'>intrinsics</a><a class='mod ' href='../io/index.html' title='I/O, including files, networking, timers, and processes'>io</a><a class='mod ' href='../iter/index.html' title='Composable external iterators'>iter</a><a class='mod ' href='../kinds/index.html' title='Primitive traits representing basic &#39;kinds&#39; of types'>kinds</a><a class='mod ' href='../macros/index.html' title='Standard library macros'>macros</a><a class='mod ' href='../mem/index.html' title='Basic functions for dealing with memory'>mem</a><a class='mod ' href='../num/index.html' title='Numeric traits and functions for generic mathematics'>num</a><a class='mod ' href='../ops/index.html' title='Overloadable operators'>ops</a><a class='mod ' href='../option/index.html' title='Optional values'>option</a><a class='mod ' href='../os/index.html' title='Higher-level interfaces to libc::* functions and operating system services.'>os</a><a class='mod ' href='../path/index.html' title='Cross-platform path support'>path</a><a class='mod ' href='../prelude/index.html' title='The Rust prelude'>prelude</a><a class='mod ' href='../ptr/index.html' title='Operations on unsafe pointers, `*const T`, and `*mut T`.'>ptr</a><a class='mod ' href='../rand/index.html' title='Utilities for random number generation'>rand</a><a class='mod ' href='../raw/index.html' title='Contains struct definitions for the layout of compiler built-in types.'>raw</a><a class='mod ' href='../rc/index.html' title='Task-local reference-counted boxes (the `Rc&lt;T&gt;` type).'>rc</a><a class='mod ' href='../result/index.html' title='Error handling with the `Result` type'>result</a><a class='mod ' href='../rt/index.html' title='Runtime services'>rt</a><a class='mod ' href='../simd/index.html' title='SIMD vectors.'>simd</a><a class='mod ' href='../slice/index.html' title='Utilities for slice manipulation'>slice</a><a class='mod ' href='../str/index.html' title='Unicode string manipulation (`str` type)'>str</a><a class='mod ' href='../string/index.html' title='An owned, growable string that enforces that its contents are valid UTF-8.'>string</a><a class='mod ' href='../sync/index.html' title='Useful synchronization primitives'>sync</a><a class='mod ' href='../task/index.html' title='Deprecated in favor of `thread`.'>task</a><a class='mod ' href='../thread/index.html' title='Native threads'>thread</a><a class='mod ' href='../thread_local/index.html' title='Thread local storage'>thread_local</a><a class='mod ' href='../thunk/index.html' title=''>thunk</a><a class='mod ' href='../time/index.html' title='Temporal quantification.'>time</a><a class='mod ' href='../u16/index.html' title='Operations and constants for unsigned 16-bits integers (`u16` type)'>u16</a><a class='mod ' href='../u32/index.html' title='Operations and constants for unsigned 32-bits integers (`u32` type)'>u32</a><a class='mod ' href='../u64/index.html' title='Operations and constants for unsigned 64-bits integer (`u64` type)'>u64</a><a class='mod ' href='../u8/index.html' title='Operations and constants for unsigned 8-bits integers (`u8` type)'>u8</a><a class='mod ' href='../uint/index.html' title='Operations and constants for architecture-sized unsigned integers (`uint` type)'>uint</a><a class='mod ' href='../vec/index.html' title='A growable list type, written `Vec&lt;T&gt;` but pronounced &#39;vector.&#39;'>vec</a></div><div class='block macro'><h2>Macros</h2><a class='macro ' href='../macro.__thread_local_inner!.html' title=''>__thread_local_inner!</a><a class='macro ' href='../macro.assert!.html' title='Ensure that a boolean expression is `true` at runtime.'>assert!</a><a class='macro ' href='../macro.assert_eq!.html' title='Asserts that two expressions are equal to each other, testing equality in both directions.'>assert_eq!</a><a class='macro ' href='../macro.bitflags!.html' title='The `bitflags!` macro generates a `struct` that holds a set of C-style bitmask flags. It is useful for creating typesafe wrappers for C APIs.'>bitflags!</a><a class='macro ' href='../macro.bytes!.html' title='Concatenate literals into a static byte slice.'>bytes!</a><a class='macro ' href='../macro.cfg!.html' title='Boolean evaluation of configuration flags.'>cfg!</a><a class='macro ' href='../macro.column!.html' title='A macro which expands to the column number on which it was invoked.'>column!</a><a class='macro ' href='../macro.concat!.html' title='Concatenates literals into a static string slice.'>concat!</a><a class='macro ' href='../macro.concat_idents!.html' title='Concatenate identifiers into one identifier.'>concat_idents!</a><a class='macro ' href='../macro.debug_assert!.html' title='Ensure that a boolean expression is `true` at runtime.'>debug_assert!</a><a class='macro ' href='../macro.debug_assert_eq!.html' title='Asserts that two expressions are equal to each other, testing equality in both directions.'>debug_assert_eq!</a><a class='macro ' href='../macro.env!.html' title='Inspect an environment variable at compile time.'>env!</a><a class='macro ' href='../macro.file!.html' title='A macro which expands to the file name from which it was invoked.'>file!</a><a class='macro ' href='../macro.format!.html' title='Use the syntax described in `std::fmt` to create a value of type `String`. See `std::fmt` for more information.'>format!</a><a class='macro ' href='../macro.format_args!.html' title='The core macro for formatted string creation & output.'>format_args!</a><a class='macro ' href='../macro.include_bin!.html' title='Deprecated alias for `include_bytes!()`.'>include_bin!</a><a class='macro ' href='../macro.include_bytes!.html' title='Includes a file as a byte slice.'>include_bytes!</a><a class='macro ' href='../macro.include_str!.html' title='Includes a utf8-encoded file as a string.'>include_str!</a><a class='macro ' href='../macro.line!.html' title='A macro which expands to the line number on which it was invoked.'>line!</a><a class='macro ' href='../macro.module_path!.html' title='Expands to a string that represents the current module path.'>module_path!</a><a class='macro ' href='../macro.option_env!.html' title='Optionally inspect an environment variable at compile time.'>option_env!</a><a class='macro ' href='../macro.panic!.html' title='The entry point for panic of Rust tasks.'>panic!</a><a class='macro ' href='../macro.print!.html' title='Equivalent to the `println!` macro except that a newline is not printed at the end of the message.'>print!</a><a class='macro ' href='../macro.println!.html' title='Macro for printing to a task&#39;s stdout handle.'>println!</a><a class='macro ' href='../macro.scoped_thread_local!.html' title='Declare a new scoped thread local storage key.'>scoped_thread_local!</a><a class='macro ' href='../macro.select!.html' title='A macro to select an event from a number of receivers.'>select!</a><a class='macro ' href='../macro.stringify!.html' title='A macro which stringifies its argument.'>stringify!</a><a class='macro ' href='../macro.try!.html' title='Helper macro for unwrapping `Result` values while returning early with an error if the value of the expression is `Err`. For more information, see `std::io`.'>try!</a><a class='macro ' href='../macro.unimplemented!.html' title='A standardised placeholder for marking unfinished code. It panics with the message `&quot;not yet implemented&quot;` when executed.'>unimplemented!</a><a class='macro ' href='../macro.unreachable!.html' title='A utility macro for indicating unreachable code.'>unreachable!</a><a class='macro ' href='../macro.vec!.html' title='Create a `std::vec::Vec` containing the arguments.'>vec!</a><a class='macro ' href='../macro.write!.html' title='Use the `format!` syntax to write data into a buffer of type `&mut Writer`. See `std::fmt` for more information.'>write!</a><a class='macro ' href='../macro.writeln!.html' title='Equivalent to the `write!` macro, except that a newline is appended after the message is written.'>writeln!</a></div>
    </section>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press 'S' to search, '?' for more options..."
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content mod">
<h1 class='fqn'><span class='in-band'>Module <a href='../index.html'>std</a>::<wbr><a class='mod' href=''>comm</a><wbr><a class='stability Unstable' title=''>Unstable</a></span><span class='out-of-band'><span id='render-detail'>
            <a id="collapse-all" href="#">[-]
            </a>&nbsp;<a id="expand-all" href="#">[+]</a>
        </span><a id='src-63413' href='../../src/std/comm/mod.rs.html#11-2028'>[src]</a></span></h1>
<div class='docblock'><p>Communication primitives for concurrent tasks</p>

<p>Rust makes it very difficult to share data among tasks to prevent race
conditions and to improve parallelism, but there is often a need for
communication between concurrent tasks. The primitives defined in this
module are the building blocks for synchronization in rust.</p>

<p>This module provides message-based communication over channels, concretely
defined among three types:</p>

<ul>
<li><code>Sender</code></li>
<li><code>SyncSender</code></li>
<li><code>Receiver</code></li>
</ul>

<p>A <code>Sender</code> or <code>SyncSender</code> is used to send data to a <code>Receiver</code>. Both
senders are clone-able such that many tasks can send simultaneously to one
receiver.  These channels are <em>task blocking</em>, not <em>thread blocking</em>. This
means that if one task is blocked on a channel, other tasks can continue to
make progress.</p>

<p>Rust channels come in one of two flavors:</p>

<ol>
<li><p>An asynchronous, infinitely buffered channel. The <code>channel()</code> function
will return a <code>(Sender, Receiver)</code> tuple where all sends will be
<strong>asynchronous</strong> (they never block). The channel conceptually has an
infinite buffer.</p></li>
<li><p>A synchronous, bounded channel. The <code>sync_channel()</code> function will return
a <code>(SyncSender, Receiver)</code> tuple where the storage for pending messages
is a pre-allocated buffer of a fixed size. All sends will be
<strong>synchronous</strong> by blocking until there is buffer space available. Note
that a bound of 0 is allowed, causing the channel to become a
&quot;rendezvous&quot; channel where each sender atomically hands off a message to
a receiver.</p></li>
</ol>

<h2 id="panic-propagation" class='section-header'><a
                           href="#panic-propagation">Panic Propagation</a></h2>
<p>In addition to being a core primitive for communicating in rust, channels
are the points at which panics are propagated among tasks.  Whenever the one
half of channel is closed, the other half will have its next operation
<code>panic!</code>. The purpose of this is to allow propagation of panics among tasks
that are linked to one another via channels.</p>

<p>There are methods on both of senders and receivers to perform their
respective operations without panicking, however.</p>

<h1 id="example" class='section-header'><a
                           href="#example">Example</a></h1>
<p>Simple usage:</p>
<span id='rust-example-raw-0' class='rusttest'>fn main() {
    use std::thread::Thread;
    
    // Create a simple streaming channel
    let (tx, rx) = channel();
    Thread::spawn(move|| {
        tx.send(10i);
    }).detach();
    assert_eq!(rx.recv(), 10i);
}</span><pre id='rust-example-rendered-0' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>thread</span>::<span class='ident'>Thread</span>;

<span class='comment'>// Create a simple streaming channel</span>
<span class='kw'>let</span> (<span class='ident'>tx</span>, <span class='ident'>rx</span>) <span class='op'>=</span> <span class='ident'>channel</span>();
<span class='ident'>Thread</span>::<span class='ident'>spawn</span>(<span class='kw'>move</span><span class='op'>||</span> {
    <span class='ident'>tx</span>.<span class='ident'>send</span>(<span class='number'>10i</span>);
}).<span class='ident'>detach</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>rx</span>.<span class='ident'>recv</span>(), <span class='number'>10i</span>);
</pre>

<p>Shared usage:</p>
<span id='rust-example-raw-1' class='rusttest'>fn main() {
    use std::thread::Thread;
    
    // Create a shared channel that can be sent along from many threads
    // where tx is the sending half (tx for transmission), and rx is the receiving
    // half (rx for receiving).
    let (tx, rx) = channel();
    for i in range(0i, 10i) {
        let tx = tx.clone();
        Thread::spawn(move|| {
            tx.send(i);
        }).detach()
    }
    
    for _ in range(0i, 10i) {
        let j = rx.recv();
        assert!(0 &lt;= j &amp;&amp; j &lt; 10);
    }
}</span><pre id='rust-example-rendered-1' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>thread</span>::<span class='ident'>Thread</span>;

<span class='comment'>// Create a shared channel that can be sent along from many threads</span>
<span class='comment'>// where tx is the sending half (tx for transmission), and rx is the receiving</span>
<span class='comment'>// half (rx for receiving).</span>
<span class='kw'>let</span> (<span class='ident'>tx</span>, <span class='ident'>rx</span>) <span class='op'>=</span> <span class='ident'>channel</span>();
<span class='kw'>for</span> <span class='ident'>i</span> <span class='kw'>in</span> <span class='ident'>range</span>(<span class='number'>0i</span>, <span class='number'>10i</span>) {
    <span class='kw'>let</span> <span class='ident'>tx</span> <span class='op'>=</span> <span class='ident'>tx</span>.<span class='ident'>clone</span>();
    <span class='ident'>Thread</span>::<span class='ident'>spawn</span>(<span class='kw'>move</span><span class='op'>||</span> {
        <span class='ident'>tx</span>.<span class='ident'>send</span>(<span class='ident'>i</span>);
    }).<span class='ident'>detach</span>()
}

<span class='kw'>for</span> _ <span class='kw'>in</span> <span class='ident'>range</span>(<span class='number'>0i</span>, <span class='number'>10i</span>) {
    <span class='kw'>let</span> <span class='ident'>j</span> <span class='op'>=</span> <span class='ident'>rx</span>.<span class='ident'>recv</span>();
    <span class='macro'>assert</span><span class='macro'>!</span>(<span class='number'>0</span> <span class='op'>&lt;=</span> <span class='ident'>j</span> <span class='op'>&amp;&amp;</span> <span class='ident'>j</span> <span class='op'>&lt;</span> <span class='number'>10</span>);
}
</pre>

<p>Propagating panics:</p>
<span id='rust-example-raw-2' class='rusttest'>fn main() {
    // The call to recv() will panic!() because the channel has already hung
    // up (or been deallocated)
    let (tx, rx) = channel::&lt;int&gt;();
    drop(tx);
    rx.recv();
}</span><pre id='rust-example-rendered-2' class='rust '>
<span class='comment'>// The call to recv() will panic!() because the channel has already hung</span>
<span class='comment'>// up (or been deallocated)</span>
<span class='kw'>let</span> (<span class='ident'>tx</span>, <span class='ident'>rx</span>) <span class='op'>=</span> <span class='ident'>channel</span>::<span class='op'>&lt;</span><span class='ident'>int</span><span class='op'>&gt;</span>();
<span class='ident'>drop</span>(<span class='ident'>tx</span>);
<span class='ident'>rx</span>.<span class='ident'>recv</span>();
</pre>

<p>Synchronous channels:</p>
<span id='rust-example-raw-3' class='rusttest'>fn main() {
    use std::thread::Thread;
    
    let (tx, rx) = sync_channel::&lt;int&gt;(0);
    Thread::spawn(move|| {
        // This will wait for the parent task to start receiving
        tx.send(53);
    }).detach();
    rx.recv();
}</span><pre id='rust-example-rendered-3' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>thread</span>::<span class='ident'>Thread</span>;

<span class='kw'>let</span> (<span class='ident'>tx</span>, <span class='ident'>rx</span>) <span class='op'>=</span> <span class='ident'>sync_channel</span>::<span class='op'>&lt;</span><span class='ident'>int</span><span class='op'>&gt;</span>(<span class='number'>0</span>);
<span class='ident'>Thread</span>::<span class='ident'>spawn</span>(<span class='kw'>move</span><span class='op'>||</span> {
    <span class='comment'>// This will wait for the parent task to start receiving</span>
    <span class='ident'>tx</span>.<span class='ident'>send</span>(<span class='number'>53</span>);
}).<span class='ident'>detach</span>();
<span class='ident'>rx</span>.<span class='ident'>recv</span>();
</pre>

<p>Reading from a channel with a timeout requires to use a Timer together
with the channel. You can use the select! macro to select either and
handle the timeout case. This first example will break out of the loop
after 10 seconds no matter what:</p>
<span id='rust-example-raw-4' class='rusttest'>fn main() {
    use std::io::timer::Timer;
    use std::time::Duration;
    
    let (tx, rx) = channel::&lt;int&gt;();
    let mut timer = Timer::new().unwrap();
    let timeout = timer.oneshot(Duration::seconds(10));
    
    loop {
        select! {
            val = rx.recv() =&gt; println!(&quot;Received {}&quot;, val),
            () = timeout.recv() =&gt; {
                println!(&quot;timed out, total time was more than 10 seconds&quot;);
                break;
            }
        }
    }
}</span><pre id='rust-example-rendered-4' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>timer</span>::<span class='ident'>Timer</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>time</span>::<span class='ident'>Duration</span>;

<span class='kw'>let</span> (<span class='ident'>tx</span>, <span class='ident'>rx</span>) <span class='op'>=</span> <span class='ident'>channel</span>::<span class='op'>&lt;</span><span class='ident'>int</span><span class='op'>&gt;</span>();
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>timer</span> <span class='op'>=</span> <span class='ident'>Timer</span>::<span class='ident'>new</span>().<span class='ident'>unwrap</span>();
<span class='kw'>let</span> <span class='ident'>timeout</span> <span class='op'>=</span> <span class='ident'>timer</span>.<span class='ident'>oneshot</span>(<span class='ident'>Duration</span>::<span class='ident'>seconds</span>(<span class='number'>10</span>));

<span class='kw'>loop</span> {
    <span class='macro'>select</span><span class='macro'>!</span> {
        <span class='ident'>val</span> <span class='op'>=</span> <span class='ident'>rx</span>.<span class='ident'>recv</span>() <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Received {}&quot;</span>, <span class='ident'>val</span>),
        () <span class='op'>=</span> <span class='ident'>timeout</span>.<span class='ident'>recv</span>() <span class='op'>=&gt;</span> {
            <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;timed out, total time was more than 10 seconds&quot;</span>);
            <span class='kw'>break</span>;
        }
    }
}
</pre>

<p>This second example is more costly since it allocates a new timer every
time a message is received, but it allows you to timeout after the channel
has been inactive for 5 seconds:</p>
<span id='rust-example-raw-5' class='rusttest'>fn main() {
    use std::io::timer::Timer;
    use std::time::Duration;
    
    let (tx, rx) = channel::&lt;int&gt;();
    let mut timer = Timer::new().unwrap();
    
    loop {
        let timeout = timer.oneshot(Duration::seconds(5));
    
        select! {
            val = rx.recv() =&gt; println!(&quot;Received {}&quot;, val),
            () = timeout.recv() =&gt; {
                println!(&quot;timed out, no message received in 5 seconds&quot;);
                break;
            }
        }
    }
}</span><pre id='rust-example-rendered-5' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>timer</span>::<span class='ident'>Timer</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>time</span>::<span class='ident'>Duration</span>;

<span class='kw'>let</span> (<span class='ident'>tx</span>, <span class='ident'>rx</span>) <span class='op'>=</span> <span class='ident'>channel</span>::<span class='op'>&lt;</span><span class='ident'>int</span><span class='op'>&gt;</span>();
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>timer</span> <span class='op'>=</span> <span class='ident'>Timer</span>::<span class='ident'>new</span>().<span class='ident'>unwrap</span>();

<span class='kw'>loop</span> {
    <span class='kw'>let</span> <span class='ident'>timeout</span> <span class='op'>=</span> <span class='ident'>timer</span>.<span class='ident'>oneshot</span>(<span class='ident'>Duration</span>::<span class='ident'>seconds</span>(<span class='number'>5</span>));

    <span class='macro'>select</span><span class='macro'>!</span> {
        <span class='ident'>val</span> <span class='op'>=</span> <span class='ident'>rx</span>.<span class='ident'>recv</span>() <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Received {}&quot;</span>, <span class='ident'>val</span>),
        () <span class='op'>=</span> <span class='ident'>timeout</span>.<span class='ident'>recv</span>() <span class='op'>=&gt;</span> {
            <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;timed out, no message received in 5 seconds&quot;</span>);
            <span class='kw'>break</span>;
        }
    }
}
</pre>
</div><h2 id='reexports' class='section-header'><a href="#reexports">Reexports</a></h2>
<table><tr><td><code>pub use self::<a class='enum' href='../../std/comm/enum.TryRecvError.html' title='std::comm::TryRecvError'>TryRecvError</a>::*;</code></td></tr><tr><td><code>pub use self::<a class='enum' href='../../std/comm/enum.TrySendError.html' title='std::comm::TrySendError'>TrySendError</a>::*;</code></td></tr></table><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table>
                    <tr>
                        <td><a class='stability Experimental' title='Experimental: This implementation, while likely sufficient, is unsafe and likely to be error prone. At some point in the future this module will likely be replaced, and it is currently unknown how much API breakage that will cause. The ability to select over a number of channels will remain forever, but no guarantees beyond this are being made'></a><a class='struct' href='struct.Handle.html'
                               title='std::comm::Handle'>Handle</a></td>
                        <td class='docblock short'><p>A handle to a receiver which is currently a member of a <code>Select</code> set of
receivers.  This handle is used to keep the receiver in the set as well as
interact with the underlying receiver.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Unstable' title='Unstable'></a><a class='struct' href='struct.Messages.html'
                               title='std::comm::Messages'>Messages</a></td>
                        <td class='docblock short'><p>An iterator over messages on a receiver, this iterator will block
whenever <code>next</code> is called, waiting for a new message, and <code>None</code> will be
returned when the corresponding channel has hung up.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Unstable' title='Unstable'></a><a class='struct' href='struct.Receiver.html'
                               title='std::comm::Receiver'>Receiver</a></td>
                        <td class='docblock short'><p>The receiving-half of Rust&#39;s channel type. This half can only be owned by
one task</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental: This implementation, while likely sufficient, is unsafe and likely to be error prone. At some point in the future this module will likely be replaced, and it is currently unknown how much API breakage that will cause. The ability to select over a number of channels will remain forever, but no guarantees beyond this are being made'></a><a class='struct' href='struct.Select.html'
                               title='std::comm::Select'>Select</a></td>
                        <td class='docblock short'><p>The &quot;receiver set&quot; of the select interface. This structure is used to manage
a set of receivers which are being selected over.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Unstable' title='Unstable'></a><a class='struct' href='struct.Sender.html'
                               title='std::comm::Sender'>Sender</a></td>
                        <td class='docblock short'><p>The sending-half of Rust&#39;s asynchronous channel type. This half can only be
owned by one task, but it can be cloned to send to other tasks.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Unstable' title='Unstable: this type may be renamed, but it will always exist'></a><a class='struct' href='struct.SyncSender.html'
                               title='std::comm::SyncSender'>SyncSender</a></td>
                        <td class='docblock short'><p>The sending-half of Rust&#39;s synchronous channel type. This half can only be
owned by one task, but it can be cloned to send to other tasks.</p>
</td>
                    </tr>
                </table><h2 id='enums' class='section-header'><a href="#enums">Enums</a></h2>
<table>
                    <tr>
                        <td><a class='stability Experimental' title='Experimental: this is likely to be removed in changing try_recv()'></a><a class='enum' href='enum.TryRecvError.html'
                               title='std::comm::TryRecvError'>TryRecvError</a></td>
                        <td class='docblock short'><p>This enumeration is the list of the possible reasons that try_recv could not
return data when called.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental: this is likely to be removed in changing try_send()'></a><a class='enum' href='enum.TrySendError.html'
                               title='std::comm::TrySendError'>TrySendError</a></td>
                        <td class='docblock short'><p>This enumeration is the list of the possible error outcomes for the
<code>SyncSender::try_send</code> method.</p>
</td>
                    </tr>
                </table><h2 id='functions' class='section-header'><a href="#functions">Functions</a></h2>
<table>
                    <tr>
                        <td><a class='stability Unstable' title='Unstable'></a><a class='fn' href='fn.channel.html'
                               title='std::comm::channel'>channel</a></td>
                        <td class='docblock short'><p>Creates a new asynchronous channel, returning the sender/receiver halves.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Unstable' title='Unstable: this function may be renamed to more accurately reflect the type of channel that is is creating'></a><a class='fn' href='fn.sync_channel.html'
                               title='std::comm::sync_channel'>sync_channel</a></td>
                        <td class='docblock short'><p>Creates a new synchronous, bounded channel.</p>
</td>
                    </tr>
                </table></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <div id="help" class="hidden">
        <div class="shortcuts">
            <h1>Keyboard shortcuts</h1>
            <dl>
                <dt>?</dt>
                <dd>Show this help dialog</dd>
                <dt>S</dt>
                <dd>Focus the search field</dd>
                <dt>&larrb;</dt>
                <dd>Move up in search results</dd>
                <dt>&rarrb;</dt>
                <dd>Move down in search results</dd>
                <dt>&#9166;</dt>
                <dd>Go to active search result</dd>
            </dl>
        </div>
        <div class="infos">
            <h1>Search tricks</h1>
            <p>
                Prefix searches with a type followed by a colon (e.g.
                <code>fn:</code>) to restrict the search to a given type.
            </p>
            <p>
                Accepted types are: <code>fn</code>, <code>mod</code>,
                <code>struct</code>, <code>enum</code>,
                <code>trait</code>, <code>typedef</code> (or
                <code>tdef</code>).
            </p>
        </div>
    </div>

    

    <script>
        window.rootPath = "../../";
        window.currentCrate = "std";
        window.playgroundUrl = "http://play.rust-lang.org/";
    </script>
    <script src="../../jquery.js"></script>
    <script src="../../main.js"></script>
    <script src="../../playpen.js"></script>
    <script async src="../../search-index.js"></script>
</body>
</html>